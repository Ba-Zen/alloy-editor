import EditorContext from '../../adapter/editor-context';
import React, {useContext, useMemo} from 'react';
import useButtonActionStyle from '../hooks/use-button-action-style';

/**
 * ButtonStylesListItem provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 */
function ButtonStylesListItem({
	activeStyle,
	name,
	style: buttonStyle = {},
	tabIndex,
}) {
	const editor = useContext(EditorContext).editor.get('nativeEditor');
	const preview = useMemo(
		() => {
			// Styles with wildcard element (*) generate an empty tag in their
			// preview < class="custom-class" />. We default to element span and
			// remove the margins to obtain a more consistent set of previews.
			let styleCfg = {
				element: 'span',
				styles: {
					margin: 0,
				},
			};

			styleCfg = CKEDITOR.tools.merge(styleCfg, buttonStyle);

			return new CKEDITOR.style(styleCfg).buildPreview(name);
		},
		[buttonStyle, name]
	);

	const {applyStyle, isActive, style} = useButtonActionStyle(buttonStyle);

	const className =
		name === activeStyle
			? 'ae-toolbar-element active'
			: 'ae-toolbar-element';

	/**
	 * Applies the item style to the editor selection.
	 */
	const handleClick = () => {
		// Typically, we want the style to be the only one
		// applied to the current selection, so we execute the
		// 'removeFormat' command first. Note that block styles won't
		// be cleaned.  However, this is consistent with other editors
		// implementations of this feature.
		editor.execCommand('removeFormat');

		applyStyle();
	};

	// We need to use dangerouslySetInnerHTML since we're not in control of
	// the style preview that is generated by CKEditor.
	return (
		<button
			className={className}
			dangerouslySetInnerHTML={{__html: preview}}
			onClick={handleClick}
			tabIndex={tabIndex}
		/>
	);
}

/**
 * The name which will be used as an alias of the button in the configuration.
 */
ButtonStylesListItem.key = 'buttonStylesListItem';

export default ButtonStylesListItem;
