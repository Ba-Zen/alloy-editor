window["AlloyEditor"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/adapter/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/create-react-class/factory.js":
/*!****************************************************!*\
  !*** ./node_modules/create-react-class/factory.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ "./node_modules/fbjs/lib/emptyObject.js");
var _invariant = __webpack_require__(/*! fbjs/lib/invariant */ "./node_modules/fbjs/lib/invariant.js");

if (true) {
  var warning = __webpack_require__(/*! fbjs/lib/warning */ "./node_modules/fbjs/lib/warning.js");
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if (true) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillMount`.
     *
     * @optional
     */
    UNSAFE_componentWillMount: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillReceiveProps`.
     *
     * @optional
     */
    UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillUpdate`.
     *
     * @optional
     */
    UNSAFE_componentWillUpdate: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Similar to ReactClassInterface but for static methods.
   */
  var ReactClassStaticInterface = {
    /**
     * This method is invoked after a component is instantiated and when it
     * receives new props. Return an object to update state in response to
     * prop changes. Return null to indicate no change to state.
     *
     * If an object is returned, its keys will be merged into the existing state.
     *
     * @return {object || null}
     * @optional
     */
    getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function(Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function(Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function(Constructor, childContextTypes) {
      if (true) {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign(
        {},
        Constructor.childContextTypes,
        childContextTypes
      );
    },
    contextTypes: function(Constructor, contextTypes) {
      if (true) {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign(
        {},
        Constructor.contextTypes,
        contextTypes
      );
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function(Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(
          Constructor.getDefaultProps,
          getDefaultProps
        );
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function(Constructor, propTypes) {
      if (true) {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function(Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function() {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if (true) {
          warning(
            typeof typeDef[propName] === 'function',
            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
              'React.PropTypes.',
            Constructor.displayName || 'ReactClass',
            ReactPropTypeLocationNames[location],
            propName
          );
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name)
      ? ReactClassInterface[name]
      : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(
        specPolicy === 'OVERRIDE_BASE',
        'ReactClassInterface: You are attempting to override ' +
          '`%s` from your class specification. Ensure that your method names ' +
          'do not overlap with React methods.',
        name
      );
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(
        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
        'ReactClassInterface: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be due ' +
          'to a mixin.',
        name
      );
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if (true) {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if (true) {
          warning(
            isMixinValid,
            "%s: You're attempting to include a mixin that is either null " +
              'or not an object. Check the mixins included by the component, ' +
              'as well as any mixins they include themselves. ' +
              'Expected object but got %s.',
            Constructor.displayName || 'ReactClass',
            spec === null ? null : typeofSpec
          );
        }
      }

      return;
    }

    _invariant(
      typeof spec !== 'function',
      "ReactClass: You're attempting to " +
        'use a component class or function as a mixin. Instead, just use a ' +
        'regular object.'
    );
    _invariant(
      !isValidElement(spec),
      "ReactClass: You're attempting to " +
        'use a component as a mixin. Instead, just use a regular object.'
    );

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind =
          isFunction &&
          !isReactClassMethod &&
          !isAlreadyDefined &&
          spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(
              isReactClassMethod &&
                (specPolicy === 'DEFINE_MANY_MERGED' ||
                  specPolicy === 'DEFINE_MANY'),
              'ReactClass: Unexpected spec policy %s for key %s ' +
                'when mixing in component specs.',
              specPolicy,
              name
            );

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if (true) {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }

    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(
        !isReserved,
        'ReactClass: You are attempting to define a reserved ' +
          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
          'as an instance property instead; it will still be accessible on the ' +
          'constructor.',
        name
      );

      var isAlreadyDefined = name in Constructor;
      if (isAlreadyDefined) {
        var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)
          ? ReactClassStaticInterface[name]
          : null;

        _invariant(
          specPolicy === 'DEFINE_MANY_MERGED',
          'ReactClass: You are attempting to define ' +
            '`%s` on your component more than once. This conflict may be ' +
            'due to a mixin.',
          name
        );

        Constructor[name] = createMergedResultFunction(Constructor[name], property);

        return;
      }

      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(
      one && two && typeof one === 'object' && typeof two === 'object',
      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
    );

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(
          one[key] === undefined,
          'mergeIntoWithNoDuplicateKeys(): ' +
            'Tried to merge two objects with the same key: `%s`. This conflict ' +
            'may be due to a mixin; in particular, this may be caused by two ' +
            'getInitialState() or getDefaultProps() methods returning objects ' +
            'with clashing keys.',
          key
        );
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if (true) {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if (true) {
            warning(
              false,
              'bind(): React component methods may only be bound to the ' +
                'component instance. See %s',
              componentName
            );
          }
        } else if (!args.length) {
          if (true) {
            warning(
              false,
              'bind(): You are binding a component method to the component. ' +
                'React does this for you automatically in a high-performance ' +
                'way, so you can safely remove this call. See %s',
              componentName
            );
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function() {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function() {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function(newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function() {
      if (true) {
        warning(
          this.__didWarnIsMounted,
          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
            'subscriptions and pending requests in componentWillUnmount to ' +
            'prevent memory leaks.',
          (this.constructor && this.constructor.displayName) ||
            this.name ||
            'Component'
        );
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function() {};
  _assign(
    ReactClassComponent.prototype,
    ReactComponent.prototype,
    ReactClassMixin
  );

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function(props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (true) {
        warning(
          this instanceof Constructor,
          'Something is calling a React component directly. Use a factory or ' +
            'JSX instead. See: https://fb.me/react-legacyfactory'
        );
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (true) {
        // We allow auto-mocks to proceed as if they're returning null.
        if (
          initialState === undefined &&
          this.getInitialState._isMockFunction
        ) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant(
        typeof initialState === 'object' && !Array.isArray(initialState),
        '%s.getInitialState(): must return an object or null',
        Constructor.displayName || 'ReactCompositeComponent'
      );

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (true) {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    );

    if (true) {
      warning(
        !Constructor.prototype.componentShouldUpdate,
        '%s has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.componentWillRecieveProps,
        '%s has a method called ' +
          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.UNSAFE_componentWillRecieveProps,
        '%s has a method called UNSAFE_componentWillRecieveProps(). ' +
          'Did you mean UNSAFE_componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;


/***/ }),

/***/ "./node_modules/create-react-class/index.js":
/*!**************************************************!*\
  !*** ./node_modules/create-react-class/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var React = __webpack_require__(/*! react */ "react");
var factory = __webpack_require__(/*! ./factory */ "./node_modules/create-react-class/factory.js");

if (typeof React === 'undefined') {
  throw Error(
    'create-react-class could not find the React object. If you are using script tags, ' +
      'make sure that React is being loaded before create-react-class.'
  );
}

// Hack to grab NoopUpdateQueue from isomorphic React
var ReactNoopUpdateQueue = new React.Component().updater;

module.exports = factory(
  React.Component,
  React.isValidElement,
  ReactNoopUpdateQueue
);


/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(/*! ./emptyFunction */ "./node_modules/fbjs/lib/emptyFunction.js");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          )

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
       true ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(isValidElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./src/adapter/core.js":
/*!*****************************!*\
  !*** ./src/adapter/core.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

__webpack_require__(/*! ../core */ "./src/core/index.js");

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

__webpack_require__(/*! ../components/uibridge */ "./src/components/uibridge/index.js");

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _base = __webpack_require__(/*! ../oop/base */ "./src/oop/base.js");

var _base2 = _interopRequireDefault(_base);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _main = __webpack_require__(/*! ../components/main.jsx */ "./src/components/main.jsx");

var _main2 = _interopRequireDefault(_main);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * AlloyEditor main class. Creates instance of the editor and provides the user configuration
 * to the UI.
 *
 * @class Core
 * @constructor
 */
function Core(config) {
    Core.superclass.constructor.call(this, config);
}

(0, _oop2.default)(Core, _base2.default, {
    /**
     * Initializer lifecycle implementation for the AlloyEditor class. Creates a CKEditor
     * instance, passing it the provided configuration attributes.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method initializer
     * @param config {Object} Configuration object literal for the editor.
     */
    initializer: function initializer(config) {
        var node = this.get('srcNode');

        if (this.get('enableContentEditable')) {
            node.setAttribute('contenteditable', 'true');
        }

        var editor = CKEDITOR.inline(node);

        editor.config.allowedContent = this.get('allowedContent');

        editor.config.toolbars = this.get('toolbars');

        editor.config.removePlugins = this.get('removePlugins');

        editor.config.extraPlugins = this.get('extraPlugins');

        editor.config.placeholderClass = this.get('placeholderClass');

        editor.config.pasteFromWordRemoveStyles = false;
        editor.config.pasteFromWordRemoveFontStyles = false;

        editor.config.selectionKeystrokes = this.get('selectionKeystrokes');

        _lang2.default.mix(editor.config, config);

        if (CKEDITOR.env.ie && !CKEDITOR.env.edge) {
            editor.config.extraPlugins = editor.config.extraPlugins.replace('ae_dragresize', 'ae_dragresize_ie');
            editor.config.removePlugins = editor.config.removePlugins.replace('ae_dragresize', 'ae_dragresize_ie');
        }

        editor.once('contentDom', function () {

            this._addReadOnlyLinkClickListener(editor);

            var editable = editor.editable();

            editable.addClass('ae-editable');
        }.bind(this));

        this._editor = editor;

        AlloyEditor.loadLanguageResources(this._renderUI.bind(this));
    },

    /**
     * Destructor lifecycle implementation for the AlloyEdtor class. Destroys the CKEditor
     * instance and destroys all created toolbars.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method destructor
     */
    destructor: function destructor() {
        this._destroyed = true;

        if (this._editorUIElement) {
            _reactDom2.default.unmountComponentAtNode(this._editorUIElement);
            this._editorUIElement.parentNode.removeChild(this._editorUIElement);
        }

        var nativeEditor = this.get('nativeEditor');

        if (nativeEditor) {
            var editable = nativeEditor.editable();

            if (editable) {
                editable.removeClass('ae-editable');

                if (this.get('enableContentEditable')) {
                    this.get('srcNode').setAttribute('contenteditable', 'false');
                }
            }

            this._clearSelections();

            nativeEditor.destroy();
        }
    },

    /**
     * Clear selections from window object
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _clearSelections
     */
    _clearSelections: function _clearSelections() {
        var nativeEditor = this.get('nativeEditor');
        var isMSSelection = typeof window.getSelection != 'function';

        if (isMSSelection) {
            nativeEditor.document.$.selection.empty();
        } else {
            nativeEditor.document.getWindow().$.getSelection().removeAllRanges();
        }
    },

    /**
     * Method to set default link behavior
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _addReadOnlyLinkClickListener
     * @param {Object} editor
     */
    _addReadOnlyLinkClickListener: function _addReadOnlyLinkClickListener(editor) {
        editor.editable().on('click', this._defaultReadOnlyClickFn, this, {
            editor: editor
        });
    },

    /**
     * Called on `click` event when the editor is in read only mode. Navigates to link's URL or opens
     * the link in a new window.
     *
     * @memberof Core
     * @instance
     * @event readOnlyClick
     * @protected
     * @method _defaultReadOnlyClickFn
     * @param {Object} event The fired `click` event payload
     */
    _defaultReadOnlyClickFn: function _defaultReadOnlyClickFn(event) {
        var mouseEvent = event.data.$;
        var hasCtrlKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
        var shouldOpen = this._editor.config.readOnly || hasCtrlKey;

        mouseEvent.preventDefault();

        if (!shouldOpen) {
            return;
        }

        if (event.listenerData.editor.editable().editor.fire('readOnlyClick', event.data) !== false) {
            var ckElement = new CKEDITOR.dom.elementPath(event.data.getTarget(), this);
            var link = ckElement.lastElement;

            if (link) {
                var href = link.$.attributes.href ? link.$.attributes.href.value : null;
                var target = hasCtrlKey ? '_blank' : link.$.attributes.target ? link.$.attributes.target.value : null;
                this._redirectLink(href, target);
            }
        }
    },

    /**
     * Retrieves the native CKEditor instance. Having this, the developer may use the API of CKEditor OOTB.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _getNativeEditor
     * @return {Object} The current instance of CKEditor.
     */
    _getNativeEditor: function _getNativeEditor() {
        return this._editor;
    },

    /**
     * Redirects the browser to a given link
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _redirectLink
     * @param {string} href The href to take the browser to
     * @param {string=} target Specifies where to display the link
     */
    _redirectLink: function _redirectLink(href, target) {
        if (target && href) {
            window.open(href, target);
        } else if (href) {
            window.location.href = href;
        }
    },

    /**
     * Renders the specified from the user toolbars.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _renderUI
     */
    _renderUI: function _renderUI() {
        if (!this._destroyed) {
            var editorUIElement = document.createElement('div');
            editorUIElement.className = 'ae-ui';

            var uiNode = this.get('uiNode') || document.body;

            uiNode.appendChild(editorUIElement);

            this._mainUI = _reactDom2.default.render(_react2.default.createElement(_main2.default, {
                editor: this,
                eventsDelay: this.get('eventsDelay'),
                toolbars: this.get('toolbars') }), editorUIElement);

            this._editorUIElement = editorUIElement;

            this.get('nativeEditor').fire('uiReady');
        }
    },

    /**
     * The function returns an HTML element from the passed value. If the passed value is a string, it should be
     * the Id of the element which have to be retrieved from the DOM.
     * If an HTML Element is passed, the element itself will be returned.
     *
     * @memberof Core
     * @instance
     * @method _toElement
     * @protected
     * @param {!(String|HTMLElement)} value String, which have to correspond to an HTML element from the DOM,
     * or the HTML element itself. If Id is passed, the HTML element will be retrieved from the DOM.
     * @return {HTMLElement} An HTML element.
     */
    _toElement: function _toElement(value) {
        if (_lang2.default.isString(value)) {
            value = document.getElementById(value);
        }

        return value;
    },

    /**
     * Validates the allowed content attribute. Look
     * [here](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent) for more information about the
     * supported values.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _validateAllowedContent
     * @param {Any} The value to be checked
     * @return {Boolean} True if the current value is valid configuration, false otherwise
     */
    _validateAllowedContent: function _validateAllowedContent(value) {
        return _lang2.default.isString(value) || _lang2.default.isObject(value) || _lang2.default.isBoolean(value);
    },

    /**
     * Validates the value of toolbars attribute
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _validateToolbars
     * @param {Any} The value to be checked
     * @return {Boolean} True if the current value is valid toolbars configuration, false otherwise
     */
    _validateToolbars: function _validateToolbars(value) {
        return _lang2.default.isObject(value) || _lang2.default.isNull(value);
    }
}, {
    ATTRS: {
        /**
         * Configures the allowed content for the current instance of AlloyEditor.
         * Look on the [official CKEditor API](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent)
         * for more information about the valid values.
         *
         * @memberof Core
         * @instance
         * @property allowedContent
         * @default true
         * @writeOnce
         * @type {Boolean, String, Object}
         */
        allowedContent: {
            validator: '_validateAllowedContent',
            value: true,
            writeOnce: true
        },

        /**
         * Specifies whether AlloyEditor set the contenteditable attribute
         * to "true" on its srcNode.
         *
         * @memberof Core
         * @instance
         * @property enableContentEditable
         * @type Boolean
         * @default true
         * @writeOnce
         */
        enableContentEditable: {
            validator: _lang2.default.isBoolean,
            value: true,
            writeOnce: true
        },

        /**
         * The delay (timeout), in ms, after which events such like key or mouse events will be processed.
         *
         * @memberof Core
         * @instance
         * @property eventsDelay
         * @type {Number}
         */
        eventsDelay: {
            validator: _lang2.default.isNumber,
            value: 100
        },

        /**
         * Specifies the extra plugins which have to be loaded to the current CKEditor instance in order to
         * make AlloyEditor to work properly.
         *
         * @memberof Core
         * @instance
         * @property extraPlugins
         * @default 'uicore,selectionregion,dragresize,addimages,placeholder,tabletools,tableresize,autolink'
         * @writeOnce
         * @type {String}
         */
        extraPlugins: {
            validator: _lang2.default.isString,
            value: 'ae_uicore,ae_selectionregion,ae_selectionkeystrokes,ae_imagealignment,ae_addimages,ae_placeholder,' + 'ae_tabletools,ae_tableresize,ae_autolink,ae_embed,ae_autolist,ae_dragresize,' + 'ae_uibridge,ae_richcombobridge,ae_panelmenubuttonbridge,ae_menubridge,ae_menubuttonbridge,ae_buttonbridge,font,colorbutton',
            writeOnce: true
        },

        /**
         * Specifies the "mode" for alloy editor
         * @memberof Core
         * @instance
         * @property mode
         * @default 'simple'
         * @writeOnce
         * @type {String}
         */
        mode: {
            validator: _lang2.default.isString,
            value: 'simple'
        },

        /**
         * Retrieves the native CKEditor instance. Having this, the developer may use the full API of CKEditor.
         *
         * @memberof Core
         * @instance
         * @property nativeEditor
         * @readOnly
         * @type {Object}
         */
        nativeEditor: {
            getter: '_getNativeEditor',
            readOnly: true
        },

        /**
         * Specifies the class, which should be added by Placeholder plugin
         * {{#crossLink "CKEDITOR.plugins.ae_placeholder}}{{/crossLink}}
         * when editor is not focused.
         *
         * @memberof Core
         * @instance
         * @property placeholderClass
         * @default 'ae-placeholder'
         * @writeOnce
         * @type {String}
         */
        placeholderClass: {
            validator: _lang2.default.isString,
            value: 'ae-placeholder',
            writeOnce: true
        },

        /**
         * Specifies the plugins, which come by default with CKEditor, but which are not needed by AlloyEditor.
         * These plugins add the default UI for CKeditor, which is no more needed. Please note that AlloyEdtor
         * comes with its own highly optimized copy of CKEditor (just customized via their official download page).
         * This version does not come with the unneeded plugins, so the value of this property won't be needed.
         * However, if you decide to go with the OOTB version of CKEditor, you will have to remove some of the
         * plugins if you decide to use AlloyEditor. Keep in mind that removing these plugins doesn't remove them
         * entirely from CKEditor. It just removes them from its current instance, in which you will use different
         * UI - those of AlloyEditor. You will be fully able to use both OOTB CKEditor and AlloyEditor on the same
         * page!
         *
         * @memberof Core
         * @instance
         * @property removePlugins
         * @default 'contextmenu,toolbar,elementspath,resize,liststyle,link'
         * @writeOnce
         * @type {String}
         */
        removePlugins: {
            validator: _lang2.default.isString,
            value: 'contextmenu,toolbar,elementspath,resize,liststyle,link',
            writeOnce: true
        },

        /**
         * Array of manual selection triggers. They can be configured to manually show a specific selection toolbar
         * by forcing the selection type. A selectionKeystroke item consists of a keys property with a [CKEditor keystroke
         * definition](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-keystrokes) and a selection property with
         * the selection name to trigger.
         *
         * @memberof Core
         * @instance
         * @property selectionKeystrokes
         * @type {Array}
         */
        selectionKeystrokes: {
            validator: _lang2.default.isArray,
            value: [{
                keys: CKEDITOR.CTRL + 76 /*L*/
                , selection: 'link'
            }, {
                keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /*L*/
                , selection: 'embed'
            }]
        },

        /**
         * The Node ID or HTMl node, which AlloyEditor should use as an editable area.
         *
         * @memberof Core
         * @instance
         * @property srcNode
         * @type String | Node
         * @writeOnce
         */
        srcNode: {
            setter: '_toElement',
            writeOnce: true
        },

        /**
         * The toolbars configuration for this editor instance
         *
         * @memberof Core
         * @instance
         * @property {Object} toolbars
         */
        toolbars: {
            validator: '_validateToolbars',
            value: {
                add: {
                    buttons: ['image', 'embed', 'camera', 'hline', 'table'],
                    tabIndex: 2
                },
                styles: {
                    selections: _selections2.default,
                    tabIndex: 1
                }
            }
        },

        /**
         * The Node ID or HTMl node, where AlloyEditor's UI should be rendered.
         *
         * @memberof Core
         * @instance
         * @property uiNode
         * @type String | Node
         * @writeOnce
         */
        uiNode: {
            setter: '_toElement',
            writeOnce: true
        }
    }
});

CKEDITOR.event.implementOn(Core);

exports.default = Core;

/***/ }),

/***/ "./src/adapter/main.js":
/*!*****************************!*\
  !*** ./src/adapter/main.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Toolbars = exports.SelectionTest = exports.SelectionSetPosition = exports.Selections = exports.SelectionGetArrowBoxClasses = exports.registerBridgeButton = exports.OOP = exports.loadLanguageResources = exports.Lang = exports.implementEventTarget = exports.getUrl = exports.getButtons = exports.getBasePath = exports.editable = exports.Core = exports.Buttons = exports.Attribute = undefined;

var _core = __webpack_require__(/*! ./core.js */ "./src/adapter/core.js");

var _core2 = _interopRequireDefault(_core);

var _lang = __webpack_require__(/*! ../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _buttons = __webpack_require__(/*! ../components/buttons */ "./src/components/buttons/index.js");

var _buttons2 = _interopRequireDefault(_buttons);

var _toolbars = __webpack_require__(/*! ../components/toolbars */ "./src/components/toolbars/index.js");

var _toolbars2 = _interopRequireDefault(_toolbars);

var _selectionArrowbox = __webpack_require__(/*! ../selections/selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _selectionPosition = __webpack_require__(/*! ../selections/selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

var _attribute = __webpack_require__(/*! ../oop/attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// An object containing all currently registered plugins in AlloyEditor.
var BRIDGE_BUTTONS = {};

/**
 * Creates an instance of AlloyEditor.
 *
 * @memberof AlloyEditor
 * @method editable
 * @static
 * @param {String|Node} node The Node ID or HTMl node, which AlloyEditor should use as an editable area.
 * @param {Object} config Configuration attributes for the current instance of AlloyEditor.
 * @return {Object} An instance of {{#crossLink "Core"}}{{/crossLink}}
 */
var editable = function editable(node, config) {
    config = config || {};
    config.srcNode = node;

    AlloyEditor.implementEventTarget();

    return new _core2.default(config);
};

/**
 * The full URL for the AlloyEditor installation directory.
 * It is possible to manually provide the base path by setting a
 * global variable named `ALLOYEDITOR_BASEPATH`. This global variable
 * must be set **before** the editor script loading.
 *
 * @memberof AlloyEditor
 * @method getBasePath
 * @static
 * @return {String} The found base path
 */
var getBasePath = function getBasePath() {
    // Find out the editor directory path, based on its <script> tag.
    var path = window.ALLOYEDITOR_BASEPATH || '';

    if (!path) {
        var scripts = document.getElementsByTagName('script');

        for (var i = 0; i < scripts.length; i++) {
            var match = scripts[i].src.match(AlloyEditor.regexBasePath);

            if (match) {
                path = match[1];
                break;
            }
        }
    }

    // In IE (only) the script.src string is the raw value entered in the
    // HTML source. Other browsers return the full resolved URL instead.
    if (path.indexOf(':/') === -1 && path.slice(0, 2) !== '//') {
        // Absolute path.
        if (path.indexOf('/') === 0) {
            path = location.href.match(/^.*?:\/\/[^\/]*/)[0] + path;
        }
        // Relative path.
        else {
                path = location.href.match(/^[^\?]*\/(?:)/)[0] + path;
            }
    }

    if (!path) {
        throw 'The AlloyEditor installation path could not be automatically detected. Please set the global variable "ALLOYEDITOR_BASEPATH" before creating editor instances.';
    }

    return path;
};

/**
 * Detects and load the corresponding language file if AlloyEditor language strings are not already present.
 * The function fires a {{#crossLink "AlloyEditor/languageResourcesLoaded:event"}}{{/crossLink}} event
 *
 * @memberof AlloyEditor
 * @method loadLanguageResources
 * @static
 * @param {Function} callback Optional callback to be called when AlloyEditor loads the language resource.
 */
var loadLanguageResources = function loadLanguageResources(callback) {
    AlloyEditor.implementEventTarget();

    if (_lang2.default.isFunction(callback)) {
        if (AlloyEditor.Strings) {
            setTimeout(callback, 0);
        } else {
            AlloyEditor.once('languageResourcesLoaded', function () {
                setTimeout(callback, 0);
            });
        }
    }

    if (!AlloyEditor._langResourceRequested) {
        AlloyEditor._langResourceRequested = true;

        var languages = ['af', 'ar', 'bg', 'bn', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fo', 'fr-ca', 'fr', 'gl', 'gu', 'he', 'hi', 'hr', 'hu', 'id', 'is', 'it', 'ja', 'ka', 'km', 'ko', 'ku', 'lt', 'lv', 'mk', 'mn', 'ms', 'nb', 'nl', 'no', 'pl', 'pt-br', 'pt', 'ro', 'ru', 'si', 'sk', 'sl', 'sq', 'sr-latn', 'sr', 'sv', 'th', 'tr', 'tt', 'ug', 'uk', 'vi', 'zh-cn', 'zh'];

        var userLanguage = navigator.language || navigator.userLanguage || 'en';

        var parts = userLanguage.toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/);
        var lang = parts[1];
        var locale = parts[2];

        if (languages.indexOf(lang + '-' + locale) >= 0) {
            lang = lang + '-' + locale;
        } else if (languages.indexOf(lang) === -1) {
            lang = 'en';
        }

        CKEDITOR.scriptLoader.load(AlloyEditor.getUrl('lang/alloy-editor/' + lang + '.js'), function (loaded) {
            if (loaded) {
                AlloyEditor.fire('languageResourcesLoaded');
            }
        }, this);
    }
};

/**
 * Gets the full URL for AlloyEditor resources. By default, URLs
 * returned by this function contain a querystring parameter ("t")
 * set to the {@link CKEDITOR#timestamp} value.
 *
 * @memberof AlloyEditor
 * @method getUrl
 * @static
 * @param {String} resource The resource whose full URL we want to get.
 * It may be a full, absolute, or relative URL.
 * @return {String} The full URL.
 */
var getUrl = function getUrl(resource) {
    var basePath = AlloyEditor.getBasePath();

    // If this is not a full or absolute path.
    if (resource.indexOf(':/') === -1 && resource.indexOf('/') !== 0) {
        resource = basePath + resource;
    }

    // Add the timestamp, except for directories.
    if (CKEDITOR.timestamp && resource.charAt(resource.length - 1) !== '/' && !/[&?]t=/.test(resource)) {
        resource += (resource.indexOf('?') >= 0 ? '&' : '?') + 't=' + CKEDITOR.timestamp;
    }

    return resource;
};

/**
 * Implements event firing and subscribing via CKEDITOR.event.
 *
 * @memberof AlloyEditor
 * @method implementEventTarget
 * @static
 */
var implementEventTarget = function implementEventTarget() {
    if (!AlloyEditor.fire && !AlloyEditor.on) {
        CKEDITOR.event.implementOn(AlloyEditor);
    }
};

/**
 * Regular expression which should match the script which have been used to load AlloyEditor.
 *
 * @memberof AlloyEditor
 * @property regexBasePath
 * @type {RegExp}
 * @static
 */
var regexBasePath = /(^|.*[\\\/])(?:alloy-editor[^/]+|alloy-editor)\.js(?:\?.*|;.*)?$/i;

/**
 * Fired when AlloyEditor detects the browser language and loads the corresponding language file. Once this event
 * is fired, AlloyEditor.Strings will be populated with data.
 *
 * @event languageResourcesLoaded
 */

/**
 * Returns the required plugin names needed for a given plugin
 * if it is already registered or an empty array.
 *
 * @memberof AlloyEditor
 * @method getButtons
 * @param {Array} buttons An array of buttons or plugin names.
 * @return {Function} A function that can be invoked to resolve the requested button names.
 * @static
 */
var getButtons = function getButtons(buttons) {
    return function () {
        return buttons.reduce(function (acc, val) {
            val = BRIDGE_BUTTONS[val] || [val];
            return acc.concat(val);
        }, []);
    };
};

/**
 * Register a button and try to get its required plugins.
 *
 * @memberof AlloyEditor
 * @method registerBridgeButton
 * @param {String} buttonName The name of the button.
 * @param {String} pluginName The name of the plugin that registers the button.
 * @static
 */
var registerBridgeButton = function registerBridgeButton(buttonName, pluginName) {
    if (!BRIDGE_BUTTONS[pluginName]) {
        BRIDGE_BUTTONS[pluginName] = [];
    }

    BRIDGE_BUTTONS[pluginName].push(buttonName);
};

/**
 * @method OOP
 * @memberof AlloyEditor
 */
var OOP = {
    extend: _oop2.default
};

exports.Attribute = _attribute2.default;
exports.Buttons = _buttons2.default;
exports.Core = _core2.default;
exports.editable = editable;
exports.getBasePath = getBasePath;
exports.getButtons = getButtons;
exports.getUrl = getUrl;
exports.implementEventTarget = implementEventTarget;
exports.Lang = _lang2.default;
exports.loadLanguageResources = loadLanguageResources;
exports.OOP = OOP;
exports.registerBridgeButton = registerBridgeButton;
exports.SelectionGetArrowBoxClasses = _selectionArrowbox2.default;
exports.Selections = _selections2.default;
exports.SelectionSetPosition = _selectionPosition2.default;
exports.SelectionTest = _selectionTest2.default;
exports.Toolbars = _toolbars2.default;

/***/ }),

/***/ "./src/components/base/button-action-style.js":
/*!****************************************************!*\
  !*** ./src/components/base/button-action-style.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonActionStyle is a mixin that provides applying style implementation for a
 * button based on the `applyStyle` and `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following methods which can be obtained
 * out of the box using the {{#crossLink "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to return the style that should be applied
 *
 * @class ButtonActionStyle
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'applyStyle',

            /**
             * Removes or applies the component style to the current selection.
             *
             * @instance
             * @memberof ButtonActionStyle
             * @method applyStyle
             */
            value: function applyStyle() {
                if (_lang2.default.isFunction(this.isActive) && _lang2.default.isFunction(this.getStyle)) {
                    var editor = this.props.editor.get('nativeEditor');

                    editor.getSelection().lock();

                    if (this.isActive()) {
                        editor.removeStyle(this.getStyle());
                    } else {
                        editor.applyStyle(this.getStyle());
                    }

                    editor.getSelection().unlock();

                    editor.fire('actionPerformed', this);
                }
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-command-active.js":
/*!******************************************************!*\
  !*** ./src/components/base/button-command-active.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to determine if
 * a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
exports.default = function (WrappedComponent) {
  return function (_WrappedComponent) {
    _inherits(_class, _WrappedComponent);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'isActive',

      /**
       * Checks if the command is active in the current selection.
       *
       * @instance
       * @memberof ButtonCommandActive
       * @method isActive
       * @return {Boolean} True if the command is active, false otherwise.
       */
      value: function isActive() {
        var editor = this.props.editor.get('nativeEditor');

        var command = editor.getCommand(this.props.command);

        return command ? command.state === CKEDITOR.TRISTATE_ON : false;
      }
    }]);

    return _class;
  }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-command.js":
/*!***********************************************!*\
  !*** ./src/components/base/button-command.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'execCommand',

            /**
             * Executes a CKEditor command and fires `actionPerformed` event.
             *
             * @instance
             * @memberof ButtonCommand
             * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
             * @method execCommand
             */
            value: function execCommand(data) {
                var editor = this.props.editor.get('nativeEditor');

                editor.execCommand(this.props.command, data);

                if (this.props.modifiesSelection) {
                    editor.selectionChange(true);
                }

                editor.fire('actionPerformed', this);
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-keystroke.js":
/*!*************************************************!*\
  !*** ./src/components/base/button-keystroke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentWillMount',

            /**
             * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
             *
             * @instance
             * @memberof ButtonKeystroke
             * @method componentWillMount
             */
            value: function componentWillMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this).call(this);
                }

                var nativeEditor = this.props.editor.get('nativeEditor');
                var keystroke = this.props.keystroke;

                var commandName = keystroke.name || (Math.random() * 1e9 >>> 0).toString();

                var command = nativeEditor.getCommand(commandName);

                if (!command) {
                    command = new CKEDITOR.command(nativeEditor, {
                        exec: function (editor) {
                            var keystrokeFn = keystroke.fn;

                            if (_lang2.default.isString(keystrokeFn)) {
                                this[keystrokeFn].call(this, editor);
                            } else if (_lang2.default.isFunction(keystrokeFn)) {
                                keystrokeFn.call(this, editor);
                            }
                        }.bind(this)
                    });

                    nativeEditor.addCommand(commandName, command);
                }

                this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

                nativeEditor.setKeystroke(keystroke.keys, commandName);
            }

            /**
             * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
             *
             * @instance
             * @memberof ButtonKeystroke
             * @method componentWillUnmount
             */

        }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this).call(this);
                }

                this.props.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-props.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-props.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCfgProps is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonCfgProps
 */
exports.default = function (WrappedComponent) {
  return function (_WrappedComponent) {
    _inherits(_class, _WrappedComponent);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'mergeButtonCfgProps',

      /**
       * Merges the properties, passed to the current component with user's configuration
       * via `buttonCfg` property.
       *
       * @instance
       * @memberof ButtonCfgProps
       * @method mergeButtonCfgProps
       * @param {Object} props The properties to be merged with the provided configuration for this
       * button. If not passed, the user configuration will be merged with `this.props`
       * @return {Object} The merged properties
       */
      value: function mergeButtonCfgProps(props) {
        props = props || this.props;

        var nativeEditor = this.props.editor.get('nativeEditor');
        var buttonCfg = nativeEditor.config.buttonCfg || {};
        var result = CKEDITOR.tools.merge(props, buttonCfg['linkEdit']);

        return result;
      }
    }]);

    return _class;
  }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-state-classes.js":
/*!*****************************************************!*\
  !*** ./src/components/base/button-state-classes.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 * - `Function` **isDisabled** to check the disabled state
 *
 * @class ButtonStateClasses
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getStateClasses',

            /**
             * Returns the list of state classes associated to the current element's state, according
             * to the results of the isActive and isDisabled methods.
             *
             * @instance
             * @memberof ButtonStateClasses
             * @method getStateClasses
             * @return {String} A string with the state CSS classes.
             */
            value: function getStateClasses() {
                var stateClasses = '';

                // Check for active state
                if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
                    stateClasses += 'ae-button-pressed';
                }

                // Check for disabled state
                if (_lang2.default.isFunction(this.isDisabled) && this.isDisabled()) {
                    stateClasses += ' ae-button-disabled';
                }

                return stateClasses;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-style.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-style.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonStyle
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentWillMount',

            /**
             * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
             *
             * @instance
             * @memberof ButtonStyle
             * @method componentWillMount
             */
            value: function componentWillMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this).call(this);
                }

                var style = this.props.style;

                if (_lang2.default.isString(style)) {
                    var parts = style.split('.');
                    var currentMember = this.props.editor.get('nativeEditor').config;
                    var property = parts.shift();

                    while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
                        currentMember = currentMember[property];
                        property = parts.shift();
                    }

                    if (_lang2.default.isObject(currentMember)) {
                        style = currentMember;
                    }
                }

                this._style = new CKEDITOR.style(style);
            }

            /**
             * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
             *
             * @instance
             * @memberof ButtonStyle
             * @method componentWillUnmount
             */

        }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this).call(this);
                }

                this._style = null;
            }

            /**
             * Returns instance of CKEDITOR.style which represents the current button style.
             *
             * @instance
             * @memberof ButtonStyle
             * @method getStyle
             * @return {CKEDITOR.style} The current style representation.
             */

        }, {
            key: 'getStyle',
            value: function getStyle() {
                return this._style;
            }

            /**
             * Checks if style is active in the current selection.
             *
             * @instance
             * @memberof ButtonStyle
             * @method isActive
             * @return {Boolean} True if style is active, false otherwise.
             */

        }, {
            key: 'isActive',
            value: function isActive() {
                var result;

                var editor = this.props.editor.get('nativeEditor');

                var elementPath = editor.elementPath();

                result = this.getStyle().checkActive(elementPath, editor);

                return result;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

// WrappedComponent.propTypes = {
//     /**
//     * The style the button should handle. Allowed values are:
//     * - Object as described by http://docs.ckeditor.com/#!/api/CKEDITOR.style.
//     * - String pointing to an object inside the editor instance configuration. For example, `style = 'coreStyles_bold'` will try to
//     * retrieve the style object from `editor.config.coreStyles_bold`. Nested properties such as `style = 'myplugin.myConfig.myStyle'`
//     * are also supported and will try to retrieve the style object from the editor configuration as well.
//     *
//     * @instance
//     * @memberof ButtonStyle
//     * @property {Object|String} style
//     */
//     style: PropTypes.oneOfType([
//         PropTypes.object,
//         PropTypes.string
//     ]),
//     /**
//      * The style function the button should handle.
//      * If specified, style function has higher priority than style property.
//      *
//      * @instance
//      * @memberof ButtonStyle
//      * @property {function} styleFn
//      */
//     styleFn: PropTypes.func
// };

/***/ }),

/***/ "./src/components/base/toolbar-buttons.js":
/*!************************************************!*\
  !*** ./src/components/base/toolbar-buttons.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ToolbarButtons is a mixin which provides a list of buttons which have to be
 * displayed on the current toolbar depending on user preferences and given state.
 *
 * @class ToolbarButtons
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getToolbarButtonGroups',

            /**
             * Analayses the current selection and returns the buttons or button groups to be rendered.
             *
             * @instance
             * @method getToolbarButtonGroups
             * @param {Array} buttons The buttons could be shown, prior to the state filtering.
             * @param {Object} additionalProps Additional props that should be passed down to the buttons.
             * @return {Array} An Array which contains the buttons or button groups that should be rendered.
             */
            value: function getToolbarButtonGroups(buttons, additionalProps) {
                var instance = this;

                if (_lang2.default.isFunction(buttons)) {
                    buttons = buttons.call(this) || [];
                }

                return buttons.reduce(function (list, button) {
                    if (Array.isArray(button)) {
                        list.push(instance.getToolbarButtons(button, additionalProps));
                        return list;
                    } else {
                        return instance.getToolbarButtons(buttons, additionalProps);
                    }
                }, []);
            }

            /**
             * Analyzes the current selection and the buttons exclusive mode value to figure out which
             * buttons should be present in a given state.
             *
             * @instance
             * @memberof ToolbarButtons
             * @method getToolbarButtons
             * @param {Array} buttons The buttons could be shown, prior to the state filtering.
             * @param {Object} additionalProps Additional props that should be passed down to the buttons.
             * @return {Array} An Array which contains the buttons that should be rendered.
             */

        }, {
            key: 'getToolbarButtons',
            value: function getToolbarButtons(buttons, additionalProps) {
                var buttonProps = {};

                var nativeEditor = this.props.editor.get('nativeEditor');
                var buttonCfg = nativeEditor.config.buttonCfg || {};

                if (_lang2.default.isFunction(buttons)) {
                    buttons = buttons.call(this) || [];
                }

                var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
                    return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
                }).map(function (button) {
                    if (_lang2.default.isString(button)) {
                        buttonProps[button] = buttonCfg[button];
                        button = AlloyEditor.Buttons[button];
                    } else if (_lang2.default.isString(button.name)) {
                        buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
                        button = AlloyEditor.Buttons[button.name];
                    }

                    return button;
                })).map(function (button, index) {
                    var props = this.mergeExclusiveProps({
                        editor: this.props.editor,
                        key: button.key !== 'separator' ? button.key : button.key + '-' + index,
                        tabKey: button.key,
                        tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
                        trigger: this.props.trigger
                    }, button.key);

                    props = this.mergeDropdownProps(props, button.key);

                    if (additionalProps) {
                        props = CKEDITOR.tools.merge(props, additionalProps);
                    }

                    props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

                    return _react2.default.createElement(button, props);
                }, this);

                return toolbarButtons;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-arrow-box.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-arrow-box.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for displaying Widget Arrow box on top or on bottom of the widget
 * depending on the point of user interaction with the editor.
 *
 * @class WidgetArrowBox
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getArrowBoxClasses',

            /**
             * Returns the list of arrow box classes associated to the current element's state. It relies
             * on the getInteractionPoint method to calculate the selection direction.
             *
             * @instance
             * @memberof WidgetArrowBox
             * @method getArrowBoxClasses
             * @return {String} A string with the arrow box CSS classes.
             */
            value: function getArrowBoxClasses() {
                var arrowBoxClasses = 'ae-arrow-box';

                if (_lang2.default.isFunction(this.getInteractionPoint) && this.getInteractionPoint()) {
                    if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
                        arrowBoxClasses += ' ae-arrow-box-top';
                    } else {
                        arrowBoxClasses += ' ae-arrow-box-bottom';
                    }
                }

                return arrowBoxClasses;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-dropdown.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-dropdown.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class(props) {
            _classCallCheck(this, _class);

            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));

            _this.state = _extends({}, _this.state, {
                dropdownTrigger: null,
                itemDropdown: null
            });
            return _this;
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof WidgetDropdown
         * @method componentWillReceiveProps
         */


        _createClass(_class, [{
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps) {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this).call(this);
                }

                this.setState({
                    dropdownTrigger: null,
                    itemDropdown: null
                });
            }

            /**
             * Merges the provided object with two more properties:
             * - expanded - boolean flag which indicates if an widget should be rendered exclusively.
             * - toggleDropdown - function, which can be used by an widget in order to obtain exclusive state.
             *
             * @instance
             * @memberof WidgetDropdown
             * @method mergeDropdownProps
             * @param {Object} obj The properties container which should be merged with the properties, related
             *    to dropdown state.
             * @param {Object} itemKey They key of an React Widget which contains the dropdown.
             * @return {Object} The merged object.
             */

        }, {
            key: 'mergeDropdownProps',
            value: function mergeDropdownProps(obj, itemKey) {
                return CKEDITOR.tools.merge(obj, {
                    expanded: this.state.itemDropdown === itemKey ? true : false,
                    tabIndex: this.state.dropdownTrigger === itemKey ? 0 : -1,
                    toggleDropdown: this.toggleDropdown.bind(this, itemKey)
                });
            }

            /**
             * Sets the active dropdown of the widget or discards the toggled item from the state.
             *
             * @instance
             * @memberof WidgetDropdown
             * @method toggleDropdown
             * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
             * @param {Number} toggleDirection User movement direction when toggled via keyboard.
             */

        }, {
            key: 'toggleDropdown',
            value: function toggleDropdown(itemDropdown, toggleDirection) {
                this.setState({
                    dropdownTrigger: itemDropdown,
                    itemDropdown: itemDropdown !== this.state.itemDropdown ? itemDropdown : null
                }, function () {
                    if (!this.state.itemDropdown) {
                        if (this.moveFocus) {
                            this.moveFocus(toggleDirection);
                        } else {
                            _reactDom2.default.findDOMNode(this).focus();
                        }
                    }
                });
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-exclusive.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-exclusive.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'cancelExclusive',

            /**
             * Cancels the exclusive state of an widget.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method cancelExclusive
             * @param {Object} itemExclusive The widget which exclusive state should be canceled.
             */
            value: function cancelExclusive(itemExclusive) {
                if (this.state.itemExclusive === itemExclusive) {
                    this.setState({
                        itemExclusive: null
                    });
                }
            }

            /**
             * Lifecycle. Invoked when a component is receiving new props.
             * This method is not called for the initial render.
             * Calling this.setState() within this function will not trigger an additional render.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method componentWillReceiveProps
             * @param {Object} nextProps Object containing the current set of properties.
             */

        }, {
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps) {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this).call(this);
                }

                // Receiving properties means that the component is being re-rendered.
                // Re-rendering is triggered by editorInteraction, so we have to
                // reset the exclusive state and render the UI according to the new selection.
                this.setState({
                    itemExclusive: null
                });
            }

            /**
             * Filters the items and returns only those with exclusive state.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method filterExclusive
             * @param {Array} items The widgets to be filtered.
             * @return {Array|Object} The item with executive state.
             */

        }, {
            key: 'filterExclusive',
            value: function filterExclusive(items) {
                return items.filter(function (item) {
                    if (this.state.itemExclusive) {
                        if (this.state.itemExclusive === item.key) {
                            return item;
                        }
                    } else {
                        return item;
                    }
                }.bind(this));
            }

            /**
             * Merges the provided object with three more properties:
             * - cancelExclusive - function, which can be used by a widget in order to cancel executive state.
             * - renderExclusive - boolean flag which indicates if an widget should be rendered exclusively.
             * - requestExclusive - function, which can be used by a widget in order to obtain exclusive state.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method mergeExclusiveProps
             * @param {Object} obj The properties container which should be merged with the properties, related
             *    to exclusive state.
             * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
             * @return {Object} The merged object.
             */

        }, {
            key: 'mergeExclusiveProps',
            value: function mergeExclusiveProps(obj, itemKey) {
                return CKEDITOR.tools.merge(obj, {
                    cancelExclusive: this.cancelExclusive.bind(this, itemKey),
                    renderExclusive: this.state.itemExclusive === itemKey,
                    requestExclusive: this.requestExclusive.bind(this, itemKey)
                });
            }

            /**
             * Requests and sets exclusive state of an widget.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method requestExclusive
             * @param {Object} itemExclusive The widget which requests exclusive state.
             */

        }, {
            key: 'requestExclusive',
            value: function requestExclusive(itemExclusive) {
                this.setState({
                    itemExclusive: itemExclusive
                });
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-focus-manager.js":
/*!*****************************************************!*\
  !*** ./src/components/base/widget-focus-manager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DIRECTION_NONE = 0;
var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */

exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentDidMount',

            /**
             * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method componentDidMount
             */
            value: function componentDidMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidMount', this).call(this);
                }

                this._refresh();
            }

            /**
             * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
             * Refreshes the descendants list.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method componentDidUpdate
             */

        }, {
            key: 'componentDidUpdate',
            value: function componentDidUpdate() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidUpdate', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidUpdate', this).call(this);
                }

                this._refresh();
            }

            /**
             * Focuses the current active descendant.
             *
             * Several Widgets can be nested in a component hierarchy by attaching this focus method to
             * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method focus
             */

        }, {
            key: 'focus',
            value: function focus(event) {
                if (!event || this._isValidTarget(event.target)) {
                    if (this._descendants && this._descendants.length) {
                        var activeDescendantEl = this._descendants[this._activeDescendant];
                        // When user clicks with the mouse, the activeElement is already set and there
                        // is no need to focus it. Focusing of the active descendant (usually some button) is required
                        // in case of keyboard navigation, because the focused element might be not the first button,
                        // but the div element, which contains the button.
                        if (document.activeElement !== activeDescendantEl && !this.props.focusFirstChild) {
                            if (this._descendants.indexOf(document.activeElement) === -1) {
                                activeDescendantEl.focus();
                            }
                        }

                        if (event) {
                            event.stopPropagation();
                            event.preventDefault();
                        }
                    }
                }
            }

            /**
             * Handles the key events on a DOM node to execute the appropriate navigation when needed.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @param {Object} event The Keyboard event that was detected on the widget DOM node.
             * @method handleKey
             */

        }, {
            key: 'handleKey',
            value: function handleKey(event) {
                if (this._isValidTarget(event.target) && this._descendants) {
                    var action = this._getFocusAction(event);

                    if (action.type) {
                        event.stopPropagation();
                        event.preventDefault();

                        if (action.type === ACTION_MOVE_FOCUS) {
                            this._moveFocus(action.direction);
                        }

                        if (action.type === ACTION_DISMISS_FOCUS) {
                            this.props.onDismiss(action.direction);
                        }
                    }
                }
            }

            /**
             * Moves the focus among descendants in the especified direction.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method moveFocus
             * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
             */

        }, {
            key: 'moveFocus',
            value: function moveFocus(direction) {
                direction = _lang2.default.isNumber(direction) ? direction : 0;

                this._moveFocus(direction);
            }

            /**
             * Returns the action, if any, that a keyboard event in the current focus manager state
             * should produce.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusAction
             * @param {object} event The Keyboard event.
             * @protected
             * @return {Object} An action object with type and direction properties.
             */

        }, {
            key: '_getFocusAction',
            value: function _getFocusAction(event) {
                var action = {
                    type: ACTION_NONE
                };

                if (this.props.keys) {
                    var direction = this._getFocusMoveDirection(event);

                    if (direction) {
                        action.direction = direction;
                        action.type = ACTION_MOVE_FOCUS;
                    }

                    var dismissAction = this._getFocusDismissAction(event, direction);

                    if (dismissAction.dismiss) {
                        action.direction = dismissAction.direction;
                        action.type = ACTION_DISMISS_FOCUS;
                    }
                }

                return action;
            }

            /**
             * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
             * will happen in any of these scenarios if a dismiss callback has been specified:
             * - A dismiss key has been pressed
             * - In a non-circular focus manager, when:
             *     - The active descendant is the first one and a prev key has been pressed.
             *     - The active descendant is the last one and a next key has been pressed.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusDismissAction
             * @param {Number} focusMoveDirection The focus movement direction (if any).
             * @param {Object} event The Keyboard event.
             * @protected
             * @return {Object} A dismiss action with dismiss and direction properties.
             */

        }, {
            key: '_getFocusDismissAction',
            value: function _getFocusDismissAction(event, focusMoveDirection) {
                var dismissAction = {
                    direction: focusMoveDirection,
                    dismiss: false
                };

                if (this.props.onDismiss) {
                    if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
                        dismissAction.dismiss = true;
                    }
                    if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
                        dismissAction.dismiss = true;
                        dismissAction.direction = DIRECTION_NEXT;
                    }
                    if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
                        dismissAction.dismiss = true;
                        dismissAction.direction = DIRECTION_PREV;
                    }

                    if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
                        dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
                    }
                }

                return dismissAction;
            }

            /**
             * Returns the direction, if any, in which the focus should be moved. In presence of the
             * shift key modifier, the direction of the movement is inverted.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusMoveDirection
             * @param {Object} event The Keyboard event.
             * @protected
             * @return {Number} The computed direction of the expected focus movement.
             */

        }, {
            key: '_getFocusMoveDirection',
            value: function _getFocusMoveDirection(event) {
                var direction = DIRECTION_NONE;

                if (this._isValidKey(event.keyCode, this.props.keys.next)) {
                    direction = DIRECTION_NEXT;
                }
                if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
                    direction = DIRECTION_PREV;
                }

                if (event.shifKey) {
                    direction *= -1;
                }

                return direction;
            }

            /**
             * Indicates if a given keyCode is valid for the given set of keys.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _isValidKey
             * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
             * @param {Number} keyCode An event keyCode.
             * @protected
             * @return {Boolean} A boolean value indicating if the key is valid.
             */

        }, {
            key: '_isValidKey',
            value: function _isValidKey(keyCode, keys) {
                return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
            }

            /**
             * Indicates if a given element is valid for focus management. User input elements such as
             * input, select or textarea are excluded.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _isValidKey
             * @param {DOMNode} element A DOM element.
             * @protected
             * @return {Boolean} A boolean value indicating if the element is valid.
             */

        }, {
            key: '_isValidTarget',
            value: function _isValidTarget(element) {
                var tagName = element.tagName.toLowerCase();

                return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
            }

            /**
             * Moves the focus among descendants in the especified direction.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _moveFocus
             * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
             * @protected
             */

        }, {
            key: '_moveFocus',
            value: function _moveFocus(direction) {
                var numDescendants = this._descendants.length;

                var descendant = this._descendants[this._activeDescendant];

                descendant.setAttribute('tabIndex', -1);

                this._activeDescendant += direction;

                if (this.props.circular) {
                    // Calculate proper modulo result since remainder operator doesn't behave in the
                    // same way for negative numbers
                    this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
                } else {
                    this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
                }

                descendant = this._descendants[this._activeDescendant];

                descendant.setAttribute('tabIndex', 0);
                descendant.focus();
            }

            /**
             * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _refresh
             * @protected
             */

        }, {
            key: '_refresh',
            value: function _refresh() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (domNode) {
                    var descendants = domNode.querySelectorAll(this.props.descendants);

                    var priorityDescendants = [];

                    this._descendants = [];

                    Array.prototype.slice.call(descendants).forEach(function (item) {
                        var dataTabIndex = item.getAttribute('data-tabindex');

                        if (dataTabIndex) {
                            priorityDescendants.push(item);
                        } else {
                            this._descendants.push(item);
                        }
                    }.bind(this));

                    priorityDescendants = priorityDescendants.sort(function (a, b) {
                        return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
                    });

                    this._descendants = priorityDescendants.concat(this._descendants);

                    this._activeDescendant = 0;

                    this._descendants.some(function (item, index) {
                        if (item.getAttribute('tabindex') === '0') {
                            this._activeDescendant = index;
                            this.focus();

                            return true;
                        }
                    }.bind(this));
                }
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-position.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-position.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Calculates the position where an Widget should be displayed based on the point
 * where user interacted with the editor.
 *
 * @class WidgetPosition
 */
exports.default = function (WrappedComponent) {
    var _class, _temp;

    return _temp = _class = function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'cancelAnimation',


            /**
             * Cancels an scheduled animation frame.
             *
             * @instance
             * @memberof WidgetPosition
             * @method cancelAnimation
             */
            value: function cancelAnimation() {
                if (window.cancelAnimationFrame) {
                    window.cancelAnimationFrame(this._animationFrameId);
                }
            }

            /**
             * Returns an object which contains the position of the element in page coordinates,
             * restricted to fit to given viewport.
             *
             * @instance
             * @memberof WidgetPosition
             * @method getConstrainedPosition
             * @param {Object} attrs The following properties, provided as numbers:
             * - height
             * - left
             * - top
             * - width
             * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
             * - width
             * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
             * element.
             */

            /**
             * Lifecycle. Returns the default values of the properties used in the widget.
             *
             * @instance
             * @memberof WidgetPosition
             * @method getDefaultProps
             */

        }, {
            key: 'getConstrainedPosition',
            value: function getConstrainedPosition(attrs, viewPaneSize) {
                viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

                var x = attrs.left;
                var y = attrs.top;

                if (attrs.left + attrs.width > viewPaneSize.width) {
                    x -= attrs.left + attrs.width - viewPaneSize.width;
                }

                if (y < 0) {
                    y = 0;
                }

                return {
                    x: x,
                    y: y
                };
            }

            /**
             * Returns the position, in page coordinates, according to which a widget should appear.
             * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
             *
             * It depends on the props editorEvent to analyze the following user-interaction parameters:
             * - {Object} selectionData The data about the selection in the editor as returned from
             * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
             * This may be the point where the user released the mouse, or just the beginning or the end of
             * the selection.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method getInteractionPoint
             * @return {Object} An Object which contains the following properties:
             * direction, x, y, where x and y are in page coordinates and direction can be one of these:
             * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
             */

        }, {
            key: 'getInteractionPoint',
            value: function getInteractionPoint() {
                var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

                if (!eventPayload) {
                    return;
                }

                var selectionData = eventPayload.selectionData;

                var nativeEvent = eventPayload.nativeEvent;

                var pos = {
                    x: eventPayload.nativeEvent.pageX,
                    y: selectionData.region.top
                };

                var direction = selectionData.region.direction;

                var endRect = selectionData.region.endRect;

                var startRect = selectionData.region.startRect;

                if (endRect && startRect && startRect.top === endRect.top) {
                    direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
                }

                var x;
                var y;

                // If we have the point where user released the mouse, show Toolbar at this point
                // otherwise show it on the middle of the selection.

                if (pos.x && pos.y) {
                    x = this._getXPoint(selectionData, pos.x);

                    if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
                        y = Math.min(pos.y, selectionData.region.top);
                    } else {
                        y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
                    }
                } else {
                    x = selectionData.region.left + selectionData.region.width / 2;

                    if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {

                        y = this._getYPoint(selectionData, nativeEvent);
                    } else {
                        y = selectionData.region.top;
                    }
                }

                return {
                    direction: direction,
                    x: x,
                    y: y
                };
            }

            /**
             * Returns the position of the Widget.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method _getXPoint
             * @param {Object} eventX The X coordinate received from the native event (mouseup).
             * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * @protected
             * @return {Number} The calculated X point in page coordinates.
             */

        }, {
            key: '_getXPoint',
            value: function _getXPoint(selectionData, eventX) {
                var region = selectionData.region;

                var left = region.startRect ? region.startRect.left : region.left;
                var right = region.endRect ? region.endRect.right : region.right;

                var x;

                if (left < eventX && right > eventX) {
                    x = eventX;
                } else {
                    var leftDist = Math.abs(left - eventX);
                    var rightDist = Math.abs(right - eventX);

                    if (leftDist < rightDist) {
                        // user raised the mouse on left on the selection
                        x = left;
                    } else {
                        x = right;
                    }
                }

                return x;
            }

            /**
             * Returns the position of the Widget.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method _getYPoint
             * @param {Object} nativeEvent The data about event is fired
             * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * @protected
             * @return {Number} The calculated Y point in page coordinates.
             */

        }, {
            key: '_getYPoint',
            value: function _getYPoint(selectionData, nativeEvent) {
                var y = 0;

                if (selectionData && nativeEvent) {
                    var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

                    if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
                        y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
                    } else {
                        y = selectionData.region.bottom;
                    }
                }

                return y;
            }

            /**
             * Returns the position of the Widget taking in consideration the
             * {{#crossLink "WidgetPosition/gutter:attribute"}}{{/crossLink}} attribute.
             *
             * @instance
             * @memberof WidgetPosition
             * @protected
             * @method  getWidgetXYPoint
             * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
             * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
             * @param {Number} direction The direction of the selection. May be one of the following:
             * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
             * @return {Array} An Array with left and top offsets in page coordinates.
             */

        }, {
            key: 'getWidgetXYPoint',
            value: function getWidgetXYPoint(left, top, direction) {
                var domNode = _reactDom2.default.findDOMNode(this);

                var gutter = this.props.gutter;

                if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
                    left = left - gutter.left - domNode.offsetWidth / 2;

                    top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
                } else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {

                    left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

                    top = top - gutter.top - domNode.offsetHeight / 2;
                }

                if (left < 0) {
                    left = 0;
                }

                if (top < 0) {
                    top = 0;
                }

                return [left, top];
            }

            /**
             * Returns true if the widget is visible, false otherwise
             *
             * @instance
             * @memberof WidgetPosition
             * @method isVisible
             * @return {Boolean} True if the widget is visible, false otherwise
             */

        }, {
            key: 'isVisible',
            value: function isVisible() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (domNode) {
                    var domElement = new CKEDITOR.dom.element(domNode);

                    return domElement.hasClass('alloy-editor-visible');
                }

                return false;
            }

            /**
             * Moves a widget from a starting point to a destination point.
             *
             * @instance
             * @memberof WidgetPosition
             * @method moveToPoint
             * @param  {Object} startPoint The starting point for the movement.
             * @param  {Object} endPoint The destination point for the movement.
             */

        }, {
            key: 'moveToPoint',
            value: function moveToPoint(startPoint, endPoint) {
                var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

                domElement.setStyles({
                    left: startPoint[0] + 'px',
                    top: startPoint[1] + 'px',
                    opacity: 0
                });

                domElement.removeClass('alloy-editor-invisible');

                this._animate(function () {
                    domElement.addClass('ae-toolbar-transition');
                    domElement.addClass('alloy-editor-visible');
                    domElement.setStyles({
                        left: endPoint[0] + 'px',
                        top: endPoint[1] + 'px',
                        opacity: 1
                    });
                });
            }

            /**
             * Shows the widget with the default animation transition.
             *
             * @instance
             * @memberof WidgetPosition
             * @method show
             */

        }, {
            key: 'show',
            value: function show() {
                var domNode = _reactDom2.default.findDOMNode(this);
                var uiNode = this.props.editor.get('uiNode');

                var scrollTop = uiNode ? uiNode.scrollTop : 0;

                if (!this.isVisible() && domNode) {
                    var interactionPoint = this.getInteractionPoint();

                    if (interactionPoint) {
                        var domElement = new CKEDITOR.dom.element(domNode);

                        var finalX, finalY, initialX, initialY;

                        finalX = initialX = parseFloat(domElement.getStyle('left'));
                        finalY = initialY = parseFloat(domElement.getStyle('top'));

                        if (this.props.constrainToViewport) {
                            var res = this.getConstrainedPosition({
                                height: parseFloat(domNode.offsetHeight),
                                left: finalX,
                                top: finalY,
                                width: parseFloat(domNode.offsetWidth)
                            });

                            finalX = res.x;
                            finalY = res.y;
                        }

                        if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
                            initialY = this.props.selectionData.region.bottom + scrollTop;
                        } else {
                            initialY = this.props.selectionData.region.top + scrollTop;
                        }

                        this.moveToPoint([initialX, initialY], [finalX, finalY]);
                    }
                }
            }

            /**
             * Updates the widget position based on the current interaction point.
             *
             * @instance
             * @memberof WidgetPosition
             * @method updatePosition
             */

        }, {
            key: 'updatePosition',
            value: function updatePosition() {
                var interactionPoint = this.getInteractionPoint();

                var domNode = _reactDom2.default.findDOMNode(this);

                if (interactionPoint && domNode) {
                    var uiNode = this.props.editor.get('uiNode') || document.body;
                    var uiNodeStyle = getComputedStyle(uiNode);
                    var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
                    var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
                    var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

                    var scrollTop = uiNode ? uiNode.scrollTop : 0;

                    var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);
                    xy[1] += scrollTop;

                    if (xy[0] < 0) {
                        xy[0] = 0;
                    }
                    if (xy[0] > totalWidth - domNode.offsetWidth) {
                        xy[0] = totalWidth - domNode.offsetWidth;
                    }

                    new CKEDITOR.dom.element(domNode).setStyles({
                        left: xy[0] + 'px',
                        top: xy[1] + 'px'
                    });
                }
            }

            /**
             * Requests an animation frame, if possible, to simulate an animation.
             *
             * @instance
             * @memberof WidgetPosition
             * @method _animate
             * @param {Function} callback The function to be executed on the scheduled frame.
             * @protected
             */

        }, {
            key: '_animate',
            value: function _animate(callback) {
                if (window.requestAnimationFrame) {
                    this._animationFrameId = window.requestAnimationFrame(callback);
                } else {
                    callback();
                }
            }
        }]);

        return _class;
    }(WrappedComponent), _class.defaultProps = _extends({}, WrappedComponent.defaultProps, {
        gutter: {
            left: 0,
            top: 10
        },
        constrainToViewport: true }), _temp;
};

/***/ }),

/***/ "./src/components/buttons/button-bold.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-bold.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonBold class provides functionality for styling an selection with strong (bold) style.
 *
 * @class ButtonBold
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonBold = function (_React$Component) {
    _inherits(ButtonBold, _React$Component);

    function ButtonBold() {
        _classCallCheck(this, ButtonBold);

        return _possibleConstructorReturn(this, (ButtonBold.__proto__ || Object.getPrototypeOf(ButtonBold)).apply(this, arguments));
    }

    _createClass(ButtonBold, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonBold
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.bold, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-bold', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.bold },
                _react2.default.createElement('span', { className: 'ae-icon-bold' })
            );
        }
    }]);

    return ButtonBold;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default bold
 * @memberof ButtonBold
 * @property {String} key
 * @static
 */


ButtonBold.key = 'bold';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonBold
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonBold.defaultProps = {
    command: 'bold',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 66 /*B*/
    },
    style: 'coreStyles_bold'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonBold))));

/***/ }),

/***/ "./src/components/buttons/button-camera-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-camera-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCameraImage class takes photo from camera and inserts it to the content.
 *
 * @class ButtonCameraImage
 */
var ButtonCameraImage = function (_React$Component) {
    _inherits(ButtonCameraImage, _React$Component);

    function ButtonCameraImage() {
        _classCallCheck(this, ButtonCameraImage);

        return _possibleConstructorReturn(this, (ButtonCameraImage.__proto__ || Object.getPrototypeOf(ButtonCameraImage)).apply(this, arguments));
    }

    _createClass(ButtonCameraImage, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses the take photo button.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this.refs.buttonTakePhoto).focus();
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._stream) {
                if (this._stream.stop) {
                    this._stream.stop();
                } else if (this._stream.getVideoTracks) {
                    this._stream.getVideoTracks().forEach(function (track) {
                        track.stop();
                    });
                }
                this._stream = null;
            }
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

            getUserMedia.call(navigator, {
                video: true,
                audio: false
            }, this._handleStreamSuccess.bind(this), this._handleStreamError.bind(this));

            return _react2.default.createElement(
                'div',
                { className: 'ae-camera' },
                _react2.default.createElement(
                    'video',
                    { ref: 'videoContainer' },
                    'Video stream not available.'
                ),
                _react2.default.createElement(
                    'button',
                    { className: 'ae-camera-shoot', onClick: this.takePhoto.bind(this), ref: 'buttonTakePhoto' },
                    'Take photo'
                ),
                _react2.default.createElement('canvas', { className: 'ae-camera-canvas', ref: 'canvasContainer' })
            );
        }

        /**
         * Takes photo from the video stream and inserts in into editor's content.
         *
         * @fires ButtonCameraImage#imageCameraAdd
         * @instance
         * @memberof ButtonCameraImage
         * @method takePhoto
         */

    }, {
        key: 'takePhoto',
        value: function takePhoto() {
            var videoEl = _reactDom2.default.findDOMNode(this.refs.videoContainer);
            var canvasEl = _reactDom2.default.findDOMNode(this.refs.canvasContainer);

            var context = canvasEl.getContext('2d');

            var height = this._videoHeight;
            var width = this.props.videoWidth;

            if (width && height) {
                canvasEl.width = width;
                canvasEl.height = height;

                context.drawImage(videoEl, 0, 0, width, height);

                var imgURL = canvasEl.toDataURL('image/png');

                var el = CKEDITOR.dom.element.createFromHtml('<img src="' + imgURL + '">');

                var editor = this.props.editor.get('nativeEditor');

                editor.insertElement(el);

                this.props.cancelExclusive();

                editor.fire('actionPerformed', this);

                editor.fire('imageCameraAdd', el);
            }
        }

        /**
         * Displays error message in case of video stream capturing failure.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method _handleStreamError
         * @param {Event} error The fired event in case of error.
         * @protected
         */

    }, {
        key: '_handleStreamError',
        value: function _handleStreamError(error) {
            window.alert('An error occurred! ' + error);
        }

        /**
         * Starts streaming video in the video element and sets width/height to the video
         * and canvas elements.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method _handleStreamSuccess
         * @param {Object} stream The video stream
         * @protected
         */

    }, {
        key: '_handleStreamSuccess',
        value: function _handleStreamSuccess(stream) {
            var videoEl = _reactDom2.default.findDOMNode(this.refs.videoContainer);
            var canvasEl = _reactDom2.default.findDOMNode(this.refs.canvasContainer);

            videoEl.addEventListener('canplay', function (event) {
                var height = videoEl.videoHeight / (videoEl.videoWidth / this.props.videoWidth);

                if (isNaN(height)) {
                    height = this.props.videoWidth / (4 / 3);
                }

                videoEl.setAttribute('width', this.props.videoWidth);
                videoEl.setAttribute('height', height);
                canvasEl.setAttribute('width', this.props.videoWidth);
                canvasEl.setAttribute('height', height);

                this._videoHeight = height;
            }.bind(this), false);

            this._stream = stream;

            if (navigator.mozGetUserMedia) {
                videoEl.mozSrcObject = stream;
            } else {
                videoEl.src = (window.URL || window.webkitURL).createObjectURL(stream);
            }

            videoEl.play();

            _reactDom2.default.findDOMNode(this.refs.buttonTakePhoto).disabled = false;
        }

        /**
         * Fired when an image is being taken from the camera and added as an element to the editor.
         *
         * @event ButtonCameraImage#imageCameraAdd
         * @memberof ButtonCameraImage
         * @param {CKEDITOR.dom.element} el The created img element in editor.
         */

    }]);

    return ButtonCameraImage;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default cameraImage
 * @memberof ButtonCameraImage
 * @property {String} key
 * @static
 */


ButtonCameraImage.key = 'cameraImage';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCameraImage
 * @method getDefaultProps
 */
ButtonCameraImage.defaultProps = {
    videoWidth: 320
};

exports.default = ButtonCameraImage;

/***/ }),

/***/ "./src/components/buttons/button-camera.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-camera.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCamera class renders in two different ways:
 *
 * - Normal: Just a button that allows to switch to the edition mode.
 * - Exclusive: Renders ButtonCameraImage in order to take photo from the camera.
 *
 * @class ButtonCamera
 */
var ButtonCamera = function (_React$Component) {
    _inherits(ButtonCamera, _React$Component);

    function ButtonCamera() {
        _classCallCheck(this, ButtonCamera);

        return _possibleConstructorReturn(this, (ButtonCamera.__proto__ || Object.getPrototypeOf(ButtonCamera)).apply(this, arguments));
    }

    _createClass(ButtonCamera, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCamera
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonCameraImage2.default, this.props);
            } else {
                var disabled = !(navigator.getUserMedia || navigator.webkitGetUserMedia && location.protocol === 'https' || navigator.mozGetUserMedia || navigator.msGetUserMedia);

                var label = disabled ? AlloyEditor.Strings.cameraDisabled : AlloyEditor.Strings.camera;

                return _react2.default.createElement(
                    'button',
                    { 'aria-label': label, className: 'ae-button', 'data-type': 'button-image-camera', disabled: disabled, onClick: this.props.requestExclusive.bind(ButtonCamera.key), tabIndex: this.props.tabIndex, title: label },
                    _react2.default.createElement('span', { className: 'ae-icon-camera' })
                );
            }
        }
    }]);

    return ButtonCamera;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default camera
 * @memberof ButtonCamera
 * @property {String} key
 * @static
 */


ButtonCamera.key = 'camera';

exports.default = ButtonCamera;

/***/ }),

/***/ "./src/components/buttons/button-code.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-code.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCode class provides wraps a selection in `pre` element.
 *
 * @class ButtonCode
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonCode = function (_React$Component) {
    _inherits(ButtonCode, _React$Component);

    function ButtonCode() {
        _classCallCheck(this, ButtonCode);

        return _possibleConstructorReturn(this, (ButtonCode.__proto__ || Object.getPrototypeOf(ButtonCode)).apply(this, arguments));
    }

    _createClass(ButtonCode, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCode
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.code, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-code', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.code },
                _react2.default.createElement('span', { className: 'ae-icon-code' })
            );
        }
    }]);

    return ButtonCode;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default code
 * @memberof ButtonCode
 * @property {String} key
 * @static
 */


ButtonCode.key = 'code';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCode
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonCode.defaultProps = {
    style: {
        element: 'pre'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonCode)));

/***/ }),

/***/ "./src/components/buttons/button-command-list-item.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-command-list-item.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandListItem class is a UI class that renders a ButtonCommand that can be used inside
 * a list as an item, with a string representation of its behaviour.
 *
 * @class ButtonCommandListItem
 * @uses ButtonCommand
 */
var ButtonCommandListItem = function (_React$Component) {
    _inherits(ButtonCommandListItem, _React$Component);

    function ButtonCommandListItem() {
        _classCallCheck(this, ButtonCommandListItem);

        return _possibleConstructorReturn(this, (ButtonCommandListItem.__proto__ || Object.getPrototypeOf(ButtonCommandListItem)).apply(this, arguments));
    }

    _createClass(ButtonCommandListItem, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCommandListItem
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': this.props.description, className: this._getClassName(), onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex },
                this.props.description
            );
        }

        /**
         * Returns the class name of Widget.
         *
         * @instance
         * @memberof ButtonCommandListItem
         * @method _getClassName
         * @protected
         * @return {String} The class name of the Widget.
         */

    }, {
        key: '_getClassName',
        value: function _getClassName() {
            var className = 'ae-container ae-toolbar-element';

            return className;
        }
    }]);

    return ButtonCommandListItem;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonCommandListItem
 * @memberof ButtonCommandListItem
 * @property {String} key
 * @static
 */


ButtonCommandListItem.key = 'buttonCommandListItem';

exports.default = (0, _buttonCommand2.default)(ButtonCommandListItem);

/***/ }),

/***/ "./src/components/buttons/button-commands-list.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-commands-list.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandsList class provides functionality for showing a list of commands that can be
 * executed to the current selection..
 *
 * @class ButtonCommandsList
 * @uses WidgetFocusManager
 */
var ButtonCommandsList = function (_React$Component) {
    _inherits(ButtonCommandsList, _React$Component);

    function ButtonCommandsList() {
        _classCallCheck(this, ButtonCommandsList);

        return _possibleConstructorReturn(this, (ButtonCommandsList.__proto__ || Object.getPrototypeOf(ButtonCommandsList)).apply(this, arguments));
    }

    _createClass(ButtonCommandsList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses on the list node to allow keyboard interaction.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'div',
                { className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left', onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), tabIndex: '0' },
                _react2.default.createElement(
                    'ul',
                    { className: 'ae-listbox', id: this.props.listId, role: 'listbox' },
                    this._renderActions(this.props.commands)
                )
            );
        }

        /**
         * Renders instances of ButtonCommandListItem with the description of the row action that will be executed.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method _renderActions
         * @protected
         * @return {Array} Rendered instances of ButtonCommandListItem class
         */

    }, {
        key: '_renderActions',
        value: function _renderActions(commands) {
            var editor = this.props.editor;
            var items;

            if (commands && commands.length) {
                items = commands.map(function (item) {
                    return _react2.default.createElement(
                        'li',
                        { key: item.command, role: 'option' },
                        _react2.default.createElement(_buttonCommandListItem2.default, { command: item.command, description: typeof item.label === 'string' ? item.label : item.label(), icon: item.icon, editor: editor })
                    );
                });
            }

            return items;
        }
    }]);

    return ButtonCommandsList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonCommandsList
 * @memberof ButtonCommandsList
 * @property {String} key
 * @static
 */


ButtonCommandsList.key = 'buttonCommandsList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCommandsList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonCommandsList.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonCommandsList);

/***/ }),

/***/ "./src/components/buttons/button-dropdown.jsx":
/*!****************************************************!*\
  !*** ./src/components/buttons/button-dropdown.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonDropdown class provides markup and keyboard navigation behaviour to a dropdown
 * opened from a button.
 *
 * @class ButtonDropdown
 */
var ButtonDropdown = function (_React$Component) {
    _inherits(ButtonDropdown, _React$Component);

    function ButtonDropdown() {
        _classCallCheck(this, ButtonDropdown);

        return _possibleConstructorReturn(this, (ButtonDropdown.__proto__ || Object.getPrototypeOf(ButtonDropdown)).apply(this, arguments));
    }

    _createClass(ButtonDropdown, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonDropdown
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'div',
                { className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left', onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), tabIndex: '0' },
                _react2.default.createElement(
                    'ul',
                    { className: 'ae-listbox', role: 'listbox' },
                    this.props.children
                )
            );
        }
    }]);

    return ButtonDropdown;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the dropdown in the configuration.
 *
 * @default dropdown
 * @memberof ButtonDropdown
 * @property {String} key
 * @static
 */


ButtonDropdown.key = 'dropdown';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonDropdown
 * @method getDefaultProps
 */
ButtonDropdown.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonDropdown);

/***/ }),

/***/ "./src/components/buttons/button-embed-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-embed-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedEdit class provides functionality for creating and editing an embed link in a document.
 * Provides UI for creating and editing an embed link.
 *
 * @class ButtonEmbedEdit
 */

var ButtonEmbedEdit = function (_React$Component) {
    _inherits(ButtonEmbedEdit, _React$Component);

    function ButtonEmbedEdit(props) {
        _classCallCheck(this, ButtonEmbedEdit);

        var _this = _possibleConstructorReturn(this, (ButtonEmbedEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedEdit)).call(this, props));

        _this.linkInput = _react2.default.createRef();
        _this.state = _this.getInitialState();
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing. This should only happen if the component
     * is rendered in exclusive mode to prevent aggressive focus stealing.
     *
     * @instance
     * @memberof ButtonEmbedEdit
     * @method componentDidMount
     */


    _createClass(ButtonEmbedEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.renderExclusive || this.props.manualSelection) {
                // We need to wait for the next rendering cycle before focusing to avoid undesired
                // scrolls on the page
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(this._focusLinkInput.bind(this));
                } else {
                    setTimeout(this._focusLinkInput.bind(this), 0);
                }
            }
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method componentWillReceiveProps
         */

    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps() {
            this.setState(this.getInitialState());
        }

        /**
         * Lifecycle. Invoked once before the component is mounted.
         * The return value will be used as the initial value of this.state.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method getInitialState
         */

    }, {
        key: 'getInitialState',
        value: function getInitialState() {
            var editor = this.props.editor.get('nativeEditor');
            var embed;

            var selection = editor.getSelection();

            if (selection) {
                var selectedElement = selection.getSelectedElement();

                if (selectedElement) {
                    embed = selectedElement.findOne('[data-widget="ae_embed"]');
                }
            }

            var href = embed ? embed.getAttribute('data-ae-embed-url') : '';

            return {
                element: embed,
                initialLink: {
                    href: href
                },
                linkHref: href
            };
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var clearLinkStyle = {
                opacity: this.state.linkHref ? 1 : 0
            };

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link' },
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.deleteEmbed, className: 'ae-button', 'data-type': 'button-embed-remove', disabled: !this.state.element, onClick: this._removeEmbed.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.deleteEmbed },
                    _react2.default.createElement('span', { className: 'ae-icon-bin' })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input xxl' },
                    _react2.default.createElement('input', { className: 'ae-input', onChange: this._handleLinkHrefChange.bind(this), onKeyDown: this._handleKeyDown.bind(this), placeholder: AlloyEditor.Strings.editLink, ref: this.linkInput, type: 'text', value: this.state.linkHref }),
                    _react2.default.createElement('button', { 'aria-label': AlloyEditor.Strings.clearInput, className: 'ae-button ae-icon-remove', onClick: this._clearLink.bind(this), style: clearLinkStyle, title: AlloyEditor.Strings.clear })
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.confirm, className: 'ae-button', disabled: !this._isValidState(), onClick: this._embedLink.bind(this), title: AlloyEditor.Strings.confirm },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }

        /**
         * Clears the link input. This only changes the component internal state, but does not
         * affect the link element of the editor. Only the _removeLink and _updateLink methods
         * are translated to the editor element.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _clearLink
         * @protected
         */

    }, {
        key: '_clearLink',
        value: function _clearLink() {
            this.setState({
                linkHref: ''
            });
        }

        /**
         * Triggers the embedUrl command to transform the link into an embed media object
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _embedLink
         * @protected
         */

    }, {
        key: '_embedLink',
        value: function _embedLink() {
            var nativeEditor = this.props.editor.get('nativeEditor');

            nativeEditor.execCommand('embedUrl', {
                url: this.state.linkHref
            });

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();
        }

        /**
         * Focuses the user cursor on the widget's input.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _focusLinkInput
         * @protected
         */

    }, {
        key: '_focusLinkInput',
        value: function _focusLinkInput() {
            this.linkInput.current.focus();
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates/updates the link.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
                event.preventDefault();
            }

            if (event.keyCode === KEY_ENTER) {
                this._embedLink();
            } else if (event.keyCode === KEY_ESC) {
                var editor = this.props.editor.get('nativeEditor');

                // We need to cancelExclusive with the bound parameters in case the button is used
                // inside another in exclusive mode (such is the case of the link button)
                this.props.cancelExclusive();

                editor.fire('actionPerformed', this);
            }
        }

        /**
         * Updates the component state when the link input changes on user interaction.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _handleLinkHrefChange
         * @param {SyntheticEvent} event The change event.
         * @protected
         */

    }, {
        key: '_handleLinkHrefChange',
        value: function _handleLinkHrefChange(event) {
            this.setState({
                linkHref: event.target.value
            });
        }

        /**
         * Verifies that the current link state is valid so the user can save the link. A valid state
         * means that we have a non-empty href that's different from the original one.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _isValidState
         * @protected
         * @return {Boolean} True if the state is valid, false otherwise
         */

    }, {
        key: '_isValidState',
        value: function _isValidState() {
            var validState = this.state.linkHref && this.state.linkHref !== this.state.initialLink.href;

            return validState;
        }

        /**
         * Removes the embed in the editor element.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _removeEmbed
         * @protected
         */

    }, {
        key: '_removeEmbed',
        value: function _removeEmbed() {
            var editor = this.props.editor.get('nativeEditor');

            var embedWrapper = this.state.element.getAscendant(function (element) {
                return element.hasClass('cke_widget_wrapper');
            });

            embedWrapper.remove();

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonEmbedEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default embedEdit
 * @memberof ButtonEmbedEdit
 * @property {String} key
 * @static
 */


ButtonEmbedEdit.key = 'embedEdit';

exports.default = ButtonEmbedEdit;

/***/ }),

/***/ "./src/components/buttons/button-embed.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-embed.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonEmbed class provides functionality for creating and editing an embed link in a document.
 * ButtonEmbed renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonEmbedEdit UI with all the link edition controls.
 *
 * @class ButtonEmbed
 * @uses ButtonKeystroke
 */
var ButtonEmbed = function (_React$Component) {
    _inherits(ButtonEmbed, _React$Component);

    function ButtonEmbed() {
        _classCallCheck(this, ButtonEmbed);

        return _possibleConstructorReturn(this, (ButtonEmbed.__proto__ || Object.getPrototypeOf(ButtonEmbed)).apply(this, arguments));
    }

    _createClass(ButtonEmbed, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonEmbed
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonEmbedEdit2.default, this.props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.link, className: 'ae-button', 'data-type': 'button-embed', onClick: this._requestExclusive.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.link },
                    _react2.default.createElement('span', { className: 'ae-icon-add' })
                );
            }
        }

        /**
         * Requests the link button to be rendered in exclusive mode to allow the embedding of a link.
         *
         * @instance
         * @memberof ButtonEmbed
         * @method _requestExclusive
         * @protected
         */

    }, {
        key: '_requestExclusive',
        value: function _requestExclusive() {
            this.props.requestExclusive(ButtonEmbed.key);
        }
    }]);

    return ButtonEmbed;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default embed
 * @memberof ButtonEmbed
 * @property {String} key
 * @static
 */


ButtonEmbed.key = 'embed';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonEmbed
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonEmbed.defaultProps = {
    keystroke: {
        fn: '_requestExclusive',
        keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /*L*/
    }
};

exports.default = (0, _buttonKeystroke2.default)(ButtonEmbed);

/***/ }),

/***/ "./src/components/buttons/button-h1.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h1.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH1 class provides wraps a selection in `h1` element.
 *
 * @class ButtonH1
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH1 = function (_React$Component) {
    _inherits(ButtonH1, _React$Component);

    function ButtonH1() {
        _classCallCheck(this, ButtonH1);

        return _possibleConstructorReturn(this, (ButtonH1.__proto__ || Object.getPrototypeOf(ButtonH1)).apply(this, arguments));
    }

    _createClass(ButtonH1, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonH1
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.h1, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-h1', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.h1 },
                _react2.default.createElement('span', { className: 'ae-icon-h1' })
            );
        }
    }]);

    return ButtonH1;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default h1
 * @memberof ButtonH1
 * @property {String} key
 * @static
 */


ButtonH1.key = 'h1';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonH1
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonH1.defaultProps = {
    style: {
        element: 'h1'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH1)));

/***/ }),

/***/ "./src/components/buttons/button-h2.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h2.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH2 class provides wraps a selection in `h2` element.
 *
 * @class ButtonH2
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH2 = function (_React$Component) {
    _inherits(ButtonH2, _React$Component);

    function ButtonH2() {
        _classCallCheck(this, ButtonH2);

        return _possibleConstructorReturn(this, (ButtonH2.__proto__ || Object.getPrototypeOf(ButtonH2)).apply(this, arguments));
    }

    _createClass(ButtonH2, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonH2
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.h2, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-h2', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.h2 },
                _react2.default.createElement('span', { className: 'ae-icon-h2' })
            );
        }
    }]);

    return ButtonH2;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default h2
 * @memberof ButtonH2
 * @property {String} key
 * @static
 */


ButtonH2.key = 'h2';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonH2
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonH2.defaultProps = {
    style: {
        element: 'h2'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH2)));

/***/ }),

/***/ "./src/components/buttons/button-hline.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-hline.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonHline class provides inserts horizontal line.
 *
 * @class ButtonHline
 * @uses ButtonCommand
 * @uses ButtonStyle
 */
var ButtonHline = function (_React$Component) {
    _inherits(ButtonHline, _React$Component);

    function ButtonHline() {
        _classCallCheck(this, ButtonHline);

        return _possibleConstructorReturn(this, (ButtonHline.__proto__ || Object.getPrototypeOf(ButtonHline)).apply(this, arguments));
    }

    _createClass(ButtonHline, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonHline
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.horizontalrule, className: 'ae-button', 'data-type': 'button-hline', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.horizontalrule },
                _react2.default.createElement('span', { className: 'ae-icon-separator' })
            );
        }
    }]);

    return ButtonHline;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default hline
 * @memberof ButtonHline
 * @property {String} key
 * @static
 */


ButtonHline.key = 'hline';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonHline
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonHline.defaultProps = {
    command: 'horizontalrule',
    style: {
        element: 'hr'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStyle2.default)(ButtonHline));

/***/ }),

/***/ "./src/components/buttons/button-image-align-center.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-image-align-center.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignCenter class provides functionality for aligning an image in the center.
 *
 * @class ButtonImageAlignCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignCenter = function (_React$Component) {
    _inherits(ButtonImageAlignCenter, _React$Component);

    function ButtonImageAlignCenter() {
        _classCallCheck(this, ButtonImageAlignCenter);

        return _possibleConstructorReturn(this, (ButtonImageAlignCenter.__proto__ || Object.getPrototypeOf(ButtonImageAlignCenter)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignCenter, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignCenter
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignCenter, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-center', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignCenter },
                _react2.default.createElement('span', { className: 'ae-icon-align-center' })
            );
        }
    }]);

    return ButtonImageAlignCenter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageCenter
 * @memberof ButtonImageAlignCenter
 * @property {String} key
 * @static
 */


ButtonImageAlignCenter.key = 'imageCenter';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignCenter
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignCenter.defaultProps = {
    command: 'justifycenter'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignCenter)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-left.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-image-align-left.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignLeft class provides functionality for aligning an image on left.
 *
 * @class ButtonImageAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignLeft = function (_React$Component) {
    _inherits(ButtonImageAlignLeft, _React$Component);

    function ButtonImageAlignLeft() {
        _classCallCheck(this, ButtonImageAlignLeft);

        return _possibleConstructorReturn(this, (ButtonImageAlignLeft.__proto__ || Object.getPrototypeOf(ButtonImageAlignLeft)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignLeft, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignLeft
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignLeft, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-left', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignLeft },
                _react2.default.createElement('span', { className: 'ae-icon-align-left' })
            );
        }
    }]);

    return ButtonImageAlignLeft;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageLeft
 * @memberof ButtonImageAlignLeft
 * @property {String} key
 * @static
 */


ButtonImageAlignLeft.key = 'imageLeft';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignLeft
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignLeft.defaultProps = {
    command: 'justifyleft'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-right.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-image-align-right.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignRight class provides functionality for aligning an image on right.
 *
 * @class ButtonImageAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignRight = function (_React$Component) {
    _inherits(ButtonImageAlignRight, _React$Component);

    function ButtonImageAlignRight() {
        _classCallCheck(this, ButtonImageAlignRight);

        return _possibleConstructorReturn(this, (ButtonImageAlignRight.__proto__ || Object.getPrototypeOf(ButtonImageAlignRight)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignRight, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignRight
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignRight, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-right', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignRight },
                _react2.default.createElement('span', { className: 'ae-icon-align-right' })
            );
        }
    }]);

    return ButtonImageAlignRight;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageRight
 * @memberof ButtonImageAlignRight
 * @property {String} key
 * @static
 */


ButtonImageAlignRight.key = 'imageRight';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignRight
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignRight.defaultProps = {
    command: 'justifyright'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-image.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-image.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImage class inserts an image to the content.
 *
 * @class ButtonImage
 */
var ButtonImage = function (_React$Component) {
    _inherits(ButtonImage, _React$Component);

    function ButtonImage(props) {
        _classCallCheck(this, ButtonImage);

        var _this = _possibleConstructorReturn(this, (ButtonImage.__proto__ || Object.getPrototypeOf(ButtonImage)).call(this, props));

        _this.fileInput = _react2.default.createRef();
        return _this;
    }

    /**
     * Lifecycle. Renders the UI of the button.
     *
     * @instance
     * @memberof ButtonImage
     * @method render
     * @return {Object} The content which should be rendered.
     */


    _createClass(ButtonImage, [{
        key: 'render',
        value: function render() {
            var inputSyle = { display: 'none' };

            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.image, className: 'ae-button', 'data-type': 'button-image', onClick: this.handleClick.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.image },
                    _react2.default.createElement('span', { className: 'ae-icon-image' })
                ),
                _react2.default.createElement('input', { accept: 'image/*', onChange: this._onInputChange.bind(this), ref: this.fileInput, style: inputSyle, type: 'file' })
            );
        }

        /**
         * Simulates click on the input element. This will open browser's native file open dialog.
         *
         * @instance
         * @memberof ButtonImage
         * @method handleClick
         * @param {SyntheticEvent} event The received click event on the button.
         */

    }, {
        key: 'handleClick',
        value: function handleClick() {
            this.fileInput.current.click();
        }

        /**
         * On input change, reads the chosen file and fires an event `beforeImageAdd` with the image which will be added
         * to the content. The image file will be passed in the `imageFiles` property.
         * If any of the listeners returns `false` or cancels the event, the image won't be added to the content.
         * Otherwise, an event `imageAdd` will be fired with the inserted element into the editable area.
         * The passed params will be:
         * - `el` - the created img element
         * - `file` - the original image file from the input element
         *
         * @fires ButtonImage#beforeImageAdd
         * @fires ButtonImage#imageAdd
         * @instance
         * @memberof ButtonImage
         * @method _onInputChange
         * @protected
         */

    }, {
        key: '_onInputChange',
        value: function _onInputChange() {
            var inputEl = this.fileInput.current;

            // On IE11 the function might be called with an empty array of
            // files. In such a case, no actions will be taken.
            if (!inputEl.files.length) {
                return;
            }

            var reader = new FileReader();
            var file = inputEl.files[0];

            reader.onload = function (event) {
                var editor = this.props.editor.get('nativeEditor');

                var result = editor.fire('beforeImageAdd', {
                    imageFiles: file
                });

                if (!!result) {
                    var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

                    editor.insertElement(el);

                    editor.fire('actionPerformed', this);

                    var imageData = {
                        el: el,
                        file: file
                    };

                    editor.fire('imageAdd', imageData);
                }
            }.bind(this);

            reader.readAsDataURL(file);

            inputEl.value = '';
        }
    }]);

    return ButtonImage;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default image
 * @memberof ButtonImage
 * @property {String} key
 * @static
 */


ButtonImage.key = 'image';

exports.default = ButtonImage;

/***/ }),

/***/ "./src/components/buttons/button-indent-block.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-indent-block.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonIndentBlock class provides functionality for indenting the selected blocks.
 *
 * @class ButtonIndentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonIndentBlock = function (_React$Component) {
    _inherits(ButtonIndentBlock, _React$Component);

    function ButtonIndentBlock() {
        _classCallCheck(this, ButtonIndentBlock);

        return _possibleConstructorReturn(this, (ButtonIndentBlock.__proto__ || Object.getPrototypeOf(ButtonIndentBlock)).apply(this, arguments));
    }

    _createClass(ButtonIndentBlock, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonIndentBlock
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.indent, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-indent-block', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.indent },
                _react2.default.createElement('span', { className: 'ae-icon-indent-block' })
            );
        }
    }]);

    return ButtonIndentBlock;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default indentBlock
 * @memberof ButtonIndentBlock
 * @property {String} key
 * @static
 */


ButtonIndentBlock.key = 'indentBlock';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonIndentBlock
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonIndentBlock.defaultProps = {
    command: 'indent'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonIndentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-italic.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-italic.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonItalic class provides functionality for styling an selection with italic (em) style.
 *
 * @class ButtonItalic
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonItalic = function (_React$Component) {
    _inherits(ButtonItalic, _React$Component);

    function ButtonItalic() {
        _classCallCheck(this, ButtonItalic);

        return _possibleConstructorReturn(this, (ButtonItalic.__proto__ || Object.getPrototypeOf(ButtonItalic)).apply(this, arguments));
    }

    _createClass(ButtonItalic, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonItalic
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.italic, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-italic', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.italic },
                _react2.default.createElement('span', { className: 'ae-icon-italic' })
            );
        }
    }]);

    return ButtonItalic;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default italic
 * @memberof ButtonItalic
 * @property {String} key
 * @static
 */


ButtonItalic.key = 'italic';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonItalic
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonItalic.defaultProps = {
    command: 'italic',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 73 /*I*/
    },
    style: 'coreStyles_italic'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonItalic))));

/***/ }),

/***/ "./src/components/buttons/button-link-autocomplete-list.jsx":
/*!******************************************************************!*\
  !*** ./src/components/buttons/button-link-autocomplete-list.jsx ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkAutocompleteList class provides functionality for showing a list of
 * items that can be selected for the link.
 *
 * @class ButtonLinkAutocompleteList
 * @uses WidgetFocusManager
 */
var ButtonLinkAutocompleteList = function (_React$Component) {
    _inherits(ButtonLinkAutocompleteList, _React$Component);

    function ButtonLinkAutocompleteList(props) {
        _classCallCheck(this, ButtonLinkAutocompleteList);

        var _this = _possibleConstructorReturn(this, (ButtonLinkAutocompleteList.__proto__ || Object.getPrototypeOf(ButtonLinkAutocompleteList)).call(this, props));

        _this.state = {
            items: []
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked when a component is receiving new props.
     * This method is not called for the initial render.
     *
     * @instance
     * @memberof ButtonLinkAutocompleteList
     * @method componentWillReceiveProps
     */


    _createClass(ButtonLinkAutocompleteList, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (!nextProps.term || nextProps.term !== this.props.term) {
                clearTimeout(this._timeout);

                if (nextProps.term) {
                    this._timeout = setTimeout(this._updateItems, this.props.delay);
                } else {
                    this.setState({
                        items: []
                    });
                }
            }

            if (nextProps.autocompleteSelected) {
                setTimeout(this.focus, 0);
                this.props.setAutocompleteState({
                    selected: false
                });
            }
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            clearTimeout(this._timeout);
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            if (!this.props.expanded || !this.state.items.length) {
                return null;
            }

            return _react2.default.createElement(
                _buttonDropdown2.default,
                null,
                this._renderAutocompleteItems(this.state.items)
            );
        }

        /**
         * Lifecycle. Invoked before rendering when new props or state are being received.
         * This method is not called for the initial render or when forceUpdate is used.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method  shouldComponentUpdate
         * @return {Boolean} Returns false when the transition to the new props and state will not
         * require a component update.
         */

    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps, nextState) {
            return nextProps.expanded !== this.props.expanded || nextProps.term !== this.props.term || nextState.items !== this.state.items;
        }

        /**
         * Renders a set of list items for the provided items
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method _renderAutocompleteItems
         * @param {Array} items List of autocomplete items to render
         * @protected
         * @return {Array} Rendered list item instances
         */

    }, {
        key: '_renderAutocompleteItems',
        value: function _renderAutocompleteItems(items) {
            items = items || [];

            var handleLinkAutocompleteClick = this.props.handleLinkAutocompleteClick;

            return items.map(function (item) {
                var className = this.props.term === item.url ? 'ae-toolbar-element active' : 'ae-toolbar-element';

                return _react2.default.createElement(
                    'li',
                    { key: item.url, role: 'option' },
                    _react2.default.createElement(
                        'button',
                        { className: className, onClick: handleLinkAutocompleteClick, 'data-value': item.url },
                        item.title
                    )
                );
            }.bind(this));
        }

        /**
         * Retrieves the data according to {this.props.term} and calls setState() with the returned data
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method _updateItems
         * @protected
         */

    }, {
        key: '_updateItems',
        value: function _updateItems() {
            var instance = this;

            if (!this.props.term) {
                return;
            }

            var promise = Promise.resolve(this.props.data(this.props.term));

            promise.then(function (items) {
                if (items.length) {
                    !instance.props.expanded && instance.props.toggleDropdown();
                }

                instance.setState({
                    items: items
                });
            });
        }
    }]);

    return ButtonLinkAutocompleteList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonLinkAutocompleteList
 * @memberof ButtonLinkAutocompleteList
 * @property {String} key
 * @static
 */


ButtonLinkAutocompleteList.key = 'buttonLinkAutocompleteList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLinkAutocompleteList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLinkAutocompleteList.defaultProps = {
    circular: false,
    data: [],
    delay: 100,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonLinkAutocompleteList);

/***/ }),

/***/ "./src/components/buttons/button-link-edit.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-link-edit.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props.js */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkEdit class provides functionality for creating and editing a link in a document.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEdit
 * @uses ButtonCfgProps
 * @uses WidgetDropdown
 * @uses WidgetFocusManager
 */
var ButtonLinkEdit = function (_React$Component) {
    _inherits(ButtonLinkEdit, _React$Component);

    function ButtonLinkEdit(props) {
        _classCallCheck(this, ButtonLinkEdit);

        var _this = _possibleConstructorReturn(this, (ButtonLinkEdit.__proto__ || Object.getPrototypeOf(ButtonLinkEdit)).call(this, props));

        _this.linkInput = _react2.default.createRef();
        _this.state = _this._getInitialState();
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing. This should only happen if the component
     * is rendered in exclusive mode to prevent aggressive focus stealing.
     *
     * @instance
     * @memberof ButtonLinkEdit
     * @method componentDidMount
     */


    _createClass(ButtonLinkEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.renderExclusive || this.props.manualSelection) {
                // We need to wait for the next rendering cycle before focusing to avoid undesired
                // scrolls on the page
                this._focusLinkInput();
            }
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method componentWillReceiveProps
         */

    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps() {
            this.setState(this._getInitialState());
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var targetSelector = {
                allowedTargets: this.props.allowedTargets,
                editor: this.props.editor,
                handleLinkTargetChange: this._handleLinkTargetChange.bind(this),
                selectedTarget: this.state.linkTarget || AlloyEditor.Strings.linkTargetDefault
            };

            targetSelector = this.mergeDropdownProps(targetSelector, _buttonLinkTargetEdit2.default.key);

            var autocompleteDropdown;

            if (this.props.data) {
                var dataFn = this.props.data;

                if (!_lang2.default.isFunction(dataFn)) {
                    var items = this.props.data;

                    dataFn = function dataFn() {
                        return items;
                    };
                }

                var autocompleteDropdownProps = {
                    autocompleteSelected: this.state.autocompleteSelected,
                    data: dataFn,
                    editor: this.props.editor,
                    handleLinkAutocompleteClick: this._handleLinkAutocompleteClick,
                    onDismiss: this.props.toggleDropdown,
                    setAutocompleteState: this._setAutocompleteState,
                    term: this.state.linkHref
                };

                autocompleteDropdownProps = this.mergeDropdownProps(autocompleteDropdownProps, _buttonLinkAutocompleteList2.default.key);

                autocompleteDropdown = _react2.default.createElement(_buttonLinkAutocompleteList2.default, autocompleteDropdownProps);
            }

            var buttonClearLink;

            if (this.state.linkHref) {
                buttonClearLink = _react2.default.createElement('button', { 'aria-label': AlloyEditor.Strings.clearInput, className: 'ae-button ae-icon-remove', onClick: this._clearLink.bind(this), title: AlloyEditor.Strings.clear });
            }

            var placeholderProp = {};

            if (!CKEDITOR.env.ie && AlloyEditor.Strings) {
                placeholderProp.placeholder = AlloyEditor.Strings.editLink;
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link' },
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.removeLink, className: 'ae-button', disabled: !this.state.element, onClick: this._removeLink.bind(this), title: AlloyEditor.Strings.remove },
                    _react2.default.createElement('span', { className: 'ae-icon-unlink' })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input xxl' },
                    this.props.showTargetSelector && _react2.default.createElement(_buttonLinkTargetEdit2.default, targetSelector),
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container-input' },
                        _react2.default.createElement('input', _extends({ className: 'ae-input', onChange: this._handleLinkHrefChange.bind(this), onKeyDown: this._handleKeyDown.bind(this) }, placeholderProp, { ref: this.linkInput, type: 'text', value: this.state.linkHref })),
                        autocompleteDropdown
                    ),
                    buttonClearLink
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.confirm, className: 'ae-button', disabled: !this._isValidState(), onClick: this._updateLink.bind(this), title: AlloyEditor.Strings.confirm },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }

        /**
         * The return value will be used as the initial value of this.state.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _getInitialState
         * @protected
         * @return {Object}
         */

    }, {
        key: '_getInitialState',
        value: function _getInitialState() {
            var _props = this.props,
                editor = _props.editor,
                defaultLinkTarget = _props.defaultLinkTarget;


            var link = new CKEDITOR.Link(editor.get('nativeEditor')).getFromSelection();
            var href = link ? link.getAttribute('href') : '';
            var target = link ? link.getAttribute('target') : defaultLinkTarget;

            return {
                autocompleteSelected: false,
                element: link,
                initialLink: {
                    href: href,
                    target: target
                },
                linkHref: href,
                linkTarget: target
            };
        }

        /**
         * Clears the link input. This only changes the component internal state, but does not
         * affect the link element of the editor. Only the _removeLink and _updateLink methods
         * are translated to the editor element.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _clearLink
         * @protected
         */

    }, {
        key: '_clearLink',
        value: function _clearLink() {
            this.setState({
                linkHref: ''
            });

            this._focusLinkInput();
        }

        /**
         * Focuses the user cursor on the widget's input.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _focusLinkInput
         * @protected
         */

    }, {
        key: '_focusLinkInput',
        value: function _focusLinkInput() {
            var instance = this;

            var focusLinkEl = function focusLinkEl() {
                instance.linkInput.current.focus();
            };

            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(focusLinkEl);
            } else {
                setTimeout(focusLinkEl, 0);
            }
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates/updates the link.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === 13 || event.keyCode === 27) {
                event.preventDefault();
            }

            if (event.keyCode === 13) {
                this._updateLink();
            } else if (event.keyCode === 40) {
                this.setState({
                    autocompleteSelected: true
                });
            } else if (event.keyCode === 27) {
                var editor = this.props.editor.get('nativeEditor');

                new CKEDITOR.Link(editor).advanceSelection();

                this.props.editor.get('nativeEditor').fire('actionPerformed', this);
            }
        }

        /**
         * Updates the component state when the link input changes on user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkHrefChange
         * @param {SyntheticEvent} event The change event.
         * @protected
         */

    }, {
        key: '_handleLinkHrefChange',
        value: function _handleLinkHrefChange(event) {
            this.setState({
                linkHref: event.target.value
            });

            this._focusLinkInput();
        }

        /**
         * Updates the component state when the link target changes on user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkTargetChange
         * @param {SyntheticEvent} event The click event.
         * @protected
         */

    }, {
        key: '_handleLinkTargetChange',
        value: function _handleLinkTargetChange(event) {
            this.setState({
                itemDropdown: null,
                linkTarget: event.target.getAttribute('data-value')
            });

            this._focusLinkInput();
        }

        /**
         * Updates the component state when an autocomplete link result is selected by user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkAutocompleteClick
         * @param {SyntheticEvent} event The click event.
         * @protected
         */

    }, {
        key: '_handleLinkAutocompleteClick',
        value: function _handleLinkAutocompleteClick(event) {
            this.setState({
                itemDropdown: null,
                linkHref: event.target.getAttribute('data-value')
            });

            this._focusLinkInput();
        }

        /**
         * Verifies that the current link state is valid so the user can save the link. A valid state
         * means that we have a non-empty href and that either that or the link target are different
         * from the original link.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _isValidState
         * @protected
         * @return {Boolean} [description]
         */

    }, {
        key: '_isValidState',
        value: function _isValidState() {
            var validState = this.state.linkHref && (this.state.linkHref !== this.state.initialLink.href || this.state.linkTarget !== this.state.initialLink.target);

            return validState;
        }

        /**
         * Removes the link in the editor element.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _removeLink
         * @protected
         */

    }, {
        key: '_removeLink',
        value: function _removeLink() {
            var editor = this.props.editor.get('nativeEditor');
            var linkUtils = new CKEDITOR.Link(editor);
            var selection = editor.getSelection();
            var bookmarks = selection.createBookmarks();

            linkUtils.remove(this.state.element, { advance: true });

            selection.selectBookmarks(bookmarks);

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();

            editor.fire('actionPerformed', this);
        }

        /**
         * Update autocompleteSelected state to focus and select autocomplete´s dropdown
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _setAutocompleteState
         * @protected
         */

    }, {
        key: '_setAutocompleteState',
        value: function _setAutocompleteState(state) {
            this.setState({
                autocompleteSelected: state.selected
            });
        }

        /**
         * Updates the link in the editor element. If the element didn't exist previously, it will
         * create a new <a> element with the href specified in the link input.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _updateLink
         * @protected
         */

    }, {
        key: '_updateLink',
        value: function _updateLink() {
            var editor = this.props.editor.get('nativeEditor');
            var linkUtils = new CKEDITOR.Link(editor, { appendProtocol: this.props.appendProtocol });
            var linkAttrs = {
                target: this.state.linkTarget
            };
            var modifySelection = { advance: true };

            if (this.state.linkHref) {
                if (this.state.element) {
                    linkAttrs.href = this.state.linkHref;

                    linkUtils.update(linkAttrs, this.state.element, modifySelection);
                } else {
                    linkUtils.create(this.state.linkHref, linkAttrs, modifySelection);
                }

                editor.fire('actionPerformed', this);
            }

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();
        }
    }]);

    return ButtonLinkEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkEdit
 * @memberof ButtonLinkEdit
 * @property {String} key
 * @static
 */


ButtonLinkEdit.key = 'linkEdit';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLinkEdit
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLinkEdit.defaultProps = {
    appendProtocol: true,
    autocompleteUrl: '',
    circular: true,
    customIndexStart: true,
    defaultLinkTarget: '',
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    },
    showTargetSelector: true
};

exports.default = (0, _buttonProps2.default)((0, _widgetDropdown2.default)((0, _widgetFocusManager2.default)(ButtonLinkEdit)));

/***/ }),

/***/ "./src/components/buttons/button-link-target-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-target-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkTargetEdit class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonLinkTargetEdit
 */
var ButtonLinkTargetEdit = function (_React$Component) {
    _inherits(ButtonLinkTargetEdit, _React$Component);

    function ButtonLinkTargetEdit() {
        _classCallCheck(this, ButtonLinkTargetEdit);

        return _possibleConstructorReturn(this, (ButtonLinkTargetEdit.__proto__ || Object.getPrototypeOf(ButtonLinkTargetEdit)).apply(this, arguments));
    }

    _createClass(ButtonLinkTargetEdit, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLinkTargetEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var handleLinkTargetChange = this.props.handleLinkTargetChange;
            var allowedLinkTargets = this.props.allowedTargets;

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link-target ae-container-dropdown ae-container-dropdown-medium ae-has-dropdown', tabIndex: '0' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': this.props.selectedTarget, className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: this.props.selectedTarget },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            this.props.selectedTarget
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                this.props.expanded && _react2.default.createElement(_buttonTargetList2.default, { editor: this.props.editor, onDismiss: this.props.toggleDropdown, allowedLinkTargets: allowedLinkTargets, handleLinkTargetChange: handleLinkTargetChange, selectedTarget: this.props.selectedTarget })
            );
        }

        /**
         * Lifecycle. Invoked before rendering when new props or state are being received.
         * This method is not called for the initial render or when forceUpdate is used.
         *
         * @instance
         * @memberof ButtonLinkTargetEdit
         * @method  shouldComponentUpdate
         * @return {Boolean} Returns false when the transition to the new props and state will not
         * require a component update.
         */

    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.expanded !== this.props.expanded || nextProps.selectedTarget !== this.props.selectedTarget;
        }
    }]);

    return ButtonLinkTargetEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkTargetEdit
 * @memberof ButtonLinkTargetEdit
 * @property {String} key
 * @static
 */


ButtonLinkTargetEdit.key = 'linkTargetEdit';

exports.default = ButtonLinkTargetEdit;

/***/ }),

/***/ "./src/components/buttons/button-link.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-link.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props.js */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLink class provides functionality for creating and editing a link in a document. ButtonLink
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonLinkEdit UI with all the link edition controls.
 *
 * @class ButtonLink
 * @uses ButtonCfgProps
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 */
var ButtonLink = function (_React$Component) {
    _inherits(ButtonLink, _React$Component);

    function ButtonLink() {
        _classCallCheck(this, ButtonLink);

        return _possibleConstructorReturn(this, (ButtonLink.__proto__ || Object.getPrototypeOf(ButtonLink)).apply(this, arguments));
    }

    _createClass(ButtonLink, [{
        key: 'isActive',

        /**
         * Checks if the current selection is contained within a link.
         *
         * @instance
         * @memberof ButtonLink
         * @method isActive
         * @return {Boolean} True if the selection is inside a link, false otherwise.
         */
        value: function isActive() {
            return new CKEDITOR.Link(this.props.editor.get('nativeEditor')).getFromSelection() !== null;
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLink
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            if (this.props.renderExclusive) {
                var props = this.mergeButtonCfgProps();

                return _react2.default.createElement(_buttonLinkEdit2.default, props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.link, className: cssClass, 'data-type': 'button-link', onClick: this._requestExclusive.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.link },
                    _react2.default.createElement('span', { className: 'ae-icon-link' })
                );
            }
        }

        /**
         * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
         *
         * @instance
         * @memberof ButtonLink
         * @method _requestExclusive
         * @protected
         */

    }, {
        key: '_requestExclusive',
        value: function _requestExclusive() {
            this.props.requestExclusive(ButtonLink.key);
        }
    }]);

    return ButtonLink;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default link
 * @memberof ButtonLink
 * @property {String} key
 * @static
 */


ButtonLink.key = 'link';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLink
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLink.defaultProps = {
    keystroke: {
        fn: '_requestExclusive',
        keys: CKEDITOR.CTRL + 76 /*L*/
    }
};

exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)(ButtonLink)));

/***/ }),

/***/ "./src/components/buttons/button-ol.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ol.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOrderedList class provides functionality for creating ordered lists in an editor.
 *
 * @class ButtonOrderedList
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonOrderedList = function (_React$Component) {
    _inherits(ButtonOrderedList, _React$Component);

    function ButtonOrderedList() {
        _classCallCheck(this, ButtonOrderedList);

        return _possibleConstructorReturn(this, (ButtonOrderedList.__proto__ || Object.getPrototypeOf(ButtonOrderedList)).apply(this, arguments));
    }

    _createClass(ButtonOrderedList, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonOrderedList
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.numberedlist, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-ol', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.numberedlist },
                _react2.default.createElement('span', { className: 'ae-icon-numbered-list' })
            );
        }
    }]);

    return ButtonOrderedList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default ol
 * @memberof ButtonOrderedList
 * @property {String} key
 * @static
 */


ButtonOrderedList.key = 'ol';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonOrderedList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonOrderedList.defaultProps = {
    command: 'numberedlist',
    style: {
        element: 'ol'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonOrderedList)));

/***/ }),

/***/ "./src/components/buttons/button-outdent-block.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-outdent-block.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOutdentBlock class provides functionality for outdenting blocks.
 *
 * @class ButtonOutdentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonOutdentBlock = function (_React$Component) {
    _inherits(ButtonOutdentBlock, _React$Component);

    function ButtonOutdentBlock() {
        _classCallCheck(this, ButtonOutdentBlock);

        return _possibleConstructorReturn(this, (ButtonOutdentBlock.__proto__ || Object.getPrototypeOf(ButtonOutdentBlock)).apply(this, arguments));
    }

    _createClass(ButtonOutdentBlock, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonOutdentBlock
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.outdent, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-outdent-block', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.outdent },
                _react2.default.createElement('span', { className: 'ae-icon-outdent-block' })
            );
        }
    }]);

    return ButtonOutdentBlock;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default indentBlock
 * @memberof ButtonOutdentBlock
 * @property {String} key
 * @static
 */


ButtonOutdentBlock.key = 'outdentBlock';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonOutdentBlock
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonOutdentBlock.defaultProps = {
    command: 'outdent'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonOutdentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-left.jsx":
/*!****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-left.jsx ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignLeft class provides functionality for aligning a paragraph on left.
 *
 * @class ButtonParagraphAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignLeft = function (_React$Component) {
    _inherits(ButtonParagraphAlignLeft, _React$Component);

    function ButtonParagraphAlignLeft() {
        _classCallCheck(this, ButtonParagraphAlignLeft);

        return _possibleConstructorReturn(this, (ButtonParagraphAlignLeft.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignLeft)).apply(this, arguments));
    }

    _createClass(ButtonParagraphAlignLeft, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphAlignLeft
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignLeft, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-align-left', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignLeft },
                _react2.default.createElement('span', { className: 'ae-icon-align-left' })
            );
        }
    }]);

    return ButtonParagraphAlignLeft;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphLeft
 * @memberof ButtonParagraphAlignLeft
 * @property {String} key
 * @static
 */


ButtonParagraphAlignLeft.key = 'paragraphLeft';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphAlignLeft
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphAlignLeft.defaultProps = {
    command: 'justifyleft'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-right.jsx":
/*!*****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-right.jsx ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignRight class provides functionality for aligning a paragraph on right.
 *
 * @class ButtonParagraphAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignRight = function (_React$Component) {
    _inherits(ButtonParagraphAlignRight, _React$Component);

    function ButtonParagraphAlignRight() {
        _classCallCheck(this, ButtonParagraphAlignRight);

        return _possibleConstructorReturn(this, (ButtonParagraphAlignRight.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignRight)).apply(this, arguments));
    }

    _createClass(ButtonParagraphAlignRight, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphAlignRight
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignRight, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-align-right', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignRight },
                _react2.default.createElement('span', { className: 'ae-icon-align-right' })
            );
        }
    }]);

    return ButtonParagraphAlignRight;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphRight
 * @memberof ButtonParagraphAlignRight
 * @property {String} key
 * @static
 */


ButtonParagraphAlignRight.key = 'paragraphRight';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphAlignRight
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphAlignRight.defaultProps = {
    command: 'justifyright'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-center.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-center.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphCenter class provides functionality for centering a paragraph.
 *
 * @class ButtonParagraphCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphCenter = function (_React$Component) {
    _inherits(ButtonParagraphCenter, _React$Component);

    function ButtonParagraphCenter() {
        _classCallCheck(this, ButtonParagraphCenter);

        return _possibleConstructorReturn(this, (ButtonParagraphCenter.__proto__ || Object.getPrototypeOf(ButtonParagraphCenter)).apply(this, arguments));
    }

    _createClass(ButtonParagraphCenter, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphCenter
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignCenter, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-center', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignCenter },
                _react2.default.createElement('span', { className: 'ae-icon-align-center' })
            );
        }
    }]);

    return ButtonParagraphCenter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphCenter
 * @memberof ButtonParagraphCenter
 * @property {String} key
 * @static
 */


ButtonParagraphCenter.key = 'paragraphCenter';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphCenter
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphCenter.defaultProps = {
    command: 'justifycenter'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphCenter)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-justify.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-justify.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphJustify class provides functionality for justfying a paragraph.
 *
 * @class ButtonParagraphJustify
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphJustify = function (_React$Component) {
    _inherits(ButtonParagraphJustify, _React$Component);

    function ButtonParagraphJustify() {
        _classCallCheck(this, ButtonParagraphJustify);

        return _possibleConstructorReturn(this, (ButtonParagraphJustify.__proto__ || Object.getPrototypeOf(ButtonParagraphJustify)).apply(this, arguments));
    }

    _createClass(ButtonParagraphJustify, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphJustify
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignJustify, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-justify', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignJustify },
                _react2.default.createElement('span', { className: 'ae-icon-align-justified' })
            );
        }
    }]);

    return ButtonParagraphJustify;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphJustify
 * @memberof ButtonParagraphJustify
 * @property {String} key
 * @static
 */


ButtonParagraphJustify.key = 'paragraphJustify';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphJustify
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphJustify.defaultProps = {
    command: 'justifyblock'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphJustify)));

/***/ }),

/***/ "./src/components/buttons/button-quote.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-quote.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonQuote class wraps a selection in `blockquote` element.
 *
 * @class ButtonQuote
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonQuote = function (_React$Component) {
    _inherits(ButtonQuote, _React$Component);

    function ButtonQuote() {
        _classCallCheck(this, ButtonQuote);

        return _possibleConstructorReturn(this, (ButtonQuote.__proto__ || Object.getPrototypeOf(ButtonQuote)).apply(this, arguments));
    }

    _createClass(ButtonQuote, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonQuote
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.quote, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-quote', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.quote },
                _react2.default.createElement('span', { className: 'ae-icon-quote' })
            );
        }
    }]);

    return ButtonQuote;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default quote
 * @memberof ButtonQuote
 * @property {String} key
 * @static
 */


ButtonQuote.key = 'quote';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonQuote
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonQuote.defaultProps = {
    command: 'blockquote',
    style: {
        element: 'blockquote'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonQuote)));

/***/ }),

/***/ "./src/components/buttons/button-remove-format.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-remove-format.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonRemoveFormat class removes style formatting.
 *
 * @class ButtonRemoveFormat
 * @uses ButtonCommand
 */
var ButtonRemoveFormat = function (_React$Component) {
    _inherits(ButtonRemoveFormat, _React$Component);

    function ButtonRemoveFormat() {
        _classCallCheck(this, ButtonRemoveFormat);

        return _possibleConstructorReturn(this, (ButtonRemoveFormat.__proto__ || Object.getPrototypeOf(ButtonRemoveFormat)).apply(this, arguments));
    }

    _createClass(ButtonRemoveFormat, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonRemoveFormat
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.removeformat, className: 'ae-button', 'data-type': 'button-removeformat', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.removeformat },
                _react2.default.createElement('span', { className: 'ae-icon-removeformat' })
            );
        }
    }]);

    return ButtonRemoveFormat;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default removeFormat
 * @memberof ButtonRemoveFormat
 * @property {String} key
 * @static
 */


ButtonRemoveFormat.key = 'removeFormat';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonRemoveFormat
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonRemoveFormat.defaultProps = {
    command: 'removeFormat'
};

exports.default = (0, _buttonCommand2.default)(ButtonRemoveFormat);

/***/ }),

/***/ "./src/components/buttons/button-separator.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-separator.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSeparator class renders a simple separator.
 *
 * @class ButtonSeparator
 */
var ButtonSeparator = function (_React$Component) {
  _inherits(ButtonSeparator, _React$Component);

  function ButtonSeparator() {
    _classCallCheck(this, ButtonSeparator);

    return _possibleConstructorReturn(this, (ButtonSeparator.__proto__ || Object.getPrototypeOf(ButtonSeparator)).apply(this, arguments));
  }

  _createClass(ButtonSeparator, [{
    key: 'render',

    /**
     * Lifecycle. Renders the UI of the separator.
     *
     * @instance
     * @memberof ButtonSeparator
     * @method render
     * @return {Object} The content which should be rendered.
     */
    value: function render() {
      return _react2.default.createElement('span', { className: 'ae-separator' });
    }
  }]);

  return ButtonSeparator;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default separator
 * @memberof ButtonSeparator
 * @property {String} key
 * @static
 */


ButtonSeparator.key = 'separator';

exports.default = ButtonSeparator;

/***/ }),

/***/ "./src/components/buttons/button-strike.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-strike.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStrike class styles a selection with strike style.
 *
 * @class ButtonStrike
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonStrike = function (_React$Component) {
    _inherits(ButtonStrike, _React$Component);

    function ButtonStrike() {
        _classCallCheck(this, ButtonStrike);

        return _possibleConstructorReturn(this, (ButtonStrike.__proto__ || Object.getPrototypeOf(ButtonStrike)).apply(this, arguments));
    }

    _createClass(ButtonStrike, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         * @instance
         * @memberof ButtonStrike
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.strike, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-strike', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.strike },
                _react2.default.createElement('span', { className: 'ae-icon-strike' })
            );
        }
    }]);

    return ButtonStrike;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default strike
 * @memberof ButtonStrike
 * @property {String} key
 * @static
 */


ButtonStrike.key = 'strike';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStrike
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStrike.defaultProps = {
    command: 'strike',
    style: 'coreStyles_strike'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonStrike)));

/***/ }),

/***/ "./src/components/buttons/button-styles-list-header.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-header.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonsStylesListHeader class provides the header of an list of style items.
 *
 * @class ButtonsStylesListHeader
 */
var ButtonsStylesListHeader = function (_React$Component) {
    _inherits(ButtonsStylesListHeader, _React$Component);

    function ButtonsStylesListHeader() {
        _classCallCheck(this, ButtonsStylesListHeader);

        return _possibleConstructorReturn(this, (ButtonsStylesListHeader.__proto__ || Object.getPrototypeOf(ButtonsStylesListHeader)).apply(this, arguments));
    }

    _createClass(ButtonsStylesListHeader, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonsStylesListHeader
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.styles && this.props.styles.length) {
                return _react2.default.createElement(
                    'span',
                    { className: 'ae-list-header' },
                    this.props.name
                );
            } else {
                return null;
            }
        }
    }]);

    return ButtonsStylesListHeader;
}(_react2.default.Component);

ButtonsStylesListHeader.key = 'buttonStylesListHeader';

exports.default = ButtonsStylesListHeader;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item-remove.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item-remove.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItemRemove class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItemRemove
 */
var ButtonStylesListItemRemove = function (_React$Component) {
    _inherits(ButtonStylesListItemRemove, _React$Component);

    function ButtonStylesListItemRemove() {
        _classCallCheck(this, ButtonStylesListItemRemove);

        return _possibleConstructorReturn(this, (ButtonStylesListItemRemove.__proto__ || Object.getPrototypeOf(ButtonStylesListItemRemove)).apply(this, arguments));
    }

    _createClass(ButtonStylesListItemRemove, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStylesListItemRemove
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                "li",
                { role: "option" },
                _react2.default.createElement(
                    "button",
                    { className: "ae-toolbar-element", onClick: this._removeStyles.bind(this), tabIndex: this.props.tabIndex },
                    AlloyEditor.Strings.normal
                )
            );
        }

        /**
         * Removes all inline styles and configured block elements applied to the current selection.
         *
         * @instance
         * @memberof ButtonStylesListItemRemove
         * @method _removeStyles
         * @protected
         */

    }, {
        key: "_removeStyles",
        value: function _removeStyles() {
            var editor = this.props.editor.get('nativeEditor');

            editor.execCommand('removeFormat');

            this.props.removeBlocks.forEach(function (blockItem) {
                var blockStyle = new CKEDITOR.style({ element: blockItem });

                editor.removeStyle(blockStyle);
            });

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonStylesListItemRemove;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonStylesListItemRemove
 * @memberof ButtonStylesListItemRemove
 * @property {String} key
 * @static
 */


ButtonStylesListItemRemove.key = 'buttonStylesListItemRemove';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStylesListItemRemove
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStylesListItemRemove.defaultProps = {
    removeBlocks: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre']
};

exports.default = ButtonStylesListItemRemove;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItem class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItem
 * @uses ButtonActionStyle
 * @uses ButtonStyle
 */
var ButtonStylesListItem = function (_React$Component) {
    _inherits(ButtonStylesListItem, _React$Component);

    function ButtonStylesListItem() {
        _classCallCheck(this, ButtonStylesListItem);

        return _possibleConstructorReturn(this, (ButtonStylesListItem.__proto__ || Object.getPrototypeOf(ButtonStylesListItem)).apply(this, arguments));
    }

    _createClass(ButtonStylesListItem, [{
        key: 'componentWillMount',

        /**
         * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method componentWillMount
         */
        value: function componentWillMount() {
            // Styles with wildcard element (*) generate an empty tag in their preview < class="custom-class" />.
            // We default to element span and remove the margins to obtain a more consistent set of previews.
            var styleCfg = {
                element: 'span',
                styles: {
                    margin: 0
                }
            };

            styleCfg = CKEDITOR.tools.merge(styleCfg, this.props.style);

            this._preview = new CKEDITOR.style(styleCfg).buildPreview(this.props.name);
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            // We need to use dangerouselySetInnterHTML since we're not in control of the style
            // preview that is generated by CKEditor.
            var className = this.props.name === this.props.activeStyle ? 'ae-toolbar-element active' : 'ae-toolbar-element';

            return _react2.default.createElement('button', { className: className, dangerouslySetInnerHTML: { __html: this._preview }, onClick: this._onClick.bind(this), tabIndex: this.props.tabIndex });
        }

        /**
         * Applies the item style to the editor selection.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method _onClick
         * @protected
         */

    }, {
        key: '_onClick',
        value: function _onClick() {
            // Typically, we want the style to be the only one applied to the current selection, so
            // we execute the 'removeFormat' command first. Note that block styles won't be cleaned.
            // However, this is consistent with other editors implementations of this feature.
            this.props.editor.get('nativeEditor').execCommand('removeFormat');

            this.applyStyle();
        }
    }]);

    return ButtonStylesListItem;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonStylesListItem
 * @memberof ButtonStylesListItem
 * @property {String} key
 * @static
 */


ButtonStylesListItem.key = 'buttonStylesListItem';

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStyle2.default)(ButtonStylesListItem));

/***/ }),

/***/ "./src/components/buttons/button-styles-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-styles-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesList class provides functionality for showing a list of styles that can be
 * applied to the current selection..
 *
 * @class ButtonStylesList
 * @uses WidgetFocusManager
 */
var ButtonStylesList = function (_React$Component) {
    _inherits(ButtonStylesList, _React$Component);

    function ButtonStylesList() {
        _classCallCheck(this, ButtonStylesList);

        return _possibleConstructorReturn(this, (ButtonStylesList.__proto__ || Object.getPrototypeOf(ButtonStylesList)).apply(this, arguments));
    }

    _createClass(ButtonStylesList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses on the list node to allow keyboard interaction.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method componentWillMount
         */

    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            var blockStyles = [];
            var inlineStyles = [];
            var objectStyles = [];

            this.props.styles.forEach(function (item) {
                var style = new CKEDITOR.style(item.style);

                if (style.type === CKEDITOR.STYLE_BLOCK) {
                    blockStyles.push(item);
                } else if (style.type === CKEDITOR.STYLE_INLINE) {
                    inlineStyles.push(item);
                } else if (style.type === CKEDITOR.STYLE_OBJECT) {
                    objectStyles.push(item);
                }
            });

            this._blockStyles = blockStyles;
            this._inlineStyles = inlineStyles;
            this._objectStyles = objectStyles;
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var removeStylesItem;

            if (this.props.showRemoveStylesItem) {
                removeStylesItem = _react2.default.createElement(_buttonStylesListItemRemove2.default, { editor: this.props.editor, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                _buttonDropdown2.default,
                this.props,
                removeStylesItem,
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.blockStyles, styles: this._blockStyles }),
                this._renderStylesItems(this._blockStyles),
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.inlineStyles, styles: this._inlineStyles }),
                this._renderStylesItems(this._inlineStyles),
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.objectStyles, styles: this._objectStyles }),
                this._renderStylesItems(this._objectStyles)
            );
        }

        /**
         * Renders instances of ButtonStylesListItem with the preview of the correspondent block, inline or object styles.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method _renderStylesItems
         * @param {Array} styles List of styles for which preview should be rendered.
         * @protected
         * @return {Array} Rendered instances of ButtonStylesListItem class
         */

    }, {
        key: '_renderStylesItems',
        value: function _renderStylesItems(styles) {
            var editor = this.props.editor;
            var items;

            if (styles && styles.length) {
                items = styles.map(function (item) {
                    return _react2.default.createElement(
                        'li',
                        { key: item.name, role: 'option' },
                        _react2.default.createElement(_buttonStylesListItem2.default, { activeStyle: this.props.activeStyle, editor: editor, name: item.name, style: item.style })
                    );
                }.bind(this));
            }

            return items;
        }
    }]);

    return ButtonStylesList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @memberof ButtonStylesList
 * @static
 * @property {String} key
 * @default buttonStylesList
 */


ButtonStylesList.key = 'buttonStylesList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStylesList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStylesList.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    },
    showRemoveStylesItem: true
};

exports.default = (0, _widgetFocusManager2.default)(ButtonStylesList);

/***/ }),

/***/ "./src/components/buttons/button-styles.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-styles.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStyles class provides functionality for styling a selection with a list of
 * configurable and customizable styles. The allowed styles follow CKEDITOR.Style configuration
 * (http://docs.ckeditor.com/#!/api/CKEDITOR.style)
 *
 * @class ButtonStyles
 */
var ButtonStyles = function (_React$Component) {
    _inherits(ButtonStyles, _React$Component);

    function ButtonStyles() {
        _classCallCheck(this, ButtonStyles);

        return _possibleConstructorReturn(this, (ButtonStyles.__proto__ || Object.getPrototypeOf(ButtonStyles)).apply(this, arguments));
    }

    _createClass(ButtonStyles, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStyles
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var activeStyle = AlloyEditor.Strings.normal;

            var styles = this._getStyles();

            styles.forEach(function (item) {
                if (this._checkActive(item.style)) {
                    activeStyle = item.name;
                }
            }.bind(this));

            var buttonStylesList;

            if (this.props.expanded) {
                buttonStylesList = _react2.default.createElement(_buttonStylesList2.default, { activeStyle: activeStyle, editor: this.props.editor, onDismiss: this.props.toggleDropdown, showRemoveStylesItem: this.props.showRemoveStylesItem, styles: styles });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-dropdown ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.styles + ' ' + activeStyle, className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.styles + ' ' + activeStyle },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            activeStyle
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                buttonStylesList
            );
        }

        /**
         * Checks if the given style definition is applied to the current selection in the editor.
         *
         * @instance
         * @memberof ButtonStyles
         * @method _checkActive
         * @param {Object} styleConfig Style definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
         * @protected
         * @return {Boolean} Returns true if the style is applied to the selection, false otherwise.
         */

    }, {
        key: '_checkActive',
        value: function _checkActive(styleConfig) {
            var nativeEditor = this.props.editor.get('nativeEditor');

            // Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
            // to a 'span' element works for most of those cases with no defined element.
            styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

            var style = new CKEDITOR.style(styleConfig);

            return style.checkActive(nativeEditor.elementPath(), nativeEditor);
        }

        /**
         * Returns an array of styles. Each style consists from two properties:
         * - name - the style name, for example "h1"
         * - style - an object with one property, called `element` which value
         * represents the style which have to be applied to the element.
         *
         * @instance
         * @memberof ButtonStyles
         * @method _getStyles
         * @protected
         * @return {Array<object>} An array of objects containing the styles.
         */

    }, {
        key: '_getStyles',
        value: function _getStyles() {
            return this.props.styles || [{
                name: AlloyEditor.Strings.h1,
                style: {
                    element: 'h1'
                }
            }, {
                name: AlloyEditor.Strings.h2,
                style: {
                    element: 'h2'
                }
            }, {
                name: AlloyEditor.Strings.formatted,
                style: {
                    element: 'pre'
                }
            }, {
                name: AlloyEditor.Strings.cite,
                style: {
                    element: 'cite'
                }
            }, {
                name: AlloyEditor.Strings.code,
                style: {
                    element: 'code'
                }
            }];
        }
    }]);

    return ButtonStyles;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default styles
 * @memberof ButtonStyles
 * @property {String} key
 * @static
 */


ButtonStyles.key = 'styles';

exports.default = ButtonStyles;

/***/ }),

/***/ "./src/components/buttons/button-subscript.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-subscript.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSubscript class provides functionality for applying subscript style to a text selection.
 *
 * @class ButtonSubscript
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSubscript = function (_React$Component) {
    _inherits(ButtonSubscript, _React$Component);

    function ButtonSubscript() {
        _classCallCheck(this, ButtonSubscript);

        return _possibleConstructorReturn(this, (ButtonSubscript.__proto__ || Object.getPrototypeOf(ButtonSubscript)).apply(this, arguments));
    }

    _createClass(ButtonSubscript, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonSubscript
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.subscript, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-subscript', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.subscript },
                _react2.default.createElement('span', { className: 'ae-icon-subscript' })
            );
        }
    }]);

    return ButtonSubscript;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default subscript
 * @memberof ButtonSubscript
 * @property {String} key
 * @static
 */


ButtonSubscript.key = 'subscript';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonSubscript
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonSubscript.defaultProps = {
    command: 'subscript',
    style: 'coreStyles_subscript'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSubscript)));

/***/ }),

/***/ "./src/components/buttons/button-superscript.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-superscript.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSuperscript class provides functionality for applying superscript style to a text selection.
 *
 * @class ButtonSuperscript
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSuperscript = function (_React$Component) {
    _inherits(ButtonSuperscript, _React$Component);

    function ButtonSuperscript() {
        _classCallCheck(this, ButtonSuperscript);

        return _possibleConstructorReturn(this, (ButtonSuperscript.__proto__ || Object.getPrototypeOf(ButtonSuperscript)).apply(this, arguments));
    }

    _createClass(ButtonSuperscript, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonSuperscript
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.superscript, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-superscript', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.superscript },
                _react2.default.createElement('span', { className: 'ae-icon-superscript' })
            );
        }
    }]);

    return ButtonSuperscript;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default superscript
 * @memberof ButtonSuperscript
 * @property {String} key
 * @static
 */


ButtonSuperscript.key = 'superscript';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonSuperscript
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonSuperscript.defaultProps = {
    command: 'superscript',
    style: 'coreStyles_superscript'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSuperscript)));

/***/ }),

/***/ "./src/components/buttons/button-table-cell.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-cell.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableCell class provides functionality to work with table cells.
 *
 * @class ButtonTableCell
 */
var ButtonTableCell = function (_React$Component) {
    _inherits(ButtonTableCell, _React$Component);

    function ButtonTableCell() {
        _classCallCheck(this, ButtonTableCell);

        return _possibleConstructorReturn(this, (ButtonTableCell.__proto__ || Object.getPrototypeOf(ButtonTableCell)).apply(this, arguments));
    }

    _createClass(ButtonTableCell, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableCell
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableCell.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.cell, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.cell },
                    _react2.default.createElement('span', { className: 'ae-icon-cell' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableCell
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'cellInsertBefore',
                label: AlloyEditor.Strings.cellInsertBefore
            }, {
                command: 'cellInsertAfter',
                label: AlloyEditor.Strings.cellInsertAfter
            }, {
                command: 'cellDelete',
                label: AlloyEditor.Strings.cellDelete
            }, {
                command: 'cellMerge',
                label: AlloyEditor.Strings.cellMerge
            }, {
                command: 'cellMergeDown',
                label: AlloyEditor.Strings.cellMergeDown
            }, {
                command: 'cellMergeRight',
                label: AlloyEditor.Strings.cellMergeRight
            }, {
                command: 'cellHorizontalSplit',
                label: AlloyEditor.Strings.cellSplitHorizontal
            }, {
                command: 'cellVerticalSplit',
                label: AlloyEditor.Strings.cellSplitVertical
            }];
        }
    }]);

    return ButtonTableCell;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableCell
 * @memberof ButtonTableCell
 * @property {String} key
 * @static
 */


ButtonTableCell.key = 'tableCell';

exports.default = ButtonTableCell;

/***/ }),

/***/ "./src/components/buttons/button-table-column.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-column.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableColumn class provides functionality to work with table columns.
 *
 * @class ButtonTableColumn
 */
var ButtonTableColumn = function (_React$Component) {
    _inherits(ButtonTableColumn, _React$Component);

    function ButtonTableColumn() {
        _classCallCheck(this, ButtonTableColumn);

        return _possibleConstructorReturn(this, (ButtonTableColumn.__proto__ || Object.getPrototypeOf(ButtonTableColumn)).apply(this, arguments));
    }

    _createClass(ButtonTableColumn, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableColumn
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList, buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableColumn.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.column, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), role: 'listbox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.column },
                    _react2.default.createElement('span', { className: 'ae-icon-column' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableColumn
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'columnInsertBefore',
                label: AlloyEditor.Strings.columnInsertBefore
            }, {
                command: 'columnInsertAfter',
                label: AlloyEditor.Strings.columnInsertAfter
            }, {
                command: 'columnDelete',
                label: AlloyEditor.Strings.columnDelete
            }];
        }
    }]);

    return ButtonTableColumn;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableColumn
 * @memberof ButtonTableColumn
 * @property {String} key
 * @static
 */


ButtonTableColumn.key = 'tableColumn';

exports.default = ButtonTableColumn;

/***/ }),

/***/ "./src/components/buttons/button-table-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonTableEdit class provides functionality for creating and editing a table in a document.
 * Provides UI for creating a table.
 *
 * @class ButtonTableEdit
 */

var ButtonTableEdit = function (_React$Component) {
    _inherits(ButtonTableEdit, _React$Component);

    /**
     * Lifecycle. Invoked once before the component is mounted.
     *
     * @instance
     * @memberof ButtonTableEdit
     * @method getInitialState
     */
    function ButtonTableEdit(props) {
        _classCallCheck(this, ButtonTableEdit);

        var _this = _possibleConstructorReturn(this, (ButtonTableEdit.__proto__ || Object.getPrototypeOf(ButtonTableEdit)).call(this, props));

        _this.rowsRef = _react2.default.createRef();
        _this.colsRef = _react2.default.createRef();
        _this.state = {
            cols: 3,
            rows: 3
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing.
     *
     * @instance
     * @memberof ButtonTableEdit
     * @method componentDidMount
     */


    _createClass(ButtonTableEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.rowsRef.current.focus();
        }

        /**
         * Creates a table.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _createTable
         * @protected
         */

    }, {
        key: '_createTable',
        value: function _createTable() {
            var editor = this.props.editor.get('nativeEditor');
            var tableUtils = new CKEDITOR.Table(editor);

            tableUtils.create({
                attrs: this.props.tableAttributes,
                cols: this.state.cols,
                rows: this.state.rows
            });

            this.props.cancelExclusive();

            editor.fire('actionPerformed', this);
        }

        /**
         * Handles a change in input value. Sets the provided value from the user back to the input.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _handleChange
         * @param {String} inputName The name of the input which value should be updated.
         * @param {SyntheticEvent} event The provided event.
         * @protected
         */

    }, {
        key: '_handleChange',
        value: function _handleChange(inputName, event) {
            var state = {};
            state[inputName] = event.target.value;

            this.setState(state);
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates the table.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
                event.preventDefault();
            }

            if (event.keyCode === KEY_ENTER) {
                this._createTable();
            } else if (event.keyCode === KEY_ESC) {
                this.props.cancelExclusive();
            }
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var time = Date.now();
            var rowsId = time + 'rows';
            var colsId = time + 'cols';

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-table' },
                _react2.default.createElement(
                    'label',
                    { htmlFor: rowsId },
                    AlloyEditor.Strings.rows
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input small' },
                    _react2.default.createElement('input', { className: 'ae-input', id: rowsId, onChange: this._handleChange.bind(this, 'rows'), min: '1', onKeyDown: this._handleKeyDown.bind(this), placeholder: 'Rows', ref: this.rowsRef, type: 'number', value: this.state.rows })
                ),
                _react2.default.createElement(
                    'label',
                    { htmlFor: colsId },
                    AlloyEditor.Strings.columns
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input small' },
                    _react2.default.createElement('input', { className: 'ae-input', id: colsId, onChange: this._handleChange.bind(this, 'cols'), min: '1', onKeyDown: this._handleKeyDown.bind(this), placeholder: 'Colums', ref: this.colsRef, type: 'number', value: this.state.cols })
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': 'Confirm', className: 'ae-button', onClick: this._createTable.bind(this) },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }
    }]);

    return ButtonTableEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableEdit
 * @memberof ButtonTableEdit
 * @property {String} key
 * @static
 */


ButtonTableEdit.key = 'tableEdit';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonTableEdit
 * @method getDefaultProps
 */
ButtonTableEdit.defaultProps = {
    tableAttributes: {
        border: 1,
        cellPadding: 0,
        cellSpacing: 0,
        style: 'width: 100%'
    }
};

exports.default = ButtonTableEdit;

/***/ }),

/***/ "./src/components/buttons/button-table-heading.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-table-heading.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableHeading class provides functionality to work with table heading.
 *
 * @class ButtonTableHeading
 */
var ButtonTableHeading = function (_React$Component) {
    _inherits(ButtonTableHeading, _React$Component);

    function ButtonTableHeading() {
        _classCallCheck(this, ButtonTableHeading);

        return _possibleConstructorReturn(this, (ButtonTableHeading.__proto__ || Object.getPrototypeOf(ButtonTableHeading)).apply(this, arguments));
    }

    _createClass(ButtonTableHeading, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableHeading
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableHeading.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            var activeHeading = new CKEDITOR.Table(this.props.editor.get('nativeEditor')).getHeading();
            var activeHeadingIntro = AlloyEditor.Strings.headers + ':';
            var activeHeadingLabel = AlloyEditor.Strings['headers' + activeHeading];

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-dropdown-xl ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': '', className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: '' },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            activeHeadingIntro,
                            ' ',
                            _react2.default.createElement(
                                'strong',
                                null,
                                activeHeadingLabel
                            )
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableHeading
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'tableHeadingNone',
                label: AlloyEditor.Strings.headersNone
            }, {
                command: 'tableHeadingRow',
                label: AlloyEditor.Strings.headersRow
            }, {
                command: 'tableHeadingColumn',
                label: AlloyEditor.Strings.headersColumn
            }, {
                command: 'tableHeadingBoth',
                label: AlloyEditor.Strings.headersBoth
            }];
        }
    }]);

    return ButtonTableHeading;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRow
 * @memberof ButtonTableHeading
 * @property {String} key
 * @static
 */


ButtonTableHeading.key = 'tableHeading';

exports.default = ButtonTableHeading;

/***/ }),

/***/ "./src/components/buttons/button-table-remove.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-remove.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRemove class provides functionality for removing a table
 *
 * @class ButtonTableRemove
 */
var ButtonTableRemove = function (_React$Component) {
    _inherits(ButtonTableRemove, _React$Component);

    function ButtonTableRemove() {
        _classCallCheck(this, ButtonTableRemove);

        return _possibleConstructorReturn(this, (ButtonTableRemove.__proto__ || Object.getPrototypeOf(ButtonTableRemove)).apply(this, arguments));
    }

    _createClass(ButtonTableRemove, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableRemove
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                "button",
                { "aria-label": AlloyEditor.Strings.deleteTable, className: "ae-button", "data-type": "button-table-remove", onClick: this._removeTable.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.deleteTable },
                _react2.default.createElement("span", { className: "ae-icon-bin" })
            );
        }

        /**
         * Removes the table in the editor element.
         *
         * @instance
         * @memberof ButtonTableRemove
         * @method _removeTable
         * @protected
         */

    }, {
        key: "_removeTable",
        value: function _removeTable() {
            var editor = this.props.editor.get('nativeEditor');
            var tableUtils = new CKEDITOR.Table(editor);

            tableUtils.remove();

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonTableRemove;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRemove
 * @memberof ButtonTableRemove
 * @property {String} key
 * @static
 */


ButtonTableRemove.key = 'tableRemove';

exports.default = ButtonTableRemove;

/***/ }),

/***/ "./src/components/buttons/button-table-row.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-table-row.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRow class provides functionality to work with table rows.
 *
 * @class ButtonTableRow
 */
var ButtonTableRow = function (_React$Component) {
    _inherits(ButtonTableRow, _React$Component);

    function ButtonTableRow() {
        _classCallCheck(this, ButtonTableRow);

        return _possibleConstructorReturn(this, (ButtonTableRow.__proto__ || Object.getPrototypeOf(ButtonTableRow)).apply(this, arguments));
    }

    _createClass(ButtonTableRow, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableRow
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableRow.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.row, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.row },
                    _react2.default.createElement('span', { className: 'ae-icon-row' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableRow
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'rowInsertBefore',
                label: AlloyEditor.Strings.rowInsertBefore
            }, {
                command: 'rowInsertAfter',
                label: AlloyEditor.Strings.rowInsertAfter
            }, {
                command: 'rowDelete',
                label: AlloyEditor.Strings.rowDelete
            }];
        }
    }]);

    return ButtonTableRow;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRow
 * @memberof ButtonTableRow
 * @property {String} key
 * @static
 */


ButtonTableRow.key = 'tableRow';

exports.default = ButtonTableRow;

/***/ }),

/***/ "./src/components/buttons/button-table.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-table.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTable class provides functionality for creating and editing a table in a document. ButtonTable
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonTableEdit UI with all the table edition controls.
 *
 * @class ButtonTable
 */
var ButtonTable = function (_React$Component) {
    _inherits(ButtonTable, _React$Component);

    function ButtonTable() {
        _classCallCheck(this, ButtonTable);

        return _possibleConstructorReturn(this, (ButtonTable.__proto__ || Object.getPrototypeOf(ButtonTable)).apply(this, arguments));
    }

    _createClass(ButtonTable, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTable
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonTableEdit2.default, this.props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.table, className: 'ae-button', 'data-type': 'button-table', onClick: this.props.requestExclusive, tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.table },
                    _react2.default.createElement('span', { className: 'ae-icon-table' })
                );
            }
        }
    }]);

    return ButtonTable;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default table
 * @memberof ButtonTable
 * @property {String} key
 * @static
 */


ButtonTable.key = 'table';

exports.default = ButtonTable;

/***/ }),

/***/ "./src/components/buttons/button-target-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-target-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTargetList class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonTargetList
 * @uses WidgetFocusManager
 */
var ButtonTargetList = function (_React$Component) {
    _inherits(ButtonTargetList, _React$Component);

    function ButtonTargetList() {
        _classCallCheck(this, ButtonTargetList);

        return _possibleConstructorReturn(this, (ButtonTargetList.__proto__ || Object.getPrototypeOf(ButtonTargetList)).apply(this, arguments));
    }

    _createClass(ButtonTargetList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var listTargets = this._renderListTargets();

            return _react2.default.createElement(
                _buttonDropdown2.default,
                this.props,
                listTargets
            );
        }

        /**
         * Returns the the allowed link target items.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method _getAllowedTargetItems
         * @protected
         * @return {Array} The allowed target items.
         */

    }, {
        key: '_getAllowedTargetItems',
        value: function _getAllowedTargetItems() {
            return this.props.allowedLinkTargets || [{
                label: AlloyEditor.Strings.linkTargetDefault,
                value: ''
            }, {
                label: AlloyEditor.Strings.linkTargetSelf,
                value: '_self'
            }, {
                label: AlloyEditor.Strings.linkTargetBlank,
                value: '_blank'
            }, {
                label: AlloyEditor.Strings.linkTargetParent,
                value: '_parent'
            }, {
                label: AlloyEditor.Strings.linkTargetTop,
                value: '_top'
            }];
        }

        /**
         * Renders the allowed link target items.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method _renderListTargets
         * @protected
         * @return {Object} Returns the rendered link items
         */

    }, {
        key: '_renderListTargets',
        value: function _renderListTargets() {
            var targets = this._getAllowedTargetItems();

            var handleLinkTargetChange = this.props.handleLinkTargetChange;

            targets = targets.map(function (target) {
                var className = this.props.selectedTarget === target.value ? 'ae-toolbar-element active' : 'ae-toolbar-element';

                return _react2.default.createElement(
                    'li',
                    { key: target.value, role: 'option' },
                    _react2.default.createElement(
                        'button',
                        { className: className, 'data-value': target.value, onClick: handleLinkTargetChange },
                        target.label
                    )
                );
            }.bind(this));

            return targets;
        }
    }]);

    return ButtonTargetList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkTargetEdit
 * @memberof ButtonTargetList
 * @property {String} key
 * @static
 */


ButtonTargetList.key = 'targetList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonTargetList
 * @method getDefaultProps
 */
ButtonTargetList.defaultProps = {
    circular: true,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonTargetList);

/***/ }),

/***/ "./src/components/buttons/button-twitter.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-twitter.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MAX_TWEET_LENGTH = 280;

/**
 * The ButtonTwitter class provides functionality for creating a link which
 * allows people to tweet part of the content in the editor.
 *
 * @class ButtonTwitter
 * @uses ButtonStateClasses
 */

var ButtonTwitter = function (_React$Component) {
    _inherits(ButtonTwitter, _React$Component);

    function ButtonTwitter() {
        _classCallCheck(this, ButtonTwitter);

        return _possibleConstructorReturn(this, (ButtonTwitter.__proto__ || Object.getPrototypeOf(ButtonTwitter)).apply(this, arguments));
    }

    _createClass(ButtonTwitter, [{
        key: 'handleClick',

        /**
         * Creates or removes the twitter link on the selection.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method handleClick
         */
        value: function handleClick() {
            var editor = this.props.editor.get('nativeEditor');

            var linkUtils = new CKEDITOR.Link(editor);

            if (this.isActive()) {
                linkUtils.remove(linkUtils.getFromSelection());
            } else {
                linkUtils.create(this._getHref(), {
                    'class': 'ae-twitter-link',
                    'target': '_blank'
                });
            }

            editor.fire('actionPerformed', this);
        }

        /**
         * Checks if the current selection is contained within a link that points to twitter.com/intent/tweet.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method isActive
         * @return {Boolean} True if the selection is inside a twitter link, false otherwise.
         */

    }, {
        key: 'isActive',
        value: function isActive() {
            var link = new CKEDITOR.Link(this.props.editor.get('nativeEditor')).getFromSelection();

            return link && link.getAttribute('href').indexOf('twitter.com/intent/tweet') !== -1;
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.twitter, className: cssClass, 'data-type': 'button-twitter', onClick: this.handleClick.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.twitter },
                _react2.default.createElement('span', { className: 'ae-icon-twitter' })
            );
        }

        /**
         * Generates the appropriate twitter url based on the selected text and the configuration
         * options received via props.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method _getHref
         * @protected
         * @return {String} A valid twitter url with the selected text and given configuration.
         */

    }, {
        key: '_getHref',
        value: function _getHref() {
            var nativeEditor = this.props.editor.get('nativeEditor');
            var selectedText = nativeEditor.getSelection().getSelectedText().substring(0, MAX_TWEET_LENGTH);
            var url = this.props.url;
            var via = this.props.via;
            var twitterHref = 'https://twitter.com/intent/tweet?text=' + selectedText;

            if (url) {
                twitterHref += '&url=' + url;
            }

            if (via) {
                twitterHref += '&via=' + via;
            }

            return twitterHref;
        }
    }]);

    return ButtonTwitter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default twitter
 * @memberof ButtonTwitter
 * @property {String} key
 * @static
 */


ButtonTwitter.key = 'twitter';

exports.default = (0, _buttonStateClasses2.default)(ButtonTwitter);

/***/ }),

/***/ "./src/components/buttons/button-ul.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ul.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnorderedlist class provides functionality for creating unordered lists in an editor.
 *
 * @class ButtonUnorderedlist
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnorderedlist = function (_React$Component) {
    _inherits(ButtonUnorderedlist, _React$Component);

    function ButtonUnorderedlist() {
        _classCallCheck(this, ButtonUnorderedlist);

        return _possibleConstructorReturn(this, (ButtonUnorderedlist.__proto__ || Object.getPrototypeOf(ButtonUnorderedlist)).apply(this, arguments));
    }

    _createClass(ButtonUnorderedlist, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonUnorderedlist
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.bulletedlist, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-ul', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.bulletedlist },
                _react2.default.createElement('span', { className: 'ae-icon-bulleted-list' })
            );
        }
    }]);

    return ButtonUnorderedlist;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default ul
 * @memberof ButtonUnorderedlist
 * @property {String} key
 * @static
 */


ButtonUnorderedlist.key = 'ul';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonUnorderedlist
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonUnorderedlist.defaultProps = {
    command: 'bulletedlist',
    style: {
        element: 'ul'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnorderedlist)));

/***/ }),

/***/ "./src/components/buttons/button-underline.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-underline.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnderline class provides functionality for underlying a text selection.
 *
 * @class ButtonUnderline
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnderline = function (_React$Component) {
    _inherits(ButtonUnderline, _React$Component);

    function ButtonUnderline() {
        _classCallCheck(this, ButtonUnderline);

        return _possibleConstructorReturn(this, (ButtonUnderline.__proto__ || Object.getPrototypeOf(ButtonUnderline)).apply(this, arguments));
    }

    _createClass(ButtonUnderline, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonUnderline
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.underline, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-underline', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.underline },
                _react2.default.createElement('span', { className: 'ae-icon-underline' })
            );
        }
    }]);

    return ButtonUnderline;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default underline
 * @memberof ButtonUnderline
 * @property {String} key
 * @static
 */


ButtonUnderline.key = 'underline';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonUnderline
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonUnderline.defaultProps = {
    command: 'underline',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 85 /*U*/
    },
    style: 'coreStyles_underline'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnderline))));

/***/ }),

/***/ "./src/components/buttons/index.js":
/*!*****************************************!*\
  !*** ./src/components/buttons/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ButtonBold$key$Butto;

var _buttonBold = __webpack_require__(/*! ./button-bold.jsx */ "./src/components/buttons/button-bold.jsx");

var _buttonBold2 = _interopRequireDefault(_buttonBold);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonCamera = __webpack_require__(/*! ./button-camera.jsx */ "./src/components/buttons/button-camera.jsx");

var _buttonCamera2 = _interopRequireDefault(_buttonCamera);

var _buttonCode = __webpack_require__(/*! ./button-code.jsx */ "./src/components/buttons/button-code.jsx");

var _buttonCode2 = _interopRequireDefault(_buttonCode);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonEmbed = __webpack_require__(/*! ./button-embed.jsx */ "./src/components/buttons/button-embed.jsx");

var _buttonEmbed2 = _interopRequireDefault(_buttonEmbed);

var _buttonH = __webpack_require__(/*! ./button-h1.jsx */ "./src/components/buttons/button-h1.jsx");

var _buttonH2 = _interopRequireDefault(_buttonH);

var _buttonH3 = __webpack_require__(/*! ./button-h2.jsx */ "./src/components/buttons/button-h2.jsx");

var _buttonH4 = _interopRequireDefault(_buttonH3);

var _buttonHline = __webpack_require__(/*! ./button-hline.jsx */ "./src/components/buttons/button-hline.jsx");

var _buttonHline2 = _interopRequireDefault(_buttonHline);

var _buttonImageAlignCenter = __webpack_require__(/*! ./button-image-align-center.jsx */ "./src/components/buttons/button-image-align-center.jsx");

var _buttonImageAlignCenter2 = _interopRequireDefault(_buttonImageAlignCenter);

var _buttonImageAlignLeft = __webpack_require__(/*! ./button-image-align-left.jsx */ "./src/components/buttons/button-image-align-left.jsx");

var _buttonImageAlignLeft2 = _interopRequireDefault(_buttonImageAlignLeft);

var _buttonImageAlignRight = __webpack_require__(/*! ./button-image-align-right.jsx */ "./src/components/buttons/button-image-align-right.jsx");

var _buttonImageAlignRight2 = _interopRequireDefault(_buttonImageAlignRight);

var _buttonImage = __webpack_require__(/*! ./button-image.jsx */ "./src/components/buttons/button-image.jsx");

var _buttonImage2 = _interopRequireDefault(_buttonImage);

var _buttonIndentBlock = __webpack_require__(/*! ./button-indent-block.jsx */ "./src/components/buttons/button-indent-block.jsx");

var _buttonIndentBlock2 = _interopRequireDefault(_buttonIndentBlock);

var _buttonItalic = __webpack_require__(/*! ./button-italic.jsx */ "./src/components/buttons/button-italic.jsx");

var _buttonItalic2 = _interopRequireDefault(_buttonItalic);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

var _buttonOl = __webpack_require__(/*! ./button-ol.jsx */ "./src/components/buttons/button-ol.jsx");

var _buttonOl2 = _interopRequireDefault(_buttonOl);

var _buttonOutdentBlock = __webpack_require__(/*! ./button-outdent-block.jsx */ "./src/components/buttons/button-outdent-block.jsx");

var _buttonOutdentBlock2 = _interopRequireDefault(_buttonOutdentBlock);

var _buttonParagraphAlignLeft = __webpack_require__(/*! ./button-paragraph-align-left.jsx */ "./src/components/buttons/button-paragraph-align-left.jsx");

var _buttonParagraphAlignLeft2 = _interopRequireDefault(_buttonParagraphAlignLeft);

var _buttonParagraphAlignRight = __webpack_require__(/*! ./button-paragraph-align-right.jsx */ "./src/components/buttons/button-paragraph-align-right.jsx");

var _buttonParagraphAlignRight2 = _interopRequireDefault(_buttonParagraphAlignRight);

var _buttonParagraphCenter = __webpack_require__(/*! ./button-paragraph-center.jsx */ "./src/components/buttons/button-paragraph-center.jsx");

var _buttonParagraphCenter2 = _interopRequireDefault(_buttonParagraphCenter);

var _buttonParagraphJustify = __webpack_require__(/*! ./button-paragraph-justify.jsx */ "./src/components/buttons/button-paragraph-justify.jsx");

var _buttonParagraphJustify2 = _interopRequireDefault(_buttonParagraphJustify);

var _buttonQuote = __webpack_require__(/*! ./button-quote.jsx */ "./src/components/buttons/button-quote.jsx");

var _buttonQuote2 = _interopRequireDefault(_buttonQuote);

var _buttonRemoveFormat = __webpack_require__(/*! ./button-remove-format.jsx */ "./src/components/buttons/button-remove-format.jsx");

var _buttonRemoveFormat2 = _interopRequireDefault(_buttonRemoveFormat);

var _buttonSeparator = __webpack_require__(/*! ./button-separator.jsx */ "./src/components/buttons/button-separator.jsx");

var _buttonSeparator2 = _interopRequireDefault(_buttonSeparator);

var _buttonStrike = __webpack_require__(/*! ./button-strike.jsx */ "./src/components/buttons/button-strike.jsx");

var _buttonStrike2 = _interopRequireDefault(_buttonStrike);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _buttonStyles = __webpack_require__(/*! ./button-styles.jsx */ "./src/components/buttons/button-styles.jsx");

var _buttonStyles2 = _interopRequireDefault(_buttonStyles);

var _buttonSubscript = __webpack_require__(/*! ./button-subscript.jsx */ "./src/components/buttons/button-subscript.jsx");

var _buttonSubscript2 = _interopRequireDefault(_buttonSubscript);

var _buttonSuperscript = __webpack_require__(/*! ./button-superscript.jsx */ "./src/components/buttons/button-superscript.jsx");

var _buttonSuperscript2 = _interopRequireDefault(_buttonSuperscript);

var _buttonTableCell = __webpack_require__(/*! ./button-table-cell.jsx */ "./src/components/buttons/button-table-cell.jsx");

var _buttonTableCell2 = _interopRequireDefault(_buttonTableCell);

var _buttonTableColumn = __webpack_require__(/*! ./button-table-column.jsx */ "./src/components/buttons/button-table-column.jsx");

var _buttonTableColumn2 = _interopRequireDefault(_buttonTableColumn);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _buttonTableHeading = __webpack_require__(/*! ./button-table-heading.jsx */ "./src/components/buttons/button-table-heading.jsx");

var _buttonTableHeading2 = _interopRequireDefault(_buttonTableHeading);

var _buttonTableRemove = __webpack_require__(/*! ./button-table-remove.jsx */ "./src/components/buttons/button-table-remove.jsx");

var _buttonTableRemove2 = _interopRequireDefault(_buttonTableRemove);

var _buttonTableRow = __webpack_require__(/*! ./button-table-row.jsx */ "./src/components/buttons/button-table-row.jsx");

var _buttonTableRow2 = _interopRequireDefault(_buttonTableRow);

var _buttonTable = __webpack_require__(/*! ./button-table.jsx */ "./src/components/buttons/button-table.jsx");

var _buttonTable2 = _interopRequireDefault(_buttonTable);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _buttonTwitter = __webpack_require__(/*! ./button-twitter.jsx */ "./src/components/buttons/button-twitter.jsx");

var _buttonTwitter2 = _interopRequireDefault(_buttonTwitter);

var _buttonUl = __webpack_require__(/*! ./button-ul.jsx */ "./src/components/buttons/button-ul.jsx");

var _buttonUl2 = _interopRequireDefault(_buttonUl);

var _buttonUnderline = __webpack_require__(/*! ./button-underline.jsx */ "./src/components/buttons/button-underline.jsx");

var _buttonUnderline2 = _interopRequireDefault(_buttonUnderline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ButtonBold$key$Butto = {}, _defineProperty(_ButtonBold$key$Butto, _buttonBold2.default.key, _buttonBold2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCameraImage2.default.key, _buttonCameraImage2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCamera2.default.key, _buttonCamera2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCode2.default.key, _buttonCode2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCommandListItem2.default.key, _buttonCommandListItem2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCommandsList2.default.key, _buttonCommandsList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonDropdown2.default.key, _buttonDropdown2.default), _defineProperty(_ButtonBold$key$Butto, _buttonEmbedEdit2.default.key, _buttonEmbedEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonEmbed2.default.key, _buttonEmbed2.default), _defineProperty(_ButtonBold$key$Butto, _buttonH2.default.key, _buttonH2.default), _defineProperty(_ButtonBold$key$Butto, _buttonH4.default.key, _buttonH4.default), _defineProperty(_ButtonBold$key$Butto, _buttonHline2.default.key, _buttonHline2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignCenter2.default.key, _buttonImageAlignCenter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignLeft2.default.key, _buttonImageAlignLeft2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignRight2.default.key, _buttonImageAlignRight2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImage2.default.key, _buttonImage2.default), _defineProperty(_ButtonBold$key$Butto, _buttonIndentBlock2.default.key, _buttonIndentBlock2.default), _defineProperty(_ButtonBold$key$Butto, _buttonItalic2.default.key, _buttonItalic2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkAutocompleteList2.default.key, _buttonLinkAutocompleteList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkEdit2.default.key, _buttonLinkEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkTargetEdit2.default.key, _buttonLinkTargetEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLink2.default.key, _buttonLink2.default), _defineProperty(_ButtonBold$key$Butto, _buttonOl2.default.key, _buttonOl2.default), _defineProperty(_ButtonBold$key$Butto, _buttonOutdentBlock2.default.key, _buttonOutdentBlock2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphAlignLeft2.default.key, _buttonParagraphAlignLeft2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphAlignRight2.default.key, _buttonParagraphAlignRight2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphCenter2.default.key, _buttonParagraphCenter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphJustify2.default.key, _buttonParagraphJustify2.default), _defineProperty(_ButtonBold$key$Butto, _buttonQuote2.default.key, _buttonQuote2.default), _defineProperty(_ButtonBold$key$Butto, _buttonRemoveFormat2.default.key, _buttonRemoveFormat2.default), _defineProperty(_ButtonBold$key$Butto, _buttonSeparator2.default.key, _buttonSeparator2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStrike2.default.key, _buttonStrike2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListHeader2.default.key, _buttonStylesListHeader2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListItemRemove2.default.key, _buttonStylesListItemRemove2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListItem2.default.key, _buttonStylesListItem2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesList2.default.key, _buttonStylesList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStyles2.default.key, _buttonStyles2.default), _defineProperty(_ButtonBold$key$Butto, _buttonSubscript2.default.key, _buttonSubscript2.default), _defineProperty(_ButtonBold$key$Butto, _buttonSuperscript2.default.key, _buttonSuperscript2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableCell2.default.key, _buttonTableCell2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableColumn2.default.key, _buttonTableColumn2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableEdit2.default.key, _buttonTableEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableHeading2.default.key, _buttonTableHeading2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableRemove2.default.key, _buttonTableRemove2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableRow2.default.key, _buttonTableRow2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTable2.default.key, _buttonTable2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTargetList2.default.key, _buttonTargetList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTwitter2.default.key, _buttonTwitter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonUl2.default.key, _buttonUl2.default), _defineProperty(_ButtonBold$key$Butto, _buttonUnderline2.default.key, _buttonUnderline2.default), _ButtonBold$key$Butto);

/***/ }),

/***/ "./src/components/main.jsx":
/*!*********************************!*\
  !*** ./src/components/main.jsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetExclusive = __webpack_require__(/*! ./base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ./base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The main editor UI class manages a hierarchy of widgets (toolbars and buttons).
 *
 * @class UI
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var UI = function (_React$Component) {
    _inherits(UI, _React$Component);

    function UI(props) {
        _classCallCheck(this, UI);

        var _this = _possibleConstructorReturn(this, (UI.__proto__ || Object.getPrototypeOf(UI)).call(this, props));

        _this.state = {
            hidden: false
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof UI
     * @method componentDidMount
     */


    _createClass(UI, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var editor = this.props.editor.get('nativeEditor');

            editor.on('editorInteraction', this._onEditorInteraction, this);
            editor.on('actionPerformed', this._onActionPerformed, this);
            editor.on('key', this._onEditorKey, this);

            // Set up events for hiding the UI when user stops interacting with the editor.
            // This may happen when he just clicks outside of the editor. However,
            // this does not include a situation when he clicks on some button, part of
            // editor's UI.

            // It is not easy to debounce _setUIHidden on mousedown, because if we
            // debounce it, when the handler is being invoked, the target might be no more part
            // of the editor's UI - onActionPerformed causes re-render.
            this._mousedownListener = function (event) {
                this._setUIHidden(event.target);
            }.bind(this);

            this._keyDownListener = CKEDITOR.tools.debounce(function (event) {
                this._setUIHidden(document.activeElement);
            }, this.props.eventsDelay, this);

            document.addEventListener('mousedown', this._mousedownListener);
            document.addEventListener('keydown', this._keyDownListener);
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * Fires `ariaUpdate` event passing ARIA related messages.
         * Fires `editorUpdate` event passing the previous and current properties and state.
         *
         * @instance
         * @memberof UI
         * @method componentDidUpdate
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            var domNode = _reactDom2.default.findDOMNode(this);

            var editor = this.props.editor.get('nativeEditor');

            if (domNode) {
                editor.fire('ariaUpdate', {
                    message: this._getAvailableToolbarsMessage(domNode)
                });
            }

            editor.fire('editorUpdate', {
                prevProps: prevProps,
                prevState: prevState,
                props: this.props,
                state: this.state
            });
        }
    }, {
        key: '_getAriaUpdateTemplate',
        value: function _getAriaUpdateTemplate(ariaUpdate) {
            if (!this._ariaUpdateTemplates) {
                this._ariaUpdateTemplates = {};
            }

            if (!this._ariaUpdateTemplates[ariaUpdate]) {
                this._ariaUpdateTemplates[ariaUpdate] = new CKEDITOR.template(this._getAriaUpdates()[ariaUpdate]);
            }

            return this._ariaUpdateTemplates[ariaUpdate];
        }

        /**
         * Returns the templates for ARIA messages.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _getAriaUpdates
         * @return {Object} ARIA relates messages. Default:
         * {
         *      noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
         *      oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
         *      manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
         *  }
         */

    }, {
        key: '_getAriaUpdates',
        value: function _getAriaUpdates() {
            return this.props.ariaUpdates || {
                noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
                oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
                manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
            };
        }

        /**
         * Returns an ARIA message which represents the number of currently available toolbars.
         *
         * @instance
         * @memberof UI
         * @method _getAvailableToolbarsMessage
         * @protected
         * @param {CKEDITOR.dom.element} domNode The DOM node from which the available toolbars will be retrieved.
         * @return {String} The ARIA message for the number of available toolbars
         */

    }, {
        key: '_getAvailableToolbarsMessage',
        value: function _getAvailableToolbarsMessage(domNode) {
            var toolbarsNodeList = domNode.querySelectorAll('[role="toolbar"]');

            if (!toolbarsNodeList.length) {
                return this._getAriaUpdates().noToolbar;
            } else {
                var toolbarNames = Array.prototype.slice.call(toolbarsNodeList).map(function (toolbar) {
                    return toolbar.getAttribute('aria-label');
                });

                var ariaUpdate = toolbarNames.length === 1 ? 'oneToolbar' : 'manyToolbars';

                return this._getAriaUpdateTemplate(ariaUpdate).output({
                    toolbars: toolbarNames.join(',').replace(/,([^,]*)$/, ' and ' + '$1')
                });
            }
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof UI
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._mousedownListener) {
                document.removeEventListener('mousedown', this._mousedownListener);
            }

            if (this._keyDownListener) {
                this._keyDownListener.detach();
                document.removeEventListener('keydown', this._keyDownListener);
            }
        }

        /**
         * Lifecycle. Renders the UI of the editor. This may include several toolbars and buttons.
         * The editor's UI also takes care of rendering the items in exclusive mode.
         *
         * @instance
         * @memberof UI
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            if (this.state.hidden) {
                return null;
            }

            var toolbars = Object.keys(this.props.toolbars).map(function (toolbar) {
                return AlloyEditor.Toolbars[toolbar] || window[toolbar];
            });

            toolbars = this.filterExclusive(toolbars).map(function (toolbar) {
                var props = this.mergeExclusiveProps({
                    config: this.props.toolbars[toolbar.key],
                    editor: this.props.editor,
                    editorEvent: this.state.editorEvent,
                    key: toolbar.key,
                    onDismiss: this._onDismissToolbarFocus,
                    selectionData: this.state.selectionData
                }, toolbar.key);

                return _react2.default.createElement(toolbar, props);
            }.bind(this));

            return _react2.default.createElement(
                'div',
                { className: 'ae-toolbars', onKeyDown: this.handleKey.bind(this) },
                toolbars
            );
        }

        /**
         * Listener to the editor's `actionPerformed` event. Sets state and redraws the UI of the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onActionPerformed
         * @param {SynteticEvent} event The provided event
         */

    }, {
        key: '_onActionPerformed',
        value: function _onActionPerformed(event) {
            var editor = this.props.editor.get('nativeEditor');

            editor.focus();

            this.setState({
                itemExclusive: null,
                selectionData: editor.getSelectionData()
            });
        }

        /**
         * Executed when a dismiss key is pressed over a toolbar to return the focus to the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onDismissToolbarFocus
         */

    }, {
        key: '_onDismissToolbarFocus',
        value: function _onDismissToolbarFocus() {
            var editor = this.props.editor.get('nativeEditor');

            editor.focus();
        }

        /**
         * Listener to the editor's `userInteraction` event. Retrieves the data about the user selection and
         * provides it via component's state property.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onEditorInteraction
         * @param {SynteticEvent} event The provided event
         */

    }, {
        key: '_onEditorInteraction',
        value: function _onEditorInteraction(event) {
            this.setState({
                editorEvent: event,
                hidden: false,
                itemExclusive: null,
                selectionData: event.data.selectionData
            });
        }

        /**
         * Focuses on the active toolbar when the combination ALT+F10 is pressed inside the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onEditorKey
         */

    }, {
        key: '_onEditorKey',
        value: function _onEditorKey(event) {
            var nativeEvent = event.data.domEvent.$;

            if (nativeEvent.altKey && nativeEvent.keyCode === 121) {
                this.focus();
            }
        }

        /**
         * Checks if the target with which the user interacted is part of editor's UI or it is
         * the editable area. If none of these, sets the state of editor's UI to be hidden.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _setUIHidden
         * @param {DOMElement} target The DOM element with which user interacted lastly.
         */

    }, {
        key: '_setUIHidden',
        value: function _setUIHidden(target) {
            var domNode = _reactDom2.default.findDOMNode(this);

            if (domNode) {
                var editable = this.props.editor.get('nativeEditor').editable();
                var parentNode = target.parentNode;
                var targetNode = new CKEDITOR.dom.node(target);

                if (!editable) {
                    this.setState({
                        hidden: true
                    });
                } else {
                    var res = editable.$ === target || editable.contains(targetNode) || new CKEDITOR.dom.element(domNode).contains(targetNode);

                    if (parentNode) {
                        res = res || parentNode.id === "ckimgrsz";
                    }

                    if (!res) {
                        this.setState({
                            hidden: true
                        });
                    }
                }
            }
        }
    }]);

    return UI;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof UI
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


UI.defaultProps = {
    circular: true,
    descendants: '[class^=ae-toolbar-]',
    eventsDelay: 0,
    keys: {
        next: 9
    }
};

/**
 * Fired when component updates and when it is rendered in the DOM.
 * The payload consists from a `message` property containing the ARIA message.
 *
 * @event ariaUpdate
 */

/**
 * Fired when component updates. The payload consists from an object with the following
 * properties:
 * - prevProps - The previous properties of the component
 * - prevState - The previous state of the component
 * - props - The current properties of the component
 * - state - The current state of the component
 *
 * @event ariaUpdate
 */

UI.propTypes = {
    /**
     * Localized messages for live aria updates. Should include the following messages:
     * - noToolbar: Notification for no available toolbar in the editor.
     * - oneToolbar: Notification for just one available toolbar in the editor.
     * - manyToolbars: Notification for more than one available toolbar in the editor.
     *
     * @instance
     * @memberof UI
     * @property {Object} ariaUpdates
     */
    ariaUpdates: _propTypes2.default.object,

    /**
     * The editor instance where the component is being used.
     *
     * @instance
     * @memberof UI
     * @property {Object} editor
     */
    editor: _propTypes2.default.object.isRequired,

    /**
     * The delay (ms), after which key or mouse events will be processed.
     *
     * @instance
     * @memberof UI
     * @property {Number} eventsDelay
     */
    eventsDelay: _propTypes2.default.number,

    /**
     * The toolbars configuration for this editor instance
     *
     * @instance
     * @memberof UI
     * @property {Object} toolbars
     */
    toolbars: _propTypes2.default.object.isRequired
};

exports.default = (0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)(UI));

/***/ }),

/***/ "./src/components/toolbars/index.js":
/*!******************************************!*\
  !*** ./src/components/toolbars/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ToolbarAdd$key$Toolb;

var _toolbarAdd = __webpack_require__(/*! ./toolbar-add.jsx */ "./src/components/toolbars/toolbar-add.jsx");

var _toolbarAdd2 = _interopRequireDefault(_toolbarAdd);

var _toolbarStyles = __webpack_require__(/*! ./toolbar-styles.jsx */ "./src/components/toolbars/toolbar-styles.jsx");

var _toolbarStyles2 = _interopRequireDefault(_toolbarStyles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ToolbarAdd$key$Toolb = {}, _defineProperty(_ToolbarAdd$key$Toolb, _toolbarAdd2.default.key, _toolbarAdd2.default), _defineProperty(_ToolbarAdd$key$Toolb, _toolbarStyles2.default.key, _toolbarStyles2.default), _ToolbarAdd$key$Toolb);

/***/ }),

/***/ "./src/components/toolbars/toolbar-add.jsx":
/*!*************************************************!*\
  !*** ./src/components/toolbars/toolbar-add.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons.js */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box.js */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position.js */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var POSITION_LEFT = 1;
var POSITION_RIGHT = 2;

/**
 * The ToolbarAdd class provides functionality for adding content to the editor.
 *
 * @class ToolbarAdd
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */

var ToolbarAdd = function (_React$Component) {
    _inherits(ToolbarAdd, _React$Component);

    function ToolbarAdd(props) {
        _classCallCheck(this, ToolbarAdd);

        var _this = _possibleConstructorReturn(this, (ToolbarAdd.__proto__ || Object.getPrototypeOf(ToolbarAdd)).call(this, props));

        _this.state = {};
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof ToolbarAdd
     * @method componentDidMount
     */


    _createClass(ToolbarAdd, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._updatePosition();
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method componentDidUpdate
         * @param {Object} prevProps The previous state of the component's properties.
         * @param {Object} prevState Component's previous state.
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this._updatePosition();

            // In case of exclusive rendering, focus the first descendant (button)
            // so the user will be able to start interacting with the buttons immediately.
            if (this.props.renderExclusive) {
                this.focus();
            }
        }

        /**
         * Lifecycle. Renders the buttons for adding content or hides the toolbar
         * if user interacted with a non-editable element.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method render
         * @return {Object|null} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            // Some operations such as `requestExclusive` may force editor to blur which will
            // invalidate the `props.editorEvent` stored value, without causing a `props` change.
            // For example, if the editor is empty, `ae_placeholder` plugin will remove
            // the target from the DOM and will prevent `add` toolbar from rendering.
            //
            // It should be safe to assume that if you have been able to render the toolbar
            // and request the exclusive mode, then rendering might be kept until the exclusive mode is left.
            if (!this.state.itemExclusive && this.props.editorEvent && this.props.editorEvent.data.nativeEvent.target && !this.props.editorEvent.data.nativeEvent.target.isContentEditable) {
                return null;
            }

            var buttons = this._getButtons();
            var className = this._getToolbarClassName();

            return _react2.default.createElement(
                'div',
                { 'aria-label': AlloyEditor.Strings.add, className: className, 'data-tabindex': this.props.config.tabIndex || 0, onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), role: 'toolbar', tabIndex: '-1' },
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container' },
                    buttons
                )
            );
        }

        /**
         * Returns a list of buttons that will eventually render to HTML.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _getButtons
         * @protected
         * @return {Object} The buttons which have to be rendered.
         */

    }, {
        key: '_getButtons',
        value: function _getButtons() {
            var buttons;

            if (this.props.renderExclusive) {
                buttons = this.getToolbarButtons(this.props.config.buttons);
            } else {
                if (this.props.selectionData && this.props.selectionData.region) {
                    buttons = _react2.default.createElement(
                        'button',
                        { 'aria-label': AlloyEditor.Strings.add, className: 'ae-button ae-button-add', onClick: this.props.requestExclusive.bind(this, ToolbarAdd.key), title: AlloyEditor.Strings.add },
                        _react2.default.createElement('span', { className: 'ae-icon-add' })
                    );
                }
            }

            return buttons;
        }

        /**
         * Returns the class name of the toolbar in case of both exclusive and normal mode.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _getToolbarClassName
         * @protected
         * @return {String} The class name which have to be applied to the DOM element.
         */

    }, {
        key: '_getToolbarClassName',
        value: function _getToolbarClassName() {
            var cssClass = 'ae-toolbar-add';

            if (this.props.renderExclusive) {
                cssClass = 'ae-toolbar ' + this.getArrowBoxClasses();
            }

            return cssClass;
        }

        /**
         * Calculates and sets the position of the toolbar in exclusive or normal mode.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _updatePosition
         * @protected
         */

    }, {
        key: '_updatePosition',
        value: function _updatePosition() {
            var region;

            // If component is not mounted, there is nothing to do
            if (!_reactDom2.default.findDOMNode(this)) {
                return;
            }

            if (this.props.renderExclusive) {
                this.updatePosition();
                this.show();
            } else {
                if (this.props.selectionData) {
                    region = this.props.selectionData.region;
                }

                if (region) {
                    var domNode = _reactDom2.default.findDOMNode(this);

                    var domElement = new CKEDITOR.dom.element(domNode);

                    var startRect = region.startRect || region;

                    var nativeEditor = this.props.editor.get('nativeEditor');

                    var clientRect = nativeEditor.editable().getClientRect();

                    var offsetLeft;

                    var position = this.props.config.position || this.props.position;

                    if (position === POSITION_LEFT) {
                        offsetLeft = clientRect.left - domNode.offsetWidth - this.props.gutterExclusive.left + 'px';
                    } else {
                        offsetLeft = clientRect.right + this.props.gutterExclusive.left + 'px';
                    }

                    domNode.style.left = offsetLeft;

                    domNode.style.top = Math.floor((region.bottom + region.top) / 2) + 'px';

                    var uiNode = this.props.editor.get('uiNode');

                    var scrollTop = uiNode ? uiNode.scrollTop : 0;

                    if (nativeEditor.element.getStyle('overflow') !== 'auto') {
                        domNode.style.top = Math.floor(region.top - domNode.offsetHeight / 2 + startRect.height / 2 + scrollTop) + 'px';
                    } else {
                        domNode.style.top = Math.floor(nativeEditor.element.$.offsetTop + startRect.height / 2 - domNode.offsetHeight / 2) + 'px';
                    }

                    domNode.style.opacity = 1;

                    domElement.removeClass('ae-arrow-box');

                    this.cancelAnimation();
                }
            }
        }
    }]);

    return ToolbarAdd;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default add
 * @memberof ToolbarAdd
 * @property {String} key
 * @static
 */


ToolbarAdd.key = 'add';

/**
 * Defines the constant for positioning the Toolbar on left of the editable area.
 *
 * @default 1
 * @memberof ToolbarAdd
 * @property {String} left
 * @static
 */
ToolbarAdd.left = POSITION_LEFT;

/**
 * Defines the constant for positioning the Toolbar on right of the editable area.
 *
 * @default 2
 * @memberof ToolbarAdd
 * @property {String} right
 * @static
 */
ToolbarAdd.right = POSITION_RIGHT;

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarAdd
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ToolbarAdd.defaultProps = {
    circular: true,
    descendants: '.ae-button',
    gutterExclusive: {
        left: 10,
        top: 0
    },
    keys: {
        dismiss: [27],
        next: [39, 40],
        prev: [37, 38]
    },
    position: POSITION_LEFT
};

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarAdd))))));

/***/ }),

/***/ "./src/components/toolbars/toolbar-styles.jsx":
/*!****************************************************!*\
  !*** ./src/components/toolbars/toolbar-styles.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons.js */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box.js */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position.js */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ToolbarStyles class hosts the buttons for styling a text selection.
 *
 * @class ToolbarStyles
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */
var ToolbarStyles = function (_React$Component) {
    _inherits(ToolbarStyles, _React$Component);

    function ToolbarStyles(props) {
        _classCallCheck(this, ToolbarStyles);

        var _this = _possibleConstructorReturn(this, (ToolbarStyles.__proto__ || Object.getPrototypeOf(ToolbarStyles)).call(this, props));

        _this.state = {};
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof ToolbarStyles
     * @method componentDidMount
     */


    _createClass(ToolbarStyles, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._updatePosition();
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method componentDidUpdate
         * @param {Object} prevProps The previous state of the component's properties.
         * @param {Object} prevState Component's previous state.
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this._updatePosition();
        }

        /**
         * Lifecycle. Renders the buttons for adding content or hides the toolbar
         * if user interacted with a non-editable element.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method render
         * @return {Object|null} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var currentSelection = this._getCurrentSelection();

            if (currentSelection) {
                var getArrowBoxClassesFn = this._getSelectionFunction(currentSelection.getArrowBoxClasses);
                var arrowBoxClasses;

                if (getArrowBoxClassesFn) {
                    arrowBoxClasses = getArrowBoxClassesFn();
                } else {
                    arrowBoxClasses = this.getArrowBoxClasses();
                }

                var cssClasses = 'ae-toolbar-styles ' + arrowBoxClasses;

                var buttons = currentSelection.buttons;

                if ((typeof buttons === 'undefined' ? 'undefined' : _typeof(buttons)) === 'object' && !Array.isArray(buttons)) {
                    buttons = buttons[this.props.editor.get('mode')] || buttons['simple'];
                }

                var buttonsGroup = this.getToolbarButtonGroups(buttons, {
                    manualSelection: this.props.editorEvent ? this.props.editorEvent.data.manualSelection : null,
                    selectionType: currentSelection.name
                });

                var hasGroups = buttonsGroup.filter(function (button) {
                    return Array.isArray(button);
                }).length > 0;

                var className = 'ae-container';

                if (hasGroups) {
                    className += ' ae-container-column';
                }

                return _react2.default.createElement(
                    'div',
                    { 'aria-label': AlloyEditor.Strings.styles, className: cssClasses, 'data-tabindex': this.props.config.tabIndex || 0, onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), role: 'toolbar', tabIndex: '-1' },
                    _react2.default.createElement(
                        'div',
                        { className: className },
                        buttonsGroup.map(function (value, index) {
                            if (Array.isArray(value)) {
                                return _react2.default.createElement(
                                    'div',
                                    { className: 'ae-row', key: index.toString() },
                                    value.map(function (button) {
                                        return button;
                                    })
                                );
                            } else {
                                return value;
                            }
                        })
                    )
                );
            }

            return null;
        }

        /**
         * Retrieve a function from String. It converts a fully qualified string into the mapped function.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _getSelectionFunction
         * @param {Function|String} selectionFn A function, or a fully qualified string pointing to the desired one (e.g. 'AlloyEditor.SelectionTest.image').
         * @protected
         * @return {Function} The mapped function.
         */

    }, {
        key: '_getSelectionFunction',
        value: function _getSelectionFunction(selectionFn) {
            var selectionFunction;

            if (_lang2.default.isFunction(selectionFn)) {
                selectionFunction = selectionFn;
            } else if (_lang2.default.isString(selectionFn)) {
                var parts = selectionFn.split('.');
                var currentMember = window;
                var property = parts.shift();

                while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
                    currentMember = currentMember[property];
                    property = parts.shift();
                }

                if (_lang2.default.isFunction(currentMember)) {
                    selectionFunction = currentMember;
                }
            }

            return selectionFunction;
        }

        /**
         * Analyzes the current editor selection and returns the selection configuration that matches.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _getCurrentSelection
         * @protected
         * @return {Object} The matched selection configuration.
         */

    }, {
        key: '_getCurrentSelection',
        value: function _getCurrentSelection() {
            var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;
            var selection;

            if (eventPayload) {
                this.props.config.selections.some(function (item) {
                    var testFn = this._getSelectionFunction(item.test);
                    var result;

                    if (testFn) {
                        result = eventPayload.manualSelection === item.name || testFn({
                            data: eventPayload,
                            editor: this.props.editor
                        });
                    }

                    if (result) {
                        selection = item;
                    }

                    return result;
                }, this);
            }

            return selection;
        }

        /**
         * Calculates and sets the position of the toolbar.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _updatePosition
         * @protected
         */

    }, {
        key: '_updatePosition',
        value: function _updatePosition() {
            // If component is not mounted, there is nothing to do
            if (!_reactDom2.default.findDOMNode(this)) {
                return;
            }

            var currentSelection = this._getCurrentSelection();
            var result;

            // If current selection has a function called `setPosition`, call it
            // and check the returned value. If false, fallback to the default positioning logic.
            if (currentSelection) {
                var setPositionFn = this._getSelectionFunction(currentSelection.setPosition);

                if (setPositionFn) {
                    result = setPositionFn.call(this, {
                        editor: this.props.editor,
                        editorEvent: this.props.editorEvent,
                        selectionData: this.props.selectionData
                    });
                }
            }

            if (!result) {
                this.updatePosition();
                this.show();
            }
        }
    }]);

    return ToolbarStyles;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarStyles
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


ToolbarStyles.defaultProps = {
    circular: true,
    descendants: '.ae-input, .ae-button:not([disabled]), .ae-toolbar-element',
    keys: {
        dismiss: [27],
        next: [39, 40],
        prev: [37, 38]
    }
};

/**
* The name which will be used as an alias of the button in the configuration.
*
* @default styles
* @memberof ToolbarStyles
* @property {String} key
* @static
*/
ToolbarStyles.key = 'styles';

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarStyles))))));

/***/ }),

/***/ "./src/components/uibridge/button.jsx":
/*!********************************************!*\
  !*** ./src/components/uibridge/button.jsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _createReactClass = __webpack_require__(/*! create-react-class */ "./node_modules/create-react-class/index.js");

var _createReactClass2 = _interopRequireDefault(_createReactClass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_buttonbridge')) {
        return;
    }

    /* istanbul ignore next */
    function noop() {}

    // API not yet implemented inside the button bridge. By mocking the unsupported methods, we
    // prevent plugins from crashing if they make use of them.
    //
    // Some methods like `getState` and `setState` clash with React's own state methods. For them,
    // unsupported means that we don't account for the different meaning in the passed or returned
    // arguments.
    var UNSUPPORTED_BUTTON_API = {
        //getState: function() {},
        //setState: function(state) {},
        toFeature: noop
    };

    var BUTTON_DEFS = {};

    /**
     * Generates a ButtonBridge React class for a given button definition if it has not been
     * already created based on the button name and definition.
     *
     * @private
     * @method generateButtonBridge
     * @param {String} buttonName The button's name
     * @param {Object} buttonDefinition The button's definition
     * @return {Object} The generated or already existing React Button Class
     */

    function generateButtonBridge(buttonName, buttonDefinition, editor) {
        var ButtonBridge = AlloyEditor.Buttons[buttonName];

        BUTTON_DEFS[editor.name] = BUTTON_DEFS[editor.name] || {};
        BUTTON_DEFS[editor.name][buttonName] = BUTTON_DEFS[editor.name][buttonName] || buttonDefinition;

        if (!ButtonBridge) {
            ButtonBridge = (0, _createReactClass2.default)(CKEDITOR.tools.merge(UNSUPPORTED_BUTTON_API, {
                displayName: buttonName,

                statics: {
                    key: buttonName
                },

                render: function render() {
                    var editor = this.props.editor.get('nativeEditor');

                    var buttonClassName = 'ae-button ae-button-bridge';

                    var buttonDisplayName = BUTTON_DEFS[editor.name][buttonName].name || BUTTON_DEFS[editor.name][buttonName].command || buttonName;

                    var buttonLabel = BUTTON_DEFS[editor.name][buttonName].label;

                    var buttonType = 'button-' + buttonDisplayName;

                    var iconClassName = 'ae-icon-' + buttonDisplayName;

                    var iconStyle = {};

                    var cssStyle = CKEDITOR.skin.getIconStyle(buttonDisplayName);

                    if (cssStyle) {
                        var cssStyleParts = cssStyle.split(';');

                        iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
                        iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
                        iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
                    }

                    return _react2.default.createElement(
                        'button',
                        { 'aria-label': buttonLabel, className: buttonClassName, 'data-type': buttonType, onClick: this._handleClick, tabIndex: this.props.tabIndex, title: buttonLabel },
                        _react2.default.createElement('span', { className: iconClassName, style: iconStyle })
                    );
                },

                _handleClick: function _handleClick(event) {
                    var editor = this.props.editor.get('nativeEditor');

                    var buttonCommand = BUTTON_DEFS[editor.name][buttonName].command;

                    var buttonOnClick = BUTTON_DEFS[editor.name][buttonName].onClick;

                    if (buttonOnClick) {
                        buttonOnClick.call(this);
                    } else {
                        editor.execCommand(buttonCommand);
                    }

                    editor.fire('actionPerformed', this);
                }
            }));

            AlloyEditor.Buttons[buttonName] = ButtonBridge;
        }

        return ButtonBridge;
    }

    /* istanbul ignore else */
    if (!CKEDITOR.plugins.get('button')) {
        CKEDITOR.UI_BUTTON = 'button';

        CKEDITOR.plugins.add('button', {});
    }

    /**
     * CKEditor plugin that bridges the support offered by CKEditor Button plugin. It takes over the
     * responsibility of registering and creating buttons via:
     * - editor.ui.addButton(name, definition)
     * - editor.ui.add(name, CKEDITOR.UI_BUTTON, definition)
     *
     * @class CKEDITOR.plugins.ae_buttonbridge
     * @requires CKEDITOR.plugins.ae_uibridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_buttonbridge', {
        requires: ['ae_uibridge'],

        /**
         * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
         * the one in the native plugin in case it's present.
         *
         * @method init
         * @param {Object} editor The CKEditor instance being initialized
         */
        beforeInit: function beforeInit(editor) {
            editor.ui.addButton = function (buttonName, buttonDefinition) {
                this.add(buttonName, CKEDITOR.UI_BUTTON, buttonDefinition);
            };

            editor.ui.addHandler(CKEDITOR.UI_BUTTON, {
                add: generateButtonBridge,
                create: function create(buttonDefinition) {
                    var buttonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
                    var ButtonBridge = generateButtonBridge(buttonName, buttonDefinition);

                    return new ButtonBridge();
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/components/uibridge/index.js":
/*!******************************************!*\
  !*** ./src/components/uibridge/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uibridge = exports.richcombo = exports.panelMenuButton = exports.menu = exports.menuButton = exports.button = undefined;

var _button = __webpack_require__(/*! ./button.jsx */ "./src/components/uibridge/button.jsx");

var _button2 = _interopRequireDefault(_button);

var _menuButton = __webpack_require__(/*! ./menu-button.jsx */ "./src/components/uibridge/menu-button.jsx");

var _menuButton2 = _interopRequireDefault(_menuButton);

var _menu = __webpack_require__(/*! ./menu.jsx */ "./src/components/uibridge/menu.jsx");

var _menu2 = _interopRequireDefault(_menu);

var _panelMenuButton = __webpack_require__(/*! ./panel-menu-button.jsx */ "./src/components/uibridge/panel-menu-button.jsx");

var _panelMenuButton2 = _interopRequireDefault(_panelMenuButton);

var _richcombo = __webpack_require__(/*! ./richcombo.jsx */ "./src/components/uibridge/richcombo.jsx");

var _richcombo2 = _interopRequireDefault(_richcombo);

var _uibridge = __webpack_require__(/*! ./uibridge */ "./src/components/uibridge/uibridge.js");

var _uibridge2 = _interopRequireDefault(_uibridge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.button = _button2.default;
exports.menuButton = _menuButton2.default;
exports.menu = _menu2.default;
exports.panelMenuButton = _panelMenuButton2.default;
exports.richcombo = _richcombo2.default;
exports.uibridge = _uibridge2.default;

/***/ }),

/***/ "./src/components/uibridge/menu-button.jsx":
/*!*************************************************!*\
  !*** ./src/components/uibridge/menu-button.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _createReactClass = __webpack_require__(/*! create-react-class */ "./node_modules/create-react-class/index.js");

var _createReactClass2 = _interopRequireDefault(_createReactClass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_menubuttonbridge')) {
        return;
    }

    /* istanbul ignore next */
    function noop() {}

    // API not yet implemented inside the menubutton bridge. By mocking the unsupported methods, we
    // prevent plugins from crashing if they make use of them.
    //
    // Some methods like `getState` and `setState` clash with React's own state methods. For them,
    // unsupported means that we don't account for the different meaning in the passed or returned
    // arguments.
    var UNSUPPORTED_MENUBUTTON_API = {
        //getState: function() {},
        //setState: function(state) {},
        toFeature: noop
    };

    var MENUBUTTON_DEFS = {};

    /**
     * Generates a MenuButtonBridge React class for a given menuButton definition if it has not been
     * already created based on the button name and definition.
     *
     * @private
     * @method generateMenuButtonBridge
     * @param {String} menuButtonName The menuButton's name
     * @param {Object} menuButtonDefinition The menuButton's definition
     * @return {Object} The generated or already existing React MenuButton Class
     */
    function generateMenuButtonBridge(menuButtonName, menuButtonDefinition, editor) {
        var MenuButtonBridge = AlloyEditor.Buttons[menuButtonName];

        MENUBUTTON_DEFS[editor.name] = MENUBUTTON_DEFS[editor.name] || {};
        MENUBUTTON_DEFS[editor.name][menuButtonName] = MENUBUTTON_DEFS[editor.name][menuButtonName] || menuButtonDefinition;

        if (!MenuButtonBridge) {
            MenuButtonBridge = (0, _createReactClass2.default)(CKEDITOR.tools.merge(UNSUPPORTED_MENUBUTTON_API, {
                displayName: menuButtonName,

                statics: {
                    key: menuButtonName
                },

                render: function render() {
                    var editor = this.props.editor.get('nativeEditor');

                    var panelMenuButtonDisplayName = MENUBUTTON_DEFS[editor.name][menuButtonName].name || MENUBUTTON_DEFS[editor.name][menuButtonName].command || menuButtonName;

                    var buttonClassName = 'ae-button ae-button-bridge';

                    var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

                    var iconStyle = {};

                    var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

                    if (cssStyle) {
                        var cssStyleParts = cssStyle.split(';');

                        iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
                        iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
                        iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
                    }

                    return _react2.default.createElement(
                        'div',
                        { className: 'ae-container ae-has-dropdown' },
                        _react2.default.createElement(
                            'button',
                            { 'aria-expanded': this.props.expanded, 'aria-label': MENUBUTTON_DEFS[editor.name][menuButtonName].label, className: buttonClassName, onClick: this.props.toggleDropdown, role: 'combobox', tabIndex: this.props.tabIndex, title: MENUBUTTON_DEFS[editor.name][menuButtonName].label },
                            _react2.default.createElement('span', { className: iconClassName, style: iconStyle })
                        ),
                        this.props.expanded && _react2.default.createElement(
                            _buttonDropdown2.default,
                            { onDismiss: this.props.toggleDropdown },
                            this._getMenuItems()
                        )
                    );
                },

                _getMenuItems: function _getMenuItems() {
                    var editor = this.props.editor.get('nativeEditor');
                    var items = menuButtonDefinition.onMenu();
                    var menuItems = Object.keys(items).map(function (key) {
                        var menuItem = editor.getMenuItem(key);

                        if (!menuItem) {
                            return null;
                        }

                        var menuItemDefinition = menuItem.definition || menuItem;
                        var menuItemState = items[key];

                        var className = 'ae-toolbar-element ' + (menuItemState === CKEDITOR.TRISTATE_ON ? 'active' : '');
                        var disabled = menuItemState === CKEDITOR.TRISTATE_DISABLED;
                        var onClick = function onClick() {
                            if (menuItemDefinition.command) {
                                editor.execCommand(menuItemDefinition.command);
                            } else if (menuItemDefinition.onClick) {
                                menuItemDefinition.onClick.apply(menuItemDefinition);
                            }
                        };

                        return _react2.default.createElement(
                            'li',
                            { key: menuItem.name, role: 'option' },
                            _react2.default.createElement(
                                'button',
                                { className: className, disabled: disabled, onClick: onClick },
                                menuItemDefinition.label
                            )
                        );
                    }.bind(this));

                    return menuItems;
                }
            }));

            AlloyEditor.Buttons[menuButtonName] = MenuButtonBridge;
        }

        return MenuButtonBridge;
    }

    /* istanbul ignore else */
    if (!CKEDITOR.plugins.get('menubutton')) {
        CKEDITOR.UI_MENU_BUTTON = 'menubutton';

        CKEDITOR.plugins.add('menubutton', {});
    }

    /**
     * CKEditor plugin that bridges the support offered by CKEditor MenuButton plugin. It takes over the
     * responsibility of registering and creating menuButtons via:
     * - editor.ui.addMenuButton(name, definition)
     * - editor.ui.add(name, CKEDITOR.UI_MENUBUTTON, definition)
     *
     * @class CKEDITOR.plugins.ae_menubuttonbridge
     * @requires CKEDITOR.plugins.ae_uibridge
     * @requires CKEDITOR.plugins.ae_menubridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_menubuttonbridge', {
        requires: ['ae_uibridge', 'ae_menubridge'],

        /**
         * Set the add handler for UI_MENUBUTTON to our own. We do this in the init phase to override
         * the one in the native plugin in case it's present.
         *
         * @method init
         * @param {Object} editor The CKEditor instance being initialized
         */
        beforeInit: function beforeInit(editor) {
            editor.ui.addMenuButton = function (menuButtonName, menuButtonDefinition) {
                this.add(menuButtonName, CKEDITOR.UI_MENUBUTTON, menuButtonDefinition);
            };

            editor.ui.addHandler(CKEDITOR.UI_MENUBUTTON, {
                add: generateMenuButtonBridge,
                create: function create(menuButtonDefinition) {
                    var menuButtonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
                    var MenuButtonBridge = generateMenuButtonBridge(menuButtonName, menuButtonDefinition);

                    return new MenuButtonBridge();
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/components/uibridge/menu.jsx":
/*!******************************************!*\
  !*** ./src/components/uibridge/menu.jsx ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_menubridge')) {
        return;
    }

    /**
     * CKEditor plugin that bridges the support offered by CKEditor Menu plugin. It takes over the
     * responsibility of adding, removing and retrieving menu groups and items
     * - editor.addMenuGroup(name, order)
     * - editor.addMenuItem(name, definition)
     * - editor.addMenuItems(definitions)
     * - editor.getMenuItem(name)
     * - editor.removeMenuItem(name)
     *
     * @class CKEDITOR.plugins.ae_menubridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_menubridge', {
        /**
         * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
         * the one in the native plugin in case it's present.
         *
         * @method init
         * @param {Object} editor The CKEditor instance being initialized
         */
        beforeInit: function beforeInit(editor) {
            // Do nothing if the real menu plugin is present
            if (CKEDITOR.plugins.get('menu')) {
                return;
            }

            var groups = [];
            var groupsOrder = editor._.menuGroups = {};
            var menuItems = editor._.menuItems = {};

            for (var i = 0; i < groups.length; i++) {
                groupsOrder[groups[i]] = i + 1;
            }

            /**
             * Registers an item group to the editor context menu in order to make it
             * possible to associate it with menu items later.
             *
             * @method addMenuGroup
             * @param {String} name Specify a group name.
             * @param {Number} [order=100] Define the display sequence of this group
             * inside the menu. A smaller value gets displayed first.
             */
            editor.addMenuGroup = function (name, order) {
                groupsOrder[name] = order || 100;
            };

            /**
             * Adds an item from the specified definition to the editor context menu.
             *
             * @method addMenuItem
             * @param {String} name The menu item name.
             * @param {Object} definition The menu item definition.
             */
            editor.addMenuItem = function (name, definition) {
                if (groupsOrder[definition.group]) {
                    menuItems[name] = {
                        name: name,
                        definition: definition
                    };
                }
            };

            /**
             * Adds one or more items from the specified definition object to the editor context menu.
             *
             * @method addMenuItems
             * @param {Object} definitions Object where keys are used as itemName and corresponding values as definition for a {@link #addMenuItem} call.
             */
            editor.addMenuItems = function (definitions) {
                for (var itemName in definitions) {
                    this.addMenuItem(itemName, definitions[itemName]);
                }
            };

            /**
             * Retrieves a particular menu item definition from the editor context menu.
             *
             * @method getMenuItem
             * @param {String} name The name of the desired menu item.
             * @return {Object}
             */
            editor.getMenuItem = function (name) {
                return menuItems[name];
            };

            /**
             * Removes a particular menu item added before from the editor context menu.
             *
             * @method  removeMenuItem
             * @param {String} name The name of the desired menu item.
             */
            editor.removeMenuItem = function (name) {
                delete menuItems[name];
            };
        }
    });
})();

/***/ }),

/***/ "./src/components/uibridge/panel-menu-button.jsx":
/*!*******************************************************!*\
  !*** ./src/components/uibridge/panel-menu-button.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _createReactClass = __webpack_require__(/*! create-react-class */ "./node_modules/create-react-class/index.js");

var _createReactClass2 = _interopRequireDefault(_createReactClass);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_panelmenubuttonbridge')) {
        return;
    }

    /* istanbul ignore next */
    function noop() {}

    // API not yet implemented inside the panel menu button bridge. By mocking the unsupported methods, we
    // prevent plugins from crashing if they make use of them.
    var UNSUPPORTED_PANEL_MENU_BUTTON_API = {
        createPanel: noop
    };

    var PANEL_MENU_DEFS = {};

    /**
     * Generates a PanelMenuButtonBridge React class for a given panelmenubutton definition if it has not been
     * already created based on the panelmenubutton name and definition.
     *
     * @private
     * @method generatePanelMenuButtonBridge
     * @param {String} panelMenuButtonName The panel button name
     * @param {Object} panelMenuButtonDefinition The panel button definition
     * @return {Object} The generated or already existing React PanelMenuButton Class
     */
    var generatePanelMenuButtonBridge = function generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition, editor) {
        var PanelMenuButtonBridge = AlloyEditor.Buttons[panelMenuButtonName];

        PANEL_MENU_DEFS[editor.name] = PANEL_MENU_DEFS[editor.name] || {};
        PANEL_MENU_DEFS[editor.name][panelMenuButtonName] = PANEL_MENU_DEFS[editor.name][panelMenuButtonName] || panelMenuButtonDefinition;

        if (!PanelMenuButtonBridge) {
            PanelMenuButtonBridge = (0, _createReactClass2.default)(CKEDITOR.tools.merge(UNSUPPORTED_PANEL_MENU_BUTTON_API, {
                displayName: panelMenuButtonName,

                statics: {
                    key: panelMenuButtonName
                },

                render: function render() {
                    var editor = this.props.editor.get('nativeEditor');

                    var panelMenuButtonDisplayName = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].name || PANEL_MENU_DEFS[editor.name][panelMenuButtonName].command || panelMenuButtonName;

                    var buttonClassName = 'ae-button ae-button-bridge';

                    var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

                    var iconStyle = {};

                    var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

                    if (cssStyle) {
                        var cssStyleParts = cssStyle.split(';');

                        iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
                        iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
                        iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
                    }

                    var panel;

                    if (this.props.expanded) {
                        panel = this._getPanel();
                    }

                    return _react2.default.createElement(
                        'div',
                        { className: 'ae-container ae-has-dropdown' },
                        _react2.default.createElement(
                            'button',
                            { 'aria-expanded': this.props.expanded, 'aria-label': PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label, className: buttonClassName, onClick: this.props.toggleDropdown, role: 'combobox', tabIndex: this.props.tabIndex, title: PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label },
                            _react2.default.createElement('span', { className: iconClassName, style: iconStyle })
                        ),
                        panel
                    );
                },

                _getPanel: function _getPanel() {
                    var editor = this.props.editor.get('nativeEditor');

                    var panelMenuButtonOnBlock = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].onBlock;

                    var panel = {
                        hide: this.props.toggleDropdown,
                        show: this.props.toggleDropdown
                    };

                    var blockElement = new CKEDITOR.dom.element('div');

                    var block = {
                        element: blockElement,
                        keys: {}
                    };

                    /* istanbul ignore else */
                    if (panelMenuButtonOnBlock) {
                        panelMenuButtonOnBlock.call(this, panel, block);
                    }

                    // TODO
                    // Use block.keys to configure the panel keyboard navigation

                    return _react2.default.createElement(
                        _buttonDropdown2.default,
                        { onDismiss: this.props.toggleDropdown },
                        _react2.default.createElement('div', { className: blockElement.getAttribute('class'), dangerouslySetInnerHTML: { __html: blockElement.getHtml() } })
                    );
                }
            }));

            AlloyEditor.Buttons[panelMenuButtonName] = PanelMenuButtonBridge;
        }

        return PanelMenuButtonBridge;
    };

    /* istanbul ignore else */
    if (!CKEDITOR.plugins.get('panelmenubutton')) {
        CKEDITOR.UI_PANELBUTTON = 'panelmenubutton';

        CKEDITOR.plugins.add('panelmenubutton', {});
    }

    /* istanbul ignore else */
    if (!CKEDITOR.plugins.get('panelbutton')) {
        CKEDITOR.UI_PANELBUTTON = 'panelbutton';

        CKEDITOR.plugins.add('panelbutton', {});
    }

    /**
     * CKEditor plugin that bridges the support offered by CKEditor PanelButton plugin. It takes over the
     * responsibility of registering and creating buttons via:
     * - editor.ui.addPanelMenuButton(name, definition)
     * - editor.ui.add(name, CKEDITOR.UI_PANELBUTTON, definition)
     *
     * @class CKEDITOR.plugins.ae_panelmenubuttonbridge
     * @requires CKEDITOR.plugins.ae_uibridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_panelmenubuttonbridge', {
        requires: ['ae_uibridge'],

        /**
         * Set the add handler for UI_PANELBUTTON to our own. We do this in the init phase to override
         * the one in the native plugin in case it's present
         *
         * @method init
         * @param {Object} editor The CKEditor instance being initialized
         */
        beforeInit: function beforeInit(editor) {
            editor.ui.addPanelMenuButton = function (panelMenuButtonName, panelMenuButtonDefinition) {
                this.add(panelMenuButtonName, CKEDITOR.UI_PANELBUTTON, panelMenuButtonDefinition);
            };

            editor.ui.addHandler(CKEDITOR.UI_PANELBUTTON, {
                add: generatePanelMenuButtonBridge,
                create: function create(panelMenuButtonDefinition) {
                    var panelMenuButtonName = 'panelMenuButtonBridge' + (Math.random() * 1e9 >>> 0);
                    var PanelMenuButtonBridge = generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition);

                    return new PanelMenuButtonBridge();
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/components/uibridge/richcombo.jsx":
/*!***********************************************!*\
  !*** ./src/components/uibridge/richcombo.jsx ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _createReactClass = __webpack_require__(/*! create-react-class */ "./node_modules/create-react-class/index.js");

var _createReactClass2 = _interopRequireDefault(_createReactClass);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_richcombobridge')) {
        return;
    }

    /* istanbul ignore next */
    function noop() {}

    // API not yet implemented inside the richcombo bridge. By mocking the unsupported methods, we
    // prevent plugins from crashing if they make use of them.
    //
    // Some methods like `setState` clash with React's own state methods. For them, unsupported means
    // that we don't account for the different meaning in the passed or returned arguments.
    var UNSUPPORTED_RICHCOMBO_API = {
        commit: noop,
        createPanel: noop,
        disable: noop,
        enable: noop,
        getState: noop,
        hideGroup: noop,
        hideItem: noop,
        mark: noop,
        //setState: noop,
        showAll: noop,
        startGroup: noop,
        unmarkAll: noop
    };

    var RICH_COMBO_DEFS = {};

    /**
     * Generates a RichComboBridge React class for a given richcombo definition if it has not been
     * already created based on the richcombo name and definition.
     *
     * @method generateRichComboBridge
     * @private
     * @param {String} richComboName The rich combo name
     * @param {Object} richComboDefinition The rich combo definition
     * @return {Object} The generated or already existing React RichCombo Class
     */
    var generateRichComboBridge = function generateRichComboBridge(richComboName, richComboDefinition, editor) {
        var RichComboBridge = AlloyEditor.Buttons[richComboName];

        RICH_COMBO_DEFS[editor.name] = RICH_COMBO_DEFS[editor.name] || {};
        RICH_COMBO_DEFS[editor.name][richComboName] = RICH_COMBO_DEFS[editor.name][richComboName] || richComboDefinition;
        RICH_COMBO_DEFS[editor.name][richComboName].currentValue = undefined;

        if (!RichComboBridge) {
            RichComboBridge = (0, _createReactClass2.default)(CKEDITOR.tools.merge(UNSUPPORTED_RICHCOMBO_API, {
                displayName: richComboName,

                statics: {
                    key: richComboName
                },

                add: function add(value, preview, title) {
                    this._items.push({
                        preview: preview,
                        title: title,
                        value: value
                    });
                },

                componentWillMount: function componentWillMount() {
                    var editor = this.props.editor.get('nativeEditor');

                    var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

                    this._items = [];

                    this.setValue = this._setValue;

                    if (editorCombo.init) {
                        editorCombo.init.call(this);
                    }

                    if (editorCombo.onRender) {
                        editorCombo.onRender.call(this);
                    }
                },

                componentWillUnmount: function componentWillUnmount() {
                    this._cacheValue(this.state.value);

                    this.setValue = this._cacheValue;
                },

                getInitialState: function getInitialState() {
                    return {
                        value: RICH_COMBO_DEFS[editor.name][richComboName].currentValue
                    };
                },

                getValue: function getValue() {
                    return this.state.value;
                },

                render: function render() {
                    var editor = this.props.editor.get('nativeEditor');

                    var richComboLabel = RICH_COMBO_DEFS[editor.name][richComboName].currentValue || richComboDefinition.label;

                    return _react2.default.createElement(
                        'div',
                        { className: 'ae-container-dropdown ae-has-dropdown' },
                        _react2.default.createElement(
                            'button',
                            { 'aria-expanded': this.props.expanded, 'aria-label': richComboLabel, className: 'ae-toolbar-element', onClick: this.props.toggleDropdown, role: 'combobox', tabIndex: this.props.tabIndex, title: richComboLabel },
                            _react2.default.createElement(
                                'div',
                                { className: 'ae-container' },
                                _react2.default.createElement(
                                    'span',
                                    { className: 'ae-container-dropdown-selected-item' },
                                    richComboLabel
                                ),
                                _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                            )
                        ),
                        this.props.expanded && _react2.default.createElement(
                            _buttonDropdown2.default,
                            { onDismiss: this.props.toggleDropdown },
                            this._getItems()
                        )
                    );
                },

                _cacheValue: function _cacheValue(value) {
                    var editor = this.props.editor.get('nativeEditor');

                    RICH_COMBO_DEFS[editor.name][richComboName].currentValue = value;
                },

                _getItems: function _getItems() {
                    var richCombo = this;

                    var items = this._items.map(function (item) {

                        var className = 'ae-toolbar-element ' + (item.value === this.state.value ? 'active' : '');

                        return _react2.default.createElement(
                            'li',
                            { key: item.title, role: 'option' },
                            _react2.default.createElement('button', { className: className, dangerouslySetInnerHTML: { __html: item.preview }, 'data-value': item.value, onClick: richCombo._onClick })
                        );
                    }.bind(this));

                    return items;
                },

                _onClick: function _onClick(event) {
                    var editor = this.props.editor.get('nativeEditor');

                    var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

                    if (editorCombo.onClick) {
                        var newValue = event.currentTarget.getAttribute('data-value');

                        editorCombo.onClick.call(this, newValue);

                        RICH_COMBO_DEFS[editor.name][richComboName].currentValue = newValue;

                        editor.fire('actionPerformed', this);
                    }
                },

                _setValue: function _setValue(value) {
                    this._cacheValue(value);

                    this.setState({
                        value: value
                    });
                }
            }));

            AlloyEditor.Buttons[richComboName] = RichComboBridge;
        }

        return RichComboBridge;
    };

    /* istanbul ignore else */
    if (!CKEDITOR.plugins.get('richcombo')) {
        CKEDITOR.UI_RICHCOMBO = 'richcombo';

        CKEDITOR.plugins.add('richcombo', {});
    }

    /**
     * CKEditor plugin that bridges the support offered by CKEditor RichCombo plugin. It takes over the
     * responsibility of registering and creating rich combo elements via:
     * - editor.ui.addRichCombo(name, definition)
     * - editor.ui.add(name, CKEDITOR.UI_RICHCOMBO, definition)
     *
     * @class CKEDITOR.plugins.ae_richcombobridge
     * @requires CKEDITOR.plugins.ae_uibridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_richcombobridge', {
        requires: ['ae_uibridge'],

        /**
         * Set the add handler for UI_RICHCOMBO to our own. We do this in the init phase to override
         * the one in the original plugin in case it's present
         *
         * @method init
         * @param {Object} editor The CKEditor instance being initialized
         */
        beforeInit: function beforeInit(editor) {
            editor.ui.addRichCombo = function (richComboName, richComboDefinition) {
                this.add(richComboName, CKEDITOR.UI_RICHCOMBO, richComboDefinition);
            };

            editor.ui.addHandler(CKEDITOR.UI_RICHCOMBO, {
                add: generateRichComboBridge,
                create: function create(richComboDefinition) {
                    var richComboName = 'richComboBridge' + (Math.random() * 1e9 >>> 0);
                    var RichComboBridge = generateRichComboBridge(richComboName, richComboDefinition);

                    return new RichComboBridge();
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/components/uibridge/uibridge.js":
/*!*********************************************!*\
  !*** ./src/components/uibridge/uibridge.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_uibridge')) {
        return;
    }

    /**
     * CKEditor plugin that extends CKEDITOR.ui.add function so an add handler can be specified
     * on top of the original ones. It bridges the calls to add components via:
     * - editor.ui.add(name, type, definition)
     *
     * @class CKEDITOR.plugins.ae_uibridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_uibridge', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         *
         * @method beforeInit
         * @param {Object} editor The current editor instance
         */
        beforeInit: function beforeInit(editor) {
            var originalUIAddFn = editor.ui.add;

            editor.ui.add = function (name, type, definition) {
                originalUIAddFn.apply(this, arguments);

                var typeHandler = this._.handlers[type];

                if (typeHandler && typeHandler.add) {
                    typeHandler.add(name, definition, editor);
                    AlloyEditor.registerBridgeButton(name, editor.__processingPlugin__.plugin.name);
                }
            };
        }
    });
})();

/***/ }),

/***/ "./src/core/debounce.js":
/*!******************************!*\
  !*** ./src/core/debounce.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /**
     * Debounce util function. If a function execution is expensive, it might be debounced. This means
     * that it will be executed after some amount of time after its last call. For example, if we attach a
     * a function on scroll event, it might be called hundreds times per second. In this case it may be
     * debounced with, let's say 100ms. The real execution of this function will happen 100ms after last
     * scroll event.
     *
     * @memberof CKEDITOR.tools
     * @method debounce
     * @param {Array} args An array of arguments which the callback will receive.
     * @param {Function} callback The callback which has to be called after given timeout.
     * @param {Number} timeout Timeout in milliseconds after which the callback will be called.
     * @param {Object} context The context in which the callback will be called. This argument is optional.
     * @static
     */

    CKEDITOR.tools.debounce = CKEDITOR.tools.debounce || function (callback, timeout, context, args) {
        var debounceHandle;

        var callFn = function callFn() {
            var callContext = context || this;

            clearTimeout(debounceHandle);

            var result = [];

            for (var len = arguments.length, startIndex = 0; startIndex < len; ++startIndex) {
                result.push(arguments[startIndex]);
            }

            var callArgs = result.concat(args || []);

            debounceHandle = setTimeout(function () {
                callback.apply(callContext, callArgs);
            }, timeout);
        };

        callFn.detach = function () {
            clearTimeout(debounceHandle);
        };

        return callFn;
    };
})();

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uicore = exports.tools = exports.table = exports.selectionRegion = exports.plugins = exports.link = exports.debounce = undefined;

var _debounce = __webpack_require__(/*! ./debounce */ "./src/core/debounce.js");

var _debounce2 = _interopRequireDefault(_debounce);

var _link = __webpack_require__(/*! ./link */ "./src/core/link.js");

var _link2 = _interopRequireDefault(_link);

var _plugins = __webpack_require__(/*! ./plugins */ "./src/core/plugins.js");

var _plugins2 = _interopRequireDefault(_plugins);

var _selectionRegion = __webpack_require__(/*! ./selection-region */ "./src/core/selection-region.js");

var _selectionRegion2 = _interopRequireDefault(_selectionRegion);

var _table = __webpack_require__(/*! ./table */ "./src/core/table.js");

var _table2 = _interopRequireDefault(_table);

var _tools = __webpack_require__(/*! ./tools */ "./src/core/tools.js");

var _tools2 = _interopRequireDefault(_tools);

var _uicore = __webpack_require__(/*! ./uicore */ "./src/core/uicore.js");

var _uicore2 = _interopRequireDefault(_uicore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.debounce = _debounce2.default;
exports.link = _link2.default;
exports.plugins = _plugins2.default;
exports.selectionRegion = _selectionRegion2.default;
exports.table = _table2.default;
exports.tools = _tools2.default;
exports.uicore = _uicore2.default;

/***/ }),

/***/ "./src/core/link.js":
/*!**************************!*\
  !*** ./src/core/link.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
    'use strict';

    var REGEX_BOOKMARK_SCHEME = /^#.*/i;
    var REGEX_EMAIL_SCHEME = /^[a-z0-9\u0430-\u044F\._-]+@/i;
    var REGEX_URI_SCHEME = /^(?:[a-z][a-z0-9+\-.]*)\:|^\//i;

    /**
     * Link class utility. Provides methods for create, delete and update links.
     *
     * @class CKEDITOR.Link
     * @constructor
     * @param {Object} editor The CKEditor instance.
     */
    function Link(editor, config) {
        this._editor = editor;
        this.appendProtocol = config && config.appendProtocol === false ? false : true;
    }

    Link.prototype = {
        constructor: Link,

        /**
         * Advances the editor selection to the next available position after a
         * given link or the one in the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method advanceSelection
         * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
         */
        advanceSelection: function advanceSelection(link) {
            link = link || this.getFromSelection();

            var range = this._editor.getSelection().getRanges()[0];

            if (link) {
                range.moveToElementEditEnd(link);

                var nextNode = range.getNextEditableNode();

                if (nextNode && !this._editor.element.equals(nextNode.getCommonAncestor(link))) {
                    var whitespace = /\s/.exec(nextNode.getText());

                    var offset = whitespace ? whitespace.index + 1 : 0;

                    range.setStart(nextNode, offset);
                    range.setEnd(nextNode, offset);
                }
            }

            this._editor.getSelection().selectRanges([range]);
        },

        /**
         * Create a link with given URI as href.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method create
         * @param {Object} attrs A config object with link attributes. These might be arbitrary DOM attributes.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         * @param {String} URI The URI of the link.
         */
        create: function create(URI, attrs, modifySelection) {
            var selection = this._editor.getSelection();

            var range = selection.getRanges()[0];

            if (range.collapsed) {
                var text = new CKEDITOR.dom.text(URI, this._editor.document);
                range.insertNode(text);
                range.selectNodeContents(text);
            }

            URI = this._getCompleteURI(URI);

            var linkAttrs = CKEDITOR.tools.merge({
                'data-cke-saved-href': URI,
                href: URI
            }, attrs);

            var style = new CKEDITOR.style({
                attributes: linkAttrs,
                element: 'a'
            });

            style.type = CKEDITOR.STYLE_INLINE;
            style.applyToRange(range, this._editor);

            if (modifySelection && modifySelection.advance) {
                this.advanceSelection();
            } else {
                range.select();
            }
        },

        /**
         * Retrieves a link from the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method getFromSelection
         * @return {CKEDITOR.dom.element} The retrieved link or null if not found.
         */
        getFromSelection: function getFromSelection() {
            var selection = this._editor.getSelection();

            var selectedElement = selection.getSelectedElement();

            if (selectedElement && selectedElement.is('a')) {
                return selectedElement;
            }

            if (selectedElement && CKEDITOR.env.ie) {
                var children = selectedElement.getChildren();

                var count = children.count();

                for (var i = 0; i < count; i++) {
                    var node = children.getItem(i);

                    if (node.is('a')) {
                        return node;
                    }
                }
            }

            var range = selection.getRanges()[0];

            if (range) {
                range.shrink(CKEDITOR.SHRINK_TEXT);

                return this._editor.elementPath(range.getCommonAncestor()).contains('a', 1);
            }

            return null;
        },

        /**
         * Removes a link from the editor.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method remove
         * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         */
        remove: function remove(link, modifySelection) {
            var editor = this._editor;

            if (link) {
                if (modifySelection && modifySelection.advance) {
                    this.advanceSelection();
                }

                link.remove(editor);
            } else {
                var style = new CKEDITOR.style({
                    alwaysRemoveElement: 1,
                    element: 'a',
                    type: CKEDITOR.STYLE_INLINE
                });

                // 'removeStyle()' removes the style from the editor's current selection.
                //  We need to force the selection to be the whole link element
                //  to remove it properly.

                var selection = editor.getSelection();
                selection.selectElement(selection.getStartElement());

                editor.removeStyle(style);
            }
        },

        /**
         * Updates the href of an already existing link.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method update
         * @param {CKEDITOR.dom.element} link The link element which href should be removed.
         * @param {Object|String} attrs The attributes to update or remove. Attributes with null values will be removed.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         */
        update: function update(attrs, link, modifySelection) {
            var instance = this;

            link = link || this.getFromSelection();

            if (typeof attrs === 'string') {
                var uri = instance._getCompleteURI(attrs);

                link.setAttributes({
                    'data-cke-saved-href': uri,
                    href: uri
                });
            } else if ((typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object') {
                var removeAttrs = [];

                var setAttrs = {};

                Object.keys(attrs).forEach(function (key) {
                    if (attrs[key] === null) {
                        if (key === 'href') {
                            removeAttrs.push('data-cke-saved-href');
                        }

                        removeAttrs.push(key);
                    } else {
                        if (key === 'href') {
                            var uri = instance._getCompleteURI(attrs[key]);

                            setAttrs['data-cke-saved-href'] = uri;
                            setAttrs[key] = uri;
                        } else {
                            setAttrs[key] = attrs[key];
                        }
                    }
                });

                link.removeAttributes(removeAttrs);
                link.setAttributes(setAttrs);
            }

            if (modifySelection && modifySelection.advance) {
                this.advanceSelection(link);
            }
        },

        /**
         * Checks if the URI begins with a '#' symbol to determine if it's an on page bookmark.
         * If it doesn't, it then checks if the URI has an '@' symbol. If it does and the URI
         * looks like an email and doesn't have 'mailto:', 'mailto:' is added to the URI.
         * If it doesn't and the URI doesn't have a scheme, the default 'http' scheme with
         * hierarchical path '//' is added to the URI.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method _getCompleteURI
         * @param {String} URI The URI of the link.
         * @protected
         * @return {String} The URI updated with the protocol.
         */
        _getCompleteURI: function _getCompleteURI(URI) {
            if (REGEX_BOOKMARK_SCHEME.test(URI)) {
                return URI;
            } else if (REGEX_EMAIL_SCHEME.test(URI)) {
                URI = 'mailto:' + URI;
            } else if (!REGEX_URI_SCHEME.test(URI)) {
                URI = this.appendProtocol ? 'http://' + URI : URI;
            }

            return URI;
        }
    };

    CKEDITOR.Link = CKEDITOR.Link || Link;
})();

/***/ }),

/***/ "./src/core/plugins.js":
/*!*****************************!*\
  !*** ./src/core/plugins.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    // Wraps each of the plugin lifecycle methods in a closure that will
    // set up the editor.__processingPlugin__ variable so it can be globally
    // accessed exposing the plugin being processed and the lifecycle phase
    // in which it is happening
    //
    // @param {Object} plugin The plugin to wrap lifecycle methods

    var wrapPluginLifecycle = function wrapPluginLifecycle(plugin) {
        var methods = ['beforeInit', 'init', 'afterInit'];

        methods.forEach(function (methodName) {
            if (plugin[methodName]) {
                plugin[methodName] = CKEDITOR.tools.override(plugin[methodName], function (originalPluginMethod) {
                    var payload = {
                        phase: methodName,
                        plugin: plugin
                    };

                    return function (editor) {
                        editor.__processingPlugin__ = payload;

                        originalPluginMethod.call(this, editor);

                        editor.__processingPlugin__ = null;
                    };
                });
            }
        });
    };

    // Filters the requires object to remove unwanted dependencies. At this point
    // only 'toolbar' has been identified, but more can appear. An unwanted plugin
    // dependency is one that prevents a necessary plugin from being removed
    //
    // @param {string|Array<string>} requires The requires object
    // @return {string} The filtered requires object
    var filterUnwantedDependencies = function filterUnwantedDependencies(requires) {
        if (typeof requires === 'string') {
            requires = requires.split(',');
        }

        return requires.filter(function (require) {
            return require !== 'toolbar';
        });
    };

    /**
     * CKEDITOR.plugins class utility which adds additional methods to those of CKEditor.
     *
     * @class CKEDITOR.plugins
     */

    /**
     * Overrides CKEDITOR.plugins.load method so we can extend the lifecycle methods of
     * the loaded plugins to add some metainformation about the plugin being processed
     *
    * @param {String/Array} names The name of the resource to load. It may be a
    * string with a single resource name, or an array with several names.
    * @param {Function} callback A function to be called when all resources
    * are loaded. The callback will receive an array containing all loaded names.
    * @param {Object} [scope] The scope object to be used for the callback call.
     * @memberof CKEDITOR.plugins
     * @method load
     * @static
     */
    CKEDITOR.plugins.load = CKEDITOR.tools.override(CKEDITOR.plugins.load, function (pluginsLoad) {
        // Wrap original load function so we can transform the plugin input parameter
        // before passing it down to the original callback
        return function (names, callback, scope) {
            pluginsLoad.call(this, names, function (plugins) {
                if (callback) {
                    Object.keys(plugins).forEach(function (pluginName) {
                        var plugin = plugins[pluginName];

                        if (plugin.requires) {
                            plugin.requires = filterUnwantedDependencies(plugin.requires);
                        }

                        wrapPluginLifecycle(plugin);
                    });

                    callback.call(scope, plugins);
                }
            });
        };
    });
})();

/***/ }),

/***/ "./src/core/selection-region.js":
/*!**************************************!*\
  !*** ./src/core/selection-region.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_selectionregion')) {
        return;
    }

    CKEDITOR.SELECTION_TOP_TO_BOTTOM = 0;
    CKEDITOR.SELECTION_BOTTOM_TO_TOP = 1;
    CKEDITOR.SELECTION_LEFT_TO_RIGHT = 2;
    CKEDITOR.SELECTION_RIGHT_TO_LEFT = 3;

    /**
     * SelectionRegion utility class which provides metadata about the selection. The metadata may be the start and end
     * rectangles, caret region, etc. **This class is not intended to be used standalone. Its functions will
     * be merged into each editor instance, so the developer may use them directly via the editor, without making
     * an instance of this class**.
     *
     * @class SelectionRegion
     * @constructor
     */
    function SelectionRegion() {}

    SelectionRegion.prototype = {
        constructor: SelectionRegion,

        /**
         * Creates selection from two points in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method createSelectionFromPoint
         * @param {Number} x X point in page coordinates.
         * @param {Number} y Y point in page coordinates.
         */
        createSelectionFromPoint: function createSelectionFromPoint(x, y) {
            this.createSelectionFromRange(x, y, x, y);
        },

        /**
         * Creates selection from range. A range consists from two points in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method createSelectionFromRange
         * @param {Number} startX X coordinate of the first point.
         * @param {Number} startY Y coordinate of the first point.
         * @param {Number} endX X coordinate of the second point.
         * @param {Number} endY Y coordinate of the second point.
         */
        createSelectionFromRange: function createSelectionFromRange(startX, startY, endX, endY) {
            var end;
            var endContainer;
            var endOffset;
            var range;
            var start;
            var startContainer;
            var startOffset;

            if (typeof document.caretPositionFromPoint === 'function') {
                start = document.caretPositionFromPoint(startX, startY);
                end = document.caretPositionFromPoint(endX, endY);

                startContainer = start.offsetNode;
                endContainer = end.offsetNode;

                startOffset = start.offset;
                endOffset = end.offset;

                range = this.createRange();
            } else if (typeof document.caretRangeFromPoint === 'function') {
                start = document.caretRangeFromPoint(startX, startY);
                end = document.caretRangeFromPoint(endX, endY);

                startContainer = start.startContainer;
                endContainer = end.startContainer;

                startOffset = start.startOffset;
                endOffset = end.startOffset;

                range = this.createRange();
            }

            if (range && document.getSelection) {
                range.setStart(new CKEDITOR.dom.node(startContainer), startOffset);
                range.setEnd(new CKEDITOR.dom.node(endContainer), endOffset);

                this.getSelection().selectRanges([range]);
            } else if (typeof document.body.createTextRange === 'function') {
                var selection = this.getSelection();

                selection.unlock();

                range = document.body.createTextRange();
                range.moveToPoint(startX, startY);

                var endRange = range.duplicate();
                endRange.moveToPoint(endX, endY);

                range.setEndPoint('EndToEnd', endRange);
                range.select();

                this.getSelection().lock();
            }
        },

        /**
         * Returns the region of the current position of the caret. The points are in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getCaretRegion
         * @return {Object} Returns object with the following properties:
         * - bottom
         * - left
         * - right
         * - top
         */
        getCaretRegion: function getCaretRegion() {
            var selection = this.getSelection();

            var region = {
                bottom: 0,
                left: 0,
                right: 0,
                top: 0
            };

            var bookmarks = selection.createBookmarks();

            if (!bookmarks.length) {
                return region;
            }

            var bookmarkNodeEl = bookmarks[0].startNode.$;

            bookmarkNodeEl.style.display = 'inline-block';

            region = new CKEDITOR.dom.element(bookmarkNodeEl).getClientRect();

            bookmarkNodeEl.parentNode.removeChild(bookmarkNodeEl);

            var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

            region.bottom = scrollPos.y + region.bottom;
            region.left = scrollPos.x + region.left;
            region.right = scrollPos.x + region.right;
            region.top = scrollPos.y + region.top;

            return region;
        },

        /**
         * Returns data for the current selection.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionData
         * @return {Object|null} Returns an object with the following data:
         * - element - The currently selected element, if any
         * - text - The selected text
         * - region - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionRegion:method"}}{{/crossLink}}
         */
        getSelectionData: function getSelectionData() {
            var selection = this.getSelection();

            if (!selection.getNative()) {
                return null;
            }

            var result = {
                element: selection.getSelectedElement(),
                text: selection.getSelectedText()
            };

            result.region = this.getSelectionRegion(selection);

            return result;
        },

        /**
         * Returns the region of the current selection.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionRegion
         * @return {Object} Returns object which is being returned from
         * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getClientRectsRegion:method"}}{{/crossLink}} with three more properties:
         * - direction - the direction of the selection. Can be one of these:
         *   1. CKEDITOR.SELECTION_TOP_TO_BOTTOM
         *   2. CKEDITOR.SELECTION_BOTTOM_TO_TOP
         * - height - The height of the selection region
         * - width - The width of the selection region
         */
        getSelectionRegion: function getSelectionRegion() {
            var region = this.getClientRectsRegion();

            region.direction = this.getSelectionDirection();

            region.height = region.bottom - region.top;
            region.width = region.right - region.left;

            return region;
        },

        /**
         * Returns true if the current selection is empty, false otherwise.
         *
         * @instance
         * @memberof SelectionRegion
         * @method isSelectionEmpty
         * @return {Boolean} Returns true if the current selection is empty, false otherwise.
         */
        isSelectionEmpty: function isSelectionEmpty() {
            var ranges;

            var selection = this.getSelection();

            return selection.getType() === CKEDITOR.SELECTION_NONE || (ranges = selection.getRanges()) && ranges.length === 1 && ranges[0].collapsed;
        },

        /**
         * Returns object with data about the [client rectangles](https://developer.mozilla.org/en-US/docs/Web/API/Element.getClientRects) of the selection,
         * normalized across browses. All offsets below are in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getClientRectsRegion
         * @return {Object} Returns object with the following data:
         * - bottom - bottom offset of all client rectangles
         * - left - left offset of all client rectangles
         * - right - right offset of all client rectangles
         * - top - top offset of all client rectangles
         * - startRect - An Object, which contains the following information:
         *     + bottom - bottom offset
         *     + height - the height of the rectangle
         *     + left - left offset of the selection
         *     + right - right offset of the selection
         *     + top - top offset of the selection
         *     + width - the width of the rectangle
         * - endRect - An Object, which contains the following information:
         *     + bottom - bottom offset
         *     + height - the height of the rectangle
         *     + left - left offset of the selection
         *     + right - right offset of the selection
         *     + top - top offset of the selection
         *     + width - the width of the rectangle
         *
         * If there is no native selection, the objects will be filled with 0.
         */
        getClientRectsRegion: function getClientRectsRegion() {
            var selection = this.getSelection();
            var nativeSelection = selection.getNative();

            var defaultRect = {
                bottom: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                width: 0
            };

            var region = {
                bottom: 0,
                endRect: defaultRect,
                left: 0,
                right: 0,
                top: 0,
                startRect: defaultRect
            };

            if (!nativeSelection) {
                return region;
            }

            var bottom = 0;
            var clientRects;
            var left = Infinity;
            var rangeCount;
            var right = -Infinity;
            var top = Infinity;

            if (nativeSelection.createRange) {
                clientRects = nativeSelection.createRange().getClientRects();
            } else {
                rangeCount = nativeSelection.rangeCount;
                clientRects = nativeSelection.rangeCount > 0 ? nativeSelection.getRangeAt(0).getClientRects() : [];
            }

            if (clientRects.length === 0) {
                region = this.getCaretRegion();
            } else {
                for (var i = 0, length = clientRects.length; i < length; i++) {
                    var item = clientRects[i];

                    if (item.left < left) {
                        left = item.left;
                    }

                    if (item.right > right) {
                        right = item.right;
                    }

                    if (item.top < top) {
                        top = item.top;
                    }

                    if (item.bottom > bottom) {
                        bottom = item.bottom;
                    }
                }

                var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

                region.bottom = scrollPos.y + bottom;
                region.left = scrollPos.x + left;
                region.right = scrollPos.x + right;
                region.top = scrollPos.y + top;

                if (clientRects.length) {
                    var endRect = clientRects[clientRects.length - 1];
                    var startRect = clientRects[0];

                    region.endRect = {
                        bottom: scrollPos.y + endRect.bottom,
                        height: endRect.height,
                        left: scrollPos.x + endRect.left,
                        right: scrollPos.x + endRect.right,
                        top: scrollPos.y + endRect.top,
                        width: endRect.width
                    };

                    region.startRect = {
                        bottom: scrollPos.y + startRect.bottom,
                        height: startRect.height,
                        left: scrollPos.x + startRect.left,
                        right: scrollPos.x + startRect.right,
                        top: scrollPos.y + startRect.top,
                        width: startRect.width
                    };
                }
            }

            return region;
        },

        /**
         * Retrieves the direction of the selection. The direction is from top to bottom or from bottom to top.
         * For IE < 9 it is not possible, so the direction for these browsers will be always CKEDITOR.SELECTION_TOP_TO_BOTTOM.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionDirection
         * @return {Number} Returns a number which represents selection direction. It might be one of these:
         * - CKEDITOR.SELECTION_TOP_TO_BOTTOM;
         * - CKEDITOR.SELECTION_BOTTOM_TO_TOP;
         */
        getSelectionDirection: function getSelectionDirection() {
            var direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;
            var selection = this.getSelection();
            var nativeSelection = selection.getNative();

            if (!nativeSelection) {
                return direction;
            }

            var anchorNode;

            if ((anchorNode = nativeSelection.anchorNode) && anchorNode.compareDocumentPosition) {
                var position = anchorNode.compareDocumentPosition(nativeSelection.focusNode);

                if (!position && nativeSelection.anchorOffset > nativeSelection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) {
                    direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
                }
            }

            return direction;
        }
    };

    CKEDITOR.plugins.add('ae_selectionregion', {
        init: function init(editor) {
            var attr, hasOwnProperty;

            hasOwnProperty = Object.prototype.hasOwnProperty;

            for (attr in SelectionRegion.prototype) {
                if (hasOwnProperty.call(SelectionRegion.prototype, attr) && typeof editor[attr] === 'undefined') {
                    editor[attr] = SelectionRegion.prototype[attr];
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/core/table.js":
/*!***************************!*\
  !*** ./src/core/table.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    var IE_NON_DIRECTLY_EDITABLE_ELEMENT = {
        'table': 1,
        'col': 1,
        'colgroup': 1,
        'tbody': 1,
        'td': 1,
        'tfoot': 1,
        'th': 1,
        'thead': 1,
        'tr': 1
    };

    /**
     * Table class utility. Provides methods for create, delete and update tables.
     *
     * @class CKEDITOR.Table
     * @constructor
     * @param {Object} editor The CKEditor instance.
     */

    function Table(editor) {
        this._editor = editor;
    }

    Table.HEADING_BOTH = 'Both';
    Table.HEADING_COL = 'Column';
    Table.HEADING_NONE = 'None';
    Table.HEADING_ROW = 'Row';

    Table.prototype = {
        constructor: Table,

        /**
         * Creates a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method create
         * @param {Object} config Table configuration object
         * @return {Object} The created table
         */
        create: function create(config) {
            var editor = this._editor;
            var table = this._createElement('table');

            config = config || {};

            // Generate the rows and cols.
            var tbody = table.append(this._createElement('tbody'));
            var rows = config.rows || 1;
            var cols = config.cols || 1;

            for (var i = 0; i < rows; i++) {
                var row = tbody.append(this._createElement('tr'));
                for (var j = 0; j < cols; j++) {
                    var cell = row.append(this._createElement('td'));

                    cell.appendBogus();
                }
            }

            this.setAttributes(table, config.attrs);
            this.setHeading(table, config.heading);

            // Insert the table element if we're creating one.
            editor.insertElement(table);

            var firstCell = new CKEDITOR.dom.element(table.$.rows[0].cells[0]);
            var range = editor.createRange();
            range.moveToPosition(firstCell, CKEDITOR.POSITION_AFTER_START);
            range.select();

            return table;
        },

        /**
         * Retrieves a table from the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method getFromSelection
         * @return {CKEDITOR.dom.element} The retrieved table or null if not found.
         */
        getFromSelection: function getFromSelection() {
            var table;
            var selection = this._editor.getSelection();
            var selected = selection.getSelectedElement();

            if (selected && selected.is('table')) {
                table = selected;
            } else {
                var ranges = selection.getRanges();

                if (ranges.length > 0) {
                    // Webkit could report the following range on cell selection (#4948):
                    // <table><tr><td>[&nbsp;</td></tr></table>]

                    /* istanbul ignore else */
                    if (CKEDITOR.env.webkit) {
                        ranges[0].shrink(CKEDITOR.NODE_ELEMENT);
                    }

                    table = this._editor.elementPath(ranges[0].getCommonAncestor(true)).contains('table', 1);
                }
            }

            return table;
        },

        /**
         * Checks if a given table can be considered as editable. This method
         * workarounds a limitation of IE where for some elements (like table),
         * `isContentEditable` returns always false. This is because IE does not support
         * `contenteditable` on such elements. However, despite such elements
         * cannot be set as content editable directly, a content editable SPAN,
         * or DIV element can be placed inside the individual table cells.
         * See https://msdn.microsoft.com/en-us/library/ms537837%28v=VS.85%29.aspx
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method isEditable
         * @param {CKEDITOR.dom.element} el The table element to test if editable
         * @return {Boolean}
         */
        isEditable: function isEditable(el) {
            if (!CKEDITOR.env.ie || !el.is(IE_NON_DIRECTLY_EDITABLE_ELEMENT)) {
                return !el.isReadOnly();
            }

            if (el.hasAttribute('contenteditable')) {
                return el.getAttribute('contenteditable') !== 'false';
            }

            return this.isEditable(el.getParent());
        },

        /**
         * Returns which heading style is set for the given table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method getHeading
         * @param {CKEDITOR.dom.element} table The table to gather the heading from. If null, it will be retrieved from the current selection.
         * @return {String} The heading of the table. Expected values are `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
         */
        getHeading: function getHeading(table) {
            table = table || this.getFromSelection();

            if (!table) {
                return null;
            }

            var rowHeadingSettings = table.$.tHead !== null;

            var colHeadingSettings = true;

            // Check if all of the first cells in every row are TH
            for (var row = 0; row < table.$.rows.length; row++) {
                // If just one cell isn't a TH then it isn't a header column
                var cell = table.$.rows[row].cells[0];

                if (cell && cell.nodeName.toLowerCase() !== 'th') {
                    colHeadingSettings = false;
                    break;
                }
            }

            var headingSettings = Table.HEADING_NONE;

            if (rowHeadingSettings) {
                headingSettings = Table.HEADING_ROW;
            }

            if (colHeadingSettings) {
                headingSettings = headingSettings === Table.HEADING_ROW ? Table.HEADING_BOTH : Table.HEADING_COL;
            }

            return headingSettings;
        },

        /**
         * Removes a table from the editor.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method remove
         * @param {CKEDITOR.dom.element} table The table element which table style should be removed.
         */
        remove: function remove(table) {
            var editor = this._editor;

            if (table) {
                table.remove();
            } else {
                table = editor.elementPath().contains('table', 1);

                if (table) {
                    // If the table's parent has only one child remove it as well (unless it's a table cell, or the editable element) (#5416, #6289, #12110)
                    var parent = table.getParent();
                    var editable = editor.editable();

                    if (parent.getChildCount() === 1 && !parent.is('td', 'th') && !parent.equals(editable)) {
                        table = parent;
                    }

                    var range = editor.createRange();
                    range.moveToPosition(table, CKEDITOR.POSITION_BEFORE_START);
                    table.remove();
                    range.select();
                }
            }
        },

        /**
         * Assigns provided attributes to a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method setAttributes
         * @param {Object} table The table to which the attributes should be assigned
         * @param {Object} attrs The attributes which have to be assigned to the table
         */
        setAttributes: function setAttributes(table, attrs) {
            if (attrs) {
                Object.keys(attrs).forEach(function (attr) {
                    table.setAttribute(attr, attrs[attr]);
                });
            }
        },

        /**
         * Sets the appropriate table heading style to a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method setHeading
         * @param {CKEDITOR.dom.element} table The table element to which the heading should be set. If null, it will be retrieved from the current selection.
         * @param {String} heading The table heading to be set. Accepted values are: `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
         */
        setHeading: function setHeading(table, heading) {
            table = table || this.getFromSelection();

            var i, newCell;
            var tableHead;
            var tableBody = table.getElementsByTag('tbody').getItem(0);

            var tableHeading = this.getHeading(table);
            var hadColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

            var needColHeading = heading === Table.HEADING_COL || heading === Table.HEADING_BOTH;
            var needRowHeading = heading === Table.HEADING_ROW || heading === Table.HEADING_BOTH;

            // If we need row heading and don't have a <thead> element yet, move the
            // first row of the table to the head and convert the nodes to <th> ones.
            if (!table.$.tHead && needRowHeading) {
                var tableFirstRow = tableBody.getElementsByTag('tr').getItem(0);
                var tableFirstRowChildCount = tableFirstRow.getChildCount();

                // Change TD to TH:
                for (i = 0; i < tableFirstRowChildCount; i++) {
                    var cell = tableFirstRow.getChild(i);

                    // Skip bookmark nodes. (#6155)
                    if (cell.type === CKEDITOR.NODE_ELEMENT && !cell.data('cke-bookmark')) {
                        cell.renameNode('th');
                        cell.setAttribute('scope', 'col');
                    }
                }

                tableHead = this._createElement(table.$.createTHead());
                tableHead.append(tableFirstRow.remove());
            }

            // If we don't need row heading and we have a <thead> element, move the
            // row out of there and into the <tbody> element.
            if (table.$.tHead !== null && !needRowHeading) {
                // Move the row out of the THead and put it in the TBody:
                tableHead = this._createElement(table.$.tHead);

                var previousFirstRow = tableBody.getFirst();

                while (tableHead.getChildCount() > 0) {
                    var newFirstRow = tableHead.getFirst();
                    var newFirstRowChildCount = newFirstRow.getChildCount();

                    for (i = 0; i < newFirstRowChildCount; i++) {
                        newCell = newFirstRow.getChild(i);

                        if (newCell.type === CKEDITOR.NODE_ELEMENT) {
                            newCell.renameNode('td');
                            newCell.removeAttribute('scope');
                        }
                    }

                    newFirstRow.insertBefore(previousFirstRow);
                }

                tableHead.remove();
            }

            tableHeading = this.getHeading(table);
            var hasColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

            // If we need column heading and the table doesn't have it, convert every first cell in
            // every row into a `<th scope="row">` element.
            if (!hasColHeading && needColHeading) {
                for (i = 0; i < table.$.rows.length; i++) {
                    if (table.$.rows[i].cells[0].nodeName.toLowerCase() !== 'th') {
                        newCell = new CKEDITOR.dom.element(table.$.rows[i].cells[0]);
                        newCell.renameNode('th');
                        newCell.setAttribute('scope', 'row');
                    }
                }
            }

            // If we don't need column heading but the table has it, convert every first cell in every
            // row back into a `<td>` element.
            if (hadColHeading && !needColHeading) {
                for (i = 0; i < table.$.rows.length; i++) {
                    var row = new CKEDITOR.dom.element(table.$.rows[i]);

                    if (row.getParent().getName() === 'tbody') {
                        newCell = new CKEDITOR.dom.element(row.$.cells[0]);
                        newCell.renameNode('td');
                        newCell.removeAttribute('scope');
                    }
                }
            }
        },

        /**
         * Creates a new CKEDITOR.dom.element using the passed tag name.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @protected
         * @method _createElement
         * @param {String} name The tag name from which an element should be created
         * @return {CKEDITOR.dom.element} Instance of CKEDITOR DOM element class
         */
        _createElement: function _createElement(name) {
            return new CKEDITOR.dom.element(name, this._editor.document);
        }
    };

    CKEDITOR.on('instanceReady', function (event) {
        var headingCommands = [Table.HEADING_NONE, Table.HEADING_ROW, Table.HEADING_COL, Table.HEADING_BOTH];

        var tableUtils = new Table(event.editor);

        headingCommands.forEach(function (heading) {
            event.editor.addCommand('tableHeading' + heading, {
                exec: function exec(editor) {
                    tableUtils.setHeading(null, heading);
                }
            });
        });
    });

    CKEDITOR.Table = CKEDITOR.Table || Table;
})();

/***/ }),

/***/ "./src/core/tools.js":
/*!***************************!*\
  !*** ./src/core/tools.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /**
     * CKEDITOR.tools class utility which adds additional methods to those of CKEditor.
     *
     * @class CKEDITOR.tools
     */

    /**
     * Sends a request using the JSONP technique.
     *
     * @memberof CKEDITOR.tools
     * @method jsonp
     * @param {CKEDITOR.template} urlTemplate The template of the URL to be requested. All properties passed in `urlParams` can be used, plus a `{callback}`, which represent a JSONP callback, must be defined.
     * @param {Function} callback A function to be called in case of success.
     * @param {Function} errorCallback A function to be called in case of failure.
     * @param {Object} urlParams Parameters to be passed to the `urlTemplate`.
     * @return {Object} An object with the following properties:
     *  - id: the transaction ID
     *  - a `cancel()` method
     * @static
     */

    CKEDITOR.tools.jsonp = function (urlTemplate, urlParams, callback, errorCallback) {
        var callbackKey = CKEDITOR.tools.getNextNumber();

        urlParams = urlParams || {};
        urlParams.callback = 'CKEDITOR._.jsonpCallbacks[' + callbackKey + ']';

        if (!CKEDITOR._.jsonpCallbacks) {
            CKEDITOR._.jsonpCallbacks = {};
        }

        CKEDITOR._.jsonpCallbacks[callbackKey] = function (response) {
            setTimeout(function () {
                cleanUp();

                callback(response);
            });
        };

        var scriptElement = new CKEDITOR.dom.element('script');
        scriptElement.setAttribute('src', urlTemplate.output(urlParams));
        scriptElement.on('error', function () {
            cleanUp();

            if (errorCallback) {
                errorCallback();
            }
        });

        function cleanUp() {
            if (scriptElement) {
                scriptElement.remove();
                delete CKEDITOR._.jsonpCallbacks[callbackKey];
                scriptElement = null;
            }
        }

        CKEDITOR.document.getBody().append(scriptElement);

        return {
            cancel: cleanUp,
            id: callbackKey
        };
    };

    /**
     * Returns a new object containing all of the properties of all the supplied
     * objects. The properties from later objects will overwrite those in earlier
     * objects.
     *
     * Passing in a single object will create a shallow copy of it.
     *
     * @memberof CKEDITOR.tools
     * @method merge
     * @param {Object} objects* One or more objects to merge.
     * @return {Object} A new merged object.
     * @static
     */
    CKEDITOR.tools.merge = CKEDITOR.tools.merge || function () {
        var result = {};

        for (var i = 0; i < arguments.length; ++i) {
            var obj = arguments[i];

            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    result[key] = obj[key];
                }
            }
        }

        return result;
    };

    /**
     * Simulates event on a DOM element.
     *
     * @memberof CKEDITOR.tools
     * @method simulate
     * @param {DOMElement} element The element on which the event shoud be simualted.
     * @param {String} event The name of the event which have to be simulated.
     * @static
     */
    CKEDITOR.tools.simulate = function (element, event) {
        var eventInstance = document.createEvent('Events');
        eventInstance.initEvent(event, true, false);
        element.dispatchEvent(eventInstance);
    };
})();

/***/ }),

/***/ "./src/core/uicore.js":
/*!****************************!*\
  !*** ./src/core/uicore.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_uicore')) {
        return;
    }

    /**
     * UICore class which will handle user interactions with the editor. These interactions
     * might be triggered via mouse, keyboard or touch devices. The class fill fire an event via
     * CKEditor's event system - "editorInteraction". The UI may listen to this event and
     * execute some actions - for example to show/hide toolbars.
     *
     * By default if user presses the Esc key, 'editorInteraction' event won't be fired. However, this behaviour can be changed
     * by setting {{#crossLink "CKEDITOR.plugins.ae_uicore/allowEsc:attribute"}}{{/crossLink}} config property in editor's configuration to true.
     *
     * @class ae_uicore
     */

    /**
     * Fired when user interacts somehow with the browser. This may be clicking with the mouse, pressing keyboard button,
     * or touching screen. This even will be not fired after each interaction. It will be debounced. By default the timeout
     * is 50ms. This value can be overwritten via {{#crossLink "CKEDITOR.plugins.ae_uicore/timeout:attribute"}}{{/crossLink}}
     * property of editor's configuration, like: editor.config.uicore.timeout = 100
     *
     * @memberof ae_uicore
     * @event ae_uicore#editorInteraction
     * @param {Object} data An object which contains the following properties:
     * - nativeEvent - The event as received from CKEditor.
     * - selectionData - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
     */

    /**
     * Fired by UI elements like Toolbars or Buttons when their state changes. The listener updates the live region with the provided data.
     *
     * @memberof ae_uicore
     * @event ae_uicore#ariaUpdate
     * @param {Object} data An object which contains the following properties:
     * - message - The provided message from the UI element.
     */

    /**
     * If set to true, the editor will still fire {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event,
     * if user presses Esc key.
     *
     * @memberof ae_uicore
     * @attribute allowEsc
     * @default false
     * @type Boolean
     */

    /**
     * Specifies the default timeout after which the {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event
     * will be fired.
     *
     * @memberof ae_uicore
     * @attribute timeout
     * @default 50 (ms)
     * @type Number
     */

    CKEDITOR.plugins.add('ae_uicore', {
        /**
         * Initializer lifecycle implementation for the UICore plugin.
         *
         * @memberof ae_uicore
         * @method init
         * @param {Object} editor The current CKEditor instance.
         * @protected
         */
        init: function init(editor) {
            var ariaState = [];

            var ariaElement = this._createAriaElement(editor.id);

            var uiTasksTimeout = editor.config.uicore ? editor.config.uicore.timeout : 50;

            var handleUI = CKEDITOR.tools.debounce(function (event) {
                ariaState = [];

                if (event.name !== 'keyup' || event.data.$.keyCode !== 27 || editor.config.allowEsc) {
                    var selectionData = editor.getSelectionData();

                    if (selectionData) {
                        editor.fire('editorInteraction', {
                            nativeEvent: event.data.$,
                            selectionData: selectionData
                        });
                    }
                }
            }, uiTasksTimeout);

            var handleAria = CKEDITOR.tools.debounce(function (event) {
                ariaElement.innerHTML = ariaState.join('. ');
            }, uiTasksTimeout);

            var handleMouseLeave = CKEDITOR.tools.debounce(function (event) {
                var aeUINodes = document.querySelectorAll('.ae-ui');

                var found;

                for (var i = 0; i < aeUINodes.length; i++) {
                    if (aeUINodes[i].contains(event.data.$.relatedTarget)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    handleUI(event);
                }
            }, uiTasksTimeout);

            editor.on('ariaUpdate', function (event) {
                // handleAria is debounced function, so if it is being called multiple times, it will
                // be canceled until some time passes.
                // For that reason here we explicitly append the current message to the list of messages
                // and call handleAria. Since it is debounced, when some timeout passes,
                // all the messages will be applied to the live region and not only the last one.

                ariaState.push(event.data.message);

                handleAria();
            });

            editor.once('contentDom', function () {
                var editable = editor.editable();

                var focusHandler = editable.attachListener(editable, 'focus', function (event) {
                    focusHandler.removeListener();

                    editable.attachListener(editable, 'keyup', handleUI);
                    editable.attachListener(editable, 'mouseup', handleUI);
                    editable.attachListener(editable, 'mouseleave', handleMouseLeave);

                    handleUI(event);
                });
            });

            editor.on('destroy', function (event) {
                ariaElement.parentNode.removeChild(ariaElement);

                handleUI.detach();
            });
        },

        /**
         * Creates and applies an HTML element to the body of the document which will contain ARIA messages.
         *
         * @memberof ae_uicore
         * @method _createAriaElement
         * @param {String} id The provided id of the element. It will be used as prefix for the final element Id.
         * @protected
         * @return {HTMLElement} The created and applied to DOM element.
         */
        _createAriaElement: function _createAriaElement(id) {
            var statusElement = document.createElement('div');

            statusElement.className = 'ae-sr-only';

            statusElement.setAttribute('aria-live', 'polite');
            statusElement.setAttribute('role', 'status');
            statusElement.setAttribute('id', id + 'LiveRegion');

            document.body.appendChild(statusElement);

            return statusElement;
        }
    });
})();

/***/ }),

/***/ "./src/oop/attribute.js":
/*!******************************!*\
  !*** ./src/oop/attribute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _lang = __webpack_require__(/*! ./lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attribute implementation.
 *
 * @class Attribute
 * @constructor
*/
function Attribute(config) {
    this.__config__ = config || {};
    this.__ATTRS__ = {};
}

Attribute.prototype = {
    constructor: Attribute,

    /**
     * Retrieves the value of an attribute.
     *
     * @instance
     * @memberof Attribute
     * @method get
     * @param {String} attr The attribute which value should be retrieved.
     * @return {Any} The value of the attribute.
     */
    get: function get(attr) {
        var currentAttr = this.constructor.ATTRS[attr];

        if (!currentAttr) {
            return;
        }

        if (!this._isInitialized(attr)) {
            this._init(attr);
        }

        var curValue = this.__ATTRS__[attr];

        if (currentAttr.getter) {
            curValue = this._callStringOrFunction(currentAttr.getter, curValue);
        }

        return curValue;
    },

    /**
     * Sets the value of an attribute.
     *
     * @instance
     * @memberof Attribute
     * @method set
     * @param {String} attr The attribute which value should be set.
     * @param {Any} value The value which should be set to the attribute.
     */
    set: function set(attr, value) {
        var currentAttr = this.constructor.ATTRS[attr];

        if (!currentAttr) {
            return;
        }

        if (!this._isInitialized(attr)) {
            this._init(attr);
        }

        if (currentAttr.readOnly) {
            return;
        }

        if (currentAttr.writeOnce && this._isInitialized(attr)) {
            return;
        }

        if (currentAttr.validator && !this._callStringOrFunction(currentAttr.validator, value)) {
            return;
        }

        if (currentAttr.setter) {
            value = this._callStringOrFunction(currentAttr.setter, value);
        }

        this.__ATTRS__[attr] = value;
    },

    /**
     * Calls the provided param as function with the supplied arguments.
     * If param provided as string, a corresponding function in this object will
     * be called. If provided param is a function, it will be directly called.
     *
     * @instance
     * @memberof Attribute
     * @method _callStringOrFunction
     * @param  {Any|Array} args The arguments which will be provided to the called function
     * @param  {String|Function} stringOrFunction The function which should be called
     * @protected
     * @return {Any} The returned value from the called function
     */
    _callStringOrFunction: function _callStringOrFunction(stringOrFunction, args) {
        var result = null;

        if (!_lang2.default.isArray(args)) {
            args = [args];
        }

        if (_lang2.default.isString(stringOrFunction) && _lang2.default.isFunction(this[stringOrFunction])) {
            result = this[stringOrFunction].apply(this, args);
        } else if (_lang2.default.isFunction(stringOrFunction)) {
            result = stringOrFunction.apply(this, args);
        }

        return result;
    },

    /**
     * Initializes an attribute. Sets its default value depending on the flags of the
     * attribute and the passed configuration object to the constructor.
     *
     * @instance
     * @memberof Attribute
     * @method _init
     * @param {String} attr The name of the attribute which have to be initialized.
     * @protected
     */
    _init: function _init(attr) {
        var value;

        var currentAttr = this.constructor.ATTRS[attr];

        // Check if there is default value or passed one via configuration object
        var hasDefaultValue = Object.prototype.hasOwnProperty.call(currentAttr, 'value');
        var hasPassedValueViaConfig = Object.prototype.hasOwnProperty.call(this.__config__, attr);

        // If there is valueFn, set the value to be the result of invocation of this function
        if (currentAttr.valueFn) {
            value = this._callStringOrFunction(currentAttr.valueFn, value);

            this.__ATTRS__[attr] = value;
        }
        // else if the attribute has readOnly flag, set the default value from the attribute,
        // regardless if there is value or not
        else if (currentAttr.readOnly) {
                value = currentAttr.value;
            }
            // else if the attribute has writeOnce value, set it from the passed configuration or from the
            // default value, in this order. Otherwise, return miserable.
            else if (currentAttr.writeOnce) {
                    if (hasPassedValueViaConfig) {
                        value = this.__config__[attr];
                    } else if (hasDefaultValue) {
                        value = currentAttr.value;
                    } else {
                        return;
                    }
                }
                // These two cases below are easy - set the value to be from the passed config or
                // from the default value, in this order.
                else if (hasPassedValueViaConfig) {
                        value = this.__config__[attr];
                    } else if (hasDefaultValue) {
                        value = currentAttr.value;
                    }

        // If there is validator, and user passed config object - check the returned value.
        // If it is false, then set as initial value the default one.
        // However, if there is no default value, just return.
        if (currentAttr.validator && hasPassedValueViaConfig && !this._callStringOrFunction(currentAttr.validator, value)) {
            if (hasDefaultValue) {
                value = currentAttr.value;
            } else {
                return;
            }
        }

        // If there is setter and user passed config object - pass the value thought the setter.
        // The value might be one from defaultFn, default value or provided from the config.
        if (currentAttr.setter && hasPassedValueViaConfig) {
            value = this._callStringOrFunction(currentAttr.setter, value);
        }

        // Finally, set the value as initial value to the storage with values.
        this.__ATTRS__[attr] = value;
    },

    /**
     * Checks if an attribute is initialized. An attribute is considered as initialized
     * when there is an own property with this name in the local collection of attribute values
     * for the current instance.
     *
     * @instance
     * @memberof Attribute
     * @method _isInitialized
     * @param {String} attr The attribute which should be checked if it is initialized.
     * @protected
     * @return {Boolean} Returns true if the attribute has been initialized, false otherwise.
     */
    _isInitialized: function _isInitialized(attr) {
        return Object.prototype.hasOwnProperty.call(this.__ATTRS__, attr);
    }
};

exports.default = Attribute;

/***/ }),

/***/ "./src/oop/base.js":
/*!*************************!*\
  !*** ./src/oop/base.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _attribute = __webpack_require__(/*! ./attribute.js */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ./lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ./oop.js */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Quick and dirty impl of Base class.
 *
 * @class Base
 * @constructor
 */
function Base(config) {
    Base.superclass.constructor.call(this, config);

    this.init(config);
}

(0, _oop2.default)(Base, _attribute2.default, {
    /**
     * Calls the `initializer` method of each class which extends Base starting from the parent to the child.
     * Will pass the configuration object to each initializer method.
     *
     * @instance
     * @memberof Base
     * @method init
     * @param {Object} config Configuration object
     */
    init: function init(config) {
        this._callChain('initializer', config);
    },

    /**
     * Calls the `destructor` method of each class which extends Base starting from the parent to the child.
     *
     * @instance
     * @memberof Base
     * @method destroy
     */
    destroy: function destroy() {
        this._callChain('destructor');
    },

    /**
     * Calls a method of each class, which is being present in the hierarchy starting from parent to the child.
     *
     * @instance
     * @memberof Base
     * @method _callChain
     * @param {Object|Array} args The arguments with which the method should be invoked
     * @param {String} wat  The method, which should be invoked
     * @protected
     */
    _callChain: function _callChain(wat, args) {
        var arr = [];

        var ctor = this.constructor;

        while (ctor) {
            if (_lang2.default.isFunction(ctor.prototype[wat])) {
                arr.push(ctor.prototype[wat]);
            }

            ctor = ctor.superclass ? ctor.superclass.constructor : null;
        }

        arr = arr.reverse();

        args = _lang2.default.isArray(args) ? args : [args];

        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];

            item.apply(this, args);
        }
    }
});

exports.default = Base;

/***/ }),

/***/ "./src/oop/lang.js":
/*!*************************!*\
  !*** ./src/oop/lang.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Provides core language utilities.
 *
 * @class Lang
 */
var Lang = {
    /**
     * Check if the passed value is an array.
     *
     * @memberof Lang
     * @method isArray
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is an array, false otherwise.
     * @static
     */
    isArray: function isArray(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    },

    /**
     * Check if the passed value is boolean.
     *
     * @memberof Lang
     * @method isBoolean
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is boolean, false otherwise.
     * @static
     */
    isBoolean: function isBoolean(value) {
        return typeof value === 'boolean';
    },

    /**
     * Check if the passed value is a function.
     *
     * @memberof Lang
     * @method isFunction
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is a function, false otherwise.
     * @static
     */
    isFunction: function isFunction(value) {
        return typeof value === 'function';
    },

    /**
     * Check if the passed value is NULL.
     *
     * @memberof Lang
     * @method isNull
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is NULL, false otherwise.
     * @static
     */
    isNull: function isNull(value) {
        return value === null;
    },

    /**
     * Check if the passed value is number.
     *
     * @memberof Lang
     * @method isNumber
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is number, false otherwise.
     * @static
     */
    isNumber: function isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    },

    /**
     * Check if the passed value is an object
     *
     * @memberof Lang
     * @method isObject
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is an object, false otherwise.
     * @static
     */
    isObject: function isObject(value) {
        var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        return value && (valueType === 'object' || Lang.isFunction(value));
    },

    /**
     * Check if the passed value is a string.
     *
     * @memberof Lang
     * @method isString
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is a string, false otherwise.
     * @static
     */
    isString: function isString(value) {
        return typeof value === 'string';
    },

    /**
     * Adds all properties from the supplier to the receiver.
     * The function will add all properties, not only these owned by the supplier.
     *
     * @memberof Lang
     * @method mix
     * @param {Object} receiver The object which will receive properties.
     * @param {Object} supplier The object which provides properties.
     * @return {Object} The modified receiver.
     * @static
     */
    mix: function mix(receiver, supplier) {
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var key in supplier) {
            if (hasOwnProperty.call(supplier, key)) {
                receiver[key] = supplier[key];
            }
        }
    },

    /**
     * Converts value to Integer.
     *
     * @memberof Lang
     * @method toInt
     * @param {Any} value The value which have to be converted to Integer.
     * @return {Integer} The converted value.
     * @static
     */
    toInt: function toInt(value) {
        return parseInt(value, 10);
    }
};

exports.default = Lang;

/***/ }),

/***/ "./src/oop/oop.js":
/*!************************!*\
  !*** ./src/oop/oop.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the prototype, constructor and superclass properties to support an inheritance strategy
 * that can chain constructors and methods. Static members will not be inherited.
 *
 * @memberof OOP
 * @method extend
 * @param {Function} receiver The class which will extend another class.
 * @param {Function} supplier The class which will provide the properties the child class.
 * @param {Object} protoProps Prototype properties to add/override.
 * @param {Object} staticProps Static properties to add/overwrite.
 * @return {Function} The extended class.
 * @static
 */
var extend = function extend(receiver, supplier, protoProps, staticProps) {
    if (!supplier || !receiver) {
        throw 'extend failed, verify dependencies';
    }

    var supplierProto = supplier.prototype,
        receiverProto = Object.create(supplierProto);
    receiver.prototype = receiverProto;

    receiverProto.constructor = receiver;
    receiver.superclass = supplierProto;

    // assign constructor property
    if (supplier !== Object && supplierProto.constructor === Object.prototype.constructor) {
        supplierProto.constructor = supplier;
    }

    // add prototype overrides
    if (protoProps) {
        _lang2.default.mix(receiverProto, protoProps);
    }

    // add object overrides
    if (staticProps) {
        _lang2.default.mix(receiver, staticProps);
    }

    return receiver;
};

exports.default = extend;

/***/ }),

/***/ "./src/plugins/addimages.js":
/*!**********************************!*\
  !*** ./src/plugins/addimages.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    var isIE = CKEDITOR.env.ie;

    if (CKEDITOR.plugins.get('ae_addimages')) {
        return;
    }

    /**
     * CKEditor plugin which allows Drag&Drop of images directly into the editable area. The image will be encoded
     * as Data URI. An event `beforeImageAdd` will be fired with the list of dropped images. If any of the listeners
     * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
     * an event `imageAdd` will be fired with the inserted element into the editable area.
     *
     * @class CKEDITOR.plugins.ae_addimages
     */

    /**
     * Fired before adding images to the editor.
     *
     * @event CKEDITOR.plugins.ae_addimages#beforeImageAdd
     * @instance
     * @memberof CKEDITOR.plugins.ae_addimages
     * @param {Array} imageFiles Array of image files
     */

    /**
     * Fired when an image is being added to the editor successfully.
     *
     * @event CKEDITOR.plugins.ae_addimages#imageAdd
     * @instance
     * @memberof CKEDITOR.plugins.ae_addimages
     * @param {CKEDITOR.dom.element} el The created image with src as Data URI
     * @param {File} file The image file
     */

    CKEDITOR.plugins.add('ae_addimages', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'dragenter', 'dragover', 'drop' and `paste` events on the editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'dragenter', this._onDragEnter, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'dragover', this._onDragOver, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'drop', this._onDragDrop, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'paste', this._onPaste, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Accepts an array of dropped files to the editor. Then, it filters the images and sends them for further
         * processing to {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}}
         *
         * @fires CKEDITOR.plugins.ae_addimages#beforeImageAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _handleFiles
         * @param {Array} files Array of dropped files. Only the images from this list will be processed.
         * @param {Object} editor The current editor instance
         * @protected
         */
        _handleFiles: function _handleFiles(files, editor) {
            var file;
            var i;

            var imageFiles = [];

            for (i = 0; i < files.length; i++) {
                file = files[i];

                if (file.type.indexOf('image') === 0) {
                    imageFiles.push(file);
                }
            }

            var result = editor.fire('beforeImageAdd', {
                imageFiles: imageFiles
            });

            if (!!result) {
                for (i = 0; i < imageFiles.length; i++) {
                    file = imageFiles[i];

                    this._processFile(file, editor);
                }
            }

            return false;
        },

        /**
         * Handles drag drop event. The function will create a selection from the current
         * point and will send a list of files to be processed to
         * {{#crossLink "CKEDITOR.plugins.ae_addimages/_handleFiles:method"}}{{/crossLink}} method.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragDrop
         * @param {CKEDITOR.dom.event} event dragdrop event, as received natively from CKEditor
         * @protected
         */
        _onDragDrop: function _onDragDrop(event) {
            var nativeEvent = event.data.$;

            var transferFiles = nativeEvent.dataTransfer.files;

            if (transferFiles.length > 0) {
                new CKEDITOR.dom.event(nativeEvent).preventDefault();

                var editor = event.listenerData.editor;

                event.listenerData.editor.createSelectionFromPoint(nativeEvent.clientX, nativeEvent.clientY);

                this._handleFiles(transferFiles, editor);
            }
        },

        /**
         * Handles drag enter event. In case of IE, this function will prevent the event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragEnter
         * @param {DOM event} event dragenter event, as received natively from CKEditor
         * @protected
         */
        _onDragEnter: function _onDragEnter(event) {
            if (isIE) {
                this._preventEvent(event);
            }
        },

        /**
         * Handles drag over event. In case of IE, this function will prevent the event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragOver
         * @param {DOM event} event dragover event, as received natively from CKEditor
         * @protected
         */
        _onDragOver: function _onDragOver(event) {
            if (isIE) {
                this._preventEvent(event);
            }
        },

        /**
         * Checks if the pasted data is image and passes it to
         * {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}} for processing.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onPaste
         * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
         * @protected
         */
        _onPaste: function _onPaste(event) {
            if (event.data && event.data.$ && event.data.$.clipboardData && event.data.$.clipboardData.items && event.data.$.clipboardData.items.length > 0) {
                var pastedData = event.data.$.clipboardData.items[0];

                if (pastedData.type.indexOf('image') === 0) {
                    var imageFile = pastedData.getAsFile();

                    this._processFile(imageFile, event.listenerData.editor);
                }
            }
        },

        /**
         * Prevents a native event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _preventEvent
         * @param {DOM event} event The event to be prevented.
         * @protected
         */
        _preventEvent: function _preventEvent(event) {
            event = new CKEDITOR.dom.event(event.data.$);

            event.preventDefault();
            event.stopPropagation();
        },

        /**
         * Processes an image file. The function creates an img element and sets as source
         * a Data URI, then fires an 'imageAdd' event via CKEditor's event system.
         *
         * @fires CKEDITOR.plugins.ae_addimages#imageAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _preventEvent
         * @param {DOM event} event The event to be prevented.
         * @protected
         */
        _processFile: function _processFile(file, editor) {
            var reader = new FileReader();

            reader.addEventListener('loadend', function () {
                var bin = reader.result;

                var el = CKEDITOR.dom.element.createFromHtml('<img src="' + bin + '">');

                editor.insertElement(el);

                var imageData = {
                    el: el,
                    file: file
                };

                editor.fire('imageAdd', imageData);
            });

            reader.readAsDataURL(file);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/autolink.js":
/*!*********************************!*\
  !*** ./src/plugins/autolink.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_autolink')) {
        return;
    }

    // Disables the auto URL detection feature in IE, their lacks functionality:
    // They convert the links only on space. We do on space, comma, semicolon and Enter.
    if (/MSIE ([^;]*)|Trident.*; rv:([0-9.]+)/.test(navigator.userAgent)) {
        document.execCommand('AutoUrlDetect', false, false);
    }

    var KEY_BACK = 8;

    var KEY_COMMA = 188;

    var KEY_ENTER = 13;

    var KEY_SEMICOLON = 186;

    var KEY_SPACE = 32;

    var DELIMITERS = [KEY_COMMA, KEY_ENTER, KEY_SEMICOLON, KEY_SPACE];

    var REGEX_LAST_WORD = /[^\s]+/gim;

    var REGEX_URL = /((([A - Za - z]{ 3, 9}: (?: \/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(https?\:\/\/|www.|[-;:&=.\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))((.*):(\d*)\/?(.*))?)/i;

    var REGEX_EMAIL = /[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}/i;

    /**
     * CKEditor plugin which automatically generates links when user types text which looks like URL.
     *
     * @class CKEDITOR.plugins.ae_autolink
     * @constructor
     */
    CKEDITOR.plugins.add('ae_autolink', {

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers the `keyup` event on the editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'keyup', this._onKeyUp, this, {
                    editor: editor
                });
            }.bind(this));

            editor.on('paste', function (event) {
                if (event.data.method === 'paste') {

                    if (event.data.dataValue.indexOf('<') > -1 || event.data.dataValue.indexOf('&lt;') > -1) {
                        if (event.data.dataValue.indexOf('<u><font color=\"') > -1) {
                            event.data.dataValue = event.data.dataValue.replace(/<u><font color=\"#(.*?)\">|<\/font><\/u>/g, '');
                        }
                        return;
                    }

                    var instance = this;

                    event.data.dataValue = event.data.dataValue.replace(RegExp(REGEX_URL, 'gim'), function (url) {
                        if (instance._isValidURL(url)) {
                            if (instance._isValidEmail(url)) {
                                return '<a href=\"mailto:' + url + '\">' + url + '</a>';
                            } else {
                                return '<a href=\"' + url + '\">' + url + '</a>';
                            }
                        }
                    });
                }
            }.bind(this));
        },

        /**
         * Retrieves the last word introduced by the user. Reads from the current
         * caret position backwards until it finds the first white space.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _getLastWord
         * @protected
         * @return {String} The last word introduced by user
         */
        _getLastWord: function _getLastWord(editor) {
            var range = editor.getSelection().getRanges()[0];

            var offset = range.startOffset;

            var previousText = '';

            // The user pressed Enter, so we have to look on the previous node
            if (this._currentKeyCode === KEY_ENTER) {
                var previousNode = range.startContainer.getPrevious();

                var lastChild;

                if (previousNode) {
                    // If previous node is a SPACE, (it does not have 'getLast' method),
                    // ignore it and find the previous text node
                    while (!previousNode.getLast) {
                        previousNode = previousNode.getPrevious();
                    }

                    lastChild = previousNode.getLast();

                    // Depending on the browser, the last child node may be a <BR>
                    // (which does not have 'getText' method),
                    // so ignore it and find the previous text node
                    while (lastChild && !lastChild.getText()) {
                        lastChild = lastChild.getPrevious();
                    }
                }

                // Check if the lastChild is already a link
                if (!(lastChild && lastChild.$.href)) {
                    this._startContainer = lastChild;
                    previousText = lastChild ? lastChild.getText() : '';
                    this._offset = previousText.length;
                }
            } else {
                this._startContainer = range.startContainer;

                // Last character is the delimiter, ignore it
                previousText = this._startContainer.getText().substring(0, offset - 1);

                this._offset = offset - 1;
            }

            var lastWord = '';

            var match = previousText.match(REGEX_LAST_WORD);

            if (match) {
                lastWord = match.pop();
            }

            return lastWord;
        },

        /**
         * Checks if the given link is a valid Email.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method isValidEmail
         * @param {String} link The email we want to know if it is a valid Email
         * @protected
         * @return {Boolean} Returns true if the email is a valid Email, false otherwise
         */
        _isValidEmail: function _isValidEmail(email) {
            return REGEX_EMAIL.test(email);
        },

        /**
         * Checks if the given link is a valid URL.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method isValidURL
         * @param {String} link The link we want to know if it is a valid URL
         * @protected
         * @return {Boolean} Returns true if the link is a valid URL, false otherwise
         */
        _isValidURL: function _isValidURL(link) {
            return REGEX_URL.test(link);
        },

        /**
         * Listens to the `keydown` event and if the keycode is `Backspace`, removes the previously
         * created link.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _onKeyDown
         * @param {EventFacade} event EventFacade object
         * @protected
         */
        _onKeyDown: function _onKeyDown(event) {
            var nativeEvent = event.data.$;

            var editor = event.listenerData.editor;

            var editable = editor.editable();

            editable.removeListener('keydown', this._onKeyDown);

            if (nativeEvent.keyCode === KEY_BACK) {
                event.cancel();
                event.data.preventDefault();

                this._removeLink(editor);
            }

            this._ckLink = null;
        },

        /**
         * Listens to the `Enter` and `Space` key events in order to check if the last word
         * introduced by the user should be replaced by a link element.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _onKeyUp
         * @param {EventFacade} event EventFacade object
         * @protected
         */
        _onKeyUp: function _onKeyUp(event) {
            var nativeEvent = event.data.$;

            this._currentKeyCode = nativeEvent.keyCode;

            if (DELIMITERS.indexOf(this._currentKeyCode) !== -1) {
                var editor = event.listenerData.editor;

                var lastWord = this._getLastWord(editor);

                if (this._isValidURL(lastWord)) {
                    this._replaceContentByLink(editor, lastWord);
                }
            }
        },

        /**
         * Replaces content by a link element.
         *
         * @fires CKEDITOR.plugins.ae_autolink#autolinkAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _replaceContentByLink
         * @param {String} content The text that has to be replaced by an link element
         * @protected
         */
        _replaceContentByLink: function _replaceContentByLink(editor, content) {
            var range = editor.createRange();
            var node = CKEDITOR.dom.element.get(this._startContainer);
            var offset = this._offset;

            // Select the content, so CKEDITOR.Link can properly replace it
            range.setStart(node, offset - content.length);
            range.setEnd(node, offset);
            range.select();

            var ckLink = new CKEDITOR.Link(editor);
            ckLink.create(content);
            this._ckLink = ckLink;

            var linkNode = ckLink.getFromSelection();
            editor.fire('autolinkAdd', linkNode);

            this._subscribeToKeyEvent(editor);

            // Now range is on the link and it is selected. We have to
            // return focus to the caret position.
            range = editor.getSelection().getRanges()[0];

            // If user pressed `Enter`, get the next editable node at position 0,
            // otherwise set the cursor at the next character of the link (the white space)
            if (this._currentKeyCode === KEY_ENTER) {
                var nextEditableNode = range.getNextEditableNode();

                range.setStart(nextEditableNode, 0);
                range.setEnd(nextEditableNode, 0);
            } else {
                var nextNode = range.getNextNode();

                range.setStart(nextNode, 1);
                range.setEnd(nextNode, 1);
            }

            range.select();
        },

        /**
         * Fired when a URL is detected in text and converted to a link.
         *
         * @event CKEDITOR.plugins.ae_autolink#autolinkAdd
         * @memberof CKEDITOR.plugins.ae_autolink
         * @param {CKEDITOR.dom.element} el Node of the created link.
         */

        /**
         * Removes the created link element, and replaces it by its text.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _removeLink
         * @protected
         */
        _removeLink: function _removeLink(editor) {
            var range = editor.getSelection().getRanges()[0];
            var caretOffset = range.startOffset;

            // Select the link, so CKEDITOR.Link can properly remove it
            var linkNode = this._startContainer.getNext() || this._startContainer;

            var newRange = editor.createRange();
            newRange.setStart(linkNode, 0);
            newRange.setEndAfter(linkNode);
            newRange.select();

            this._ckLink.remove();

            // Return focus to the caret position
            range.setEnd(range.startContainer, caretOffset);
            range.setStart(range.startContainer, caretOffset);

            range.select();
        },

        /**
         * Subscribe to a key event of the editable aria.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _subscribeToKeyEvent
         * @protected
         */
        _subscribeToKeyEvent: function _subscribeToKeyEvent(editor) {
            var editable = editor.editable();

            // Change the priority of keydown listener - 1 means the highest priority.
            // In Chrome on pressing `Enter` the listener is not being invoked.
            // See http://dev.ckeditor.com/ticket/11861 for more information.
            editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
                editor: editor
            }, 1);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/autolist.js":
/*!*********************************!*\
  !*** ./src/plugins/autolist.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_autolist')) {
        return;
    }

    var KEY_BACK = 8;

    var KEY_SPACE = 32;

    var DEFAULT_CONFIG = [{
        regex: /^\*$/,
        type: 'bulletedlist'
    }, {
        regex: /^1\.$/,
        type: 'numberedlist'
    }];

    /**
        * CKEditor plugin which automatically generates ordered/unordered list when user types text which looks like a list.
        *
        * @class CKEDITOR.plugins.ae_autolist
        * @constructor
        */
    CKEDITOR.plugins.add('ae_autolist', {

        /**
         * Initialization of the plugin, part of CKeditor plugin lifecycle.
         * The function registers the `keydown` event on the content editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Checks for pressing the `Backspace` key in order to undo the list creation.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method _checkForBackspaceAndUndo
         * @param {Event} event Event object
         * @protected
         */
        _checkForBackspaceAndUndo: function _checkForBackspaceAndUndo(event) {
            var editor = event.listenerData.editor;

            var nativeEvent = event.data.$;

            var editable = editor.editable();

            editable.removeListener('keydown', this._checkForBackspaceAndUndo);

            if (nativeEvent.keyCode === KEY_BACK) {
                editor.execCommand('undo');
                editor.insertHtml(event.listenerData.bullet + '&nbsp;');
                event.data.preventDefault();
            }
        },

        /**
         * Checks current line to find match with MATCHES object to create OL or UL.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method _checkLine
         * @param {editor} Editor object
         * @protected
         * @return {Object|null} Returns an object which contains the detected list config if any
         */
        _getListConfig: function _getListConfig(editor) {
            var configRegex = editor.config.autolist || DEFAULT_CONFIG;

            var range = editor.getSelection().getRanges()[0];

            var textContainer = range.endContainer.getText();

            var bullet = textContainer.substring(0, range.startOffset);

            var text = textContainer.substring(range.startOffset, textContainer.length);

            var index = 0;

            var regexLen = configRegex.length;

            var autolistCfg = null;

            while (!autolistCfg && regexLen > index) {
                var regexItem = configRegex[index];

                if (regexItem.regex.test(bullet)) {
                    autolistCfg = {
                        bullet: bullet,
                        editor: editor,
                        text: text,
                        type: regexItem.type
                    };

                    break;
                }

                index++;
            }

            return autolistCfg;
        },

        /**
                  * Create list with different types: Bulleted or Numbered list
                  *
                  * @instance
                  * @memberof CKEDITOR.plugins.ae_autolist
                  * @method _createList
                  * @param {Object} listConfig Object that contains bullet, text and type for creating the list
                  * @protected
         */
        _createList: function _createList(listConfig) {
            var editor = listConfig.editor;

            var range = editor.getSelection().getRanges()[0];

            range.endContainer.setText(listConfig.text);
            editor.execCommand(listConfig.type);

            var editable = editor.editable();

            // Subscribe to keydown in order to check if the next key press is `Backspace`.
            // If so, the creation of the list will be discarded.
            editable.attachListener(editable, 'keydown', this._checkForBackspaceAndUndo, this, {
                editor: editor,
                bullet: listConfig.bullet
            }, 1);
        },

        /**
                  * Listens to the `Space` key events to check if the last word
                  * introduced by the user should be replaced by a list (OL or UL)
                  *
                  * @instance
                  * @memberof CKEDITOR.plugins.ae_autolist
                  * @method _onKeyDown
                  * @param {Event} event Event object
                  * @protected
                  */
        _onKeyDown: function _onKeyDown(event) {
            var nativeEvent = event.data.$;

            if (nativeEvent.keyCode === KEY_SPACE) {
                var listConfig = this._getListConfig(event.listenerData.editor);

                if (listConfig) {
                    event.data.preventDefault();
                    this._createList(listConfig);
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/dragresize.js":
/*!***********************************!*\
  !*** ./src/plugins/dragresize.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Dragable image resizing
 * https://github.com/sstur/ck-dragresize
 * - Shows semi-transparent overlay while resizing
 * - Enforces Aspect Ratio (unless holding shift)
 * - Snap to size of other images in editor
 * - Escape while dragging cancels resize
 */
(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_dragresize')) {
        return;
    }

    var IMAGE_HANDLES = {
        both: ['tl', 'tm', 'tr', 'lm', 'rm', 'bl', 'bm', 'br'],
        height: ['tl', 'tm', 'tr', 'bl', 'bm', 'br'],
        scale: ['tl', 'tr', 'bl', 'br'],
        width: ['tl', 'tr', 'lm', 'rm', 'bl', 'br']
    };

    var POSITION_ELEMENT_FN = {
        bl: function bl(handle, left, top, box) {
            positionElement(handle, -3 + left, box.height - 4 + top);
        },
        bm: function bm(handle, left, top, box) {
            positionElement(handle, Math.round(box.width / 2) - 3 + left, box.height - 4 + top);
        },
        br: function br(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, box.height - 4 + top);
        },
        lm: function lm(handle, left, top, box) {
            positionElement(handle, -3 + left, Math.round(box.height / 2) - 3 + top);
        },
        tl: function tl(handle, left, top, box) {
            positionElement(handle, left - 3, top - 3);
        },
        tm: function tm(handle, left, top, box) {
            positionElement(handle, Math.round(box.width / 2) - 3 + left, -3 + top);
        },
        tr: function tr(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, -3 + top);
        },
        rm: function rm(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
        }
    };

    var IMAGE_SNAP_TO_SIZE = 7;

    var isFirefox = 'MozAppearance' in document.documentElement.style;

    var isWebKit = 'WebkitAppearance' in document.documentElement.style;

    var enablePlugin = isWebKit || isFirefox;

    if (enablePlugin) {
        // CSS is added in a compressed form
        CKEDITOR.addCss('img::selection{color:rgba(0,0,0,0)}img.ckimgrsz{outline:1px dashed #000}#ckimgrsz{position:absolute;width:0;height:0;cursor:default;z-index:10001}#ckimgrsz span{display:none;position:absolute;top:0;left:0;width:0;height:0;background-size:100% 100%;opacity:.65;outline:1px dashed #000}#ckimgrsz i{position:absolute;display:block;width:5px;height:5px;background:#fff;border:1px solid #000}#ckimgrsz i.active,#ckimgrsz i:hover{background:#000}#ckimgrsz i.br,#ckimgrsz i.tl{cursor:nwse-resize}#ckimgrsz i.bm,#ckimgrsz i.tm{cursor:ns-resize}#ckimgrsz i.bl,#ckimgrsz i.tr{cursor:nesw-resize}#ckimgrsz i.lm,#ckimgrsz i.rm{cursor:ew-resize}body.dragging-br,body.dragging-br *,body.dragging-tl,body.dragging-tl *{cursor:nwse-resize!important}body.dragging-bm,body.dragging-bm *,body.dragging-tm,body.dragging-tm *{cursor:ns-resize!important}body.dragging-bl,body.dragging-bl *,body.dragging-tr,body.dragging-tr *{cursor:nesw-resize!important}body.dragging-lm,body.dragging-lm *,body.dragging-rm,body.dragging-rm *{cursor:ew-resize!important}');
    }

    /**
     * Initializes the plugin
     */
    CKEDITOR.plugins.add('ae_dragresize', {
        onLoad: function onLoad() {
            if (!enablePlugin) {
                return;
            }
        },
        init: function init(editor) {
            if (!enablePlugin) {
                return;
            }

            editor.once('contentDom', function (evt) {
                _init(editor);
            });
        }
    });

    function _init(editor) {
        var window = editor.window.$,
            document = editor.document.$;

        if (isFirefox) {
            // Disable the native image resizing
            document.execCommand('enableObjectResizing', false, false);
        }

        var snapToSize = typeof IMAGE_SNAP_TO_SIZE === 'undefined' ? null : IMAGE_SNAP_TO_SIZE;

        editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

        var resizer = new Resizer(editor, {
            imageScaleResize: editor.config.imageScaleResize,
            snapToSize: snapToSize
        });

        var mouseDownListener = function mouseDownListener(e) {
            if (resizer.isHandle(e.target)) {
                resizer.initDrag(e);
            }
        };

        document.addEventListener('mousedown', mouseDownListener, false);

        function selectionChange() {
            var selection = editor.getSelection();

            if (!selection) return;
            // If an element is selected and that element is an IMG
            if (selection.getType() !== CKEDITOR.SELECTION_NONE && selection.getStartElement().is('img')) {
                // And we're not right or middle clicking on the image
                if (!window.event || !window.event.button || window.event.button === 0) {
                    resizer.show(selection.getStartElement().$);
                }
            } else {
                resizer.hide();
            }
        }

        editor.on('selectionChange', selectionChange);

        editor.on('getData', function (e) {
            var html = e.data.dataValue || '';
            html = html.replace(/<div id="ckimgrsz"([\s\S]*?)<\/div>/i, '');
            html = html.replace(/\b(ckimgrsz)\b/g, '');
            e.data.dataValue = html;
        });

        editor.on('beforeUndoImage', function () {
            // Remove the handles before undo images are saved
            resizer.hide();
        });

        editor.on('afterUndoImage', function () {
            // Restore the handles after undo images are saved
            selectionChange();
        });

        editor.on('blur', function () {
            // Remove the handles when editor loses focus
            resizer.hide();
        });

        editor.on('beforeModeUnload', function self() {
            editor.removeListener('beforeModeUnload', self);
            resizer.hide();
        });

        editor.on('destroy', function () {
            var resizeElement = document.getElementById('ckimgrsz');

            if (resizeElement) {
                resizeElement.remove();
            }

            if (isFirefox) {
                document.execCommand('enableObjectResizing', false, true);
            }

            document.removeEventListener('mousedown', mouseDownListener);
        });

        // Update the selection when the browser window is resized
        var resizeTimeout;
        editor.window.on('resize', function () {
            // Cancel any resize waiting to happen
            clearTimeout(resizeTimeout);
            // Delay resize to "debounce"
            resizeTimeout = setTimeout(selectionChange, 50);
        });
    }

    function Resizer(editor, cfg) {
        this.editor = editor;
        this.window = editor.window.$;
        this.document = editor.document.$;
        this.cfg = cfg || {};
        this.init();
    }

    Resizer.prototype = {
        init: function init() {
            var instance = this;

            var container = this.container = this.document.createElement('div');

            container.id = 'ckimgrsz';
            this.preview = this.document.createElement('span');
            container.appendChild(this.preview);

            var handles = this.handles = {};

            IMAGE_HANDLES[this.cfg.imageScaleResize].forEach(function (handleName, index) {
                handles[handleName] = instance.handles[handleName] = instance.createHandle(handleName);
            });

            for (var n in handles) {
                container.appendChild(handles[n]);
            }
        },
        createHandle: function createHandle(name) {
            var el = this.document.createElement('i');
            el.classList.add(name);
            return el;
        },
        isHandle: function isHandle(el) {
            var handles = this.handles;
            for (var n in handles) {
                if (handles[n] === el) {
                    return true;
                }
            }
            return false;
        },
        show: function show(el) {
            var uiNode = this.editor.config.uiNode;

            var scrollTop = uiNode ? uiNode.scrollTop : 0;

            this.el = el;
            if (this.cfg.snapToSize) {
                this.otherImages = toArray(this.document.getElementsByTagName('img'));
                this.otherImages.splice(this.otherImages.indexOf(el), 1);
            }
            var box = this.box = getBoundingBox(this.window, el);
            positionElement(this.container, box.left, box.top + scrollTop);

            uiNode = uiNode || document.body;

            uiNode.appendChild(this.container);

            this.el.classList.add('ckimgrsz');
            this.showHandles();
        },
        hide: function hide() {
            // Remove class from all img.ckimgrsz
            var elements = this.document.getElementsByClassName('ckimgrsz');
            for (var i = 0; i < elements.length; ++i) {
                elements[i].classList.remove('ckimgrsz');
            }
            this.hideHandles();
            if (this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
            }
        },
        initDrag: function initDrag(e) {
            if (e.button !== 0) {
                //right-click or middle-click
                return;
            }
            var resizer = this;
            var drag = new DragEvent(this.window, this.document);
            drag.onStart = function () {
                resizer.showPreview();
                resizer.isDragging = true;
                resizer.editor.getSelection().lock();
            };
            drag.onDrag = function () {
                resizer.calculateSize(this);
                resizer.updatePreview();
                var box = resizer.previewBox;
                resizer.updateHandles(box, box.left, box.top);
            };
            drag.onRelease = function () {
                resizer.isDragging = false;
                resizer.hidePreview();
                resizer.hide();
                resizer.editor.getSelection().unlock();
                // Save an undo snapshot before the image is permanently changed
                resizer.editor.fire('saveSnapshot');
            };
            drag.onComplete = function () {
                resizer.resizeComplete();
                // Save another snapshot after the image is changed
                resizer.editor.fire('saveSnapshot');
            };
            drag.start(e);
        },
        updateHandles: function updateHandles(box, left, top) {
            left = left || 0;
            top = top || 0;
            var handles = this.handles;

            for (var handle in handles) {
                POSITION_ELEMENT_FN[handle](handles[handle], left, top, box);
            }
        },
        showHandles: function showHandles() {
            var handles = this.handles;
            this.updateHandles(this.box);
            for (var n in handles) {
                handles[n].style.display = 'block';
            }
        },
        hideHandles: function hideHandles() {
            var handles = this.handles;
            for (var n in handles) {
                handles[n].style.display = 'none';
            }
        },
        showPreview: function showPreview() {
            this.preview.style.backgroundImage = 'url("' + this.el.src + '")';
            this.calculateSize();
            this.updatePreview();
            this.preview.style.display = 'block';
        },
        updatePreview: function updatePreview() {
            var box = this.previewBox;
            positionElement(this.preview, box.left, box.top);
            this.preview.style.width = this.previewBox.width + 'px';
            this.preview.style.height = this.previewBox.height + 'px';
        },
        hidePreview: function hidePreview() {
            var box = getBoundingBox(this.window, this.preview);
            this.result = {
                width: box.width,
                height: box.height
            };
            this.preview.style.display = 'none';
        },
        calculateSize: function calculateSize(data) {
            var box = this.previewBox = {
                top: 0,
                left: 0,
                width: this.box.width,
                height: this.box.height
            };

            if (!data) return;

            var attr = data.target.className;

            if (~attr.indexOf('r')) {
                box.width = Math.max(32, this.box.width + data.delta.x);
            }
            if (~attr.indexOf('b')) {
                box.height = Math.max(32, this.box.height + data.delta.y);
            }
            if (~attr.indexOf('l')) {
                box.width = Math.max(32, this.box.width - data.delta.x);
            }
            if (~attr.indexOf('t')) {
                box.height = Math.max(32, this.box.height - data.delta.y);
            }
            //if dragging corner, enforce aspect ratio (unless shift key is being held)
            if (attr.indexOf('m') < 0 && !data.keys.shift) {
                var ratio = this.box.width / this.box.height;
                if (box.width / box.height > ratio) {
                    box.height = Math.round(box.width / ratio);
                } else {
                    box.width = Math.round(box.height * ratio);
                }
            }

            var snapToSize = this.cfg.snapToSize;

            if (snapToSize) {
                var others = this.otherImages;
                for (var i = 0; i < others.length; i++) {
                    var other = getBoundingBox(this.window, others[i]);
                    if (Math.abs(box.width - other.width) <= snapToSize && Math.abs(box.height - other.height) <= snapToSize) {
                        box.width = other.width;
                        box.height = other.height;
                        break;
                    }
                }
            }

            //recalculate left or top position
            if (~attr.indexOf('l')) {
                box.left = this.box.width - box.width;
            }
            if (~attr.indexOf('t')) {
                box.top = this.box.height - box.height;
            }
        },
        resizeComplete: function resizeComplete() {
            resizeElement.call(this, this.el, this.result.width, this.result.height);
        }
    };

    function DragEvent(window, document) {
        this.window = window;
        this.document = document;
        this.events = {
            mousemove: bind(this.mousemove, this),
            keydown: bind(this.keydown, this),
            mouseup: bind(this.mouseup, this)
        };
    }

    DragEvent.prototype = {
        start: function start(e) {
            e.preventDefault();
            e.stopPropagation();
            this.target = e.target;
            this.attr = e.target.className;
            this.startPos = {
                x: e.clientX,
                y: e.clientY
            };
            this.update(e);
            var events = this.events;
            this.document.addEventListener('mousemove', events.mousemove, false);
            this.document.addEventListener('keydown', events.keydown, false);
            this.document.addEventListener('mouseup', events.mouseup, false);
            this.document.body.classList.add('dragging-' + this.attr);
            this.onStart && this.onStart();
        },
        update: function update(e) {
            this.currentPos = {
                x: e.clientX,
                y: e.clientY
            };
            this.delta = {
                x: e.clientX - this.startPos.x,
                y: e.clientY - this.startPos.y
            };
            this.keys = {
                shift: e.shiftKey,
                ctrl: e.ctrlKey,
                alt: e.altKey
            };
        },
        mousemove: function mousemove(e) {
            this.update(e);
            this.onDrag && this.onDrag();
            if (e.which === 0) {
                //mouse button released outside window; mouseup wasn't fired (Chrome)
                this.mouseup(e);
            }
        },
        keydown: function keydown(e) {
            //escape key cancels dragging
            if (e.keyCode === 27) {
                this.release();
            }
        },
        mouseup: function mouseup(e) {
            this.update(e);
            this.release();
            this.onComplete && this.onComplete();
        },
        release: function release() {
            this.document.body.classList.remove('dragging-' + this.attr);
            var events = this.events;
            this.document.removeEventListener('mousemove', events.mousemove, false);
            this.document.removeEventListener('keydown', events.keydown, false);
            this.document.removeEventListener('mouseup', events.mouseup, false);
            this.onRelease && this.onRelease();
        }
    };

    //helper functions
    function toArray(obj) {
        var len = obj.length,
            arr = new Array(len);
        for (var i = 0; i < len; i++) {
            arr[i] = obj[i];
        }
        return arr;
    }

    function bind(fn, ctx) {
        if (fn.bind) {
            return fn.bind(ctx);
        }
        return function () {
            fn.apply(ctx, arguments);
        };
    }

    function positionElement(el, left, top) {
        el.style.left = String(left) + 'px';
        el.style.top = String(top) + 'px';
    }

    function resizeElement(el, width, height) {
        var imageScaleResize = this.editor.config.imageScaleResize;
        if (imageScaleResize === 'both') {
            el.style.width = String(width) + 'px';
            el.style.height = String(height) + 'px';
        } else if (imageScaleResize === 'width' || imageScaleResize === 'scale') {
            el.style.height = 'auto';
            el.style.width = String(width) + 'px';
        } else if (imageScaleResize === 'height') {
            el.style.height = String(height) + 'px';
            el.style.width = 'auto';
        }
    }

    function getBoundingBox(window, el) {
        var rect = el.getBoundingClientRect();
        return {
            left: rect.left + window.pageXOffset,
            top: rect.top + window.pageYOffset,
            width: rect.width,
            height: rect.height
        };
    }
})();

/***/ }),

/***/ "./src/plugins/dragresize_ie.js":
/*!**************************************!*\
  !*** ./src/plugins/dragresize_ie.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Image2
 * - Show gripper to resize images on IE
 */
(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_dragresize_ie')) {
        return;
    }

    var alignmentsObj = {
        center: 1,
        left: 0,
        right: 2
    };

    /*
     * Set cursor css depend on imageScaleResize config
     **/

    var cursor = {
        both: 'nwse-resize',
        height: 'ns-resize',
        scale: 'nwse-resize',
        width: 'ew-resize'
    };

    var regexPercent = /^\s*(\d+\%)\s*$/i;

    var template = '<img alt="" src="" />';

    CKEDITOR.plugins.add('ae_dragresize_ie', {
        hidpi: true,

        icons: 'image',

        init: function init(editor) {
            var image = widgetDef(editor);

            // Register the widget.
            editor.widgets.add('image', image);
        },

        onLoad: function onLoad() {
            CKEDITOR.addCss('.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ns-resize{' + 'cursor: ns-resize;' + '}' + '.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ew-resize{' + 'cursor: ew-resize;' + '}' + '.cke_image_nocaption{' +
            // This is to remove unwanted space so resize
            // wrapper is displayed property.
            'line-height:0' + '}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'bottom:-5px;' + 'right:-5px;' + 'background:#000;' + 'outline:1px solid #fff;' +
            // Prevent drag handler from being misplaced (#11207).
            'line-height:0;' + 'cursor:nwse-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizer.cke_image_resizing{' + 'display:block' + '}');
        },

        requires: 'widget'
    });

    // Wiget states (forms) depending on alignment and configuration.
    //
    // Non-captioned widget (inline styles)
    // 		┌──────┬───────────────────────────────┬─────────────────────────────┐
    // 		│Align │Internal form                  │Data                         │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│none  │<wrapper>                      │<img />                      │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│left  │<wrapper style=”float:left”>   │<img style=”float:left” />   │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│center│<wrapper>                      │<p style=”text-align:center”>│
    // 		│      │ <p style=”text-align:center”> │  <img />                    │
    // 		│      │   <img />                     │</p>                         │
    // 		│      │ </p>                          │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│right │<wrapper style=”float:right”>  │<img style=”float:right” />  │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		└──────┴───────────────────────────────┴─────────────────────────────┘
    //
    // Non-captioned widget (config.image2_alignClasses defined)
    // 		┌──────┬───────────────────────────────┬─────────────────────────────┐
    // 		│Align │Internal form                  │Data                         │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│none  │<wrapper>                      │<img />                      │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│left  │<wrapper class=”left”>         │<img class=”left” />         │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│center│<wrapper>                      │<p class=”center”>           │
    // 		│      │ <p class=”center”>            │ <img />                     │
    // 		│      │   <img />                     │</p>                         │
    // 		│      │ </p>                          │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│right │<wrapper class=”right”>        │<img class=”right” />        │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		└──────┴───────────────────────────────┴─────────────────────────────┘
    //
    // Captioned widget (inline styles)
    // 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
    // 		│Align │Internal form                           │Data                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│none  │<wrapper>                               │<figure />                              │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│left  │<wrapper style=”float:left”>            │<figure style=”float:left” />           │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│center│<wrapper style=”text-align:center”>     │<div style=”text-align:center”>         │
    // 		│      │ <figure style=”display:inline-block” />│ <figure style=”display:inline-block” />│
    // 		│      │</wrapper>                              │</p>                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│right │<wrapper style=”float:right”>           │<figure style=”float:right” />          │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
    //
    // Captioned widget (config.image2_alignClasses defined)
    // 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
    // 		│Align │Internal form                           │Data                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│none  │<wrapper>                               │<figure />                              │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│left  │<wrapper class=”left”>                  │<figure class=”left” />                 │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│center│<wrapper class=”center”>                │<div class=”center”>                    │
    // 		│      │ <figure />                             │ <figure />                             │
    // 		│      │</wrapper>                              │</p>                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│right │<wrapper class=”right”>                 │<figure class=”right” />                │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function widgetDef(editor) {
        editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

        editor.on('imageAdd', function (imageData) {
            editor.widgets.initOn(imageData.data.el, 'image');
        });

        var alignClasses = editor.config.image2_alignClasses;

        var captionedClass = editor.config.image2_captionedClass;

        return {
            init: function init() {
                var helpers = CKEDITOR.plugins.image2;

                var image = this.parts.image;

                var data = {
                    alt: image.getAttribute('alt') || '',
                    hasCaption: !!this.parts.caption,
                    height: image.getAttribute('height') || '',
                    // Lock ratio is on by default (#10833).
                    lock: this.ready ? helpers.checkHasNaturalRatio(image) : true,
                    src: image.getAttribute('src'),
                    width: image.getAttribute('width') || ''
                };

                // If we used 'a' in widget#parts definition, it could happen that
                // selected element is a child of widget.parts#caption. Since there's no clever
                // way to solve it with CSS selectors, it's done like that. (#11783).
                var link = image.getAscendant('a');

                if (link && this.wrapper.contains(link)) {
                    this.parts.link = link;
                }

                // Depending on configuration, read style/class from element and
                // then remove it. Removed style/class will be set on wrapper in #data listener.
                // Note: Center alignment is detected during upcast, so only left/right cases
                // are checked below.
                if (!data.align) {
                    var alignElement = data.hasCaption ? this.element : image;

                    // Read the initial left/right alignment from the class set on element.
                    if (alignClasses) {
                        if (alignElement.hasClass(alignClasses[0])) {
                            data.align = 'left';
                        } else if (alignElement.hasClass(alignClasses[2])) {
                            data.align = 'right';
                        }

                        if (data.align) {
                            alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
                        } else {
                            data.align = 'none';
                        }
                    }
                    // Read initial float style from figure/image and then remove it.
                    else {
                            data.align = alignElement.getStyle('float') || 'none';
                            alignElement.removeStyle('float');
                        }
                }

                // Get rid of extra vertical space when there's no caption.
                // It will improve the look of the resizer.
                this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

                this.setData(data);

                if (editor.config.image2_disableResizer !== true) {
                    setupResizer(this);
                }
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#addClass
            addClass: function addClass(className) {
                getStyleableElement(this).addClass(className);
            },

            allowedContent: getWidgetAllowedContent(editor),

            // This widget converts style-driven dimensions to attributes.
            contentTransformations: [['img[width]: sizeToAttribute']],

            data: function data() {
                var features = this.features;

                // Image can't be captioned when figcaption is disallowed (#11004).
                if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) {
                    this.data.hasCaption = false;
                }

                // Image can't be aligned when floating is disallowed (#11004).
                if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) {
                    this.data.align = 'none';
                }

                // Update widget.parts.link since it will not auto-update unless widget
                // is destroyed and re-inited.
                if (!this.data.link) {
                    if (this.parts.link) {
                        delete this.parts.link;
                    }
                } else {
                    if (!this.parts.link) {
                        this.parts.link = this.parts.image.getParent();
                    }
                }

                this.parts.image.setAttributes({
                    alt: this.data.alt,

                    contenteditable: this.parts.image.getAttribute('contenteditable') ? this.parts.image.getAttribute('contenteditable') : true,

                    // This internal is required by the editor.
                    'data-cke-saved-src': this.data.src,

                    src: this.data.src
                });

                // If shifting non-captioned -> captioned, remove classes
                // related to styles from <img/>.
                if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
                    for (var c in this.data.classes) {
                        this.parts.image.removeClass(c);
                    }
                }

                // Set dimensions of the image according to gathered data.
                // Do it only when the attributes are allowed (#11004).
                if (editor.filter.checkFeature(features.dimension)) {
                    setDimensions(this);
                }

                // Cache current data.
                this.oldData = CKEDITOR.tools.extend({}, this.data);
            },

            downcast: downcastWidgetElement(editor),

            draggable: false,

            // This widget has an editable caption.
            editables: {
                caption: {
                    selector: 'figcaption',
                    allowedContent: 'br em strong sub sup u s; a[!href,target]'
                }
            },

            features: getWidgetFeatures(editor),

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#getClasses
            getClasses: function () {
                var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

                return function () {
                    var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

                    // Neither config.image2_captionedClass nor config.image2_alignClasses
                    // do not belong to style classes.
                    for (var c in classes) {
                        if (classRegex.test(c)) {
                            delete classes[c];
                        }
                    }

                    return classes;
                };
            }(),

            getLabel: function getLabel() {
                var label = (this.data.alt || '') + ' ' + this.pathName;

                return label;
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#hasClass
            hasClass: function hasClass(className) {
                return getStyleableElement(this).hasClass(className);
            },

            parts: {
                caption: 'figcaption',
                image: 'img'
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#removeClass
            removeClass: function removeClass(className) {
                getStyleableElement(this).removeClass(className);
            },

            requiredContent: 'img[src,alt]',

            styleableElements: 'img figure',

            // Template of the widget: plain image.
            template: template,

            upcast: upcastWidgetElement(editor)
        };
    }

    /**
     * A set of Enhanced Image (image2) plugin helpers.
     *
     * @class
     * @singleton
     */
    CKEDITOR.plugins.image2 = {
        /**
         * Checks whether the current image ratio matches the natural one
         * by comparing dimensions.
         *
         * @param {CKEDITOR.dom.element} image
         * @returns {Boolean}
         */
        checkHasNaturalRatio: function checkHasNaturalRatio(image) {
            var $ = image.$,
                natural = this.getNatural(image);

            // The reason for two alternative comparisons is that the rounding can come from
            // both dimensions, e.g. there are two cases:
            // 	1. height is computed as a rounded relation of the real height and the value of width,
            //	2. width is computed as a rounded relation of the real width and the value of heigh.
            return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
        },

        /**
         * Returns natural dimensions of the image. For modern browsers
         * it uses natural(Width|Height). For old ones (IE8) it creates
         * a new image and reads the dimensions.
         *
         * @param {CKEDITOR.dom.element} image
         * @returns {Object}
         */
        getNatural: function getNatural(image) {
            var dimensions;

            if (image.$.naturalWidth) {
                dimensions = {
                    height: image.$.naturalHeigh,
                    width: image.$.naturalWidth
                };
            } else {
                var img = new Image();

                img.src = image.getAttribute('src');

                dimensions = {
                    height: img.heigh,
                    width: img.width
                };
            }

            return dimensions;
        }
    };

    // Returns a function that creates widgets from all <img> and
    // <figure class="{config.image2_captionedClass}"> elements.
    //
    // @param {CKEDITOR.editor} editor
    // @returns {Function}
    function upcastWidgetElement(editor) {
        var isCenterWrapper = centerWrapperChecker(editor);

        var captionedClass = editor.config.image2_captionedClass;

        // @param {CKEDITOR.htmlParser.element} el
        // @param {Object} data
        return function (el, data) {
            var dimensions = {
                height: 1,
                width: 1
            };

            var name = el.name;

            var image;

            // #11110 Don't initialize on pasted fake objects.
            if (el.attributes['data-cke-realelement']) {
                return;
            }

            // If a center wrapper is found, there are 3 possible cases:
            //
            // 1. <div style="text-align:center"><figure>...</figure></div>.
            //    In this case centering is done with a class set on widget.wrapper.
            //    Simply replace centering wrapper with figure (it's no longer necessary).
            //
            // 2. <p style="text-align:center"><img/></p>.
            //    Nothing to do here: <p> remains for styling purposes.
            //
            // 3. <div style="text-align:center"><img/></div>.
            //    Nothing to do here (2.) but that case is only possible in enterMode different
            //    than ENTER_P.
            if (isCenterWrapper(el)) {
                if (name == 'div') {
                    var figure = el.getFirst('figure');

                    // Case #1.
                    if (figure) {
                        el.replaceWith(figure);
                        el = figure;
                    }
                }
                // Cases #2 and #3 (handled transparently)

                // If there's a centering wrapper, save it in data.
                data.align = 'center';

                // Image can be wrapped in link <a><img/></a>.
                image = el.getFirst('img') || el.getFirst('a').getFirst('img');
            }

            // No center wrapper has been found.
            else if (name == 'figure' && el.hasClass(captionedClass)) {
                    image = el.getFirst('img') || el.getFirst('a').getFirst('img');

                    // Upcast linked image like <a><img/></a>.
                } else if (isLinkedOrStandaloneImage(el)) {
                    image = el.name == 'a' ? el.children[0] : el;
                }

            if (!image) {
                return;
            }

            // If there's an image, then cool, we got a widget.
            // Now just remove dimension attributes expressed with %.
            for (var d in dimensions) {
                var dimension = image.attributes[d];

                if (dimension && dimension.match(regexPercent)) {
                    delete image.attributes[d];
                }
            }

            return el;
        };
    }

    // Returns a function which transforms the widget to the external format
    // according to the current configuration.
    //
    // @param {CKEDITOR.editor}
    function downcastWidgetElement(editor) {
        var alignClasses = editor.config.image2_alignClasses;

        // @param {CKEDITOR.htmlParser.element} el
        return function (el) {
            // In case of <a><img/></a>, <img/> is the element to hold
            // inline styles or classes (image2_alignClasses).
            var attrsHolder = el.name == 'a' ? el.getFirst() : el;

            delete attrsHolder.attributes.contenteditable;

            var attrs = attrsHolder.attributes;

            var align = this.data.align;

            // De-wrap the image from resize handle wrapper.
            // Only block widgets have one.
            if (!this.inline) {
                var resizeWrapper = el.getFirst('span');

                if (resizeWrapper) {
                    resizeWrapper.replaceWith(resizeWrapper.getFirst({
                        a: 1,
                        img: 1
                    }));
                }
            }

            if (align && align != 'none') {
                var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

                // When the widget is captioned (<figure>) and internally centering is done
                // with widget's wrapper style/class, in the external data representation,
                // <figure> must be wrapped with an element holding an style/class:
                //
                // 	<div style="text-align:center">
                // 		<figure class="image" style="display:inline-block">...</figure>
                // 	</div>
                // or
                // 	<div class="some-center-class">
                // 		<figure class="image">...</figure>
                // 	</div>
                //
                if (align == 'center' && el.name == 'figure') {
                    el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? {
                        'class': alignClasses[1]
                    } : {
                        style: 'text-align:center'
                    }));
                }

                // If left/right, add float style to the downcasted element.
                else if (align in {
                        left: 1,
                        right: 1
                    }) {
                        if (alignClasses) {
                            attrsHolder.addClass(alignClasses[alignmentsObj[align]]);
                        } else {
                            styles['float'] = align;
                        }
                    }

                // Update element styles.
                if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) {
                    attrs.style = CKEDITOR.tools.writeCssText(styles);
                }
            }

            return el;
        };
    }

    // Returns a function that checks if an element is a centering wrapper.
    //
    // @param {CKEDITOR.editor} editor
    // @returns {Function}
    function centerWrapperChecker(editor) {
        var captionedClass = editor.config.image2_captionedClass;

        var alignClasses = editor.config.image2_alignClasses;

        var validChildren = {
            a: 1,
            figure: 1,
            img: 1
        };

        return function (el) {
            // Wrapper must be either <div> or <p>.
            if (!(el.name in {
                div: 1,
                p: 1
            })) {
                return false;
            }

            var children = el.children;

            // Centering wrapper can have only one child.
            if (children.length !== 1) {
                return false;
            }

            var child = children[0];

            // Only <figure> or <img /> can be first (only) child of centering wrapper,
            // regardless of its type.
            if (!(child.name in validChildren)) {
                return false;
            }

            // If centering wrapper is <p>, only <img /> can be the child.
            //   <p style="text-align:center"><img /></p>
            if (el.name == 'p') {
                if (!isLinkedOrStandaloneImage(child)) {
                    return false;
                }
            }
            // Centering <div> can hold <img/> or <figure>, depending on enterMode.
            else {
                    // If a <figure> is the first (only) child, it must have a class.
                    //   <div style="text-align:center"><figure>...</figure><div>
                    if (child.name == 'figure') {
                        if (!child.hasClass(captionedClass)) {
                            return false;
                        }
                    } else {
                        // Centering <div> can hold <img/> or <a><img/></a> only when enterMode
                        // is ENTER_(BR|DIV).
                        //   <div style="text-align:center"><img /></div>
                        //   <div style="text-align:center"><a><img /></a></div>
                        if (editor.enterMode == CKEDITOR.ENTER_P) {
                            return false;
                        }

                        // Regardless of enterMode, a child which is not <figure> must be
                        // either <img/> or <a><img/></a>.
                        if (!isLinkedOrStandaloneImage(child)) {
                            return false;
                        }
                    }
                }

            // Centering wrapper got to be... centering. If image2_alignClasses are defined,
            // check for centering class. Otherwise, check the style.
            if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') {
                return true;
            }

            return false;
        };
    }

    // Checks whether element is <img/> or <a><img/></a>.
    //
    // @param {CKEDITOR.htmlParser.element}
    function isLinkedOrStandaloneImage(el) {
        if (el.name == 'img') {
            return true;
        } else if (el.name == 'a') {
            return el.children.length == 1 && el.getFirst('img');
        }

        return false;
    }

    // Sets width and height of the widget image according to current widget data.
    //
    // @param {CKEDITOR.plugins.widget} widget
    function setDimensions(widget) {
        var data = widget.data;

        var dimensions = {
            height: data.height,
            width: data.width
        };

        var image = widget.parts.image;

        for (var d in dimensions) {
            if (dimensions[d]) {
                image.setAttribute(d, dimensions[d]);
            } else {
                image.removeAttribute(d);
            }
        }
    }

    // Defines all features related to drag-driven image resizing.
    //
    // @param {CKEDITOR.plugins.widget} widget
    function setupResizer(widget) {
        var editor = widget.editor;

        var editable = editor.editable();

        var doc = editor.document;

        // Store the resizer in a widget for testing (#11004).
        var resizer = widget.resizer = doc.createElement('span');

        resizer.addClass('cke_image_resizer');
        resizer.addClass('cke_image_resizer_' + cursor[editor.config.imageScaleResize]);
        resizer.append(new CKEDITOR.dom.text('\u200B', doc));

        // Inline widgets don't need a resizer wrapper as an image spans the entire widget.
        if (!widget.inline) {
            var imageOrLink = widget.parts.link || widget.parts.image;

            var oldResizeWrapper = imageOrLink.getParent();

            var resizeWrapper = doc.createElement('span');

            resizeWrapper.addClass('cke_image_resizer_wrapper');
            resizeWrapper.append(imageOrLink);
            resizeWrapper.append(resizer);
            widget.element.append(resizeWrapper, true);

            // Remove the old wrapper which could came from e.g. pasted HTML
            // and which could be corrupted (e.g. resizer span has been lost).
            if (oldResizeWrapper.is('span')) {
                oldResizeWrapper.remove();
            }
        } else {
            widget.wrapper.append(resizer);
        }

        // Calculate values of size variables and mouse offsets.
        resizer.on('mousedown', function (evt) {
            var image = widget.parts.image;

            // "factor" can be either 1 or -1. I.e.: For right-aligned images, we need to
            // subtract the difference to get proper width, etc. Without "factor",
            // resizer starts working the opposite way.
            var factor = widget.data.align == 'right' ? -1 : 1;

            // The x-coordinate of the mouse relative to the screen
            // when button gets pressed.
            var startX = evt.data.$.screenX;

            var startY = evt.data.$.screenY;

            // The initial dimensions and aspect ratio of the image.
            var startWidth = image.$.clientWidth;

            var startHeight = image.$.clientHeight;

            var listeners = [];

            // A class applied to editable during resizing.
            var cursorClass = 'cke_image_s' + (!~factor ? 'w' : 'e');

            var nativeEvt, newWidth, newHeight, updateData;

            var moveDiffX, moveDiffY, moveRatio;

            // Save the undo snapshot first: before resizing.
            editor.fire('saveSnapshot');

            // Mousemove listeners are removed on mouseup.
            attachToDocuments('mousemove', onMouseMove, listeners);

            // Clean up the mousemove listener. Update widget data if valid.
            attachToDocuments('mouseup', onMouseUp, listeners);

            // The entire editable will have the special cursor while resizing goes on.
            editable.addClass(cursorClass);

            // This is to always keep the resizer element visible while resizing.
            resizer.addClass('cke_image_resizing');

            // Attaches an event to a global document if inline editor.
            // Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.
            function attachToDocuments(name, callback, collection) {
                var globalDoc = CKEDITOR.document;

                var listeners = [];

                if (!doc.equals(globalDoc)) {
                    listeners.push(globalDoc.on(name, callback));
                }

                listeners.push(doc.on(name, callback));

                if (collection) {
                    for (var i = listeners.length; i--;) {
                        collection.push(listeners.pop());
                    }
                }
            }

            // This is how variables refer to the geometry.
            // Note: x corresponds to moveOffset, this is the position of mouse
            // Note: o corresponds to [startX, startY].
            //
            // 	+--------------+--------------+
            // 	|              |              |
            // 	|      I       |      II      |
            // 	|              |              |
            // 	+------------- o -------------+ _ _ _
            // 	|              |              |      ^

            // 	|      VI      |     III      |      | moveDiffY
            // 	|              |         x _ _ _ _ _ v
            // 	+--------------+---------|----+
            // 	               |         |
            // 	                <------->
            // 	                moveDiffX
            function onMouseMove(evt) {
                var imageScaleResize = editor.config.imageScaleResize;

                nativeEvt = evt.data.$;

                // This is how far the mouse is from the point the button was pressed.
                moveDiffX = nativeEvt.screenX - startX;
                moveDiffY = startY - nativeEvt.screenY;

                // This is the aspect ratio of the move difference.
                moveRatio = Math.abs(moveDiffX / moveDiffY);

                if (imageScaleResize === 'width' || imageScaleResize === 'both' || imageScaleResize === 'scale') {
                    newWidth = startWidth + factor * moveDiffX;
                }

                if (imageScaleResize === 'height' || imageScaleResize === 'both') {
                    newHeight = startHeight - moveDiffY;
                }

                if (imageScaleResize === 'scale') {
                    newHeight = 'auto';
                }

                newWidth = newWidth || startWidth;
                newHeight = newHeight || startHeight;

                // Don't update attributes if less than 10.
                // This is to prevent images to visually disappear.
                if (newWidth >= 15 && (newHeight >= 15 || newHeight === 'auto')) {
                    image.$.style.width = newWidth + 'px';
                    image.$.style.height = newHeight + 'px';

                    updateData = true;
                } else {
                    updateData = false;
                }
            }

            function onMouseUp() {
                var l;

                while (l = listeners.pop()) {
                    l.removeListener();
                }

                // Restore default cursor by removing special class.
                editable.removeClass(cursorClass);

                // This is to bring back the regular behaviour of the resizer.
                resizer.removeClass('cke_image_resizing');

                if (updateData) {
                    widget.element.$.style.width = newWidth + 'px';
                    widget.element.$.style.height = newHeight + 'px';

                    // Save another undo snapshot: after resizing.
                    editor.fire('saveSnapshot');
                }

                // Don't update data twice or more.
                updateData = false;
            }
        });

        // Change the position of the widget resizer when data changes.
        widget.on('data', function () {
            resizer[widget.data.align == 'right' ? 'addClass' : 'removeClass']('cke_image_resizer_left');
        });

        widget.parts.image.on('click', function () {
            var selection = editor.getSelection();

            if (selection) {
                var element = selection.getStartElement();

                if (element) {
                    var widgetElement = element.findOne('img');

                    if (widgetElement) {
                        var region = element.getClientRect();

                        var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
                        region.left -= scrollPosition.x;
                        region.top += scrollPosition.y;

                        region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

                        editor.fire('editorInteraction', {
                            nativeEvent: event,
                            selectionData: {
                                element: widgetElement,
                                region: region
                            }
                        });
                    }
                }
            }
        });
    }

    // Returns a set of widget allowedContent rules, depending
    // on configurations like config#image2_alignClasses or
    // config#image2_captionedClass.
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function getWidgetAllowedContent(editor) {
        var rules = {
            figcaption: true,
            figure: {
                classes: '!' + editor.config.image2_captionedClass
            },
            img: {
                attributes: '!src,alt,width,height'
            }
        };

        return rules;
    }

    // Returns a set of widget feature rules, depending
    // on editor configuration. Note that the following may not cover
    // all the possible cases since requiredContent supports a single
    // tag only.
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function getWidgetFeatures(editor) {
        var alignClasses = editor.config.image2_alignClasses;

        var features = {
            align: {
                requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
            },
            caption: {
                requiredContent: 'figcaption'
            },
            dimension: {
                requiredContent: 'img[width,height]'
            }
        };

        return features;
    }

    // Returns element which is styled, considering current
    // state of the widget.
    //
    // @see CKEDITOR.plugins.widget#applyStyle
    // @param {CKEDITOR.plugins.widget} widget
    // @returns {CKEDITOR.dom.element}
    function getStyleableElement(widget) {
        return widget.data.hasCaption ? widget.element : widget.parts.image;
    }
})();

CKEDITOR.config.image2_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/embed.js":
/*!******************************!*\
  !*** ./src/plugins/embed.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_embed')) {
        return;
    }

    var REGEX_HTTP = /^https?/;

    var REGEX_DEFAULT_LINK = /<a href=/;

    var PROVIDERS = ['youtube', 'twitter'];

    CKEDITOR.DEFAULT_AE_EMBED_URL_TPL = 'http://alloy.iframe.ly/api/oembed?url={url}&callback={callback}';
    CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL = '<div data-ae-embed-url="{url}"></div>';
    CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL = '<a href="{url}">{url}</a>';
    /**
     * CKEditor plugin which adds the infrastructure to embed urls as media objects using an oembed
     * service. By default, and for demoing purposes only, the oembed service is hosted in iframe.ly
     * at //alloy.iframe.ly/api/oembed?url={url}&callback={callback}. Note this should be changed to
     * a self-hosted or paid service in production environments. Access to the alloy.iframe.ly endpoint
     * may be restricted per domain due to significant traffic.
     *
     * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
     * to an embedded content.
     *
     * @class CKEDITOR.plugins.ae_embed
     */
    CKEDITOR.plugins.add('ae_embed', {
        requires: 'widget',
        init: function init(editor) {
            var AE_EMBED_URL_TPL = new CKEDITOR.template(editor.config.embedUrlTemplate || CKEDITOR.DEFAULT_AE_EMBED_URL_TPL);
            var AE_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL);
            var AE_EMBED_DEFAULT_LINK_TPL = new CKEDITOR.template(editor.config.embedLinkDefaultTpl || CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL);

            // Default function to upcast DOM elements to embed widgets.
            // It matches CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL
            var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
                if (element.name === 'div' && element.attributes['data-ae-embed-url']) {
                    data.url = element.attributes['data-ae-embed-url'];

                    return true;
                }
            };

            // Create a embedUrl command that can be invoked to easily embed media URLs
            editor.addCommand('embedUrl', {
                exec: function exec(editor, data) {
                    editor.insertHtml(AE_EMBED_WIDGET_TPL.output({
                        url: data.url
                    }));
                }
            });

            // Create a widget to properly handle embed operations
            editor.widgets.add('ae_embed', {

                mask: true,
                requiredContent: 'div[data-ae-embed-url]',

                /**
                 * Listener to be executed every time the widget's data changes. It takes care of
                 * requesting the embed object to the configured oembed service and render it in
                 * the editor
                 *
                 * @method data
                 * @param {event} event Data change event
                 */
                data: function data(event) {
                    var widget = this;

                    var url = event.data.url;

                    if (url) {
                        CKEDITOR.tools.jsonp(AE_EMBED_URL_TPL, {
                            url: encodeURIComponent(url)
                        }, function (response) {
                            if (response.html) {
                                if (REGEX_DEFAULT_LINK.test(response.html)) {
                                    widget.createATag(url);
                                } else {
                                    widget.element.setHtml(response.html);
                                }
                            } else {
                                widget.createATag(url);
                            }
                        }, function (msg) {
                            widget.createATag(url);
                        });
                    }
                },

                createATag: function createATag(url) {
                    this.editor.execCommand('undo');

                    var currentSelection = this.editor.getSelection().getSelectedElement();

                    var aTagHtml = AE_EMBED_DEFAULT_LINK_TPL.output({
                        url: url
                    });

                    this.editor.insertHtml(aTagHtml);
                    this.editor.fire('actionPerformed', this);
                },

                /**
                 * Function used to upcast an element to ae_embed widgets.
                 *
                 * @method upcast
                 * @param {CKEDITOR.htmlParser.element} element The element to be checked
                 * @param {Object} data The object that will be passed to the widget
                 */
                upcast: function upcast(element, data) {
                    var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

                    return embedWidgetUpcastFn(element, data);
                }
            });

            // Add a listener to handle paste events and turn links into embed objects
            editor.once('contentDom', function () {
                editor.on('paste', function (event) {
                    var link = event.data.dataValue;

                    if (REGEX_HTTP.test(link)) {
                        event.stop();

                        editor.execCommand('embedUrl', {
                            url: event.data.dataValue
                        });
                    }
                });
            });

            // Add a listener to handle selection change events and properly detect editor
            // interactions on the widgets without messing with widget native selection
            editor.on('selectionChange', function (event) {
                var selection = editor.getSelection();

                if (selection) {
                    var element = selection.getSelectedElement();

                    if (element) {
                        var widgetElement = element.findOne('[data-widget="ae_embed"]');

                        if (widgetElement) {
                            var region = element.getClientRect();

                            var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
                            region.left -= scrollPosition.x;
                            region.top += scrollPosition.y;

                            region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

                            editor.fire('editorInteraction', {
                                nativeEvent: {},
                                selectionData: {
                                    element: widgetElement,
                                    region: region
                                }
                            });
                        }
                    }
                }
            });

            // Add a filter to skip filtering widget elements
            editor.filter.addElementCallback(function (element) {
                if ('data-ae-embed-url' in element.attributes) {
                    return CKEDITOR.FILTER_SKIP_TREE;
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/imagealignment.js":
/*!***************************************!*\
  !*** ./src/plugins/imagealignment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _selectionTest = __webpack_require__(/*! ../selections/selection-test.js */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_imagealignment')) {
        return;
    }

    /**
     * Enum for supported image alignments
     * @type {Object}
     */
    var IMAGE_ALIGNMENT = {
        CENTER: 'center',
        LEFT: 'left',
        RIGHT: 'right'
    };

    /**
     * Enum values for supported image alignments
     * @type {Array}
     */
    var ALIGN_VALUES = [IMAGE_ALIGNMENT.LEFT, IMAGE_ALIGNMENT.RIGHT, IMAGE_ALIGNMENT.CENTER];

    /**
     * Necessary styles for the center alignment
     * @type {Array.<Object>}
     */
    var CENTERED_IMAGE_STYLE = [{
        name: 'display',
        value: 'block'
    }, {
        name: 'margin-left',
        value: 'auto'
    }, {
        name: 'margin-right',
        value: 'auto'
    }];

    /**
     * Retrieves the alignment value of an image.
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @return {String} The alignment value
     */
    var getImageAlignment = function getImageAlignment(image) {
        var imageAlignment = image.getStyle('float');

        if (!imageAlignment || imageAlignment === 'inherit' || imageAlignment === 'none') {
            imageAlignment = image.getAttribute('align');
        }

        if (!imageAlignment) {
            var centeredImage = CENTERED_IMAGE_STYLE.every(function (style) {
                var styleCheck = image.getStyle(style.name) === style.value;

                if (!styleCheck && style.vendorPrefixes) {
                    styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
                        return image.getStyle(vendorPrefix + style.name) === style.value;
                    });
                }

                return styleCheck;
            });

            if (!imageAlignment) {
                var imageContainer = image.$.parentNode;

                if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
                    CENTERED_IMAGE_STYLE.forEach(function (style) {
                        image.setStyle(style.name, style.value);

                        if (style.vendorPrefixes) {
                            style.vendorPrefixes.forEach(function (vendorPrefix) {
                                image.setStyle(vendorPrefix + style.name, style.value);
                            });
                        }
                    });
                    centeredImage = true;
                }
            }

            imageAlignment = centeredImage ? IMAGE_ALIGNMENT.CENTER : null;
        }

        return imageAlignment;
    };

    /**
     * Removes the alignment value of an image
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @param {String} imageAlignment The image alignment value to be removed
     */
    var removeImageAlignment = function removeImageAlignment(image, imageAlignment) {
        if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
            image.removeStyle('float');

            if (imageAlignment === getImageAlignment(image)) {
                image.removeAttribute('align');
            }
        } else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
            CENTERED_IMAGE_STYLE.forEach(function (style) {
                image.removeStyle(style.name);

                if (style.vendorPrefixes) {
                    style.vendorPrefixes.forEach(function (vendorPrefix) {
                        image.removeStyle(vendorPrefix + style.name);
                    });
                }
            });

            var imageContainer = image.$.parentNode;

            if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
                imageContainer.style.textAlign = '';
            }
        }
    };

    /**
     * Sets the alignment value of an image
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @param {String} imageAlignment The image alignment value to be set
     */
    var setImageAlignment = function setImageAlignment(image, imageAlignment) {
        removeImageAlignment(image, getImageAlignment(image));

        if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
            image.setStyle('float', imageAlignment);
        } else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
            CENTERED_IMAGE_STYLE.forEach(function (style) {
                image.setStyle(style.name, style.value);

                if (style.vendorPrefixes) {
                    style.vendorPrefixes.forEach(function (vendorPrefix) {
                        image.setStyle(vendorPrefix + style.name, style.value);
                    });
                }
            });

            var imageContainer = image.$.parentNode;

            imageContainer.style.textAlign = IMAGE_ALIGNMENT.CENTER;
        }
    };

    /**
     * CKEditor plugin which modifies the justify commands to properly align images. This
     * plugin is an excerpt of CKEditor's original image one that can be found at
     * https://github.com/ckeditor/ckeditor-dev/blob/master/plugins/image/plugin.js
     *
     * @class CKEDITOR.plugins.ae_imagealignment
     */
    CKEDITOR.plugins.add('ae_imagealignment', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'paste' event on the editing area.
         *
         * @method afterInit
         * @param {Object} editor The current editor instance
         */
        afterInit: function afterInit(editor) {
            var self = this;

            ALIGN_VALUES.forEach(function (value) {
                var command = editor.getCommand('justify' + value);

                if (command) {
                    command.on('exec', function (event) {
                        var selectionData = editor.getSelectionData();

                        if (selectionData && _selectionTest2.default.image({ data: { selectionData: selectionData } })) {
                            var image = selectionData.element;

                            var imageAlignment = getImageAlignment(image);

                            if (imageAlignment === value) {
                                removeImageAlignment(image, value);
                            } else {
                                setImageAlignment(image, value);
                            }

                            event.cancel();

                            self.refreshCommands(editor, new CKEDITOR.dom.elementPath(image));
                        }
                    });

                    command.on('refresh', function (event) {
                        var selectionData = {
                            element: event.data.path.lastElement
                        };

                        if (_selectionTest2.default.image({ data: { selectionData: selectionData } })) {
                            var imageAlignment = getImageAlignment(selectionData.element);

                            this.setState(imageAlignment === value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

                            event.cancel();
                        }
                    });
                }
            });
        },

        /**
         * Forces a refresh of the modified justify commands. This is needed because the applied changes
         * do not modify the selection, so the refresh is never triggered and the UI does not update
         * properly until the next selectionChange event.
         *
         * @param {CKEDITOR.editor} editor The editor instance
         * @param {CKEDITOR.dom.elementPath} elementPath The path of the selected image
         */
        refreshCommands: function refreshCommands(editor, elementPath) {
            ALIGN_VALUES.forEach(function (value) {
                var command = editor.getCommand('justify' + value);

                if (command) {
                    command.refresh(editor, elementPath);
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tabletools = exports.tableresize = exports.selectionkeystrokes = exports.placeholder = exports.pasteimages = exports.imagealignment = exports.embed = exports.dragresizeie = exports.dragresize = exports.autolist = exports.autolink = exports.addimages = undefined;

var _addimages = __webpack_require__(/*! ./addimages */ "./src/plugins/addimages.js");

var _addimages2 = _interopRequireDefault(_addimages);

var _autolink = __webpack_require__(/*! ./autolink */ "./src/plugins/autolink.js");

var _autolink2 = _interopRequireDefault(_autolink);

var _autolist = __webpack_require__(/*! ./autolist */ "./src/plugins/autolist.js");

var _autolist2 = _interopRequireDefault(_autolist);

var _dragresize = __webpack_require__(/*! ./dragresize */ "./src/plugins/dragresize.js");

var _dragresize2 = _interopRequireDefault(_dragresize);

var _dragresize_ie = __webpack_require__(/*! ./dragresize_ie */ "./src/plugins/dragresize_ie.js");

var _dragresize_ie2 = _interopRequireDefault(_dragresize_ie);

var _embed = __webpack_require__(/*! ./embed */ "./src/plugins/embed.js");

var _embed2 = _interopRequireDefault(_embed);

var _imagealignment = __webpack_require__(/*! ./imagealignment */ "./src/plugins/imagealignment.js");

var _imagealignment2 = _interopRequireDefault(_imagealignment);

var _pasteimages = __webpack_require__(/*! ./pasteimages */ "./src/plugins/pasteimages.js");

var _pasteimages2 = _interopRequireDefault(_pasteimages);

var _placeholder = __webpack_require__(/*! ./placeholder */ "./src/plugins/placeholder.js");

var _placeholder2 = _interopRequireDefault(_placeholder);

var _selectionkeystrokes = __webpack_require__(/*! ./selectionkeystrokes */ "./src/plugins/selectionkeystrokes.js");

var _selectionkeystrokes2 = _interopRequireDefault(_selectionkeystrokes);

var _tableresize = __webpack_require__(/*! ./tableresize */ "./src/plugins/tableresize.js");

var _tableresize2 = _interopRequireDefault(_tableresize);

var _tabletools = __webpack_require__(/*! ./tabletools */ "./src/plugins/tabletools.js");

var _tabletools2 = _interopRequireDefault(_tabletools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.addimages = _addimages2.default;
exports.autolink = _autolink2.default;
exports.autolist = _autolist2.default;
exports.dragresize = _dragresize2.default;
exports.dragresizeie = _dragresize_ie2.default;
exports.embed = _embed2.default;
exports.imagealignment = _imagealignment2.default;
exports.pasteimages = _pasteimages2.default;
exports.placeholder = _placeholder2.default;
exports.selectionkeystrokes = _selectionkeystrokes2.default;
exports.tableresize = _tableresize2.default;
exports.tabletools = _tabletools2.default;

/***/ }),

/***/ "./src/plugins/pasteimages.js":
/*!************************************!*\
  !*** ./src/plugins/pasteimages.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_pasteimages')) {
        return;
    }

    /**
     * CKEditor plugin which allows pasting images directly into the editable area. The image will be encoded
     * as Data URI. An event `beforeImageAdd` will be fired with the list of pasted images. If any of the listeners
     * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
     * an event `imageAdd` will be fired with the inserted element into the editable area.
     *
     * @class CKEDITOR.plugins.ae_pasteimages
     */

    /**
     * Fired before adding images to the editor.
     * @event beforeImageAdd
     * @param {Array} imageFiles Array of image files
     */

    /**
     * Fired when an image is being added to the editor successfully.
     *
     * @event imageAdd
     * @param {CKEDITOR.dom.element} el The created image with src as Data URI
     * @param {File} file The image file
     */

    CKEDITOR.plugins.add('ae_pasteimages', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'paste' event on the editing area.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'paste', this._onPaste, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * The function creates an img element with src the image data as Data URI.
         * Then, it fires an 'imageAdd' event via CKEditor's event system. The passed
         * params will be:
         * - `el` - the created img element
         * - `file` - the original pasted data
         *
         * @method _onPaste
         * @protected
         * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
         */
        _onPaste: function _onPaste(event) {
            if (event.data.$.clipboardData) {
                var pastedData = event.data.$.clipboardData.items[0];
                var editor = event.listenerData.editor;

                if (pastedData.type.indexOf('image') === 0) {
                    var reader = new FileReader();
                    var imageFile = pastedData.getAsFile();

                    reader.onload = function (event) {
                        var result = editor.fire('beforeImageAdd', {
                            imageFiles: imageFile
                        });

                        if (!!result) {
                            var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

                            editor.insertElement(el);

                            var imageData = {
                                el: el,
                                file: imageFile
                            };

                            editor.fire('imageAdd', imageData);
                        }
                    }.bind(this);

                    reader.readAsDataURL(imageFile);
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/placeholder.js":
/*!************************************!*\
  !*** ./src/plugins/placeholder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_placeholder')) {
        return;
    }

    /**
     * CKEDITOR enterMode config set the behavior of paragraphs
     * When the content is empty CKEDITOR keeps the enterMode string
     * into the content
     * @property
     * @type {string}
     */
    var brFiller = CKEDITOR.env.needsBrFiller ? '<br>' : '';

    var enterModeEmptyValue = {
        1: ['<p>' + brFiller + '</p>'],
        2: ['', ' ', brFiller],
        3: ['<div>' + brFiller + '</div>']
    };

    /**
     * CKEditor plugin which allows adding a placeholder to the editor. In this case, if there
     * is no content to the editor, there will be hint to the user.
     *
     * @class CKEDITOR.plugins.ae_placeholder
     */

    /**
     * Specifies the placeholder class which have to be aded to editor when editor is not focused.
     *
     * @attribute placeholderClass
     * @default ae_placeholder
     * @type String
     */

    CKEDITOR.plugins.add('ae_placeholder', {

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'blur' and 'contentDom' event listeners.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.on('blur', this._checkEmptyData, this);
            editor.on('change', this._checkEmptyData, this);
            editor.on('focus', this._removePlaceholderClass, this);
            editor.once('contentDom', this._checkEmptyData, this);
        },

        /**
         * Removes any data from the content and adds a class,
         * specified by the "placeholderClass" config attribute.
         *
         * @protected
         * @method _checkEmptyData
         * @param {CKEDITOR.dom.event} editor event, fired from CKEditor
         */
        _checkEmptyData: function _checkEmptyData(event) {
            var editor = event.editor;

            var editableNode = editor.editable();

            var innerHtml = editableNode.$.innerHTML.trim();

            var isEmpty = enterModeEmptyValue[editor.config.enterMode].some(function (element) {
                return innerHtml === element;
            });

            if (isEmpty) {
                editableNode.addClass(editor.config.placeholderClass);
            } else {
                editableNode.removeClass(editor.config.placeholderClass);
            }
        },

        /**
         * Remove placeholder class when input is focused
         *
         * @protected
         * @method _removePlaceholderClass
         + @param {CKEDITOR.dom.event} editor event, fired from CKEditor
         */
        _removePlaceholderClass: function _removePlaceholderClass(event) {
            var editor = event.editor;

            var editorNode = new CKEDITOR.dom.element(editor.element.$);

            editorNode.removeClass(editor.config.placeholderClass);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/selectionkeystrokes.js":
/*!********************************************!*\
  !*** ./src/plugins/selectionkeystrokes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_selectionkeystrokes')) {
        return;
    }

    /**
     * CKEditor plugin that simulates editor interaction events based on manual keystrokes. This
     * can be used to trigger different reactions in the editor.
     *
     * @class CKEDITOR.plugins.ae_selectionkeystrokes
     */
    CKEDITOR.plugins.add('ae_selectionkeystrokes', {
        requires: 'ae_selectionregion',

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function adds a command to the editor for every defined selectionKeystroke
         * in the configuration and maps it to the specified keystroke.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            if (editor.config.selectionKeystrokes) {
                editor.config.selectionKeystrokes.forEach(function (selectionKeystroke) {
                    var command = new CKEDITOR.command(editor, {
                        exec: function exec(editor) {
                            editor.fire('editorInteraction', {
                                manualSelection: selectionKeystroke.selection,
                                nativeEvent: {},
                                selectionData: editor.getSelectionData()
                            });
                        }
                    });

                    var commandName = 'selectionKeystroke' + selectionKeystroke.selection;

                    editor.addCommand(commandName, command);
                    editor.setKeystroke(selectionKeystroke.keys, commandName);
                });
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/tableresize.js":
/*!************************************!*\
  !*** ./src/plugins/tableresize.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_tableresize')) {
        return;
    }

    var pxUnit = CKEDITOR.tools.cssLength;

    function getWidth(el) {
        return CKEDITOR.env.ie ? el.$.clientWidth : parseInt(el.getComputedStyle('width'), 10);
    }

    function getBorderWidth(element, side) {
        var computed = element.getComputedStyle('border-' + side + '-width'),
            borderMap = {
            thin: '0px',
            medium: '1px',
            thick: '2px'
        };

        if (computed.indexOf('px') < 0) {
            // look up keywords
            if (computed in borderMap && element.getComputedStyle('border-style') != 'none') {
                computed = borderMap[computed];
            } else {
                computed = 0;
            }
        }

        return parseInt(computed, 10);
    }

    // Gets the table row that contains the most columns.
    function getMasterPillarRow(table) {
        var $rows = table.$.rows,
            maxCells = 0,
            cellsCount,
            $elected,
            $tr;

        for (var i = 0, len = $rows.length; i < len; i++) {
            $tr = $rows[i];
            cellsCount = $tr.cells.length;

            if (cellsCount > maxCells) {
                maxCells = cellsCount;
                $elected = $tr;
            }
        }

        return $elected;
    }

    function buildTableColumnPillars(table) {
        var pillars = [],
            pillarIndex = -1,
            rtl = table.getComputedStyle('direction') === 'rtl';

        // Get the raw row element that cointains the most columns.
        var $tr = getMasterPillarRow(table);

        // Get the tbody element and position, which will be used to set the
        // top and bottom boundaries.
        var tbody = new CKEDITOR.dom.element(table.$.tBodies[0]),
            tbodyPosition = tbody.getDocumentPosition();

        // Loop thorugh all cells, building pillars after each one of them.
        for (var i = 0, len = $tr.cells.length; i < len; i++) {
            // Both the current cell and the successive one will be used in the
            // pillar size calculation.
            var td = new CKEDITOR.dom.element($tr.cells[i]),
                nextTd = $tr.cells[i + 1] && new CKEDITOR.dom.element($tr.cells[i + 1]);

            pillarIndex += td.$.colSpan || 1;

            // Calculate the pillar boundary positions.
            var pillarLeft, pillarRight, pillarWidth;

            var x = td.getDocumentPosition().x;

            // Calculate positions based on the current cell.
            rtl ? pillarRight = x + getBorderWidth(td, 'left') : pillarLeft = x + td.$.offsetWidth - getBorderWidth(td, 'right');

            // Calculate positions based on the next cell, if available.
            if (nextTd) {
                x = nextTd.getDocumentPosition().x;

                rtl ? pillarLeft = x + nextTd.$.offsetWidth - getBorderWidth(nextTd, 'right') : pillarRight = x + getBorderWidth(nextTd, 'left');
            }
            // Otherwise calculate positions based on the table (for last cell).
            else {
                    x = table.getDocumentPosition().x;

                    rtl ? pillarLeft = x : pillarRight = x + table.$.offsetWidth;
                }

            pillarWidth = Math.max(pillarRight - pillarLeft, 4);

            // The pillar should reflects exactly the shape of the hovered
            // column border line.
            pillars.push({
                table: table,
                index: pillarIndex,
                x: pillarLeft,
                y: tbodyPosition.y,
                width: pillarWidth,
                height: tbody.$.offsetHeight,
                rtl: rtl
            });
        }

        return pillars;
    }

    function getPillarAtPosition(pillars, positionX) {
        for (var i = 0, len = pillars.length; i < len; i++) {
            var pillar = pillars[i];

            if (positionX >= pillar.x && positionX <= pillar.x + pillar.width) {
                return pillar;
            }
        }

        return null;
    }

    function cancel(evt) {
        (evt.data || evt).preventDefault();
    }

    function columnResizer(editor, pillar) {
        var document, resizer, resizing, startOffset, currentShift;

        var leftSideCells, rightSideCells, leftShiftBoundary, rightShiftBoundary;

        function detach() {
            resizer.removeListener('mouseup', onMouseUp);
            resizer.removeListener('mousedown', onMouseDown);
            resizer.removeListener('mousemove', onMouseMove);
        }

        function resizeStart() {
            // Before starting to resize, figure out which cells to change
            // and the boundaries of this resizing shift.

            var columnIndex = pillar.index,
                map = CKEDITOR.tools.buildTableMap(pillar.table),
                leftColumnCells = [],
                rightColumnCells = [],
                leftMinSize = Number.MAX_VALUE,
                rightMinSize = leftMinSize,
                rtl = pillar.rtl;

            for (var i = 0, len = map.length; i < len; i++) {
                var row = map[i],
                    leftCell = row[columnIndex + (rtl ? 1 : 0)],
                    rightCell = row[columnIndex + (rtl ? 0 : 1)];

                leftCell = leftCell && new CKEDITOR.dom.element(leftCell);
                rightCell = rightCell && new CKEDITOR.dom.element(rightCell);

                if (!leftCell || !rightCell || !leftCell.equals(rightCell)) {
                    leftCell && (leftMinSize = Math.min(leftMinSize, getWidth(leftCell)));
                    rightCell && (rightMinSize = Math.min(rightMinSize, getWidth(rightCell)));

                    leftColumnCells.push(leftCell);
                    rightColumnCells.push(rightCell);
                }
            }

            // Cache the list of cells to be resized.
            leftSideCells = leftColumnCells;
            rightSideCells = rightColumnCells;

            // Cache the resize limit boundaries.
            leftShiftBoundary = pillar.x - leftMinSize;
            rightShiftBoundary = pillar.x + rightMinSize;

            resizer.setOpacity(0.5);
            startOffset = parseInt(resizer.getStyle('left'), 10);
            currentShift = 0;
            resizing = 1;

            resizer.on('mousemove', onMouseMove);

            // Prevent the native drag behavior otherwise 'mousemove' won't fire.
            document.on('dragstart', cancel);
        }

        function resizeEnd() {
            resizing = 0;

            resizer.setOpacity(0);

            currentShift && resizeColumn();

            var table = pillar.table;
            setTimeout(function () {
                table.removeCustomData('_cke_table_pillars');
            }, 0);

            document.removeListener('dragstart', cancel);
        }

        function resizeColumn() {
            var rtl = pillar.rtl,
                cellsCount = rtl ? rightSideCells.length : leftSideCells.length;

            // Perform the actual resize to table cells, only for those by side of the pillar.
            for (var i = 0; i < cellsCount; i++) {
                var leftCell = leftSideCells[i],
                    rightCell = rightSideCells[i],
                    table = pillar.table;

                // Defer the resizing to avoid any interference among cells.
                CKEDITOR.tools.setTimeout(function (leftCell, leftOldWidth, rightCell, rightOldWidth, tableWidth, sizeShift) {
                    // 1px is the minimum valid width (#11626).
                    leftCell && leftCell.setStyle('width', pxUnit(Math.max(leftOldWidth + sizeShift, 1)));
                    rightCell && rightCell.setStyle('width', pxUnit(Math.max(rightOldWidth - sizeShift, 1)));

                    // If we're in the last cell, we need to resize the table as well
                    if (tableWidth) {
                        table.setStyle('width', pxUnit(tableWidth + sizeShift * (rtl ? -1 : 1)));
                    }
                }, 0, this, [leftCell, leftCell && getWidth(leftCell), rightCell, rightCell && getWidth(rightCell), (!leftCell || !rightCell) && getWidth(table) + getBorderWidth(table, 'left') + getBorderWidth(table, 'right'), currentShift]);
            }
        }

        function onMouseDown(evt) {
            cancel(evt);

            resizeStart();

            document.on('mouseup', onMouseUp, this);
        }

        function onMouseUp(evt) {
            evt.removeListener();

            resizeEnd();
        }

        function onMouseMove(evt) {
            move(evt.data.getPageOffset().x);
        }

        document = editor.document;

        resizer = CKEDITOR.dom.element.createFromHtml('<div data-cke-temp=1 contenteditable=false unselectable=on ' + 'style="position:absolute;cursor:col-resize;filter:alpha(opacity=0);opacity:0;' + 'padding:0;background-color:#004;background-image:none;border:0px none;z-index:10"></div>', document);

        // Clean DOM when editor is destroyed.
        editor.on('destroy', function () {
            detach();

            resizer.remove();
        });

        // Place the resizer after body to prevent it
        // from being editable.
        document.getDocumentElement().append(resizer);

        resizer.setStyles({
            width: pxUnit(pillar.width),
            height: pxUnit(pillar.height),
            left: pxUnit(pillar.x),
            top: pxUnit(pillar.y)
        });

        resizer.on('mousedown', onMouseDown, this);

        document.getBody().setStyle('cursor', 'col-resize');

        // Display the resizer to receive events but don't show it,
        // only change the cursor to resizable shape.
        resizer.show();

        var move = this.move = function (posX) {
            var resizerNewPosition = posX - Math.round(resizer.$.offsetWidth / 2);

            if (isResizing) {
                if (resizerNewPosition === leftShiftBoundary || resizerNewPosition === rightShiftBoundary) {
                    return;
                }

                resizerNewPosition = Math.max(resizerNewPosition, leftShiftBoundary);
                resizerNewPosition = Math.min(resizerNewPosition, rightShiftBoundary);

                currentShift = resizerNewPosition - startOffset;
            }

            resizer.setStyle('left', pxUnit(resizerNewPosition));
        };

        var destroy = this.destroy = function () {
            detach();

            document.getBody().setStyle('cursor', 'auto');

            resizer.remove();
        };

        var isResizing = this.isResizing = function () {
            return resizing;
        };
    }

    function clearPillarsCache(evt) {
        var target = evt.data.getTarget();

        if (evt.name === 'mouseout') {
            // Bypass interal mouse move.
            if (!target.is('table')) {
                return;
            }

            var dest = new CKEDITOR.dom.element(evt.data.$.relatedTarget || evt.data.$.toElement);
            while (dest && dest.$ && !dest.equals(target) && !dest.is('body')) {
                dest = dest.getParent();
            }
            if (!dest || dest.equals(target)) {
                return;
            }
        }

        target.getAscendant('table', 1).removeCustomData('_cke_table_pillars');
        evt.removeListener();
    }

    CKEDITOR.plugins.add('ae_tableresize', {
        requires: 'ae_tabletools',

        init: function init(editor) {
            editor.on('contentDom', function () {
                var resizer,
                    editable = editor.editable();

                // In Classic editor it is better to use document
                // instead of editable so event will work below body.
                editable.attachListener(editable.isInline() ? editable : editor.document, 'mousemove', function (evt) {
                    evt = evt.data;

                    var target = evt.getTarget();

                    // FF may return document and IE8 some UFO (object with no nodeType property...)
                    // instead of an element (#11823).
                    if (target.type !== CKEDITOR.NODE_ELEMENT) {
                        return;
                    }

                    var pageX = evt.getPageOffset().x;

                    // If we're already attached to a pillar, simply move the
                    // resizer.
                    if (resizer) {
                        if (resizer.isResizing()) {
                            resizer.move(pageX);

                            cancel(evt);

                            return;
                        } else {
                            resizer.destroy();

                            resizer = null;
                        }
                    }

                    // Considering table, tr, td, tbody but nothing else.
                    var table, pillars;

                    if (!target.is('table') && !target.getAscendant('tbody', 1)) {
                        return;
                    }

                    table = target.getAscendant('table', 1);

                    // Make sure the table we found is inside the container
                    // (eg. we should not use tables the editor is embedded within)
                    if (!editor.editable().contains(table)) {
                        return;
                    }

                    if (!(pillars = table.getCustomData('_cke_table_pillars'))) {
                        // Cache table pillars calculation result.
                        table.setCustomData('_cke_table_pillars', pillars = buildTableColumnPillars(table));
                        table.on('mouseout', clearPillarsCache);
                        table.on('mousedown', clearPillarsCache);
                    }

                    var pillar = getPillarAtPosition(pillars, pageX);

                    if (pillar) {
                        resizer = new columnResizer(editor, pillar);
                    }
                });
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/tabletools.js":
/*!***********************************!*\
  !*** ./src/plugins/tabletools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
	'use strict';

	if (CKEDITOR.plugins.get('ae_tabletools')) {
		return;
	}

	var cellNodeRegex = /^(?:td|th)$/;

	function getSelectedCells(selection) {
		var ranges = selection.getRanges();
		var retval = [];
		var database = {};

		function moveOutOfCellGuard(node) {
			// Apply to the first cell only.
			if (retval.length > 0) return;

			// If we are exiting from the first </td>, then the td should definitely be
			// included.
			if (node.type == CKEDITOR.NODE_ELEMENT && cellNodeRegex.test(node.getName()) && !node.getCustomData('selected_cell')) {
				CKEDITOR.dom.element.setMarker(database, node, 'selected_cell', true);
				retval.push(node);
			}
		}

		for (var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if (range.collapsed) {
				// Walker does not handle collapsed ranges yet - fall back to old API.
				var startNode = range.getCommonAncestor();
				var nearestCell = startNode.getAscendant('td', true) || startNode.getAscendant('th', true);
				if (nearestCell) retval.push(nearestCell);
			} else {
				var walker = new CKEDITOR.dom.walker(range);
				var node;
				walker.guard = moveOutOfCellGuard;

				while (node = walker.next()) {
					// If may be possible for us to have a range like this:
					// <td>^1</td><td>^2</td>
					// The 2nd td shouldn't be included.
					//
					// So we have to take care to include a td we've entered only when we've
					// walked into its children.

					if (node.type != CKEDITOR.NODE_ELEMENT || !node.is(CKEDITOR.dtd.table)) {
						var parent = node.getAscendant('td', true) || node.getAscendant('th', true);
						if (parent && !parent.getCustomData('selected_cell')) {
							CKEDITOR.dom.element.setMarker(database, parent, 'selected_cell', true);
							retval.push(parent);
						}
					}
				}
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		return retval;
	}

	function getFocusElementAfterDelCells(cellsToDelete) {
		var i = 0,
		    last = cellsToDelete.length - 1,
		    database = {},
		    cell,
		    focusedCell,
		    tr;

		while (cell = cellsToDelete[i++]) {
			CKEDITOR.dom.element.setMarker(database, cell, 'delete_cell', true);
		} // 1.first we check left or right side focusable cell row by row;
		i = 0;
		while (cell = cellsToDelete[i++]) {
			if ((focusedCell = cell.getPrevious()) && !focusedCell.getCustomData('delete_cell') || (focusedCell = cell.getNext()) && !focusedCell.getCustomData('delete_cell')) {
				CKEDITOR.dom.element.clearAllMarkers(database);
				return focusedCell;
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		// 2. then we check the toppest row (outside the selection area square) focusable cell
		tr = cellsToDelete[0].getParent();
		if (tr = tr.getPrevious()) return tr.getLast();

		// 3. last we check the lowerest  row focusable cell
		tr = cellsToDelete[last].getParent();
		if (tr = tr.getNext()) return tr.getChild(0);

		return null;
	}

	function insertRow(selection, insertBefore) {
		var cells = getSelectedCells(selection),
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    doc = firstCell.getDocument(),
		    startRow = cells[0].getParent(),
		    startRowIndex = startRow.$.rowIndex,
		    lastCell = cells[cells.length - 1],
		    endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1,
		    endRow = new CKEDITOR.dom.element(table.$.rows[endRowIndex]),
		    rowIndex = insertBefore ? startRowIndex : endRowIndex,
		    row = insertBefore ? startRow : endRow;

		var map = CKEDITOR.tools.buildTableMap(table),
		    cloneRow = map[rowIndex],
		    nextRow = insertBefore ? map[rowIndex - 1] : map[rowIndex + 1],
		    width = map[0].length;

		var newRow = doc.createElement('tr');
		for (var i = 0; cloneRow[i] && i < width; i++) {
			var cell;
			// Check whether there's a spanning row here, do not break it.
			if (cloneRow[i].rowSpan > 1 && nextRow && cloneRow[i] == nextRow[i]) {
				cell = cloneRow[i];
				cell.rowSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneRow[i]).clone();
				cell.removeAttribute('rowSpan');
				cell.appendBogus();
				newRow.append(cell);
				cell = cell.$;
			}

			i += cell.colSpan - 1;
		}

		insertBefore ? newRow.insertBefore(row) : newRow.insertAfter(row);
	}

	function deleteRows(selectionOrRow) {
		if (selectionOrRow instanceof CKEDITOR.dom.selection) {
			var cells = getSelectedCells(selectionOrRow),
			    firstCell = cells[0],
			    table = firstCell.getAscendant('table'),
			    map = CKEDITOR.tools.buildTableMap(table),
			    startRow = cells[0].getParent(),
			    startRowIndex = startRow.$.rowIndex,
			    lastCell = cells[cells.length - 1],
			    endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1,
			    rowsToDelete = [];

			// Delete cell or reduce cell spans by checking through the table map.
			for (var i = startRowIndex; i <= endRowIndex; i++) {
				var mapRow = map[i],
				    row = new CKEDITOR.dom.element(table.$.rows[i]);

				for (var j = 0; j < mapRow.length; j++) {
					var cell = new CKEDITOR.dom.element(mapRow[j]),
					    cellRowIndex = cell.getParent().$.rowIndex;

					if (cell.$.rowSpan == 1) cell.remove();
					// Row spanned cell.
					else {
							// Span row of the cell, reduce spanning.
							cell.$.rowSpan -= 1;
							// Root row of the cell, root cell to next row.
							if (cellRowIndex == i) {
								var nextMapRow = map[i + 1];
								nextMapRow[j - 1] ? cell.insertAfter(new CKEDITOR.dom.element(nextMapRow[j - 1])) : new CKEDITOR.dom.element(table.$.rows[i + 1]).append(cell, 1);
							}
						}

					j += cell.$.colSpan - 1;
				}

				rowsToDelete.push(row);
			}

			var rows = table.$.rows;

			// Where to put the cursor after rows been deleted?
			// 1. Into next sibling row if any;
			// 2. Into previous sibling row if any;
			// 3. Into table's parent element if it's the very last row.
			var cursorPosition = new CKEDITOR.dom.element(rows[endRowIndex + 1] || (startRowIndex > 0 ? rows[startRowIndex - 1] : null) || table.$.parentNode);

			for (i = rowsToDelete.length; i >= 0; i--) {
				deleteRows(rowsToDelete[i]);
			}return cursorPosition;
		} else if (selectionOrRow instanceof CKEDITOR.dom.element) {
			table = selectionOrRow.getAscendant('table');

			if (table.$.rows.length == 1) table.remove();else selectionOrRow.remove();
		}

		return null;
	}

	function getCellColIndex(cell, isStart) {
		var row = cell.getParent(),
		    rowCells = row.$.cells;

		var colIndex = 0;
		for (var i = 0; i < rowCells.length; i++) {
			var mapCell = rowCells[i];
			colIndex += isStart ? 1 : mapCell.colSpan;
			if (mapCell == cell.$) break;
		}

		return colIndex - 1;
	}

	function getColumnsIndices(cells, isStart) {
		var retval = isStart ? Infinity : 0;
		for (var i = 0; i < cells.length; i++) {
			var colIndex = getCellColIndex(cells[i], isStart);
			if (isStart ? colIndex < retval : colIndex > retval) retval = colIndex;
		}
		return retval;
	}

	function insertColumn(selection, insertBefore) {
		var cells = getSelectedCells(selection),
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    startCol = getColumnsIndices(cells, 1),
		    lastCol = getColumnsIndices(cells),
		    colIndex = insertBefore ? startCol : lastCol;

		var map = CKEDITOR.tools.buildTableMap(table),
		    cloneCol = [],
		    nextCol = [],
		    height = map.length;

		for (var i = 0; i < height; i++) {
			cloneCol.push(map[i][colIndex]);
			var nextCell = insertBefore ? map[i][colIndex - 1] : map[i][colIndex + 1];
			nextCol.push(nextCell);
		}

		for (i = 0; i < height; i++) {
			var cell;

			if (!cloneCol[i]) continue;

			// Check whether there's a spanning column here, do not break it.
			if (cloneCol[i].colSpan > 1 && nextCol[i] == cloneCol[i]) {
				cell = cloneCol[i];
				cell.colSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneCol[i]).clone();
				cell.removeAttribute('colSpan');
				cell.appendBogus();
				cell[insertBefore ? 'insertBefore' : 'insertAfter'].call(cell, new CKEDITOR.dom.element(cloneCol[i]));
				cell = cell.$;
			}

			i += cell.rowSpan - 1;
		}
	}

	function deleteColumns(selectionOrCell) {
		var cells = getSelectedCells(selectionOrCell),
		    firstCell = cells[0],
		    lastCell = cells[cells.length - 1],
		    table = firstCell.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    startColIndex,
		    endColIndex,
		    rowsToDelete = [];

		// Figure out selected cells' column indices.
		for (var i = 0, rows = map.length; i < rows; i++) {
			for (var j = 0, cols = map[i].length; j < cols; j++) {
				if (map[i][j] == firstCell.$) startColIndex = j;
				if (map[i][j] == lastCell.$) endColIndex = j;
			}
		}

		// Delete cell or reduce cell spans by checking through the table map.
		for (i = startColIndex; i <= endColIndex; i++) {
			for (j = 0; j < map.length; j++) {
				var mapRow = map[j],
				    row = new CKEDITOR.dom.element(table.$.rows[j]),
				    cell = new CKEDITOR.dom.element(mapRow[i]);

				if (cell.$) {
					if (cell.$.colSpan == 1) cell.remove();
					// Reduce the col spans.
					else cell.$.colSpan -= 1;

					j += cell.$.rowSpan - 1;

					if (!row.$.cells.length) rowsToDelete.push(row);
				}
			}
		}

		var firstRowCells = table.$.rows[0] && table.$.rows[0].cells;

		// Where to put the cursor after columns been deleted?
		// 1. Into next cell of the first row if any;
		// 2. Into previous cell of the first row if any;
		// 3. Into table's parent element;
		var cursorPosition = new CKEDITOR.dom.element(firstRowCells[startColIndex] || (startColIndex ? firstRowCells[startColIndex - 1] : table.$.parentNode));

		// Delete table rows only if all columns are gone (do not remove empty row).
		if (rowsToDelete.length == rows) table.remove();

		return cursorPosition;
	}

	function insertCell(selection, insertBefore) {
		var startElement = selection.getStartElement();
		var cell = startElement.getAscendant('td', 1) || startElement.getAscendant('th', 1);

		if (!cell) return;

		// Create the new cell element to be added.
		var newCell = cell.clone();
		newCell.appendBogus();

		if (insertBefore) newCell.insertBefore(cell);else newCell.insertAfter(cell);
	}

	function deleteCells(selectionOrCell) {
		if (selectionOrCell instanceof CKEDITOR.dom.selection) {
			var cellsToDelete = getSelectedCells(selectionOrCell);
			var table = cellsToDelete[0] && cellsToDelete[0].getAscendant('table');
			var cellToFocus = getFocusElementAfterDelCells(cellsToDelete);

			for (var i = cellsToDelete.length - 1; i >= 0; i--) {
				deleteCells(cellsToDelete[i]);
			}if (cellToFocus) placeCursorInCell(cellToFocus, true);else if (table) table.remove();
		} else if (selectionOrCell instanceof CKEDITOR.dom.element) {
			var tr = selectionOrCell.getParent();
			if (tr.getChildCount() == 1) tr.remove();else selectionOrCell.remove();
		}
	}

	// Remove filler at end and empty spaces around the cell content.
	function trimCell(cell) {
		var bogus = cell.getBogus();
		bogus && bogus.remove();
		cell.trim();
	}

	function placeCursorInCell(cell, placeAtEnd) {
		var docInner = cell.getDocument(),
		    docOuter = CKEDITOR.document;

		// Fixing "Unspecified error" thrown in IE10 by resetting
		// selection the dirty and shameful way (#10308).
		// We can not apply this hack to IE8 because
		// it causes error (#11058).
		if (CKEDITOR.env.ie && CKEDITOR.env.version == 10) {
			docOuter.focus();
			docInner.focus();
		}

		var range = new CKEDITOR.dom.range(docInner);
		if (!range['moveToElementEdit' + (placeAtEnd ? 'End' : 'Start')](cell)) {
			range.selectNodeContents(cell);
			range.collapse(placeAtEnd ? false : true);
		}
		range.select(true);
	}

	function cellInRow(tableMap, rowIndex, cell) {
		var oRow = tableMap[rowIndex];
		if (typeof cell == 'undefined') return oRow;

		for (var c = 0; oRow && c < oRow.length; c++) {
			if (cell.is && oRow[c] == cell.$) return c;else if (c == cell) return new CKEDITOR.dom.element(oRow[c]);
		}
		return cell.is ? -1 : null;
	}

	function cellInCol(tableMap, colIndex) {
		var oCol = [];
		for (var r = 0; r < tableMap.length; r++) {
			var row = tableMap[r];
			oCol.push(row[colIndex]);

			// Avoid adding duplicate cells.
			if (row[colIndex].rowSpan > 1) r += row[colIndex].rowSpan - 1;
		}
		return oCol;
	}

	function mergeCells(selection, mergeDirection, isDetect) {
		var cells = getSelectedCells(selection);

		// Invalid merge request if:
		// 1. In batch mode despite that less than two selected.
		// 2. In solo mode while not exactly only one selected.
		// 3. Cells distributed in different table groups (e.g. from both thead and tbody).
		var commonAncestor;
		if ((mergeDirection ? cells.length != 1 : cells.length < 2) || (commonAncestor = selection.getCommonAncestor()) && commonAncestor.type == CKEDITOR.NODE_ELEMENT && commonAncestor.is('table')) return false;

		var cell,
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    mapHeight = map.length,
		    mapWidth = map[0].length,
		    startRow = firstCell.getParent().$.rowIndex,
		    startColumn = cellInRow(map, startRow, firstCell);

		if (mergeDirection) {
			var targetCell;
			try {
				var rowspan = parseInt(firstCell.getAttribute('rowspan'), 10) || 1;
				var colspan = parseInt(firstCell.getAttribute('colspan'), 10) || 1;

				targetCell = map[mergeDirection == 'up' ? startRow - rowspan : mergeDirection == 'down' ? startRow + rowspan : startRow][mergeDirection == 'left' ? startColumn - colspan : mergeDirection == 'right' ? startColumn + colspan : startColumn];
			} catch (er) {
				return false;
			}

			// 1. No cell could be merged.
			// 2. Same cell actually.
			if (!targetCell || firstCell.$ == targetCell) return false;

			// Sort in map order regardless of the DOM sequence.
			cells[mergeDirection == 'up' || mergeDirection == 'left' ? 'unshift' : 'push'](new CKEDITOR.dom.element(targetCell));
		}

		// Start from here are merging way ignorance (merge up/right, batch merge).
		var doc = firstCell.getDocument(),
		    lastRowIndex = startRow,
		    totalRowSpan = 0,
		    totalColSpan = 0,

		// Use a documentFragment as buffer when appending cell contents.
		frag = !isDetect && new CKEDITOR.dom.documentFragment(doc),
		    dimension = 0;

		for (var i = 0; i < cells.length; i++) {
			cell = cells[i];

			var tr = cell.getParent(),
			    cellFirstChild = cell.getFirst(),
			    colSpan = cell.$.colSpan,
			    rowSpan = cell.$.rowSpan,
			    rowIndex = tr.$.rowIndex,
			    colIndex = cellInRow(map, rowIndex, cell);

			// Accumulated the actual places taken by all selected cells.
			dimension += colSpan * rowSpan;
			// Accumulated the maximum virtual spans from column and row.
			totalColSpan = Math.max(totalColSpan, colIndex - startColumn + colSpan);
			totalRowSpan = Math.max(totalRowSpan, rowIndex - startRow + rowSpan);

			if (!isDetect) {
				// Trim all cell fillers and check to remove empty cells.
				if (trimCell(cell), cell.getChildren().count()) {
					// Merge vertically cells as two separated paragraphs.
					if (rowIndex != lastRowIndex && cellFirstChild && !(cellFirstChild.isBlockBoundary && cellFirstChild.isBlockBoundary({ br: 1 }))) {
						var last = frag.getLast(CKEDITOR.dom.walker.whitespaces(true));
						if (last && !(last.is && last.is('br'))) frag.append('br');
					}

					cell.moveChildren(frag);
				}
				i ? cell.remove() : cell.setHtml('');
			}
			lastRowIndex = rowIndex;
		}

		if (!isDetect) {
			frag.moveChildren(firstCell);

			firstCell.appendBogus();

			if (totalColSpan >= mapWidth) firstCell.removeAttribute('rowSpan');else firstCell.$.rowSpan = totalRowSpan;

			if (totalRowSpan >= mapHeight) firstCell.removeAttribute('colSpan');else firstCell.$.colSpan = totalColSpan;

			// Swip empty <tr> left at the end of table due to the merging.
			var trs = new CKEDITOR.dom.nodeList(table.$.rows),
			    count = trs.count();

			for (i = count - 1; i >= 0; i--) {
				var tailTr = trs.getItem(i);
				if (!tailTr.$.cells.length) {
					tailTr.remove();
					count++;
					continue;
				}
			}

			return firstCell;
		}
		// Be able to merge cells only if actual dimension of selected
		// cells equals to the caculated rectangle.
		else {
				return totalRowSpan * totalColSpan == dimension;
			}
	}

	function verticalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0],
		    tr = cell.getParent(),
		    table = tr.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    rowIndex = tr.$.rowIndex,
		    colIndex = cellInRow(map, rowIndex, cell),
		    rowSpan = cell.$.rowSpan,
		    newCell,
		    newRowSpan,
		    newCellRowSpan,
		    newRowIndex;

		if (rowSpan > 1) {
			newRowSpan = Math.ceil(rowSpan / 2);
			newCellRowSpan = Math.floor(rowSpan / 2);
			newRowIndex = rowIndex + newRowSpan;
			var newCellTr = new CKEDITOR.dom.element(table.$.rows[newRowIndex]),
			    newCellRow = cellInRow(map, newRowIndex),
			    candidateCell;

			newCell = cell.clone();

			// Figure out where to insert the new cell by checking the vitual row.
			for (var c = 0; c < newCellRow.length; c++) {
				candidateCell = newCellRow[c];
				// Catch first cell actually following the column.
				if (candidateCell.parentNode == newCellTr.$ && c > colIndex) {
					newCell.insertBefore(new CKEDITOR.dom.element(candidateCell));
					break;
				} else {
					candidateCell = null;
				}
			}

			// The destination row is empty, append at will.
			if (!candidateCell) newCellTr.append(newCell);
		} else {
			newCellRowSpan = newRowSpan = 1;

			newCellTr = tr.clone();
			newCellTr.insertAfter(tr);
			newCellTr.append(newCell = cell.clone());

			var cellsInSameRow = cellInRow(map, rowIndex);
			for (var i = 0; i < cellsInSameRow.length; i++) {
				cellsInSameRow[i].rowSpan++;
			}
		}

		newCell.appendBogus();

		cell.$.rowSpan = newRowSpan;
		newCell.$.rowSpan = newCellRowSpan;
		if (newRowSpan == 1) cell.removeAttribute('rowSpan');
		if (newCellRowSpan == 1) newCell.removeAttribute('rowSpan');

		return newCell;
	}

	function horizontalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0],
		    tr = cell.getParent(),
		    table = tr.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    rowIndex = tr.$.rowIndex,
		    colIndex = cellInRow(map, rowIndex, cell),
		    colSpan = cell.$.colSpan,
		    newCell,
		    newColSpan,
		    newCellColSpan;

		if (colSpan > 1) {
			newColSpan = Math.ceil(colSpan / 2);
			newCellColSpan = Math.floor(colSpan / 2);
		} else {
			newCellColSpan = newColSpan = 1;
			var cellsInSameCol = cellInCol(map, colIndex);
			for (var i = 0; i < cellsInSameCol.length; i++) {
				cellsInSameCol[i].colSpan++;
			}
		}
		newCell = cell.clone();
		newCell.insertAfter(cell);
		newCell.appendBogus();

		cell.$.colSpan = newColSpan;
		newCell.$.colSpan = newCellColSpan;
		if (newColSpan == 1) cell.removeAttribute('colSpan');
		if (newCellColSpan == 1) newCell.removeAttribute('colSpan');

		return newCell;
	}

	CKEDITOR.plugins.add('ae_tabletools', {
		init: function init(editor) {
			var lang = editor.lang.table;

			function createDef(def) {
				return CKEDITOR.tools.extend(def || {}, {
					contextSensitive: 1,
					refresh: function refresh(editor, path) {
						this.setState(path.contains({ td: 1, th: 1 }, 1) ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
					}
				});
			}
			function addCmd(name, def) {
				var cmd = editor.getCommand(name);

				if (cmd) {
					return;
				}

				cmd = editor.addCommand(name, def);
				editor.addFeature(cmd);
			}

			addCmd('rowDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					placeCursorInCell(deleteRows(selection));
				}
			}));

			addCmd('rowInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection, true);
				}
			}));

			addCmd('rowInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection);
				}
			}));

			addCmd('columnDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					var element = deleteColumns(selection);
					element && placeCursorInCell(element, true);
				}
			}));

			addCmd('columnInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection, true);
				}
			}));

			addCmd('columnInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection);
				}
			}));

			addCmd('cellDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					deleteCells(selection);
				}
			}));

			addCmd('cellMerge', createDef({
				allowedContent: 'td[colspan,rowspan]',
				requiredContent: 'td[colspan,rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection()), true);
				}
			}));

			addCmd('cellMergeRight', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'right'), true);
				}
			}));

			addCmd('cellMergeDown', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'down'), true);
				}
			}));

			addCmd('cellVerticalSplit', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(verticalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellHorizontalSplit', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(horizontalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection, true);
				}
			}));

			addCmd('cellInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection);
				}
			}));
		},

		getSelectedCells: getSelectedCells

	});
})();

/**
 * Create a two-dimension array that reflects the actual layout of table cells,
 * with cell spans, with mappings to the original td elements.
 *
 * @param {CKEDITOR.dom.element} table
 * @member CKEDITOR.tools
 */
CKEDITOR.tools.buildTableMap = function (table) {
	var aRows = table.$.rows;

	// Row and Column counters.
	var r = -1;

	var aMap = [];

	for (var i = 0; i < aRows.length; i++) {
		r++;
		!aMap[r] && (aMap[r] = []);

		var c = -1;

		for (var j = 0; j < aRows[i].cells.length; j++) {
			var oCell = aRows[i].cells[j];

			c++;
			while (aMap[r][c]) {
				c++;
			}var iColSpan = isNaN(oCell.colSpan) ? 1 : oCell.colSpan;
			var iRowSpan = isNaN(oCell.rowSpan) ? 1 : oCell.rowSpan;

			for (var rs = 0; rs < iRowSpan; rs++) {
				if (!aMap[r + rs]) aMap[r + rs] = [];

				for (var cs = 0; cs < iColSpan; cs++) {
					aMap[r + rs][c + cs] = aRows[i].cells[j];
				}
			}

			c += iColSpan - 1;
		}
	}
	return aMap;
};

/***/ }),

/***/ "./src/selections/selection-arrowbox.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-arrowbox.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var tableSelectionGetArrowBoxClasses = function tableSelectionGetArrowBoxClasses() {
    return 'ae-arrow-box ae-arrow-box-bottom';
};

var SelectionGetArrowBoxClasses = {
    table: tableSelectionGetArrowBoxClasses
};

exports.default = SelectionGetArrowBoxClasses;

/***/ }),

/***/ "./src/selections/selection-position.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-position.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default gutter value for toolbar positioning
var DEFAULT_GUTTER = {
    left: 0,
    top: 0
};

/**
 * Centers a Toolbar according to given rectangle
 *
 * @method centerToolbar
 * @param {Object} toolbar The toolbar to be centered
 * @param {Object} rect The rectangle according to which the Toolbar will be centered
 */
var centerToolbar = function centerToolbar(toolbar, rect) {
    var toolbarNode = _reactDom2.default.findDOMNode(toolbar);

    var nativeEditor = toolbar.props.editor.get('nativeEditor');
    var uiNode = nativeEditor.config.uiNode || document.body;
    var uiNodeStyle = getComputedStyle(uiNode);
    var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
    var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
    var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

    var halfNodeWidth = toolbarNode.offsetWidth / 2;
    var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

    var gutter = toolbar.props.gutter || DEFAULT_GUTTER;

    var widgetXY = toolbar.getWidgetXYPoint(rect.left + rect.width / 2 - scrollPosition.x, rect.top + scrollPosition.y, CKEDITOR.SELECTION_BOTTOM_TO_TOP);

    var endPosition = [rect.left + rect.width / 2 - halfNodeWidth - scrollPosition.x, rect.top - toolbarNode.offsetHeight + scrollPosition.y - gutter.top];

    if (endPosition[0] < 0) {
        endPosition[0] = 0;
    } else if (endPosition[0] > totalWidth - toolbarNode.offsetWidth) {
        endPosition[0] = totalWidth - toolbarNode.offsetWidth;
    }

    toolbar.moveToPoint(widgetXY, endPosition);
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method imageSelectionSetPosition
 * @param {Object} payload Payload, should contain the selection data for retrieving the
 * client rectangle of the selected image
 * @return {Boolean} True, in all cases
 */
var imageSelectionSetPosition = function imageSelectionSetPosition(payload) {
    var selectionData = payload.selectionData ? payload.selectionData : payload.editorEvent ? payload.editorEvent.data.selectionData : null;

    if (selectionData && selectionData.element) {
        centerToolbar(this, selectionData.element.getClientRect());

        return true;
    }
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method tableSelectionSetPosition
 * @param {Object} payload Object, which contains the selection data for retrieving the
 * client rectangle of the selected table
 * @return {Boolean} True, in all cases
 */
var tableSelectionSetPosition = function tableSelectionSetPosition(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');
    var uiNode = nativeEditor.config.uiNode;

    var scrollTop = uiNode ? uiNode.scrollTop : 0;

    var table = new CKEDITOR.Table(nativeEditor).getFromSelection();
    var rect = table.getClientRect();
    rect.top += scrollTop;

    centerToolbar(this, rect);

    return true;
};

var SelectionSetPosition = {
    image: imageSelectionSetPosition,
    table: tableSelectionSetPosition
};

exports.default = SelectionSetPosition;

/***/ }),

/***/ "./src/selections/selection-test.js":
/*!******************************************!*\
  !*** ./src/selections/selection-test.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var _isRangeAtElementEnd = function _isRangeAtElementEnd(range, element) {
    // Finding if a range is at the end of an element is somewhat tricky due to how CKEditor handles
    // ranges. It might depend on wether a source node inside the element is selected or not. For now,
    // we need to cover the following cases:
    //
    // - The text length of the element is the same as the endOffset of the range
    // - Both start and end containers match the element and the start and end offsets are 1

    return element.getText().length === range.endOffset || element.equals(range.startContainer) && element.equals(range.endContainer) && range.startOffset === range.endOffset && range.endOffset === 1;
};

var embedSelectionTest = function embedSelectionTest(payload) {
    var selectionData = payload.data.selectionData;

    return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'ae_embed');
};

var linkSelectionTest = function linkSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');
    var range = nativeEditor.getSelection().getRanges()[0];

    var element;

    return !!(nativeEditor.isSelectionEmpty() && (element = new CKEDITOR.Link(nativeEditor).getFromSelection()) && element.getText().length !== range.endOffset && !element.isReadOnly() && !_isRangeAtElementEnd(range, element));
};

var imageSelectionTest = function imageSelectionTest(payload) {
    var selectionData = payload.data.selectionData;

    return !!(selectionData.element && selectionData.element.getName() === 'img' && !selectionData.element.isReadOnly());
};

var textSelectionTest = function textSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var selectionEmpty = nativeEditor.isSelectionEmpty();

    var selectionData = payload.data.selectionData;

    return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly());
};

var tableSelectionTest = function tableSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var table = new CKEDITOR.Table(nativeEditor);
    var element = table.getFromSelection();

    return !!(element && table.isEditable(element));
};

var SelectionTest = {
    embed: embedSelectionTest,
    image: imageSelectionTest,
    link: linkSelectionTest,
    table: tableSelectionTest,
    text: textSelectionTest
};

exports.default = SelectionTest;

/***/ }),

/***/ "./src/selections/selections.js":
/*!**************************************!*\
  !*** ./src/selections/selections.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _selectionArrowbox = __webpack_require__(/*! ./selection-arrowbox.js */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ./selection-position.js */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ./selection-test.js */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Selections = [{
    name: 'embed',
    buttons: ['embedRemove', 'embedEdit'],
    test: _selectionTest2.default.embed
}, {
    name: 'link',
    buttons: ['linkEdit'],
    test: _selectionTest2.default.link
}, {
    name: 'image',
    buttons: ['imageLeft', 'imageCenter', 'imageRight'],
    setPosition: _selectionPosition2.default.image,
    test: _selectionTest2.default.image
}, {
    name: 'text',
    buttons: {
        full: [['Font', 'FontSize', 'separator', 'bold', 'italic', 'underline', 'strike', 'separator', 'link'], ['paragraphAlign', 'separator', 'ul', 'ol', 'separator', 'h1', 'h2', 'separator', 'indentBlock', 'outdentBlock', 'separator', 'TextColor', 'BGColor', 'separator', 'code', 'quote', 'separator', 'removeFormat']],
        simple: ['styles', 'bold', 'italic', 'underline', 'link']
    },
    test: _selectionTest2.default.text
}, {
    name: 'table',
    buttons: ['tableHeading', 'tableRow', 'tableColumn', 'tableCell', 'tableRemove'],
    getArrowBoxClasses: _selectionArrowbox2.default.table,
    setPosition: _selectionPosition2.default.table,
    test: _selectionTest2.default.table
}];

exports.default = Selections;

/***/ }),

/***/ "react":
/*!****************************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"} ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ }),

/***/ "react-dom":
/*!***********************************************************************************************************************!*\
  !*** external {"root":"ReactDOM","commonjs2":"react-dom","commonjs":"react-dom","amd":"react-dom","umd":"react-dom"} ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BbGxveUVkaXRvci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2FkYXB0ZXIvY29yZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL21haW4uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1rZXlzdHJva2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1wcm9wcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1zdHlsZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2UvdG9vbGJhci1idXR0b25zLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtYXJyb3ctYm94LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtZHJvcGRvd24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL3dpZGdldC1leGNsdXNpdmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1ib2xkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNhbWVyYS1pbWFnZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jYW1lcmEuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY29kZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jb21tYW5kLWxpc3QtaXRlbS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLWVkaXQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tZW1iZWQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taDEuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taDIuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taGxpbmUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UtYWxpZ24tY2VudGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLWxlZnQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UtYWxpZ24tcmlnaHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW5kZW50LWJsb2NrLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWl0YWxpYy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWF1dG9jb21wbGV0ZS1saXN0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLXRhcmdldC1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmsuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tb2wuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tb3V0ZGVudC1ibG9jay5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tbGVmdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tcmlnaHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWNlbnRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1xdW90ZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1yZW1vdmUtZm9ybWF0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXNlcGFyYXRvci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdHJpa2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN1YnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdXBlcnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1jZWxsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWNvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWhlYWRpbmcuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUtcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLXJvdy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YXJnZXQtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10d2l0dGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVuZGVybGluZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvbWFpbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy90b29sYmFycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItYWRkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL2J1dHRvbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy91aWJyaWRnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL21lbnUtYnV0dG9uLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL21lbnUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdWlicmlkZ2UvcGFuZWwtbWVudS1idXR0b24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdWlicmlkZ2UvcmljaGNvbWJvLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL3VpYnJpZGdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9wbHVnaW5zLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvc2VsZWN0aW9uLXJlZ2lvbi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL3RhYmxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvdG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS91aWNvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvYmFzZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvbGFuZy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3Avb29wLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYWRkaW1hZ2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYXV0b2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9hdXRvbGlzdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2RyYWdyZXNpemUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9kcmFncmVzaXplX2llLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9pbWFnZWFsaWdubWVudC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvcGFzdGVpbWFnZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9wbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3NlbGVjdGlvbmtleXN0cm9rZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy90YWJsZXJlc2l6ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3RhYmxldG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tYXJyb3dib3guanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9zZWxlY3Rpb25zL3NlbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwiLFwidW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdERPTVwiLFwiY29tbW9uanMyXCI6XCJyZWFjdC1kb21cIixcImNvbW1vbmpzXCI6XCJyZWFjdC1kb21cIixcImFtZFwiOlwicmVhY3QtZG9tXCIsXCJ1bWRcIjpcInJlYWN0LWRvbVwifSJdLCJuYW1lcyI6WyJDb3JlIiwiY29uZmlnIiwic3VwZXJjbGFzcyIsImNvbnN0cnVjdG9yIiwiY2FsbCIsImluaXRpYWxpemVyIiwibm9kZSIsImdldCIsInNldEF0dHJpYnV0ZSIsImVkaXRvciIsIkNLRURJVE9SIiwiaW5saW5lIiwiYWxsb3dlZENvbnRlbnQiLCJ0b29sYmFycyIsInJlbW92ZVBsdWdpbnMiLCJleHRyYVBsdWdpbnMiLCJwbGFjZWhvbGRlckNsYXNzIiwicGFzdGVGcm9tV29yZFJlbW92ZVN0eWxlcyIsInBhc3RlRnJvbVdvcmRSZW1vdmVGb250U3R5bGVzIiwic2VsZWN0aW9uS2V5c3Ryb2tlcyIsIm1peCIsImVudiIsImllIiwiZWRnZSIsInJlcGxhY2UiLCJvbmNlIiwiX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIiLCJlZGl0YWJsZSIsImFkZENsYXNzIiwiYmluZCIsIl9lZGl0b3IiLCJBbGxveUVkaXRvciIsImxvYWRMYW5ndWFnZVJlc291cmNlcyIsIl9yZW5kZXJVSSIsImRlc3RydWN0b3IiLCJfZGVzdHJveWVkIiwiX2VkaXRvclVJRWxlbWVudCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJuYXRpdmVFZGl0b3IiLCJyZW1vdmVDbGFzcyIsIl9jbGVhclNlbGVjdGlvbnMiLCJkZXN0cm95IiwiaXNNU1NlbGVjdGlvbiIsIndpbmRvdyIsImdldFNlbGVjdGlvbiIsImRvY3VtZW50IiwiJCIsInNlbGVjdGlvbiIsImVtcHR5IiwiZ2V0V2luZG93IiwicmVtb3ZlQWxsUmFuZ2VzIiwib24iLCJfZGVmYXVsdFJlYWRPbmx5Q2xpY2tGbiIsImV2ZW50IiwibW91c2VFdmVudCIsImRhdGEiLCJoYXNDdHJsS2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaG91bGRPcGVuIiwicmVhZE9ubHkiLCJwcmV2ZW50RGVmYXVsdCIsImxpc3RlbmVyRGF0YSIsImZpcmUiLCJja0VsZW1lbnQiLCJkb20iLCJlbGVtZW50UGF0aCIsImdldFRhcmdldCIsImxpbmsiLCJsYXN0RWxlbWVudCIsImhyZWYiLCJhdHRyaWJ1dGVzIiwidmFsdWUiLCJ0YXJnZXQiLCJfcmVkaXJlY3RMaW5rIiwiX2dldE5hdGl2ZUVkaXRvciIsIm9wZW4iLCJsb2NhdGlvbiIsImVkaXRvclVJRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJ1aU5vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJfbWFpblVJIiwicmVuZGVyIiwiX3RvRWxlbWVudCIsImlzU3RyaW5nIiwiZ2V0RWxlbWVudEJ5SWQiLCJfdmFsaWRhdGVBbGxvd2VkQ29udGVudCIsImlzT2JqZWN0IiwiaXNCb29sZWFuIiwiX3ZhbGlkYXRlVG9vbGJhcnMiLCJpc051bGwiLCJBVFRSUyIsInZhbGlkYXRvciIsIndyaXRlT25jZSIsImVuYWJsZUNvbnRlbnRFZGl0YWJsZSIsImV2ZW50c0RlbGF5IiwiaXNOdW1iZXIiLCJtb2RlIiwiZ2V0dGVyIiwiaXNBcnJheSIsImtleXMiLCJDVFJMIiwiU0hJRlQiLCJzcmNOb2RlIiwic2V0dGVyIiwiYWRkIiwiYnV0dG9ucyIsInRhYkluZGV4Iiwic3R5bGVzIiwic2VsZWN0aW9ucyIsImltcGxlbWVudE9uIiwiQlJJREdFX0JVVFRPTlMiLCJpbXBsZW1lbnRFdmVudFRhcmdldCIsImdldEJhc2VQYXRoIiwicGF0aCIsIkFMTE9ZRURJVE9SX0JBU0VQQVRIIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaSIsImxlbmd0aCIsIm1hdGNoIiwic3JjIiwicmVnZXhCYXNlUGF0aCIsImluZGV4T2YiLCJzbGljZSIsImNhbGxiYWNrIiwiaXNGdW5jdGlvbiIsIlN0cmluZ3MiLCJzZXRUaW1lb3V0IiwiX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCIsImxhbmd1YWdlcyIsInVzZXJMYW5ndWFnZSIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwicGFydHMiLCJ0b0xvd2VyQ2FzZSIsImxhbmciLCJsb2NhbGUiLCJzY3JpcHRMb2FkZXIiLCJsb2FkIiwiZ2V0VXJsIiwibG9hZGVkIiwicmVzb3VyY2UiLCJiYXNlUGF0aCIsInRpbWVzdGFtcCIsImNoYXJBdCIsInRlc3QiLCJnZXRCdXR0b25zIiwicmVkdWNlIiwiYWNjIiwidmFsIiwiY29uY2F0IiwicmVnaXN0ZXJCcmlkZ2VCdXR0b24iLCJidXR0b25OYW1lIiwicGx1Z2luTmFtZSIsInB1c2giLCJPT1AiLCJleHRlbmQiLCJBdHRyaWJ1dGUiLCJCdXR0b25zIiwiTGFuZyIsIlNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyIsIlNlbGVjdGlvbnMiLCJTZWxlY3Rpb25TZXRQb3NpdGlvbiIsIlNlbGVjdGlvblRlc3QiLCJUb29sYmFycyIsImlzQWN0aXZlIiwiZ2V0U3R5bGUiLCJwcm9wcyIsImxvY2siLCJyZW1vdmVTdHlsZSIsImFwcGx5U3R5bGUiLCJ1bmxvY2siLCJXcmFwcGVkQ29tcG9uZW50IiwiY29tbWFuZCIsImdldENvbW1hbmQiLCJzdGF0ZSIsIlRSSVNUQVRFX09OIiwiZXhlY0NvbW1hbmQiLCJtb2RpZmllc1NlbGVjdGlvbiIsInNlbGVjdGlvbkNoYW5nZSIsImtleXN0cm9rZSIsImNvbW1hbmROYW1lIiwibmFtZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImV4ZWMiLCJrZXlzdHJva2VGbiIsImZuIiwiYWRkQ29tbWFuZCIsIl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZCIsImtleXN0cm9rZUhhbmRsZXIiLCJrZXlzdHJva2VzIiwic2V0S2V5c3Ryb2tlIiwiYnV0dG9uQ2ZnIiwicmVzdWx0IiwidG9vbHMiLCJtZXJnZSIsInN0YXRlQ2xhc3NlcyIsImlzRGlzYWJsZWQiLCJzdHlsZSIsInNwbGl0IiwiY3VycmVudE1lbWJlciIsInByb3BlcnR5Iiwic2hpZnQiLCJfc3R5bGUiLCJjaGVja0FjdGl2ZSIsImFkZGl0aW9uYWxQcm9wcyIsImluc3RhbmNlIiwibGlzdCIsImJ1dHRvbiIsIkFycmF5IiwiZ2V0VG9vbGJhckJ1dHRvbnMiLCJidXR0b25Qcm9wcyIsInRvb2xiYXJCdXR0b25zIiwiZmlsdGVyRXhjbHVzaXZlIiwiZmlsdGVyIiwibWFwIiwia2V5IiwiY2ZnIiwiaW5kZXgiLCJtZXJnZUV4Y2x1c2l2ZVByb3BzIiwidGFiS2V5IiwidHJpZ2dlciIsIm1lcmdlRHJvcGRvd25Qcm9wcyIsImFycm93Qm94Q2xhc3NlcyIsImdldEludGVyYWN0aW9uUG9pbnQiLCJkaXJlY3Rpb24iLCJTRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSIsImRyb3Bkb3duVHJpZ2dlciIsIml0ZW1Ecm9wZG93biIsIm5leHRQcm9wcyIsInNldFN0YXRlIiwib2JqIiwiaXRlbUtleSIsImV4cGFuZGVkIiwidG9nZ2xlRHJvcGRvd24iLCJ0b2dnbGVEaXJlY3Rpb24iLCJtb3ZlRm9jdXMiLCJmaW5kRE9NTm9kZSIsImZvY3VzIiwiaXRlbUV4Y2x1c2l2ZSIsIml0ZW1zIiwiaXRlbSIsImNhbmNlbEV4Y2x1c2l2ZSIsInJlbmRlckV4Y2x1c2l2ZSIsInJlcXVlc3RFeGNsdXNpdmUiLCJESVJFQ1RJT05fTk9ORSIsIkRJUkVDVElPTl9ORVhUIiwiRElSRUNUSU9OX1BSRVYiLCJBQ1RJT05fTk9ORSIsIkFDVElPTl9NT1ZFX0ZPQ1VTIiwiQUNUSU9OX0RJU01JU1NfRk9DVVMiLCJfcmVmcmVzaCIsIl9pc1ZhbGlkVGFyZ2V0IiwiX2Rlc2NlbmRhbnRzIiwiYWN0aXZlRGVzY2VuZGFudEVsIiwiX2FjdGl2ZURlc2NlbmRhbnQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXNGaXJzdENoaWxkIiwic3RvcFByb3BhZ2F0aW9uIiwiYWN0aW9uIiwiX2dldEZvY3VzQWN0aW9uIiwidHlwZSIsIl9tb3ZlRm9jdXMiLCJvbkRpc21pc3MiLCJfZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uIiwiZGlzbWlzc0FjdGlvbiIsIl9nZXRGb2N1c0Rpc21pc3NBY3Rpb24iLCJkaXNtaXNzIiwiZm9jdXNNb3ZlRGlyZWN0aW9uIiwiX2lzVmFsaWRLZXkiLCJrZXlDb2RlIiwiZGlzbWlzc05leHQiLCJkaXNtaXNzUHJldiIsImNpcmN1bGFyIiwibmV4dCIsInByZXYiLCJzaGlmS2V5IiwiZWxlbWVudCIsInRhZ05hbWUiLCJudW1EZXNjZW5kYW50cyIsImRlc2NlbmRhbnQiLCJtYXgiLCJtaW4iLCJkb21Ob2RlIiwiZGVzY2VuZGFudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwicHJpb3JpdHlEZXNjZW5kYW50cyIsInByb3RvdHlwZSIsImZvckVhY2giLCJkYXRhVGFiSW5kZXgiLCJnZXRBdHRyaWJ1dGUiLCJzb3J0IiwiYSIsImIiLCJ0b0ludCIsInNvbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIl9hbmltYXRpb25GcmFtZUlkIiwiYXR0cnMiLCJ2aWV3UGFuZVNpemUiLCJnZXRWaWV3UGFuZVNpemUiLCJ4IiwibGVmdCIsInkiLCJ0b3AiLCJ3aWR0aCIsImV2ZW50UGF5bG9hZCIsImVkaXRvckV2ZW50Iiwic2VsZWN0aW9uRGF0YSIsIm5hdGl2ZUV2ZW50IiwicG9zIiwicGFnZVgiLCJyZWdpb24iLCJlbmRSZWN0Iiwic3RhcnRSZWN0IiwiU0VMRUNUSU9OX0JPVFRPTV9UT19UT1AiLCJfZ2V0WFBvaW50IiwiX2dldFlQb2ludCIsImV2ZW50WCIsInJpZ2h0IiwibGVmdERpc3QiLCJhYnMiLCJyaWdodERpc3QiLCJlbGVtZW50VGFyZ2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0SGVpZ2h0IiwiYm90dG9tIiwiZ3V0dGVyIiwib2Zmc2V0V2lkdGgiLCJTRUxFQ1RJT05fTEVGVF9UT19SSUdIVCIsIlNFTEVDVElPTl9SSUdIVF9UT19MRUZUIiwiZG9tRWxlbWVudCIsImhhc0NsYXNzIiwic3RhcnRQb2ludCIsImVuZFBvaW50Iiwic2V0U3R5bGVzIiwib3BhY2l0eSIsIl9hbmltYXRlIiwic2Nyb2xsVG9wIiwiaXNWaXNpYmxlIiwiaW50ZXJhY3Rpb25Qb2ludCIsImZpbmFsWCIsImZpbmFsWSIsImluaXRpYWxYIiwiaW5pdGlhbFkiLCJwYXJzZUZsb2F0IiwiY29uc3RyYWluVG9WaWV3cG9ydCIsInJlcyIsImdldENvbnN0cmFpbmVkUG9zaXRpb24iLCJoZWlnaHQiLCJtb3ZlVG9Qb2ludCIsInVpTm9kZVN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInVpTm9kZU1hcmdpbkxlZnQiLCJwYXJzZUludCIsImdldFByb3BlcnR5VmFsdWUiLCJ1aU5vZGVNYXJnaW5SaWdodCIsInRvdGFsV2lkdGgiLCJjbGllbnRXaWR0aCIsInh5IiwiZ2V0V2lkZ2V0WFlQb2ludCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRlZmF1bHRQcm9wcyIsIkJ1dHRvbkJvbGQiLCJjc3NDbGFzcyIsImdldFN0YXRlQ2xhc3NlcyIsImJvbGQiLCJDb21wb25lbnQiLCJCdXR0b25DYW1lcmFJbWFnZSIsInJlZnMiLCJidXR0b25UYWtlUGhvdG8iLCJfc3RyZWFtIiwic3RvcCIsImdldFZpZGVvVHJhY2tzIiwidHJhY2siLCJnZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJtb3pHZXRVc2VyTWVkaWEiLCJtc0dldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJfaGFuZGxlU3RyZWFtU3VjY2VzcyIsIl9oYW5kbGVTdHJlYW1FcnJvciIsInRha2VQaG90byIsInZpZGVvRWwiLCJ2aWRlb0NvbnRhaW5lciIsImNhbnZhc0VsIiwiY2FudmFzQ29udGFpbmVyIiwiY29udGV4dCIsImdldENvbnRleHQiLCJfdmlkZW9IZWlnaHQiLCJ2aWRlb1dpZHRoIiwiZHJhd0ltYWdlIiwiaW1nVVJMIiwidG9EYXRhVVJMIiwiZWwiLCJjcmVhdGVGcm9tSHRtbCIsImluc2VydEVsZW1lbnQiLCJlcnJvciIsImFsZXJ0Iiwic3RyZWFtIiwiYWRkRXZlbnRMaXN0ZW5lciIsInZpZGVvSGVpZ2h0IiwiaXNOYU4iLCJtb3pTcmNPYmplY3QiLCJVUkwiLCJ3ZWJraXRVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJwbGF5IiwiZGlzYWJsZWQiLCJCdXR0b25DYW1lcmEiLCJwcm90b2NvbCIsImxhYmVsIiwiY2FtZXJhRGlzYWJsZWQiLCJjYW1lcmEiLCJCdXR0b25Db2RlIiwiY29kZSIsIkJ1dHRvbkNvbW1hbmRMaXN0SXRlbSIsImRlc2NyaXB0aW9uIiwiX2dldENsYXNzTmFtZSIsIkJ1dHRvbkNvbW1hbmRzTGlzdCIsImhhbmRsZUtleSIsImxpc3RJZCIsIl9yZW5kZXJBY3Rpb25zIiwiY29tbWFuZHMiLCJpY29uIiwiQnV0dG9uRHJvcGRvd24iLCJjaGlsZHJlbiIsIktFWV9FTlRFUiIsIktFWV9FU0MiLCJCdXR0b25FbWJlZEVkaXQiLCJsaW5rSW5wdXQiLCJjcmVhdGVSZWYiLCJnZXRJbml0aWFsU3RhdGUiLCJtYW51YWxTZWxlY3Rpb24iLCJfZm9jdXNMaW5rSW5wdXQiLCJlbWJlZCIsInNlbGVjdGVkRWxlbWVudCIsImdldFNlbGVjdGVkRWxlbWVudCIsImZpbmRPbmUiLCJpbml0aWFsTGluayIsImxpbmtIcmVmIiwiY2xlYXJMaW5rU3R5bGUiLCJkZWxldGVFbWJlZCIsIl9yZW1vdmVFbWJlZCIsIl9oYW5kbGVMaW5rSHJlZkNoYW5nZSIsIl9oYW5kbGVLZXlEb3duIiwiZWRpdExpbmsiLCJjbGVhcklucHV0IiwiX2NsZWFyTGluayIsImNsZWFyIiwiY29uZmlybSIsIl9pc1ZhbGlkU3RhdGUiLCJfZW1iZWRMaW5rIiwidXJsIiwiY3VycmVudCIsInZhbGlkU3RhdGUiLCJlbWJlZFdyYXBwZXIiLCJnZXRBc2NlbmRhbnQiLCJyZW1vdmUiLCJCdXR0b25FbWJlZCIsIl9yZXF1ZXN0RXhjbHVzaXZlIiwiQnV0dG9uSDEiLCJoMSIsIkJ1dHRvbkgyIiwiaDIiLCJCdXR0b25IbGluZSIsImhvcml6b250YWxydWxlIiwiQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciIsImFsaWduQ2VudGVyIiwiQnV0dG9uSW1hZ2VBbGlnbkxlZnQiLCJhbGlnbkxlZnQiLCJCdXR0b25JbWFnZUFsaWduUmlnaHQiLCJhbGlnblJpZ2h0IiwiQnV0dG9uSW1hZ2UiLCJmaWxlSW5wdXQiLCJpbnB1dFN5bGUiLCJkaXNwbGF5IiwiaW1hZ2UiLCJoYW5kbGVDbGljayIsIl9vbklucHV0Q2hhbmdlIiwiY2xpY2siLCJpbnB1dEVsIiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiZmlsZSIsIm9ubG9hZCIsImltYWdlRmlsZXMiLCJpbWFnZURhdGEiLCJyZWFkQXNEYXRhVVJMIiwiQnV0dG9uSW5kZW50QmxvY2siLCJpbmRlbnQiLCJCdXR0b25JdGFsaWMiLCJpdGFsaWMiLCJCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCIsInRlcm0iLCJjbGVhclRpbWVvdXQiLCJfdGltZW91dCIsIl91cGRhdGVJdGVtcyIsImRlbGF5IiwiYXV0b2NvbXBsZXRlU2VsZWN0ZWQiLCJzZXRBdXRvY29tcGxldGVTdGF0ZSIsInNlbGVjdGVkIiwiX3JlbmRlckF1dG9jb21wbGV0ZUl0ZW1zIiwibmV4dFN0YXRlIiwiaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrIiwidGl0bGUiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiQnV0dG9uTGlua0VkaXQiLCJfZ2V0SW5pdGlhbFN0YXRlIiwidGFyZ2V0U2VsZWN0b3IiLCJhbGxvd2VkVGFyZ2V0cyIsImhhbmRsZUxpbmtUYXJnZXRDaGFuZ2UiLCJfaGFuZGxlTGlua1RhcmdldENoYW5nZSIsInNlbGVjdGVkVGFyZ2V0IiwibGlua1RhcmdldCIsImxpbmtUYXJnZXREZWZhdWx0IiwiYXV0b2NvbXBsZXRlRHJvcGRvd24iLCJkYXRhRm4iLCJhdXRvY29tcGxldGVEcm9wZG93blByb3BzIiwiX2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayIsIl9zZXRBdXRvY29tcGxldGVTdGF0ZSIsImJ1dHRvbkNsZWFyTGluayIsInBsYWNlaG9sZGVyUHJvcCIsInBsYWNlaG9sZGVyIiwicmVtb3ZlTGluayIsIl9yZW1vdmVMaW5rIiwic2hvd1RhcmdldFNlbGVjdG9yIiwiX3VwZGF0ZUxpbmsiLCJkZWZhdWx0TGlua1RhcmdldCIsIkxpbmsiLCJnZXRGcm9tU2VsZWN0aW9uIiwiZm9jdXNMaW5rRWwiLCJhZHZhbmNlU2VsZWN0aW9uIiwibGlua1V0aWxzIiwiYm9va21hcmtzIiwiY3JlYXRlQm9va21hcmtzIiwiYWR2YW5jZSIsInNlbGVjdEJvb2ttYXJrcyIsImFwcGVuZFByb3RvY29sIiwibGlua0F0dHJzIiwibW9kaWZ5U2VsZWN0aW9uIiwidXBkYXRlIiwiY3JlYXRlIiwiYXV0b2NvbXBsZXRlVXJsIiwiY3VzdG9tSW5kZXhTdGFydCIsIkJ1dHRvbkxpbmtUYXJnZXRFZGl0IiwiYWxsb3dlZExpbmtUYXJnZXRzIiwiQnV0dG9uTGluayIsIm1lcmdlQnV0dG9uQ2ZnUHJvcHMiLCJCdXR0b25PcmRlcmVkTGlzdCIsIm51bWJlcmVkbGlzdCIsIkJ1dHRvbk91dGRlbnRCbG9jayIsIm91dGRlbnQiLCJCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQiLCJCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0IiwiQnV0dG9uUGFyYWdyYXBoQ2VudGVyIiwiQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSIsImFsaWduSnVzdGlmeSIsIkJ1dHRvblF1b3RlIiwicXVvdGUiLCJCdXR0b25SZW1vdmVGb3JtYXQiLCJyZW1vdmVmb3JtYXQiLCJCdXR0b25TZXBhcmF0b3IiLCJCdXR0b25TdHJpa2UiLCJzdHJpa2UiLCJCdXR0b25zU3R5bGVzTGlzdEhlYWRlciIsIkJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIiwiX3JlbW92ZVN0eWxlcyIsIm5vcm1hbCIsInJlbW92ZUJsb2NrcyIsImJsb2NrSXRlbSIsImJsb2NrU3R5bGUiLCJCdXR0b25TdHlsZXNMaXN0SXRlbSIsInN0eWxlQ2ZnIiwibWFyZ2luIiwiX3ByZXZpZXciLCJidWlsZFByZXZpZXciLCJhY3RpdmVTdHlsZSIsIl9faHRtbCIsIl9vbkNsaWNrIiwiQnV0dG9uU3R5bGVzTGlzdCIsImJsb2NrU3R5bGVzIiwiaW5saW5lU3R5bGVzIiwib2JqZWN0U3R5bGVzIiwiU1RZTEVfQkxPQ0siLCJTVFlMRV9JTkxJTkUiLCJTVFlMRV9PQkpFQ1QiLCJfYmxvY2tTdHlsZXMiLCJfaW5saW5lU3R5bGVzIiwiX29iamVjdFN0eWxlcyIsInJlbW92ZVN0eWxlc0l0ZW0iLCJzaG93UmVtb3ZlU3R5bGVzSXRlbSIsIl9yZW5kZXJTdHlsZXNJdGVtcyIsIkJ1dHRvblN0eWxlcyIsIl9nZXRTdHlsZXMiLCJfY2hlY2tBY3RpdmUiLCJidXR0b25TdHlsZXNMaXN0Iiwic3R5bGVDb25maWciLCJmb3JtYXR0ZWQiLCJjaXRlIiwiQnV0dG9uU3Vic2NyaXB0Iiwic3Vic2NyaXB0IiwiQnV0dG9uU3VwZXJzY3JpcHQiLCJzdXBlcnNjcmlwdCIsIkJ1dHRvblRhYmxlQ2VsbCIsImJ1dHRvbkNvbW1hbmRzTGlzdCIsImJ1dHRvbkNvbW1hbmRzTGlzdElkIiwiX2dldENvbW1hbmRzIiwiY2VsbCIsImNlbGxJbnNlcnRCZWZvcmUiLCJjZWxsSW5zZXJ0QWZ0ZXIiLCJjZWxsRGVsZXRlIiwiY2VsbE1lcmdlIiwiY2VsbE1lcmdlRG93biIsImNlbGxNZXJnZVJpZ2h0IiwiY2VsbFNwbGl0SG9yaXpvbnRhbCIsImNlbGxTcGxpdFZlcnRpY2FsIiwiQnV0dG9uVGFibGVDb2x1bW4iLCJjb2x1bW4iLCJjb2x1bW5JbnNlcnRCZWZvcmUiLCJjb2x1bW5JbnNlcnRBZnRlciIsImNvbHVtbkRlbGV0ZSIsIkJ1dHRvblRhYmxlRWRpdCIsInJvd3NSZWYiLCJjb2xzUmVmIiwiY29scyIsInJvd3MiLCJ0YWJsZVV0aWxzIiwiVGFibGUiLCJ0YWJsZUF0dHJpYnV0ZXMiLCJpbnB1dE5hbWUiLCJfY3JlYXRlVGFibGUiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInJvd3NJZCIsImNvbHNJZCIsIl9oYW5kbGVDaGFuZ2UiLCJjb2x1bW5zIiwiYm9yZGVyIiwiY2VsbFBhZGRpbmciLCJjZWxsU3BhY2luZyIsIkJ1dHRvblRhYmxlSGVhZGluZyIsImFjdGl2ZUhlYWRpbmciLCJnZXRIZWFkaW5nIiwiYWN0aXZlSGVhZGluZ0ludHJvIiwiaGVhZGVycyIsImFjdGl2ZUhlYWRpbmdMYWJlbCIsImhlYWRlcnNOb25lIiwiaGVhZGVyc1JvdyIsImhlYWRlcnNDb2x1bW4iLCJoZWFkZXJzQm90aCIsIkJ1dHRvblRhYmxlUmVtb3ZlIiwiZGVsZXRlVGFibGUiLCJfcmVtb3ZlVGFibGUiLCJCdXR0b25UYWJsZVJvdyIsInJvdyIsInJvd0luc2VydEJlZm9yZSIsInJvd0luc2VydEFmdGVyIiwicm93RGVsZXRlIiwiQnV0dG9uVGFibGUiLCJ0YWJsZSIsIkJ1dHRvblRhcmdldExpc3QiLCJsaXN0VGFyZ2V0cyIsIl9yZW5kZXJMaXN0VGFyZ2V0cyIsImxpbmtUYXJnZXRTZWxmIiwibGlua1RhcmdldEJsYW5rIiwibGlua1RhcmdldFBhcmVudCIsImxpbmtUYXJnZXRUb3AiLCJ0YXJnZXRzIiwiX2dldEFsbG93ZWRUYXJnZXRJdGVtcyIsIk1BWF9UV0VFVF9MRU5HVEgiLCJCdXR0b25Ud2l0dGVyIiwiX2dldEhyZWYiLCJ0d2l0dGVyIiwic2VsZWN0ZWRUZXh0IiwiZ2V0U2VsZWN0ZWRUZXh0Iiwic3Vic3RyaW5nIiwidmlhIiwidHdpdHRlckhyZWYiLCJCdXR0b25Vbm9yZGVyZWRsaXN0IiwiYnVsbGV0ZWRsaXN0IiwiQnV0dG9uVW5kZXJsaW5lIiwidW5kZXJsaW5lIiwiVUkiLCJoaWRkZW4iLCJfb25FZGl0b3JJbnRlcmFjdGlvbiIsIl9vbkFjdGlvblBlcmZvcm1lZCIsIl9vbkVkaXRvcktleSIsIl9tb3VzZWRvd25MaXN0ZW5lciIsIl9zZXRVSUhpZGRlbiIsIl9rZXlEb3duTGlzdGVuZXIiLCJkZWJvdW5jZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsIm1lc3NhZ2UiLCJfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlIiwiYXJpYVVwZGF0ZSIsIl9hcmlhVXBkYXRlVGVtcGxhdGVzIiwidGVtcGxhdGUiLCJfZ2V0QXJpYVVwZGF0ZXMiLCJhcmlhVXBkYXRlcyIsIm5vVG9vbGJhciIsImFyaWFVcGRhdGVOb1Rvb2xiYXIiLCJvbmVUb29sYmFyIiwiYXJpYVVwZGF0ZU9uZVRvb2xiYXIiLCJtYW55VG9vbGJhcnMiLCJhcmlhVXBkYXRlTWFueVRvb2xiYXJzIiwidG9vbGJhcnNOb2RlTGlzdCIsInRvb2xiYXJOYW1lcyIsInRvb2xiYXIiLCJfZ2V0QXJpYVVwZGF0ZVRlbXBsYXRlIiwib3V0cHV0Iiwiam9pbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2giLCJPYmplY3QiLCJfb25EaXNtaXNzVG9vbGJhckZvY3VzIiwiZ2V0U2VsZWN0aW9uRGF0YSIsImRvbUV2ZW50IiwiYWx0S2V5IiwidGFyZ2V0Tm9kZSIsImNvbnRhaW5zIiwiaWQiLCJwcm9wVHlwZXMiLCJvYmplY3QiLCJpc1JlcXVpcmVkIiwibnVtYmVyIiwiUE9TSVRJT05fTEVGVCIsIlBPU0lUSU9OX1JJR0hUIiwiVG9vbGJhckFkZCIsIl91cGRhdGVQb3NpdGlvbiIsImlzQ29udGVudEVkaXRhYmxlIiwiX2dldEJ1dHRvbnMiLCJfZ2V0VG9vbGJhckNsYXNzTmFtZSIsImdldEFycm93Qm94Q2xhc3NlcyIsInVwZGF0ZVBvc2l0aW9uIiwic2hvdyIsImNsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0TGVmdCIsInBvc2l0aW9uIiwiZ3V0dGVyRXhjbHVzaXZlIiwiZmxvb3IiLCJjYW5jZWxBbmltYXRpb24iLCJUb29sYmFyU3R5bGVzIiwiY3VycmVudFNlbGVjdGlvbiIsIl9nZXRDdXJyZW50U2VsZWN0aW9uIiwiZ2V0QXJyb3dCb3hDbGFzc2VzRm4iLCJfZ2V0U2VsZWN0aW9uRnVuY3Rpb24iLCJjc3NDbGFzc2VzIiwiYnV0dG9uc0dyb3VwIiwiZ2V0VG9vbGJhckJ1dHRvbkdyb3VwcyIsInNlbGVjdGlvblR5cGUiLCJoYXNHcm91cHMiLCJzZWxlY3Rpb25GbiIsInNlbGVjdGlvbkZ1bmN0aW9uIiwidGVzdEZuIiwic2V0UG9zaXRpb25GbiIsInNldFBvc2l0aW9uIiwicGx1Z2lucyIsIm5vb3AiLCJVTlNVUFBPUlRFRF9CVVRUT05fQVBJIiwidG9GZWF0dXJlIiwiQlVUVE9OX0RFRlMiLCJnZW5lcmF0ZUJ1dHRvbkJyaWRnZSIsImJ1dHRvbkRlZmluaXRpb24iLCJCdXR0b25CcmlkZ2UiLCJkaXNwbGF5TmFtZSIsInN0YXRpY3MiLCJidXR0b25DbGFzc05hbWUiLCJidXR0b25EaXNwbGF5TmFtZSIsImJ1dHRvbkxhYmVsIiwiYnV0dG9uVHlwZSIsImljb25DbGFzc05hbWUiLCJpY29uU3R5bGUiLCJjc3NTdHlsZSIsInNraW4iLCJnZXRJY29uU3R5bGUiLCJjc3NTdHlsZVBhcnRzIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFNpemUiLCJfaGFuZGxlQ2xpY2siLCJidXR0b25Db21tYW5kIiwiYnV0dG9uT25DbGljayIsIm9uQ2xpY2siLCJVSV9CVVRUT04iLCJyZXF1aXJlcyIsImJlZm9yZUluaXQiLCJ1aSIsImFkZEJ1dHRvbiIsImFkZEhhbmRsZXIiLCJtZW51QnV0dG9uIiwibWVudSIsInBhbmVsTWVudUJ1dHRvbiIsInJpY2hjb21ibyIsInVpYnJpZGdlIiwiVU5TVVBQT1JURURfTUVOVUJVVFRPTl9BUEkiLCJNRU5VQlVUVE9OX0RFRlMiLCJnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UiLCJtZW51QnV0dG9uTmFtZSIsIm1lbnVCdXR0b25EZWZpbml0aW9uIiwiTWVudUJ1dHRvbkJyaWRnZSIsInBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lIiwiX2dldE1lbnVJdGVtcyIsIm9uTWVudSIsIm1lbnVJdGVtcyIsIm1lbnVJdGVtIiwiZ2V0TWVudUl0ZW0iLCJtZW51SXRlbURlZmluaXRpb24iLCJkZWZpbml0aW9uIiwibWVudUl0ZW1TdGF0ZSIsIlRSSVNUQVRFX0RJU0FCTEVEIiwiYXBwbHkiLCJVSV9NRU5VX0JVVFRPTiIsImFkZE1lbnVCdXR0b24iLCJVSV9NRU5VQlVUVE9OIiwiZ3JvdXBzIiwiZ3JvdXBzT3JkZXIiLCJfIiwibWVudUdyb3VwcyIsImFkZE1lbnVHcm91cCIsIm9yZGVyIiwiYWRkTWVudUl0ZW0iLCJncm91cCIsImFkZE1lbnVJdGVtcyIsImRlZmluaXRpb25zIiwiaXRlbU5hbWUiLCJyZW1vdmVNZW51SXRlbSIsIlVOU1VQUE9SVEVEX1BBTkVMX01FTlVfQlVUVE9OX0FQSSIsImNyZWF0ZVBhbmVsIiwiUEFORUxfTUVOVV9ERUZTIiwiZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UiLCJwYW5lbE1lbnVCdXR0b25OYW1lIiwicGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvbiIsIlBhbmVsTWVudUJ1dHRvbkJyaWRnZSIsInBhbmVsIiwiX2dldFBhbmVsIiwicGFuZWxNZW51QnV0dG9uT25CbG9jayIsIm9uQmxvY2siLCJoaWRlIiwiYmxvY2tFbGVtZW50IiwiYmxvY2siLCJnZXRIdG1sIiwiVUlfUEFORUxCVVRUT04iLCJhZGRQYW5lbE1lbnVCdXR0b24iLCJVTlNVUFBPUlRFRF9SSUNIQ09NQk9fQVBJIiwiY29tbWl0IiwiZGlzYWJsZSIsImVuYWJsZSIsImdldFN0YXRlIiwiaGlkZUdyb3VwIiwiaGlkZUl0ZW0iLCJtYXJrIiwic2hvd0FsbCIsInN0YXJ0R3JvdXAiLCJ1bm1hcmtBbGwiLCJSSUNIX0NPTUJPX0RFRlMiLCJnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZSIsInJpY2hDb21ib05hbWUiLCJyaWNoQ29tYm9EZWZpbml0aW9uIiwiUmljaENvbWJvQnJpZGdlIiwiY3VycmVudFZhbHVlIiwidW5kZWZpbmVkIiwicHJldmlldyIsIl9pdGVtcyIsImNvbXBvbmVudFdpbGxNb3VudCIsImVkaXRvckNvbWJvIiwic2V0VmFsdWUiLCJfc2V0VmFsdWUiLCJpbml0Iiwib25SZW5kZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl9jYWNoZVZhbHVlIiwiZ2V0VmFsdWUiLCJyaWNoQ29tYm9MYWJlbCIsIl9nZXRJdGVtcyIsInJpY2hDb21ibyIsIm5ld1ZhbHVlIiwiY3VycmVudFRhcmdldCIsIlVJX1JJQ0hDT01CTyIsImFkZFJpY2hDb21ibyIsIm9yaWdpbmFsVUlBZGRGbiIsImFyZ3VtZW50cyIsInR5cGVIYW5kbGVyIiwiaGFuZGxlcnMiLCJfX3Byb2Nlc3NpbmdQbHVnaW5fXyIsInBsdWdpbiIsInRpbWVvdXQiLCJhcmdzIiwiZGVib3VuY2VIYW5kbGUiLCJjYWxsRm4iLCJjYWxsQ29udGV4dCIsImxlbiIsInN0YXJ0SW5kZXgiLCJjYWxsQXJncyIsInNlbGVjdGlvblJlZ2lvbiIsInVpY29yZSIsIlJFR0VYX0JPT0tNQVJLX1NDSEVNRSIsIlJFR0VYX0VNQUlMX1NDSEVNRSIsIlJFR0VYX1VSSV9TQ0hFTUUiLCJyYW5nZSIsImdldFJhbmdlcyIsIm1vdmVUb0VsZW1lbnRFZGl0RW5kIiwibmV4dE5vZGUiLCJnZXROZXh0RWRpdGFibGVOb2RlIiwiZXF1YWxzIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJ3aGl0ZXNwYWNlIiwiZ2V0VGV4dCIsIm9mZnNldCIsInNldFN0YXJ0Iiwic2V0RW5kIiwic2VsZWN0UmFuZ2VzIiwiVVJJIiwiY29sbGFwc2VkIiwidGV4dCIsImluc2VydE5vZGUiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJfZ2V0Q29tcGxldGVVUkkiLCJhcHBseVRvUmFuZ2UiLCJzZWxlY3QiLCJpcyIsImdldENoaWxkcmVuIiwiY291bnQiLCJnZXRJdGVtIiwic2hyaW5rIiwiU0hSSU5LX1RFWFQiLCJhbHdheXNSZW1vdmVFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsImdldFN0YXJ0RWxlbWVudCIsInVyaSIsInNldEF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRycyIsInNldEF0dHJzIiwicmVtb3ZlQXR0cmlidXRlcyIsIndyYXBQbHVnaW5MaWZlY3ljbGUiLCJtZXRob2RzIiwibWV0aG9kTmFtZSIsIm92ZXJyaWRlIiwib3JpZ2luYWxQbHVnaW5NZXRob2QiLCJwYXlsb2FkIiwicGhhc2UiLCJmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyIsInJlcXVpcmUiLCJwbHVnaW5zTG9hZCIsIm5hbWVzIiwic2NvcGUiLCJTZWxlY3Rpb25SZWdpb24iLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQiLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2UiLCJzdGFydFgiLCJzdGFydFkiLCJlbmRYIiwiZW5kWSIsImVuZCIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsInN0YXJ0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJvZmZzZXROb2RlIiwiY3JlYXRlUmFuZ2UiLCJjYXJldFJhbmdlRnJvbVBvaW50IiwiY3JlYXRlVGV4dFJhbmdlIiwiZW5kUmFuZ2UiLCJkdXBsaWNhdGUiLCJzZXRFbmRQb2ludCIsImdldENhcmV0UmVnaW9uIiwiYm9va21hcmtOb2RlRWwiLCJzdGFydE5vZGUiLCJzY3JvbGxQb3MiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImdldE5hdGl2ZSIsImdldFNlbGVjdGlvblJlZ2lvbiIsImdldENsaWVudFJlY3RzUmVnaW9uIiwiZ2V0U2VsZWN0aW9uRGlyZWN0aW9uIiwiaXNTZWxlY3Rpb25FbXB0eSIsInJhbmdlcyIsImdldFR5cGUiLCJTRUxFQ1RJT05fTk9ORSIsIm5hdGl2ZVNlbGVjdGlvbiIsImRlZmF1bHRSZWN0IiwiY2xpZW50UmVjdHMiLCJJbmZpbml0eSIsInJhbmdlQ291bnQiLCJnZXRDbGllbnRSZWN0cyIsImdldFJhbmdlQXQiLCJhbmNob3JOb2RlIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJmb2N1c05vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJhdHRyIiwiaGFzT3duUHJvcGVydHkiLCJJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCIsIkhFQURJTkdfQk9USCIsIkhFQURJTkdfQ09MIiwiSEVBRElOR19OT05FIiwiSEVBRElOR19ST1ciLCJfY3JlYXRlRWxlbWVudCIsInRib2R5IiwiYXBwZW5kIiwiaiIsImFwcGVuZEJvZ3VzIiwic2V0SGVhZGluZyIsImhlYWRpbmciLCJmaXJzdENlbGwiLCJjZWxscyIsIm1vdmVUb1Bvc2l0aW9uIiwiUE9TSVRJT05fQUZURVJfU1RBUlQiLCJ3ZWJraXQiLCJOT0RFX0VMRU1FTlQiLCJpc0VkaXRhYmxlIiwiaXNSZWFkT25seSIsImhhc0F0dHJpYnV0ZSIsImdldFBhcmVudCIsInJvd0hlYWRpbmdTZXR0aW5ncyIsInRIZWFkIiwiY29sSGVhZGluZ1NldHRpbmdzIiwibm9kZU5hbWUiLCJoZWFkaW5nU2V0dGluZ3MiLCJwYXJlbnQiLCJnZXRDaGlsZENvdW50IiwiUE9TSVRJT05fQkVGT1JFX1NUQVJUIiwibmV3Q2VsbCIsInRhYmxlSGVhZCIsInRhYmxlQm9keSIsImdldEVsZW1lbnRzQnlUYWciLCJ0YWJsZUhlYWRpbmciLCJoYWRDb2xIZWFkaW5nIiwibmVlZENvbEhlYWRpbmciLCJuZWVkUm93SGVhZGluZyIsInRhYmxlRmlyc3RSb3ciLCJ0YWJsZUZpcnN0Um93Q2hpbGRDb3VudCIsImdldENoaWxkIiwicmVuYW1lTm9kZSIsImNyZWF0ZVRIZWFkIiwicHJldmlvdXNGaXJzdFJvdyIsImdldEZpcnN0IiwibmV3Rmlyc3RSb3ciLCJuZXdGaXJzdFJvd0NoaWxkQ291bnQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpbnNlcnRCZWZvcmUiLCJoYXNDb2xIZWFkaW5nIiwiZ2V0TmFtZSIsImhlYWRpbmdDb21tYW5kcyIsImpzb25wIiwidXJsVGVtcGxhdGUiLCJ1cmxQYXJhbXMiLCJlcnJvckNhbGxiYWNrIiwiY2FsbGJhY2tLZXkiLCJnZXROZXh0TnVtYmVyIiwianNvbnBDYWxsYmFja3MiLCJyZXNwb25zZSIsImNsZWFuVXAiLCJzY3JpcHRFbGVtZW50IiwiZ2V0Qm9keSIsImNhbmNlbCIsInNpbXVsYXRlIiwiZXZlbnRJbnN0YW5jZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImFyaWFTdGF0ZSIsImFyaWFFbGVtZW50IiwiX2NyZWF0ZUFyaWFFbGVtZW50IiwidWlUYXNrc1RpbWVvdXQiLCJoYW5kbGVVSSIsImFsbG93RXNjIiwiaGFuZGxlQXJpYSIsImlubmVySFRNTCIsImhhbmRsZU1vdXNlTGVhdmUiLCJhZVVJTm9kZXMiLCJmb3VuZCIsInJlbGF0ZWRUYXJnZXQiLCJmb2N1c0hhbmRsZXIiLCJhdHRhY2hMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwic3RhdHVzRWxlbWVudCIsIl9fY29uZmlnX18iLCJfX0FUVFJTX18iLCJjdXJyZW50QXR0ciIsIl9pc0luaXRpYWxpemVkIiwiX2luaXQiLCJjdXJWYWx1ZSIsIl9jYWxsU3RyaW5nT3JGdW5jdGlvbiIsInNldCIsInN0cmluZ09yRnVuY3Rpb24iLCJoYXNEZWZhdWx0VmFsdWUiLCJoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZyIsInZhbHVlRm4iLCJCYXNlIiwiX2NhbGxDaGFpbiIsIndhdCIsImFyciIsImN0b3IiLCJyZXZlcnNlIiwiaXNGaW5pdGUiLCJ2YWx1ZVR5cGUiLCJyZWNlaXZlciIsInN1cHBsaWVyIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwic3VwcGxpZXJQcm90byIsInJlY2VpdmVyUHJvdG8iLCJpc0lFIiwiX29uRHJhZ0VudGVyIiwiX29uRHJhZ092ZXIiLCJfb25EcmFnRHJvcCIsIl9vblBhc3RlIiwiX2hhbmRsZUZpbGVzIiwiX3Byb2Nlc3NGaWxlIiwidHJhbnNmZXJGaWxlcyIsImRhdGFUcmFuc2ZlciIsImNsaWVudFgiLCJjbGllbnRZIiwiX3ByZXZlbnRFdmVudCIsImNsaXBib2FyZERhdGEiLCJwYXN0ZWREYXRhIiwiaW1hZ2VGaWxlIiwiZ2V0QXNGaWxlIiwiYmluIiwidXNlckFnZW50IiwiS0VZX0JBQ0siLCJLRVlfQ09NTUEiLCJLRVlfU0VNSUNPTE9OIiwiS0VZX1NQQUNFIiwiREVMSU1JVEVSUyIsIlJFR0VYX0xBU1RfV09SRCIsIlJFR0VYX1VSTCIsIlJFR0VYX0VNQUlMIiwiX29uS2V5VXAiLCJtZXRob2QiLCJkYXRhVmFsdWUiLCJSZWdFeHAiLCJfaXNWYWxpZFVSTCIsIl9pc1ZhbGlkRW1haWwiLCJfZ2V0TGFzdFdvcmQiLCJwcmV2aW91c1RleHQiLCJfY3VycmVudEtleUNvZGUiLCJwcmV2aW91c05vZGUiLCJnZXRQcmV2aW91cyIsImxhc3RDaGlsZCIsImdldExhc3QiLCJfc3RhcnRDb250YWluZXIiLCJfb2Zmc2V0IiwibGFzdFdvcmQiLCJwb3AiLCJlbWFpbCIsIl9vbktleURvd24iLCJfY2tMaW5rIiwiX3JlcGxhY2VDb250ZW50QnlMaW5rIiwiY29udGVudCIsImNrTGluayIsImxpbmtOb2RlIiwiX3N1YnNjcmliZVRvS2V5RXZlbnQiLCJuZXh0RWRpdGFibGVOb2RlIiwiZ2V0TmV4dE5vZGUiLCJjYXJldE9mZnNldCIsImdldE5leHQiLCJuZXdSYW5nZSIsInNldEVuZEFmdGVyIiwiREVGQVVMVF9DT05GSUciLCJyZWdleCIsIl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8iLCJpbnNlcnRIdG1sIiwiYnVsbGV0IiwiX2dldExpc3RDb25maWciLCJjb25maWdSZWdleCIsImF1dG9saXN0IiwidGV4dENvbnRhaW5lciIsInJlZ2V4TGVuIiwiYXV0b2xpc3RDZmciLCJyZWdleEl0ZW0iLCJfY3JlYXRlTGlzdCIsImxpc3RDb25maWciLCJzZXRUZXh0IiwiSU1BR0VfSEFORExFUyIsImJvdGgiLCJzY2FsZSIsIlBPU0lUSU9OX0VMRU1FTlRfRk4iLCJibCIsImhhbmRsZSIsImJveCIsInBvc2l0aW9uRWxlbWVudCIsImJtIiwicm91bmQiLCJiciIsImxtIiwidGwiLCJ0bSIsInRyIiwicm0iLCJJTUFHRV9TTkFQX1RPX1NJWkUiLCJpc0ZpcmVmb3giLCJkb2N1bWVudEVsZW1lbnQiLCJpc1dlYktpdCIsImVuYWJsZVBsdWdpbiIsImFkZENzcyIsIm9uTG9hZCIsImV2dCIsInNuYXBUb1NpemUiLCJpbWFnZVNjYWxlUmVzaXplIiwicmVzaXplciIsIlJlc2l6ZXIiLCJtb3VzZURvd25MaXN0ZW5lciIsImUiLCJpc0hhbmRsZSIsImluaXREcmFnIiwiaHRtbCIsInNlbGYiLCJyZXNpemVFbGVtZW50IiwicmVzaXplVGltZW91dCIsImNvbnRhaW5lciIsImhhbmRsZXMiLCJoYW5kbGVOYW1lIiwiY3JlYXRlSGFuZGxlIiwibiIsImNsYXNzTGlzdCIsIm90aGVySW1hZ2VzIiwidG9BcnJheSIsInNwbGljZSIsImdldEJvdW5kaW5nQm94Iiwic2hvd0hhbmRsZXMiLCJlbGVtZW50cyIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJoaWRlSGFuZGxlcyIsImRyYWciLCJEcmFnRXZlbnQiLCJvblN0YXJ0Iiwic2hvd1ByZXZpZXciLCJpc0RyYWdnaW5nIiwib25EcmFnIiwiY2FsY3VsYXRlU2l6ZSIsInVwZGF0ZVByZXZpZXciLCJwcmV2aWV3Qm94IiwidXBkYXRlSGFuZGxlcyIsIm9uUmVsZWFzZSIsImhpZGVQcmV2aWV3Iiwib25Db21wbGV0ZSIsInJlc2l6ZUNvbXBsZXRlIiwiZGVsdGEiLCJyYXRpbyIsIm90aGVycyIsIm90aGVyIiwiZXZlbnRzIiwibW91c2Vtb3ZlIiwia2V5ZG93biIsIm1vdXNldXAiLCJzdGFydFBvcyIsImN1cnJlbnRQb3MiLCJzaGlmdEtleSIsImN0cmwiLCJhbHQiLCJ3aGljaCIsInJlbGVhc2UiLCJjdHgiLCJTdHJpbmciLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImFsaWdubWVudHNPYmoiLCJjZW50ZXIiLCJjdXJzb3IiLCJyZWdleFBlcmNlbnQiLCJoaWRwaSIsImljb25zIiwid2lkZ2V0RGVmIiwid2lkZ2V0cyIsImluaXRPbiIsImFsaWduQ2xhc3NlcyIsImltYWdlMl9hbGlnbkNsYXNzZXMiLCJjYXB0aW9uZWRDbGFzcyIsImltYWdlMl9jYXB0aW9uZWRDbGFzcyIsImhlbHBlcnMiLCJpbWFnZTIiLCJoYXNDYXB0aW9uIiwiY2FwdGlvbiIsInJlYWR5IiwiY2hlY2tIYXNOYXR1cmFsUmF0aW8iLCJ3cmFwcGVyIiwiYWxpZ24iLCJhbGlnbkVsZW1lbnQiLCJzZXREYXRhIiwiaW1hZ2UyX2Rpc2FibGVSZXNpemVyIiwic2V0dXBSZXNpemVyIiwiZ2V0U3R5bGVhYmxlRWxlbWVudCIsImdldFdpZGdldEFsbG93ZWRDb250ZW50IiwiY29udGVudFRyYW5zZm9ybWF0aW9ucyIsImZlYXR1cmVzIiwiY2hlY2tGZWF0dXJlIiwiY29udGVudGVkaXRhYmxlIiwib2xkRGF0YSIsImMiLCJjbGFzc2VzIiwiZGltZW5zaW9uIiwic2V0RGltZW5zaW9ucyIsImRvd25jYXN0IiwiZG93bmNhc3RXaWRnZXRFbGVtZW50IiwiZHJhZ2dhYmxlIiwiZWRpdGFibGVzIiwic2VsZWN0b3IiLCJnZXRXaWRnZXRGZWF0dXJlcyIsImdldENsYXNzZXMiLCJjbGFzc1JlZ2V4IiwicmVwb3NpdG9yeSIsInBhcnNlRWxlbWVudENsYXNzZXMiLCJnZXRMYWJlbCIsInBhdGhOYW1lIiwicmVxdWlyZWRDb250ZW50Iiwic3R5bGVhYmxlRWxlbWVudHMiLCJ1cGNhc3QiLCJ1cGNhc3RXaWRnZXRFbGVtZW50IiwibmF0dXJhbCIsImdldE5hdHVyYWwiLCJjbGllbnRIZWlnaHQiLCJkaW1lbnNpb25zIiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdoIiwiaW1nIiwiSW1hZ2UiLCJoZWlnaCIsImlzQ2VudGVyV3JhcHBlciIsImNlbnRlcldyYXBwZXJDaGVja2VyIiwiZmlndXJlIiwicmVwbGFjZVdpdGgiLCJpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlIiwiZCIsImF0dHJzSG9sZGVyIiwicmVzaXplV3JhcHBlciIsInBhcnNlQ3NzVGV4dCIsIndyYXBXaXRoIiwiaHRtbFBhcnNlciIsImlzRW1wdHkiLCJ3cml0ZUNzc1RleHQiLCJ2YWxpZENoaWxkcmVuIiwiZGl2IiwicCIsImNoaWxkIiwiZW50ZXJNb2RlIiwiRU5URVJfUCIsIndpZGdldCIsImRvYyIsImltYWdlT3JMaW5rIiwib2xkUmVzaXplV3JhcHBlciIsImZhY3RvciIsInNjcmVlblgiLCJzY3JlZW5ZIiwic3RhcnRXaWR0aCIsInN0YXJ0SGVpZ2h0IiwibGlzdGVuZXJzIiwiY3Vyc29yQ2xhc3MiLCJuYXRpdmVFdnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsInVwZGF0ZURhdGEiLCJtb3ZlRGlmZlgiLCJtb3ZlRGlmZlkiLCJtb3ZlUmF0aW8iLCJhdHRhY2hUb0RvY3VtZW50cyIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwiY29sbGVjdGlvbiIsImdsb2JhbERvYyIsImwiLCJ3aWRnZXRFbGVtZW50Iiwic2Nyb2xsUG9zaXRpb24iLCJydWxlcyIsImZpZ2NhcHRpb24iLCJSRUdFWF9IVFRQIiwiUkVHRVhfREVGQVVMVF9MSU5LIiwiUFJPVklERVJTIiwiREVGQVVMVF9BRV9FTUJFRF9VUkxfVFBMIiwiREVGQVVMVF9BRV9FTUJFRF9XSURHRVRfVFBMIiwiREVGQVVMVF9BRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMIiwiQUVfRU1CRURfVVJMX1RQTCIsImVtYmVkVXJsVGVtcGxhdGUiLCJBRV9FTUJFRF9XSURHRVRfVFBMIiwiZW1iZWRXaWRnZXRUcGwiLCJBRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMIiwiZW1iZWRMaW5rRGVmYXVsdFRwbCIsImRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuIiwibWFzayIsImVuY29kZVVSSUNvbXBvbmVudCIsImNyZWF0ZUFUYWciLCJzZXRIdG1sIiwibXNnIiwiYVRhZ0h0bWwiLCJlbWJlZFdpZGdldFVwY2FzdEZuIiwiYWRkRWxlbWVudENhbGxiYWNrIiwiRklMVEVSX1NLSVBfVFJFRSIsIklNQUdFX0FMSUdOTUVOVCIsIkNFTlRFUiIsIkxFRlQiLCJSSUdIVCIsIkFMSUdOX1ZBTFVFUyIsIkNFTlRFUkVEX0lNQUdFX1NUWUxFIiwiZ2V0SW1hZ2VBbGlnbm1lbnQiLCJpbWFnZUFsaWdubWVudCIsImNlbnRlcmVkSW1hZ2UiLCJldmVyeSIsInN0eWxlQ2hlY2siLCJ2ZW5kb3JQcmVmaXhlcyIsInZlbmRvclByZWZpeCIsImltYWdlQ29udGFpbmVyIiwidGV4dEFsaWduIiwic2V0U3R5bGUiLCJyZW1vdmVJbWFnZUFsaWdubWVudCIsInNldEltYWdlQWxpZ25tZW50IiwiYWZ0ZXJJbml0IiwicmVmcmVzaENvbW1hbmRzIiwiVFJJU1RBVEVfT0ZGIiwicmVmcmVzaCIsImFkZGltYWdlcyIsImF1dG9saW5rIiwiZHJhZ3Jlc2l6ZSIsImRyYWdyZXNpemVpZSIsImltYWdlYWxpZ25tZW50IiwicGFzdGVpbWFnZXMiLCJzZWxlY3Rpb25rZXlzdHJva2VzIiwidGFibGVyZXNpemUiLCJ0YWJsZXRvb2xzIiwiYnJGaWxsZXIiLCJuZWVkc0JyRmlsbGVyIiwiZW50ZXJNb2RlRW1wdHlWYWx1ZSIsIl9jaGVja0VtcHR5RGF0YSIsIl9yZW1vdmVQbGFjZWhvbGRlckNsYXNzIiwiZWRpdGFibGVOb2RlIiwiaW5uZXJIdG1sIiwidHJpbSIsImVkaXRvck5vZGUiLCJzZWxlY3Rpb25LZXlzdHJva2UiLCJweFVuaXQiLCJjc3NMZW5ndGgiLCJnZXRXaWR0aCIsImdldEJvcmRlcldpZHRoIiwic2lkZSIsImNvbXB1dGVkIiwiYm9yZGVyTWFwIiwidGhpbiIsIm1lZGl1bSIsInRoaWNrIiwiZ2V0TWFzdGVyUGlsbGFyUm93IiwiJHJvd3MiLCJtYXhDZWxscyIsImNlbGxzQ291bnQiLCIkZWxlY3RlZCIsIiR0ciIsImJ1aWxkVGFibGVDb2x1bW5QaWxsYXJzIiwicGlsbGFycyIsInBpbGxhckluZGV4IiwicnRsIiwidEJvZGllcyIsInRib2R5UG9zaXRpb24iLCJnZXREb2N1bWVudFBvc2l0aW9uIiwidGQiLCJuZXh0VGQiLCJjb2xTcGFuIiwicGlsbGFyTGVmdCIsInBpbGxhclJpZ2h0IiwicGlsbGFyV2lkdGgiLCJnZXRQaWxsYXJBdFBvc2l0aW9uIiwicG9zaXRpb25YIiwicGlsbGFyIiwiY29sdW1uUmVzaXplciIsInJlc2l6aW5nIiwiY3VycmVudFNoaWZ0IiwibGVmdFNpZGVDZWxscyIsInJpZ2h0U2lkZUNlbGxzIiwibGVmdFNoaWZ0Qm91bmRhcnkiLCJyaWdodFNoaWZ0Qm91bmRhcnkiLCJvbk1vdXNlRG93biIsInJlc2l6ZVN0YXJ0IiwiY29sdW1uSW5kZXgiLCJidWlsZFRhYmxlTWFwIiwibGVmdENvbHVtbkNlbGxzIiwicmlnaHRDb2x1bW5DZWxscyIsImxlZnRNaW5TaXplIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwicmlnaHRNaW5TaXplIiwibGVmdENlbGwiLCJyaWdodENlbGwiLCJzZXRPcGFjaXR5IiwicmVzaXplRW5kIiwicmVzaXplQ29sdW1uIiwicmVtb3ZlQ3VzdG9tRGF0YSIsImxlZnRPbGRXaWR0aCIsInJpZ2h0T2xkV2lkdGgiLCJ0YWJsZVdpZHRoIiwic2l6ZVNoaWZ0IiwibW92ZSIsImdldFBhZ2VPZmZzZXQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJwb3NYIiwicmVzaXplck5ld1Bvc2l0aW9uIiwiaXNSZXNpemluZyIsImNsZWFyUGlsbGFyc0NhY2hlIiwiZGVzdCIsInRvRWxlbWVudCIsImlzSW5saW5lIiwiZ2V0Q3VzdG9tRGF0YSIsInNldEN1c3RvbURhdGEiLCJjZWxsTm9kZVJlZ2V4IiwiZ2V0U2VsZWN0ZWRDZWxscyIsInJldHZhbCIsImRhdGFiYXNlIiwibW92ZU91dE9mQ2VsbEd1YXJkIiwic2V0TWFya2VyIiwibmVhcmVzdENlbGwiLCJ3YWxrZXIiLCJndWFyZCIsImR0ZCIsImNsZWFyQWxsTWFya2VycyIsImdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMiLCJjZWxsc1RvRGVsZXRlIiwibGFzdCIsImZvY3VzZWRDZWxsIiwiaW5zZXJ0Um93IiwiZ2V0RG9jdW1lbnQiLCJzdGFydFJvdyIsInN0YXJ0Um93SW5kZXgiLCJyb3dJbmRleCIsImxhc3RDZWxsIiwiZW5kUm93SW5kZXgiLCJyb3dTcGFuIiwiZW5kUm93IiwiY2xvbmVSb3ciLCJuZXh0Um93IiwibmV3Um93IiwiY2xvbmUiLCJpbnNlcnRBZnRlciIsImRlbGV0ZVJvd3MiLCJzZWxlY3Rpb25PclJvdyIsInJvd3NUb0RlbGV0ZSIsIm1hcFJvdyIsImNlbGxSb3dJbmRleCIsIm5leHRNYXBSb3ciLCJjdXJzb3JQb3NpdGlvbiIsImdldENlbGxDb2xJbmRleCIsImlzU3RhcnQiLCJyb3dDZWxscyIsImNvbEluZGV4IiwibWFwQ2VsbCIsImdldENvbHVtbnNJbmRpY2VzIiwiaW5zZXJ0Q29sdW1uIiwic3RhcnRDb2wiLCJsYXN0Q29sIiwiY2xvbmVDb2wiLCJuZXh0Q29sIiwibmV4dENlbGwiLCJkZWxldGVDb2x1bW5zIiwic2VsZWN0aW9uT3JDZWxsIiwic3RhcnRDb2xJbmRleCIsImVuZENvbEluZGV4IiwiZmlyc3RSb3dDZWxscyIsImluc2VydENlbGwiLCJzdGFydEVsZW1lbnQiLCJkZWxldGVDZWxscyIsImNlbGxUb0ZvY3VzIiwicGxhY2VDdXJzb3JJbkNlbGwiLCJ0cmltQ2VsbCIsImJvZ3VzIiwiZ2V0Qm9ndXMiLCJwbGFjZUF0RW5kIiwiZG9jSW5uZXIiLCJkb2NPdXRlciIsInZlcnNpb24iLCJjb2xsYXBzZSIsImNlbGxJblJvdyIsInRhYmxlTWFwIiwib1JvdyIsImNlbGxJbkNvbCIsIm9Db2wiLCJyIiwibWVyZ2VDZWxscyIsIm1lcmdlRGlyZWN0aW9uIiwiaXNEZXRlY3QiLCJjb21tb25BbmNlc3RvciIsIm1hcEhlaWdodCIsIm1hcFdpZHRoIiwic3RhcnRDb2x1bW4iLCJ0YXJnZXRDZWxsIiwicm93c3BhbiIsImNvbHNwYW4iLCJlciIsImxhc3RSb3dJbmRleCIsInRvdGFsUm93U3BhbiIsInRvdGFsQ29sU3BhbiIsImZyYWciLCJkb2N1bWVudEZyYWdtZW50IiwiY2VsbEZpcnN0Q2hpbGQiLCJpc0Jsb2NrQm91bmRhcnkiLCJ3aGl0ZXNwYWNlcyIsIm1vdmVDaGlsZHJlbiIsInRycyIsIm5vZGVMaXN0IiwidGFpbFRyIiwidmVydGljYWxTcGxpdENlbGwiLCJuZXdSb3dTcGFuIiwibmV3Q2VsbFJvd1NwYW4iLCJuZXdSb3dJbmRleCIsImNlaWwiLCJuZXdDZWxsVHIiLCJuZXdDZWxsUm93IiwiY2FuZGlkYXRlQ2VsbCIsImNlbGxzSW5TYW1lUm93IiwiaG9yaXpvbnRhbFNwbGl0Q2VsbCIsIm5ld0NvbFNwYW4iLCJuZXdDZWxsQ29sU3BhbiIsImNlbGxzSW5TYW1lQ29sIiwiY3JlYXRlRGVmIiwiZGVmIiwiY29udGV4dFNlbnNpdGl2ZSIsInRoIiwiYWRkQ21kIiwiY21kIiwiYWRkRmVhdHVyZSIsImFSb3dzIiwiYU1hcCIsIm9DZWxsIiwiaUNvbFNwYW4iLCJpUm93U3BhbiIsInJzIiwiY3MiLCJ0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyIsIkRFRkFVTFRfR1VUVEVSIiwiY2VudGVyVG9vbGJhciIsInRvb2xiYXJOb2RlIiwiaGFsZk5vZGVXaWR0aCIsIndpZGdldFhZIiwiZW5kUG9zaXRpb24iLCJpbWFnZVNlbGVjdGlvblNldFBvc2l0aW9uIiwidGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvbiIsIl9pc1JhbmdlQXRFbGVtZW50RW5kIiwiZW1iZWRTZWxlY3Rpb25UZXN0IiwibGlua1NlbGVjdGlvblRlc3QiLCJpbWFnZVNlbGVjdGlvblRlc3QiLCJ0ZXh0U2VsZWN0aW9uVGVzdCIsInNlbGVjdGlvbkVtcHR5IiwidGFibGVTZWxlY3Rpb25UZXN0IiwiZnVsbCIsInNpbXBsZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFFBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FB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QUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDNzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCOzs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCOzs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUI7Ozs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QmxHLEtBSm5DO0FBS0MzZ0IsVUFBTSx3QkFBYzJnQjtBQUxyQixDQTlCZ0IsQ0FBbkI7O2tCQXNDZTNmLFU7Ozs7Ozs7Ozs7O0FDMUNmLGFBQWEsb0NBQW9DLEVBQUUsSTs7Ozs7Ozs7Ozs7QUNBbkQsYUFBYSxvQ0FBb0MsRUFBRSxJIiwiZmlsZSI6ImFsbG95LWVkaXRvci1jb3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FkYXB0ZXIvbWFpbi5qc1wiKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbn1cblxudmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59IGVsc2Uge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBmYWN0b3J5KFJlYWN0Q29tcG9uZW50LCBpc1ZhbGlkRWxlbWVudCwgUmVhY3ROb29wVXBkYXRlUXVldWUpIHtcbiAgLyoqXG4gICAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gICAqL1xuXG4gIHZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICAgKiBvciBob3N0IGNvbXBvbmVudHMuXG4gICAqXG4gICAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAgICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICAgKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAgICpcbiAgICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICAgKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICAgKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAgICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgKlxuICAgKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBtaXhpbnM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgICAqXG4gICAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4ge1xuICAgICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgICAqIEByZXF1aXJlZFxuICAgICAqL1xuICAgIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcblxuICAgIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAgICpcbiAgICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgICAqIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAnREVGSU5FX09OQ0UnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VtZW50IGZvciAoZGVwcmVjYXRlZCkgYGNvbXBvbmVudFdpbGxNb3VudGAuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZW1lbnQgZm9yIChkZXByZWNhdGVkKSBgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc2AuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VtZW50IGZvciAoZGVwcmVjYXRlZCkgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICogQG92ZXJyaWRhYmxlXG4gICAgICovXG4gICAgdXBkYXRlQ29tcG9uZW50OiAnT1ZFUlJJREVfQkFTRSdcbiAgfTtcblxuICAvKipcbiAgICogU2ltaWxhciB0byBSZWFjdENsYXNzSW50ZXJmYWNlIGJ1dCBmb3Igc3RhdGljIG1ldGhvZHMuXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc1N0YXRpY0ludGVyZmFjZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGFmdGVyIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBhbmQgd2hlbiBpdFxuICAgICAqIHJlY2VpdmVzIG5ldyBwcm9wcy4gUmV0dXJuIGFuIG9iamVjdCB0byB1cGRhdGUgc3RhdGUgaW4gcmVzcG9uc2UgdG9cbiAgICAgKiBwcm9wIGNoYW5nZXMuIFJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNoYW5nZSB0byBzdGF0ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyByZXR1cm5lZCwgaXRzIGtleXMgd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgZXhpc3Rpbmcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3QgfHwgbnVsbH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnXG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICAgKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gICAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gICAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gICAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAgICovXG4gIHZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gICAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICB9LFxuICAgIG1peGluczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgICAgaWYgKG1peGlucykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCAnY2hpbGRDb250ZXh0Jyk7XG4gICAgICB9XG4gICAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICAgY2hpbGRDb250ZXh0VHlwZXNcbiAgICAgICk7XG4gICAgfSxcbiAgICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCAnY29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gX2Fzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyxcbiAgICAgICAgY29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKFxuICAgICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyxcbiAgICAgICAgICBnZXREZWZhdWx0UHJvcHNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsICdwcm9wJyk7XG4gICAgICB9XG4gICAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gICAgfSxcbiAgICBzdGF0aWNzOiBmdW5jdGlvbihDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICAgIH0sXG4gICAgYXV0b2JpbmQ6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBfaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgdHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArXG4gICAgICAgICAgICAgICdSZWFjdC5Qcm9wVHlwZXMuJyxcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJyxcbiAgICAgICAgICAgIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSxcbiAgICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdXG4gICAgICA6IG51bGw7XG5cbiAgICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICAgIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdPVkVSUklERV9CQVNFJyxcbiAgICAgICAgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSAnICtcbiAgICAgICAgICAnYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgJyArXG4gICAgICAgICAgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyxcbiAgICAgICAgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArXG4gICAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICtcbiAgICAgICAgICAndG8gYSBtaXhpbi4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAgICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAgICovXG4gIGZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gICAgaWYgKCFzcGVjKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgdHlwZW9mU3BlYyA9IHR5cGVvZiBzcGVjO1xuICAgICAgICB2YXIgaXNNaXhpblZhbGlkID0gdHlwZW9mU3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbDtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBpc01peGluVmFsaWQsXG4gICAgICAgICAgICBcIiVzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCBcIiArXG4gICAgICAgICAgICAgICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgK1xuICAgICAgICAgICAgICAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICtcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfaW52YXJpYW50KFxuICAgICAgdHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicsXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhICcgK1xuICAgICAgICAncmVndWxhciBvYmplY3QuJ1xuICAgICk7XG4gICAgX2ludmFyaWFudChcbiAgICAgICFpc1ZhbGlkRWxlbWVudChzcGVjKSxcbiAgICAgIFwiUmVhY3RDbGFzczogWW91J3JlIGF0dGVtcHRpbmcgdG8gXCIgK1xuICAgICAgICAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJ1xuICAgICk7XG5cbiAgICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcblxuICAgIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAgIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAgIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICAgIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPVxuICAgICAgICAgIGlzRnVuY3Rpb24gJiZcbiAgICAgICAgICAhaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgIWlzQWxyZWFkeURlZmluZWQgJiZcbiAgICAgICAgICBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgICBfaW52YXJpYW50KFxuICAgICAgICAgICAgICBpc1JlYWN0Q2xhc3NNZXRob2QgJiZcbiAgICAgICAgICAgICAgICAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcgfHxcbiAgICAgICAgICAgICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpLFxuICAgICAgICAgICAgICAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgK1xuICAgICAgICAgICAgICAgICd3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJyxcbiAgICAgICAgICAgICAgc3BlY1BvbGljeSxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIGlmICghc3RhdGljcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICFpc1Jlc2VydmVkLFxuICAgICAgICAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkICcgK1xuICAgICAgICAgICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArXG4gICAgICAgICAgJ2FzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgJyArXG4gICAgICAgICAgJ2NvbnN0cnVjdG9yLicsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG5cbiAgICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc1N0YXRpY0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgID8gUmVhY3RDbGFzc1N0YXRpY0ludGVyZmFjZVtuYW1lXVxuICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBfaW52YXJpYW50KFxuICAgICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuICAgICAgICAgICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgK1xuICAgICAgICAgICAgJ2R1ZSB0byBhIG1peGluLicsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApO1xuXG4gICAgICAgIENvbnN0cnVjdG9yW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3JbbmFtZV0sIHByb3BlcnR5KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gICAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgICBfaW52YXJpYW50KFxuICAgICAgb25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JyxcbiAgICAgICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nXG4gICAgKTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBfaW52YXJpYW50KFxuICAgICAgICAgIG9uZVtrZXldID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArXG4gICAgICAgICAgICAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArXG4gICAgICAgICAgICAnbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvICcgK1xuICAgICAgICAgICAgJ2dldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgJyArXG4gICAgICAgICAgICAnd2l0aCBjbGFzaGluZyBrZXlzLicsXG4gICAgICAgICAga2V5XG4gICAgICAgICk7XG4gICAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbmU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIHZhciBjID0ge307XG4gICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbihuZXdUaGlzKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICAgIF9rZXkgPSAxO1xuICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgIF9rZXkrK1xuICAgICAgICApIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICtcbiAgICAgICAgICAgICAgICAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArXG4gICAgICAgICAgICAgICAgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgK1xuICAgICAgICAgICAgICAgICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gICAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcbiAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBJc01vdW50ZWRQcmVNaXhpbiA9IHtcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9faXNNb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIElzTW91bnRlZFBvc3RNaXhpbiA9IHtcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9faXNNb3VudGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAgICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAgICovXG4gIHZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG4gICAgLyoqXG4gICAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgICAqL1xuICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24obmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIHRoaXMuX19kaWRXYXJuSXNNb3VudGVkLFxuICAgICAgICAgICclczogaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCAnICtcbiAgICAgICAgICAgICdzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvICcgK1xuICAgICAgICAgICAgJ3ByZXZlbnQgbWVtb3J5IGxlYWtzLicsXG4gICAgICAgICAgKHRoaXMuY29uc3RydWN0b3IgJiYgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgfHxcbiAgICAgICAgICAgIHRoaXMubmFtZSB8fFxuICAgICAgICAgICAgJ0NvbXBvbmVudCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhdGhpcy5fX2lzTW91bnRlZDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbigpIHt9O1xuICBfYXNzaWduKFxuICAgIFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLFxuICAgIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSxcbiAgICBSZWFjdENsYXNzTWl4aW5cbiAgKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhzcGVjKSB7XG4gICAgLy8gVG8ga2VlcCBvdXIgd2FybmluZ3MgbW9yZSB1bmRlcnN0YW5kYWJsZSwgd2UnbGwgdXNlIGEgbGl0dGxlIGhhY2sgaGVyZSB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxuICAgIC8vIHVubmVjZXNzYXJpbHkgaWRlbnRpZnkgYSBjbGFzcyB3aXRob3V0IGRpc3BsYXlOYW1lIGFzICdDb25zdHJ1Y3RvcicuXG4gICAgdmFyIENvbnN0cnVjdG9yID0gaWRlbnRpdHkoZnVuY3Rpb24ocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcixcbiAgICAgICAgICAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArXG4gICAgICAgICAgICAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5J1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICB0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpLFxuICAgICAgICAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJyxcbiAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50J1xuICAgICAgKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9KTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgSXNNb3VudGVkUHJlTWl4aW4pO1xuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgSXNNb3VudGVkUG9zdE1peGluKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaW52YXJpYW50KFxuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlcixcbiAgICAgICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLidcbiAgICApO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLFxuICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcbiAgICAgICAgICAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArXG4gICAgICAgICAgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICtcbiAgICAgICAgICAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLFxuICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcbiAgICAgICAgICAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsXG4gICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuICcgK1xuICAgICAgICAgICdEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDbGFzcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnknKTtcblxuaWYgKHR5cGVvZiBSZWFjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgRXJyb3IoXG4gICAgJ2NyZWF0ZS1yZWFjdC1jbGFzcyBjb3VsZCBub3QgZmluZCB0aGUgUmVhY3Qgb2JqZWN0LiBJZiB5b3UgYXJlIHVzaW5nIHNjcmlwdCB0YWdzLCAnICtcbiAgICAgICdtYWtlIHN1cmUgdGhhdCBSZWFjdCBpcyBiZWluZyBsb2FkZWQgYmVmb3JlIGNyZWF0ZS1yZWFjdC1jbGFzcy4nXG4gICk7XG59XG5cbi8vIEhhY2sgdG8gZ3JhYiBOb29wVXBkYXRlUXVldWUgZnJvbSBpc29tb3JwaGljIFJlYWN0XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkudXBkYXRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICBSZWFjdC5Db21wb25lbnQsXG4gIFJlYWN0LmlzVmFsaWRFbGVtZW50LFxuICBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nOyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgIClcblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiaW1wb3J0ICcuLi9jb3JlJztcbmltcG9ydCAnLi4vcGx1Z2lucyc7XG5cbmltcG9ydCAnLi4vY29tcG9uZW50cy91aWJyaWRnZSc7XG5cbmltcG9ydCBleHRlbmQgZnJvbSAnLi4vb29wL29vcCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi9vb3AvbGFuZyc7XG5pbXBvcnQgQmFzZSBmcm9tICcuLi9vb3AvYmFzZSc7XG5pbXBvcnQgU2VsZWN0aW9ucyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbnMnO1xuaW1wb3J0IFVJIGZyb20gJy4uL2NvbXBvbmVudHMvbWFpbi5qc3gnO1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogQWxsb3lFZGl0b3IgbWFpbiBjbGFzcy4gQ3JlYXRlcyBpbnN0YW5jZSBvZiB0aGUgZWRpdG9yIGFuZCBwcm92aWRlcyB0aGUgdXNlciBjb25maWd1cmF0aW9uXG4gKiB0byB0aGUgVUkuXG4gKlxuICogQGNsYXNzIENvcmVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb3JlKGNvbmZpZykge1xuICAgIENvcmUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNvbmZpZyk7XG59XG5cbmV4dGVuZChDb3JlLCBCYXNlLCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXIgbGlmZWN5Y2xlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgQWxsb3lFZGl0b3IgY2xhc3MuIENyZWF0ZXMgYSBDS0VkaXRvclxuICAgICAqIGluc3RhbmNlLCBwYXNzaW5nIGl0IHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVyXG4gICAgICogQHBhcmFtIGNvbmZpZyB7T2JqZWN0fSBDb25maWd1cmF0aW9uIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIGluaXRpYWxpemVyOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldCgnc3JjTm9kZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmdldCgnZW5hYmxlQ29udGVudEVkaXRhYmxlJykpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IENLRURJVE9SLmlubGluZShub2RlKTtcblxuICAgICAgICBlZGl0b3IuY29uZmlnLmFsbG93ZWRDb250ZW50ID0gdGhpcy5nZXQoJ2FsbG93ZWRDb250ZW50Jyk7XG5cbiAgICAgICAgZWRpdG9yLmNvbmZpZy50b29sYmFycyA9IHRoaXMuZ2V0KCd0b29sYmFycycpO1xuXG4gICAgICAgIGVkaXRvci5jb25maWcucmVtb3ZlUGx1Z2lucyA9IHRoaXMuZ2V0KCdyZW1vdmVQbHVnaW5zJyk7XG5cbiAgICAgICAgZWRpdG9yLmNvbmZpZy5leHRyYVBsdWdpbnMgPSB0aGlzLmdldCgnZXh0cmFQbHVnaW5zJyk7XG5cbiAgICAgICAgZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzID0gdGhpcy5nZXQoJ3BsYWNlaG9sZGVyQ2xhc3MnKTtcblxuICAgICAgICBlZGl0b3IuY29uZmlnLnBhc3RlRnJvbVdvcmRSZW1vdmVTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgZWRpdG9yLmNvbmZpZy5wYXN0ZUZyb21Xb3JkUmVtb3ZlRm9udFN0eWxlcyA9IGZhbHNlO1xuXG4gICAgICAgIGVkaXRvci5jb25maWcuc2VsZWN0aW9uS2V5c3Ryb2tlcyA9IHRoaXMuZ2V0KCdzZWxlY3Rpb25LZXlzdHJva2VzJyk7XG5cbiAgICAgICAgTGFuZy5taXgoZWRpdG9yLmNvbmZpZywgY29uZmlnKTtcblxuICAgICAgICBpZiAoQ0tFRElUT1IuZW52LmllICYmICFDS0VESVRPUi5lbnYuZWRnZSkge1xuICAgICAgICAgICAgZWRpdG9yLmNvbmZpZy5leHRyYVBsdWdpbnMgPSBlZGl0b3IuY29uZmlnLmV4dHJhUGx1Z2lucy5yZXBsYWNlKCdhZV9kcmFncmVzaXplJywgJ2FlX2RyYWdyZXNpemVfaWUnKTtcbiAgICAgICAgICAgIGVkaXRvci5jb25maWcucmVtb3ZlUGx1Z2lucyA9IGVkaXRvci5jb25maWcucmVtb3ZlUGx1Z2lucy5yZXBsYWNlKCdhZV9kcmFncmVzaXplJywgJ2FlX2RyYWdyZXNpemVfaWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIoZWRpdG9yKTtcblxuICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgIGVkaXRhYmxlLmFkZENsYXNzKCdhZS1lZGl0YWJsZScpO1xuXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yO1xuXG4gICAgICAgIEFsbG95RWRpdG9yLmxvYWRMYW5ndWFnZVJlc291cmNlcyh0aGlzLl9yZW5kZXJVSS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3RvciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBBbGxveUVkdG9yIGNsYXNzLiBEZXN0cm95cyB0aGUgQ0tFZGl0b3JcbiAgICAgKiBpbnN0YW5jZSBhbmQgZGVzdHJveXMgYWxsIGNyZWF0ZWQgdG9vbGJhcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIGRlc3RydWN0b3JcbiAgICAgKi9cbiAgICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5fZWRpdG9yVUlFbGVtZW50KSB7XG4gICAgICAgICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuX2VkaXRvclVJRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9lZGl0b3JVSUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9lZGl0b3JVSUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHRoaXMuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICBpZiAobmF0aXZlRWRpdG9yKSB7XG4gICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBuYXRpdmVFZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgaWYgKGVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZWRpdGFibGUucmVtb3ZlQ2xhc3MoJ2FlLWVkaXRhYmxlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoJ2VuYWJsZUNvbnRlbnRFZGl0YWJsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KCdzcmNOb2RlJykuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9ucygpO1xuXG4gICAgICAgICAgICBuYXRpdmVFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgc2VsZWN0aW9ucyBmcm9tIHdpbmRvdyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX2NsZWFyU2VsZWN0aW9uc1xuICAgICAqL1xuICAgIF9jbGVhclNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgaXNNU1NlbGVjdGlvbiA9IHR5cGVvZiB3aW5kb3cuZ2V0U2VsZWN0aW9uICE9ICdmdW5jdGlvbic7XG5cbiAgICAgICAgaWYgKGlzTVNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIG5hdGl2ZUVkaXRvci5kb2N1bWVudC4kLnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmF0aXZlRWRpdG9yLmRvY3VtZW50LmdldFdpbmRvdygpLiQuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHNldCBkZWZhdWx0IGxpbmsgYmVoYXZpb3JcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yXG4gICAgICovXG4gICAgX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXI6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICBlZGl0b3IuZWRpdGFibGUoKS5vbignY2xpY2snLCB0aGlzLl9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuLCB0aGlzLCB7XG4gICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGBjbGlja2AgZXZlbnQgd2hlbiB0aGUgZWRpdG9yIGlzIGluIHJlYWQgb25seSBtb2RlLiBOYXZpZ2F0ZXMgdG8gbGluaydzIFVSTCBvciBvcGVuc1xuICAgICAqIHRoZSBsaW5rIGluIGEgbmV3IHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGV2ZW50IHJlYWRPbmx5Q2xpY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfZGVmYXVsdFJlYWRPbmx5Q2xpY2tGblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZmlyZWQgYGNsaWNrYCBldmVudCBwYXlsb2FkXG4gICAgICovXG4gICAgX2RlZmF1bHRSZWFkT25seUNsaWNrRm46IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBtb3VzZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuICAgICAgICB2YXIgaGFzQ3RybEtleSA9IG1vdXNlRXZlbnQuY3RybEtleSB8fCBtb3VzZUV2ZW50Lm1ldGFLZXk7XG4gICAgICAgIHZhciBzaG91bGRPcGVuID0gdGhpcy5fZWRpdG9yLmNvbmZpZy5yZWFkT25seSB8fCBoYXNDdHJsS2V5O1xuXG4gICAgICAgIG1vdXNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIXNob3VsZE9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yLmVkaXRhYmxlKCkuZWRpdG9yLmZpcmUoJ3JlYWRPbmx5Q2xpY2snLCBldmVudC5kYXRhKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBja0VsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnRQYXRoKGV2ZW50LmRhdGEuZ2V0VGFyZ2V0KCksIHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxpbmsgPSBja0VsZW1lbnQubGFzdEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBsaW5rLiQuYXR0cmlidXRlcy5ocmVmID8gbGluay4kLmF0dHJpYnV0ZXMuaHJlZi52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGhhc0N0cmxLZXkgPyAnX2JsYW5rJyA6IGxpbmsuJC5hdHRyaWJ1dGVzLnRhcmdldCA/IGxpbmsuJC5hdHRyaWJ1dGVzLnRhcmdldC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVkaXJlY3RMaW5rKGhyZWYsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBuYXRpdmUgQ0tFZGl0b3IgaW5zdGFuY2UuIEhhdmluZyB0aGlzLCB0aGUgZGV2ZWxvcGVyIG1heSB1c2UgdGhlIEFQSSBvZiBDS0VkaXRvciBPT1RCLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfZ2V0TmF0aXZlRWRpdG9yXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBDS0VkaXRvci5cbiAgICAgKi9cbiAgICBfZ2V0TmF0aXZlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVkaXJlY3RzIHRoZSBicm93c2VyIHRvIGEgZ2l2ZW4gbGlua1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfcmVkaXJlY3RMaW5rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVGhlIGhyZWYgdG8gdGFrZSB0aGUgYnJvd3NlciB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdGFyZ2V0IFNwZWNpZmllcyB3aGVyZSB0byBkaXNwbGF5IHRoZSBsaW5rXG4gICAgICovXG4gICAgX3JlZGlyZWN0TGluazogZnVuY3Rpb24oaHJlZiwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgaHJlZikge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4oaHJlZiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChocmVmKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgc3BlY2lmaWVkIGZyb20gdGhlIHVzZXIgdG9vbGJhcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJVSVxuICAgICAqL1xuICAgIF9yZW5kZXJVSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB2YXIgZWRpdG9yVUlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlZGl0b3JVSUVsZW1lbnQuY2xhc3NOYW1lID0gJ2FlLXVpJztcblxuICAgICAgICAgICAgdmFyIHVpTm9kZSA9IHRoaXMuZ2V0KCd1aU5vZGUnKSB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAgICAgICB1aU5vZGUuYXBwZW5kQ2hpbGQoZWRpdG9yVUlFbGVtZW50KTtcblxuICAgICAgICAgICAgdGhpcy5fbWFpblVJID0gUmVhY3RET00ucmVuZGVyKDxVSVxuICAgICAgICAgICAgICAgIGVkaXRvcj17dGhpc31cbiAgICAgICAgICAgICAgICBldmVudHNEZWxheT17dGhpcy5nZXQoJ2V2ZW50c0RlbGF5Jyl9XG4gICAgICAgICAgICAgICAgdG9vbGJhcnM9e3RoaXMuZ2V0KCd0b29sYmFycycpfSAvPiwgZWRpdG9yVUlFbGVtZW50KTtcblxuICAgICAgICAgICAgdGhpcy5fZWRpdG9yVUlFbGVtZW50ID0gZWRpdG9yVUlFbGVtZW50O1xuXG4gICAgICAgICAgICB0aGlzLmdldCgnbmF0aXZlRWRpdG9yJykuZmlyZSgndWlSZWFkeScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFuIEhUTUwgZWxlbWVudCBmcm9tIHRoZSBwYXNzZWQgdmFsdWUuIElmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IHNob3VsZCBiZVxuICAgICAqIHRoZSBJZCBvZiB0aGUgZWxlbWVudCB3aGljaCBoYXZlIHRvIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBET00uXG4gICAgICogSWYgYW4gSFRNTCBFbGVtZW50IGlzIHBhc3NlZCwgdGhlIGVsZW1lbnQgaXRzZWxmIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgX3RvRWxlbWVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0geyEoU3RyaW5nfEhUTUxFbGVtZW50KX0gdmFsdWUgU3RyaW5nLCB3aGljaCBoYXZlIHRvIGNvcnJlc3BvbmQgdG8gYW4gSFRNTCBlbGVtZW50IGZyb20gdGhlIERPTSxcbiAgICAgKiBvciB0aGUgSFRNTCBlbGVtZW50IGl0c2VsZi4gSWYgSWQgaXMgcGFzc2VkLCB0aGUgSFRNTCBlbGVtZW50IHdpbGwgYmUgcmV0cmlldmVkIGZyb20gdGhlIERPTS5cbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gQW4gSFRNTCBlbGVtZW50LlxuICAgICAqL1xuICAgIF90b0VsZW1lbnQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChMYW5nLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgYWxsb3dlZCBjb250ZW50IGF0dHJpYnV0ZS4gTG9va1xuICAgICAqIFtoZXJlXShodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLmNvbmZpZy1jZmctYWxsb3dlZENvbnRlbnQpIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgICAqIHN1cHBvcnRlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF92YWxpZGF0ZUFsbG93ZWRDb250ZW50XG4gICAgICogQHBhcmFtIHtBbnl9IFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyB2YWxpZCBjb25maWd1cmF0aW9uLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBfdmFsaWRhdGVBbGxvd2VkQ29udGVudDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIExhbmcuaXNTdHJpbmcodmFsdWUpIHx8IExhbmcuaXNPYmplY3QodmFsdWUpIHx8IExhbmcuaXNCb29sZWFuKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSB2YWx1ZSBvZiB0b29sYmFycyBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX3ZhbGlkYXRlVG9vbGJhcnNcbiAgICAgKiBAcGFyYW0ge0FueX0gVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIHZhbGlkIHRvb2xiYXJzIGNvbmZpZ3VyYXRpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIF92YWxpZGF0ZVRvb2xiYXJzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTGFuZy5pc09iamVjdCh2YWx1ZSkgfHwgTGFuZy5pc051bGwodmFsdWUpO1xuICAgIH1cbn0sIHtcbiAgICBBVFRSUzoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyB0aGUgYWxsb3dlZCBjb250ZW50IGZvciB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiBBbGxveUVkaXRvci5cbiAgICAgICAgICogTG9vayBvbiB0aGUgW29mZmljaWFsIENLRWRpdG9yIEFQSV0oaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5jb25maWctY2ZnLWFsbG93ZWRDb250ZW50KVxuICAgICAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmFsaWQgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IGFsbG93ZWRDb250ZW50XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICogQHdyaXRlT25jZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbiwgU3RyaW5nLCBPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBhbGxvd2VkQ29udGVudDoge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiAnX3ZhbGlkYXRlQWxsb3dlZENvbnRlbnQnLFxuICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICB3cml0ZU9uY2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgQWxsb3lFZGl0b3Igc2V0IHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlXG4gICAgICAgICAqIHRvIFwidHJ1ZVwiIG9uIGl0cyBzcmNOb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IGVuYWJsZUNvbnRlbnRFZGl0YWJsZVxuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICogQHdyaXRlT25jZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlQ29udGVudEVkaXRhYmxlOiB7XG4gICAgICAgICAgICB2YWxpZGF0b3I6IExhbmcuaXNCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICB3cml0ZU9uY2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlbGF5ICh0aW1lb3V0KSwgaW4gbXMsIGFmdGVyIHdoaWNoIGV2ZW50cyBzdWNoIGxpa2Uga2V5IG9yIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHByb2Nlc3NlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBldmVudHNEZWxheVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRzRGVsYXk6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc051bWJlcixcbiAgICAgICAgICAgIHZhbHVlOiAxMDBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBleHRyYSBwbHVnaW5zIHdoaWNoIGhhdmUgdG8gYmUgbG9hZGVkIHRvIHRoZSBjdXJyZW50IENLRWRpdG9yIGluc3RhbmNlIGluIG9yZGVyIHRvXG4gICAgICAgICAqIG1ha2UgQWxsb3lFZGl0b3IgdG8gd29yayBwcm9wZXJseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBleHRyYVBsdWdpbnNcbiAgICAgICAgICogQGRlZmF1bHQgJ3VpY29yZSxzZWxlY3Rpb25yZWdpb24sZHJhZ3Jlc2l6ZSxhZGRpbWFnZXMscGxhY2Vob2xkZXIsdGFibGV0b29scyx0YWJsZXJlc2l6ZSxhdXRvbGluaydcbiAgICAgICAgICogQHdyaXRlT25jZVxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFQbHVnaW5zOiB7XG4gICAgICAgICAgICB2YWxpZGF0b3I6IExhbmcuaXNTdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogJ2FlX3VpY29yZSxhZV9zZWxlY3Rpb25yZWdpb24sYWVfc2VsZWN0aW9ua2V5c3Ryb2tlcyxhZV9pbWFnZWFsaWdubWVudCxhZV9hZGRpbWFnZXMsYWVfcGxhY2Vob2xkZXIsJyArXG4gICAgICAgICAgICAnYWVfdGFibGV0b29scyxhZV90YWJsZXJlc2l6ZSxhZV9hdXRvbGluayxhZV9lbWJlZCxhZV9hdXRvbGlzdCxhZV9kcmFncmVzaXplLCcgK1xuICAgICAgICAgICAgJ2FlX3VpYnJpZGdlLGFlX3JpY2hjb21ib2JyaWRnZSxhZV9wYW5lbG1lbnVidXR0b25icmlkZ2UsYWVfbWVudWJyaWRnZSxhZV9tZW51YnV0dG9uYnJpZGdlLGFlX2J1dHRvbmJyaWRnZSxmb250LGNvbG9yYnV0dG9uJyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIFwibW9kZVwiIGZvciBhbGxveSBlZGl0b3JcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAgICAgICAqIEBkZWZhdWx0ICdzaW1wbGUnXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnc2ltcGxlJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIG5hdGl2ZSBDS0VkaXRvciBpbnN0YW5jZS4gSGF2aW5nIHRoaXMsIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSB0aGUgZnVsbCBBUEkgb2YgQ0tFZGl0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgbmF0aXZlRWRpdG9yXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbmF0aXZlRWRpdG9yOiB7XG4gICAgICAgICAgICBnZXR0ZXI6ICdfZ2V0TmF0aXZlRWRpdG9yJyxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgY2xhc3MsIHdoaWNoIHNob3VsZCBiZSBhZGRlZCBieSBQbGFjZWhvbGRlciBwbHVnaW5cbiAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9wbGFjZWhvbGRlcn19e3svY3Jvc3NMaW5rfX1cbiAgICAgICAgICogd2hlbiBlZGl0b3IgaXMgbm90IGZvY3VzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgcGxhY2Vob2xkZXJDbGFzc1xuICAgICAgICAgKiBAZGVmYXVsdCAnYWUtcGxhY2Vob2xkZXInXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHBsYWNlaG9sZGVyQ2xhc3M6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnYWUtcGxhY2Vob2xkZXInLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcGx1Z2lucywgd2hpY2ggY29tZSBieSBkZWZhdWx0IHdpdGggQ0tFZGl0b3IsIGJ1dCB3aGljaCBhcmUgbm90IG5lZWRlZCBieSBBbGxveUVkaXRvci5cbiAgICAgICAgICogVGhlc2UgcGx1Z2lucyBhZGQgdGhlIGRlZmF1bHQgVUkgZm9yIENLZWRpdG9yLCB3aGljaCBpcyBubyBtb3JlIG5lZWRlZC4gUGxlYXNlIG5vdGUgdGhhdCBBbGxveUVkdG9yXG4gICAgICAgICAqIGNvbWVzIHdpdGggaXRzIG93biBoaWdobHkgb3B0aW1pemVkIGNvcHkgb2YgQ0tFZGl0b3IgKGp1c3QgY3VzdG9taXplZCB2aWEgdGhlaXIgb2ZmaWNpYWwgZG93bmxvYWQgcGFnZSkuXG4gICAgICAgICAqIFRoaXMgdmVyc2lvbiBkb2VzIG5vdCBjb21lIHdpdGggdGhlIHVubmVlZGVkIHBsdWdpbnMsIHNvIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IHdvbid0IGJlIG5lZWRlZC5cbiAgICAgICAgICogSG93ZXZlciwgaWYgeW91IGRlY2lkZSB0byBnbyB3aXRoIHRoZSBPT1RCIHZlcnNpb24gb2YgQ0tFZGl0b3IsIHlvdSB3aWxsIGhhdmUgdG8gcmVtb3ZlIHNvbWUgb2YgdGhlXG4gICAgICAgICAqIHBsdWdpbnMgaWYgeW91IGRlY2lkZSB0byB1c2UgQWxsb3lFZGl0b3IuIEtlZXAgaW4gbWluZCB0aGF0IHJlbW92aW5nIHRoZXNlIHBsdWdpbnMgZG9lc24ndCByZW1vdmUgdGhlbVxuICAgICAgICAgKiBlbnRpcmVseSBmcm9tIENLRWRpdG9yLiBJdCBqdXN0IHJlbW92ZXMgdGhlbSBmcm9tIGl0cyBjdXJyZW50IGluc3RhbmNlLCBpbiB3aGljaCB5b3Ugd2lsbCB1c2UgZGlmZmVyZW50XG4gICAgICAgICAqIFVJIC0gdGhvc2Ugb2YgQWxsb3lFZGl0b3IuIFlvdSB3aWxsIGJlIGZ1bGx5IGFibGUgdG8gdXNlIGJvdGggT09UQiBDS0VkaXRvciBhbmQgQWxsb3lFZGl0b3Igb24gdGhlIHNhbWVcbiAgICAgICAgICogcGFnZSFcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZW1vdmVQbHVnaW5zXG4gICAgICAgICAqIEBkZWZhdWx0ICdjb250ZXh0bWVudSx0b29sYmFyLGVsZW1lbnRzcGF0aCxyZXNpemUsbGlzdHN0eWxlLGxpbmsnXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVBsdWdpbnM6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnY29udGV4dG1lbnUsdG9vbGJhcixlbGVtZW50c3BhdGgscmVzaXplLGxpc3RzdHlsZSxsaW5rJyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcnJheSBvZiBtYW51YWwgc2VsZWN0aW9uIHRyaWdnZXJzLiBUaGV5IGNhbiBiZSBjb25maWd1cmVkIHRvIG1hbnVhbGx5IHNob3cgYSBzcGVjaWZpYyBzZWxlY3Rpb24gdG9vbGJhclxuICAgICAgICAgKiBieSBmb3JjaW5nIHRoZSBzZWxlY3Rpb24gdHlwZS4gQSBzZWxlY3Rpb25LZXlzdHJva2UgaXRlbSBjb25zaXN0cyBvZiBhIGtleXMgcHJvcGVydHkgd2l0aCBhIFtDS0VkaXRvciBrZXlzdHJva2VcbiAgICAgICAgICogZGVmaW5pdGlvbl0oaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5jb25maWctY2ZnLWtleXN0cm9rZXMpIGFuZCBhIHNlbGVjdGlvbiBwcm9wZXJ0eSB3aXRoXG4gICAgICAgICAqIHRoZSBzZWxlY3Rpb24gbmFtZSB0byB0cmlnZ2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IHNlbGVjdGlvbktleXN0cm9rZXNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uS2V5c3Ryb2tlczoge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBMYW5nLmlzQXJyYXksXG4gICAgICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICAgICAgICBrZXlzOiBDS0VESVRPUi5DVFJMICsgNzYgLypMKi8sXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiAnbGluaydcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXlzOiBDS0VESVRPUi5DVFJMICsgQ0tFRElUT1IuU0hJRlQgKyA3NiAvKkwqLyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246ICdlbWJlZCdcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hpY2ggQWxsb3lFZGl0b3Igc2hvdWxkIHVzZSBhcyBhbiBlZGl0YWJsZSBhcmVhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IHNyY05vZGVcbiAgICAgICAgICogQHR5cGUgU3RyaW5nIHwgTm9kZVxuICAgICAgICAgKiBAd3JpdGVPbmNlXG4gICAgICAgICAqL1xuICAgICAgICBzcmNOb2RlOiB7XG4gICAgICAgICAgICBzZXR0ZXI6ICdfdG9FbGVtZW50JyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbGJhcnMgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0b29sYmFyc1xuICAgICAgICAgKi9cbiAgICAgICAgdG9vbGJhcnM6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJ192YWxpZGF0ZVRvb2xiYXJzJyxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgYWRkOiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFsnaW1hZ2UnLCAnZW1iZWQnLCAnY2FtZXJhJywgJ2hsaW5lJywgJ3RhYmxlJ10sXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uczogU2VsZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hlcmUgQWxsb3lFZGl0b3IncyBVSSBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgdWlOb2RlXG4gICAgICAgICAqIEB0eXBlIFN0cmluZyB8IE5vZGVcbiAgICAgICAgICogQHdyaXRlT25jZVxuICAgICAgICAgKi9cbiAgICAgICAgdWlOb2RlOiB7XG4gICAgICAgICAgICBzZXR0ZXI6ICdfdG9FbGVtZW50JyxcbiAgICAgICAgICAgIHdyaXRlT25jZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkNLRURJVE9SLmV2ZW50LmltcGxlbWVudE9uKENvcmUpO1xuXG5leHBvcnQgZGVmYXVsdCBDb3JlO1xuIiwiaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCBMYW5nIGZyb20gJy4uL29vcC9sYW5nLmpzJztcblxuaW1wb3J0IEJ1dHRvbnMgZnJvbSAnLi4vY29tcG9uZW50cy9idXR0b25zJztcbmltcG9ydCBUb29sYmFycyBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2xiYXJzJztcblxuaW1wb3J0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbi1hcnJvd2JveCc7XG5pbXBvcnQgU2VsZWN0aW9ucyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbnMnO1xuaW1wb3J0IFNlbGVjdGlvblNldFBvc2l0aW9uIGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXBvc2l0aW9uJztcbmltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXRlc3QnO1xuXG5pbXBvcnQgQXR0cmlidXRlIGZyb20gJy4uL29vcC9hdHRyaWJ1dGUnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuLi9vb3Avb29wJztcbmltcG9ydCAnLi4vcGx1Z2lucyc7XG5cbi8vIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBjdXJyZW50bHkgcmVnaXN0ZXJlZCBwbHVnaW5zIGluIEFsbG95RWRpdG9yLlxudmFyIEJSSURHRV9CVVRUT05TID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBBbGxveUVkaXRvci5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZWRpdGFibGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfE5vZGV9IG5vZGUgVGhlIE5vZGUgSUQgb3IgSFRNbCBub2RlLCB3aGljaCBBbGxveUVkaXRvciBzaG91bGQgdXNlIGFzIGFuIGVkaXRhYmxlIGFyZWEuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgQWxsb3lFZGl0b3IuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIGluc3RhbmNlIG9mIHt7I2Nyb3NzTGluayBcIkNvcmVcIn19e3svY3Jvc3NMaW5rfX1cbiAqL1xuY29uc3QgZWRpdGFibGUgPSBmdW5jdGlvbihub2RlLCBjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgY29uZmlnLnNyY05vZGUgPSBub2RlO1xuXG4gICAgQWxsb3lFZGl0b3IuaW1wbGVtZW50RXZlbnRUYXJnZXQoKTtcblxuICAgIHJldHVybiBuZXcgQ29yZShjb25maWcpO1xufTtcblxuLyoqXG4gKiBUaGUgZnVsbCBVUkwgZm9yIHRoZSBBbGxveUVkaXRvciBpbnN0YWxsYXRpb24gZGlyZWN0b3J5LlxuICogSXQgaXMgcG9zc2libGUgdG8gbWFudWFsbHkgcHJvdmlkZSB0aGUgYmFzZSBwYXRoIGJ5IHNldHRpbmcgYVxuICogZ2xvYmFsIHZhcmlhYmxlIG5hbWVkIGBBTExPWUVESVRPUl9CQVNFUEFUSGAuIFRoaXMgZ2xvYmFsIHZhcmlhYmxlXG4gKiBtdXN0IGJlIHNldCAqKmJlZm9yZSoqIHRoZSBlZGl0b3Igc2NyaXB0IGxvYWRpbmcuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGdldEJhc2VQYXRoXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmb3VuZCBiYXNlIHBhdGhcbiAqL1xuY29uc3QgZ2V0QmFzZVBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAvLyBGaW5kIG91dCB0aGUgZWRpdG9yIGRpcmVjdG9yeSBwYXRoLCBiYXNlZCBvbiBpdHMgPHNjcmlwdD4gdGFnLlxuICAgIHZhciBwYXRoID0gd2luZG93LkFMTE9ZRURJVE9SX0JBU0VQQVRIIHx8ICcnO1xuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gc2NyaXB0c1sgaSBdLnNyYy5tYXRjaChBbGxveUVkaXRvci5yZWdleEJhc2VQYXRoKTtcblxuXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBJRSAob25seSkgdGhlIHNjcmlwdC5zcmMgc3RyaW5nIGlzIHRoZSByYXcgdmFsdWUgZW50ZXJlZCBpbiB0aGVcbiAgICAvLyBIVE1MIHNvdXJjZS4gT3RoZXIgYnJvd3NlcnMgcmV0dXJuIHRoZSBmdWxsIHJlc29sdmVkIFVSTCBpbnN0ZWFkLlxuICAgIGlmIChwYXRoLmluZGV4T2YoJzovJykgPT09IC0xICYmIHBhdGguc2xpY2UoMCwgMikgIT09ICcvLycgKSB7XG4gICAgICAgIC8vIEFic29sdXRlIHBhdGguXG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICAgICAgcGF0aCA9IGxvY2F0aW9uLmhyZWYubWF0Y2goL14uKj86XFwvXFwvW15cXC9dKi8pWzBdICsgcGF0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWxhdGl2ZSBwYXRoLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBsb2NhdGlvbi5ocmVmLm1hdGNoKC9eW15cXD9dKlxcLyg/OikvKVswXSArIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhdGgpe1xuICAgICAgICB0aHJvdyAnVGhlIEFsbG95RWRpdG9yIGluc3RhbGxhdGlvbiBwYXRoIGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGRldGVjdGVkLiBQbGVhc2Ugc2V0IHRoZSBnbG9iYWwgdmFyaWFibGUgXCJBTExPWUVESVRPUl9CQVNFUEFUSFwiIGJlZm9yZSBjcmVhdGluZyBlZGl0b3IgaW5zdGFuY2VzLic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIERldGVjdHMgYW5kIGxvYWQgdGhlIGNvcnJlc3BvbmRpbmcgbGFuZ3VhZ2UgZmlsZSBpZiBBbGxveUVkaXRvciBsYW5ndWFnZSBzdHJpbmdzIGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LlxuICogVGhlIGZ1bmN0aW9uIGZpcmVzIGEge3sjY3Jvc3NMaW5rIFwiQWxsb3lFZGl0b3IvbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgbG9hZExhbmd1YWdlUmVzb3VyY2VzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBBbGxveUVkaXRvciBsb2FkcyB0aGUgbGFuZ3VhZ2UgcmVzb3VyY2UuXG4gKi9cbmNvbnN0IGxvYWRMYW5ndWFnZVJlc291cmNlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgQWxsb3lFZGl0b3IuaW1wbGVtZW50RXZlbnRUYXJnZXQoKTtcblxuICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgIGlmIChBbGxveUVkaXRvci5TdHJpbmdzKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFsbG95RWRpdG9yLm9uY2UoJ2xhbmd1YWdlUmVzb3VyY2VzTG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghQWxsb3lFZGl0b3IuX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCkge1xuICAgICAgICBBbGxveUVkaXRvci5fbGFuZ1Jlc291cmNlUmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2VzID0gWydhZicsICdhcicsICdiZycsICdibicsICdicycsICdjYScsICdjcycsICdjeScsICdkYScsICdkZScsICdlbCcsICdlbi1hdScsICdlbi1jYScsICdlbi1nYicsICdlbicsICdlbycsICdlcycsICdldCcsICdldScsICdmYScsICdmaScsICdmbycsICdmci1jYScsICdmcicsICdnbCcsICdndScsICdoZScsICdoaScsICdocicsICdodScsICdpZCcsICdpcycsICdpdCcsICdqYScsICdrYScsICdrbScsICdrbycsICdrdScsICdsdCcsICdsdicsICdtaycsICdtbicsICdtcycsICduYicsICdubCcsICdubycsICdwbCcsICdwdC1icicsICdwdCcsICdybycsICdydScsICdzaScsICdzaycsICdzbCcsICdzcScsICdzci1sYXRuJywgJ3NyJywgJ3N2JywgJ3RoJywgJ3RyJywgJ3R0JywgJ3VnJywgJ3VrJywgJ3ZpJywgJ3poLWNuJywgJ3poJ107XG5cbiAgICAgICAgdmFyIHVzZXJMYW5ndWFnZSA9IG5hdmlnYXRvci5sYW5ndWFnZSB8fCBuYXZpZ2F0b3IudXNlckxhbmd1YWdlIHx8ICdlbic7XG5cbiAgICAgICAgdmFyIHBhcnRzID0gdXNlckxhbmd1YWdlLnRvTG93ZXJDYXNlKCkubWF0Y2goLyhbYS16XSspKD86LShbYS16XSspKT8vKTtcbiAgICAgICAgdmFyIGxhbmcgPSBwYXJ0c1sxXTtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHBhcnRzWzJdO1xuXG4gICAgICAgIGlmIChsYW5ndWFnZXMuaW5kZXhPZihsYW5nICsgJy0nICsgbG9jYWxlKSA+PSAwKSB7XG4gICAgICAgICAgICBsYW5nID0gbGFuZyArICctJyArIGxvY2FsZTtcbiAgICAgICAgfSBlbHNlIGlmIChsYW5ndWFnZXMuaW5kZXhPZihsYW5nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxhbmcgPSAnZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgQ0tFRElUT1Iuc2NyaXB0TG9hZGVyLmxvYWQoQWxsb3lFZGl0b3IuZ2V0VXJsKCdsYW5nL2FsbG95LWVkaXRvci8nICsgbGFuZyArICcuanMnKSwgZnVuY3Rpb24obG9hZGVkKSB7XG4gICAgICAgICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgQWxsb3lFZGl0b3IuZmlyZSgnbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBmdWxsIFVSTCBmb3IgQWxsb3lFZGl0b3IgcmVzb3VyY2VzLiBCeSBkZWZhdWx0LCBVUkxzXG4gKiByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIGNvbnRhaW4gYSBxdWVyeXN0cmluZyBwYXJhbWV0ZXIgKFwidFwiKVxuICogc2V0IHRvIHRoZSB7QGxpbmsgQ0tFRElUT1IjdGltZXN0YW1wfSB2YWx1ZS5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0VXJsXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzb3VyY2UgVGhlIHJlc291cmNlIHdob3NlIGZ1bGwgVVJMIHdlIHdhbnQgdG8gZ2V0LlxuICogSXQgbWF5IGJlIGEgZnVsbCwgYWJzb2x1dGUsIG9yIHJlbGF0aXZlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZ1bGwgVVJMLlxuICovXG5jb25zdCBnZXRVcmwgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgIHZhciBiYXNlUGF0aCA9IEFsbG95RWRpdG9yLmdldEJhc2VQYXRoKCk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIGZ1bGwgb3IgYWJzb2x1dGUgcGF0aC5cbiAgICBpZiAocmVzb3VyY2UuaW5kZXhPZignOi8nKSA9PT0gLTEgJiYgcmVzb3VyY2UuaW5kZXhPZignLycpICE9PSAwKSB7XG4gICAgICAgIHJlc291cmNlID0gYmFzZVBhdGggKyByZXNvdXJjZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHRpbWVzdGFtcCwgZXhjZXB0IGZvciBkaXJlY3Rvcmllcy5cbiAgICBpZiAoQ0tFRElUT1IudGltZXN0YW1wICYmIHJlc291cmNlLmNoYXJBdCggcmVzb3VyY2UubGVuZ3RoIC0gMSApICE9PSAnLycgJiYgISgvWyY/XXQ9LykudGVzdChyZXNvdXJjZSkpIHtcbiAgICAgICAgcmVzb3VyY2UgKz0gKHJlc291cmNlLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArICd0PScgKyBDS0VESVRPUi50aW1lc3RhbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc291cmNlO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGV2ZW50IGZpcmluZyBhbmQgc3Vic2NyaWJpbmcgdmlhIENLRURJVE9SLmV2ZW50LlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBpbXBsZW1lbnRFdmVudFRhcmdldFxuICogQHN0YXRpY1xuICovXG5jb25zdCBpbXBsZW1lbnRFdmVudFRhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghQWxsb3lFZGl0b3IuZmlyZSAmJiAhQWxsb3lFZGl0b3Iub24pIHtcbiAgICAgICAgQ0tFRElUT1IuZXZlbnQuaW1wbGVtZW50T24oQWxsb3lFZGl0b3IpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdoaWNoIHNob3VsZCBtYXRjaCB0aGUgc2NyaXB0IHdoaWNoIGhhdmUgYmVlbiB1c2VkIHRvIGxvYWQgQWxsb3lFZGl0b3IuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAcHJvcGVydHkgcmVnZXhCYXNlUGF0aFxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgcmVnZXhCYXNlUGF0aCA9IC8oXnwuKltcXFxcXFwvXSkoPzphbGxveS1lZGl0b3JbXi9dK3xhbGxveS1lZGl0b3IpXFwuanMoPzpcXD8uKnw7LiopPyQvaTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIEFsbG95RWRpdG9yIGRldGVjdHMgdGhlIGJyb3dzZXIgbGFuZ3VhZ2UgYW5kIGxvYWRzIHRoZSBjb3JyZXNwb25kaW5nIGxhbmd1YWdlIGZpbGUuIE9uY2UgdGhpcyBldmVudFxuICogaXMgZmlyZWQsIEFsbG95RWRpdG9yLlN0cmluZ3Mgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBldmVudCBsYW5ndWFnZVJlc291cmNlc0xvYWRlZFxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgcGx1Z2luIG5hbWVzIG5lZWRlZCBmb3IgYSBnaXZlbiBwbHVnaW5cbiAqIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBvciBhbiBlbXB0eSBhcnJheS5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0QnV0dG9uc1xuICogQHBhcmFtIHtBcnJheX0gYnV0dG9ucyBBbiBhcnJheSBvZiBidXR0b25zIG9yIHBsdWdpbiBuYW1lcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGludm9rZWQgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdGVkIGJ1dHRvbiBuYW1lcy5cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgZ2V0QnV0dG9ucyA9IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBidXR0b25zLnJlZHVjZShmdW5jdGlvbihhY2MsIHZhbCkge1xuICAgICAgICAgICAgdmFsID0gQlJJREdFX0JVVFRPTlNbdmFsXSB8fCBbdmFsXTtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJ1dHRvbiBhbmQgdHJ5IHRvIGdldCBpdHMgcmVxdWlyZWQgcGx1Z2lucy5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgcmVnaXN0ZXJCcmlkZ2VCdXR0b25cbiAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b25OYW1lIFRoZSBuYW1lIG9mIHRoZSBidXR0b24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2luTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgcmVnaXN0ZXJzIHRoZSBidXR0b24uXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IHJlZ2lzdGVyQnJpZGdlQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uTmFtZSwgcGx1Z2luTmFtZSkge1xuICAgIGlmICghQlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0pIHtcbiAgICAgICAgQlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBCUklER0VfQlVUVE9OU1twbHVnaW5OYW1lXS5wdXNoKGJ1dHRvbk5hbWUpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIE9PUFxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKi9cbmNvbnN0IE9PUCA9IHtcbiAgICBleHRlbmRcbn07XG5cbmV4cG9ydCB7XG4gICAgQXR0cmlidXRlLFxuICAgIEJ1dHRvbnMsXG4gICAgQ29yZSxcbiAgICBlZGl0YWJsZSxcbiAgICBnZXRCYXNlUGF0aCxcbiAgICBnZXRCdXR0b25zLFxuICAgIGdldFVybCxcbiAgICBpbXBsZW1lbnRFdmVudFRhcmdldCxcbiAgICBMYW5nLFxuICAgIGxvYWRMYW5ndWFnZVJlc291cmNlcyxcbiAgICBPT1AsXG4gICAgcmVnaXN0ZXJCcmlkZ2VCdXR0b24sXG4gICAgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzLFxuICAgIFNlbGVjdGlvbnMsXG4gICAgU2VsZWN0aW9uU2V0UG9zaXRpb24sXG4gICAgU2VsZWN0aW9uVGVzdCxcbiAgICBUb29sYmFyc1xufTtcbiIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBCdXR0b25BY3Rpb25TdHlsZSBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgYXBwbHlpbmcgc3R5bGUgaW1wbGVtZW50YXRpb24gZm9yIGFcbiAqIGJ1dHRvbiBiYXNlZCBvbiB0aGUgYGFwcGx5U3R5bGVgIGFuZCBgcmVtb3ZlU3R5bGVgIEFQSSBvZiBDS0VESVRPUi5cbiAqXG4gKiBUbyBleGVjdXRlIHByb3Blcmx5LCB0aGUgY29tcG9uZW50IGhhcyB0byBleHBvc2UgdGhlIGZvbGxvd2luZyBtZXRob2RzIHdoaWNoIGNhbiBiZSBvYnRhaW5lZFxuICogb3V0IG9mIHRoZSBib3ggdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkJ1dHRvblN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IG1peGluOlxuICogLSBgRnVuY3Rpb25gIHt7I2Nyb3NzTGluayBcIkJ1dHRvblN0eWxlL2lzQWN0aXZlXCJ9fXt7L2Nyb3NzTGlua319IHRvIGNoZWNrIHRoZSBhY3RpdmUgc3RhdGVcbiAqIC0gYEZ1bmN0aW9uYCB7eyNjcm9zc0xpbmsgXCJCdXR0b25TdHlsZS9nZXRTdHlsZVwifX17ey9jcm9zc0xpbmt9fSB0byByZXR1cm4gdGhlIHN0eWxlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWRcbiAqXG4gKiBAY2xhc3MgQnV0dG9uQWN0aW9uU3R5bGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgb3IgYXBwbGllcyB0aGUgY29tcG9uZW50IHN0eWxlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25BY3Rpb25TdHlsZVxuICAgICAqIEBtZXRob2QgYXBwbHlTdHlsZVxuICAgICAqL1xuICAgIGFwcGx5U3R5bGUoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5pc0FjdGl2ZSkgJiYgTGFuZy5pc0Z1bmN0aW9uKHRoaXMuZ2V0U3R5bGUpKSB7XG4gICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICAgICAgZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTdHlsZSh0aGlzLmdldFN0eWxlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuYXBwbHlTdHlsZSh0aGlzLmdldFN0eWxlKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudW5sb2NrKCk7XG5cbiAgICAgICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwiLyoqXG4gKiBCdXR0b25Db21tYW5kQWN0aXZlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhbiBgaXNBY3RpdmVgIG1ldGhvZCB0byBkZXRlcm1pbmUgaWZcbiAqIGEgY29udGV4dC1hd2FyZSBjb21tYW5kIGlzIGN1cnJlbnRseSBpbiBhbiBhY3RpdmUgc3RhdGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29tbWFuZCBpcyBhY3RpdmUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAgICAgKiBAbWV0aG9kIGlzQWN0aXZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tbWFuZCBpcyBhY3RpdmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgdmFyIGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCh0aGlzLnByb3BzLmNvbW1hbmQpO1xuXG4gICAgICAgIHJldHVybiBjb21tYW5kID8gY29tbWFuZC5zdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfT04gOiBmYWxzZTtcbiAgICB9XG59OyIsIi8qKlxuICogQnV0dG9uQ29tbWFuZCBpcyBhIG1peGluIHRoYXQgZXhlY3V0ZXMgYSBjb21tYW5kIHZpYSBDS0VESVRPUidzIEFQSS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29tbWFuZFxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBDS0VkaXRvciBjb21tYW5kIGFuZCBmaXJlcyBgYWN0aW9uUGVyZm9ybWVkYCBldmVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBkYXRhIE9wdGlvbmFsIGRhdGEgdG8gYmUgcGFzc2VkIHRvIENLRURJVE9SJ3MgYGV4ZWNDb21tYW5kYCBtZXRob2QuXG4gICAgICogQG1ldGhvZCBleGVjQ29tbWFuZFxuICAgICAqL1xuICAgIGV4ZWNDb21tYW5kKGRhdGEpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKHRoaXMucHJvcHMuY29tbWFuZCwgZGF0YSk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMubW9kaWZpZXNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb25DaGFuZ2UodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgfVxufTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5cbi8qKlxuICogQnV0dG9uS2V5c3Ryb2tlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIGBrZXlzdHJva2VgIHByb3AgdGhhdCBhbGxvd3MgY29uZmlndXJpbmdcbiAqIGEgZnVuY3Rpb24gb2YgdGhlIGluc3RhbmNlIHRvIGJlIGludm9rZWQgdXBvbiB0aGUga2V5c3Ryb2tlIGFjdGl2YXRpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvbktleXN0cm9rZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25LZXlzdHJva2VcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsTW91bnQpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIga2V5c3Ryb2tlID0gdGhpcy5wcm9wcy5rZXlzdHJva2U7XG5cbiAgICAgICAgdmFyIGNvbW1hbmROYW1lID0ga2V5c3Ryb2tlLm5hbWUgfHwgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCkudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgY29tbWFuZCA9IG5hdGl2ZUVkaXRvci5nZXRDb21tYW5kKGNvbW1hbmROYW1lKTtcblxuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBuZXcgQ0tFRElUT1IuY29tbWFuZChuYXRpdmVFZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzdHJva2VGbiA9IGtleXN0cm9rZS5mbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuaXNTdHJpbmcoa2V5c3Ryb2tlRm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzdHJva2VGbl0uY2FsbCh0aGlzLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChMYW5nLmlzRnVuY3Rpb24oa2V5c3Ryb2tlRm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c3Ryb2tlRm4uY2FsbCh0aGlzLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBuYXRpdmVFZGl0b3IuYWRkQ29tbWFuZChjb21tYW5kTmFtZSwgY29tbWFuZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZCA9IG5hdGl2ZUVkaXRvci5rZXlzdHJva2VIYW5kbGVyLmtleXN0cm9rZXNba2V5c3Ryb2tlLmtleXNdO1xuXG4gICAgICAgIG5hdGl2ZUVkaXRvci5zZXRLZXlzdHJva2Uoa2V5c3Ryb2tlLmtleXMsIGNvbW1hbmROYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBmcm9tIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uS2V5c3Ryb2tlXG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuc2V0S2V5c3Ryb2tlKHRoaXMucHJvcHMua2V5c3Ryb2tlLmtleXMsIHRoaXMuX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kKTtcbiAgICB9XG59OyIsIi8qKlxuICogQnV0dG9uQ2ZnUHJvcHMgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgc3R5bGUgcHJvcCBhbmQgc29tZSBtZXRob2RzIHRvIGFwcGx5IHRoZSByZXN1bHRpbmdcbiAqIHN0eWxlIGFuZCBjaGVja2luZyBpZiBpdCBpcyBwcmVzZW50IGluIGEgZ2l2ZW4gcGF0aCBvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNmZ1Byb3BzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMsIHBhc3NlZCB0byB0aGUgY3VycmVudCBjb21wb25lbnQgd2l0aCB1c2VyJ3MgY29uZmlndXJhdGlvblxuICAgICAqIHZpYSBgYnV0dG9uQ2ZnYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25DZmdQcm9wc1xuICAgICAqIEBtZXRob2QgbWVyZ2VCdXR0b25DZmdQcm9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgcHJvcGVydGllcyB0byBiZSBtZXJnZWQgd2l0aCB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbiBmb3IgdGhpc1xuICAgICAqIGJ1dHRvbi4gSWYgbm90IHBhc3NlZCwgdGhlIHVzZXIgY29uZmlndXJhdGlvbiB3aWxsIGJlIG1lcmdlZCB3aXRoIGB0aGlzLnByb3BzYFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbWVyZ2VCdXR0b25DZmdQcm9wcyhwcm9wcykge1xuICAgICAgICBwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cbiAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciBidXR0b25DZmcgPSBuYXRpdmVFZGl0b3IuY29uZmlnLmJ1dHRvbkNmZyB8fCB7fTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHByb3BzLCBidXR0b25DZmdbJ2xpbmtFZGl0J10pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uU3RhdGVDbGFzc2VzIGlzIGEgbWl4aW4gdGhhdCBkZWNvcmF0ZXMgdGhlIGRvbUVsZW1lbnQgb2YgYSBjb21wb25lbnRcbiAqIHdpdGggZGlmZmVyZW50IENTUyBjbGFzc2VzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIFRvIGNoZWNrIGZvciBzdGF0ZSwgdGhlIGNvbXBvbmVudCBjYW4gZXhwb3NlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqIC0gYEZ1bmN0aW9uYCAqKmlzQWN0aXZlKiogdG8gY2hlY2sgdGhlIGFjdGl2ZSBzdGF0ZVxuICogLSBgRnVuY3Rpb25gICoqaXNEaXNhYmxlZCoqIHRvIGNoZWNrIHRoZSBkaXNhYmxlZCBzdGF0ZVxuICpcbiAqIEBjbGFzcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygc3RhdGUgY2xhc3NlcyBhc3NvY2lhdGVkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQncyBzdGF0ZSwgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHJlc3VsdHMgb2YgdGhlIGlzQWN0aXZlIGFuZCBpc0Rpc2FibGVkIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3RhdGVDbGFzc2VzXG4gICAgICogQG1ldGhvZCBnZXRTdGF0ZUNsYXNzZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHdpdGggdGhlIHN0YXRlIENTUyBjbGFzc2VzLlxuICAgICAqL1xuICAgIGdldFN0YXRlQ2xhc3NlcygpIHtcbiAgICAgICAgdmFyIHN0YXRlQ2xhc3NlcyA9ICcnO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBhY3RpdmUgc3RhdGVcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmlzQWN0aXZlKSAmJiB0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHN0YXRlQ2xhc3NlcyArPSAnYWUtYnV0dG9uLXByZXNzZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGRpc2FibGVkIHN0YXRlXG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5pc0Rpc2FibGVkKSAmJiB0aGlzLmlzRGlzYWJsZWQoKSkge1xuICAgICAgICAgICAgc3RhdGVDbGFzc2VzICs9ICcgYWUtYnV0dG9uLWRpc2FibGVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZUNsYXNzZXM7XG4gICAgfVxufTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcydcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogQnV0dG9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgc3R5bGUgcHJvcCBhbmQgc29tZSBtZXRob2RzIHRvIGFwcGx5IHRoZSByZXN1bHRpbmdcbiAqIHN0eWxlIGFuZCBjaGVja2luZyBpZiBpdCBpcyBwcmVzZW50IGluIGEgZ2l2ZW4gcGF0aCBvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnByb3BzLnN0eWxlO1xuXG4gICAgICAgIGlmIChMYW5nLmlzU3RyaW5nKHN0eWxlKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gc3R5bGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWVtYmVyID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5jb25maWc7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICB3aGlsZSAocHJvcGVydHkgJiYgTGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyKSAmJiBMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXJbcHJvcGVydHldKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNZW1iZXIgPSBjdXJyZW50TWVtYmVyW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBjdXJyZW50TWVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCkpIHtcbiAgICAgICAgICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiBDS0VESVRPUi5zdHlsZSB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IGJ1dHRvbiBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuICAgICAqIEBtZXRob2QgZ2V0U3R5bGVcbiAgICAgKiBAcmV0dXJuIHtDS0VESVRPUi5zdHlsZX0gVGhlIGN1cnJlbnQgc3R5bGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0U3R5bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3R5bGUgaXMgYWN0aXZlIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuICAgICAqIEBtZXRob2QgaXNBY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHN0eWxlIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIHZhciBlbGVtZW50UGF0aCA9IGVkaXRvci5lbGVtZW50UGF0aCgpO1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0U3R5bGUoKS5jaGVja0FjdGl2ZShlbGVtZW50UGF0aCwgZWRpdG9yKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8vIFdyYXBwZWRDb21wb25lbnQucHJvcFR5cGVzID0ge1xuLy8gICAgIC8qKlxuLy8gICAgICogVGhlIHN0eWxlIHRoZSBidXR0b24gc2hvdWxkIGhhbmRsZS4gQWxsb3dlZCB2YWx1ZXMgYXJlOlxuLy8gICAgICogLSBPYmplY3QgYXMgZGVzY3JpYmVkIGJ5IGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUuXG4vLyAgICAgKiAtIFN0cmluZyBwb2ludGluZyB0byBhbiBvYmplY3QgaW5zaWRlIHRoZSBlZGl0b3IgaW5zdGFuY2UgY29uZmlndXJhdGlvbi4gRm9yIGV4YW1wbGUsIGBzdHlsZSA9ICdjb3JlU3R5bGVzX2JvbGQnYCB3aWxsIHRyeSB0b1xuLy8gICAgICogcmV0cmlldmUgdGhlIHN0eWxlIG9iamVjdCBmcm9tIGBlZGl0b3IuY29uZmlnLmNvcmVTdHlsZXNfYm9sZGAuIE5lc3RlZCBwcm9wZXJ0aWVzIHN1Y2ggYXMgYHN0eWxlID0gJ215cGx1Z2luLm15Q29uZmlnLm15U3R5bGUnYFxuLy8gICAgICogYXJlIGFsc28gc3VwcG9ydGVkIGFuZCB3aWxsIHRyeSB0byByZXRyaWV2ZSB0aGUgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGVkaXRvciBjb25maWd1cmF0aW9uIGFzIHdlbGwuXG4vLyAgICAgKlxuLy8gICAgICogQGluc3RhbmNlXG4vLyAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcbi8vICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fFN0cmluZ30gc3R5bGVcbi8vICAgICAqL1xuLy8gICAgIHN0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbi8vICAgICAgICAgUHJvcFR5cGVzLm9iamVjdCxcbi8vICAgICAgICAgUHJvcFR5cGVzLnN0cmluZ1xuLy8gICAgIF0pLFxuLy8gICAgIC8qKlxuLy8gICAgICAqIFRoZSBzdHlsZSBmdW5jdGlvbiB0aGUgYnV0dG9uIHNob3VsZCBoYW5kbGUuXG4vLyAgICAgICogSWYgc3BlY2lmaWVkLCBzdHlsZSBmdW5jdGlvbiBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gc3R5bGUgcHJvcGVydHkuXG4vLyAgICAgICpcbi8vICAgICAgKiBAaW5zdGFuY2Vcbi8vICAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcbi8vICAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBzdHlsZUZuXG4vLyAgICAgICovXG4vLyAgICAgc3R5bGVGbjogUHJvcFR5cGVzLmZ1bmNcbi8vIH07IiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUb29sYmFyQnV0dG9ucyBpcyBhIG1peGluIHdoaWNoIHByb3ZpZGVzIGEgbGlzdCBvZiBidXR0b25zIHdoaWNoIGhhdmUgdG8gYmVcbiAqIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCB0b29sYmFyIGRlcGVuZGluZyBvbiB1c2VyIHByZWZlcmVuY2VzIGFuZCBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckJ1dHRvbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEFuYWxheXNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHJldHVybnMgdGhlIGJ1dHRvbnMgb3IgYnV0dG9uIGdyb3VwcyB0byBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgZ2V0VG9vbGJhckJ1dHRvbkdyb3Vwc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJ1dHRvbnMgVGhlIGJ1dHRvbnMgY291bGQgYmUgc2hvd24sIHByaW9yIHRvIHRoZSBzdGF0ZSBmaWx0ZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFkZGl0aW9uYWxQcm9wcyBBZGRpdGlvbmFsIHByb3BzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBkb3duIHRvIHRoZSBidXR0b25zLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aGljaCBjb250YWlucyB0aGUgYnV0dG9ucyBvciBidXR0b24gZ3JvdXBzIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFRvb2xiYXJCdXR0b25Hcm91cHMoYnV0dG9ucywgYWRkaXRpb25hbFByb3BzKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihidXR0b25zKSkge1xuICAgICAgICAgICAgYnV0dG9ucyA9IGJ1dHRvbnMuY2FsbCh0aGlzKSB8fCBbXTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbnMucmVkdWNlKGZ1bmN0aW9uKGxpc3QsIGJ1dHRvbikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnV0dG9uKSkge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChpbnN0YW5jZS5nZXRUb29sYmFyQnV0dG9ucyhidXR0b24sIGFkZGl0aW9uYWxQcm9wcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0VG9vbGJhckJ1dHRvbnMoYnV0dG9ucywgYWRkaXRpb25hbFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5emVzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmQgdGhlIGJ1dHRvbnMgZXhjbHVzaXZlIG1vZGUgdmFsdWUgdG8gZmlndXJlIG91dCB3aGljaFxuICAgICAqIGJ1dHRvbnMgc2hvdWxkIGJlIHByZXNlbnQgaW4gYSBnaXZlbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuICAgICAqIEBtZXRob2QgZ2V0VG9vbGJhckJ1dHRvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidXR0b25zIFRoZSBidXR0b25zIGNvdWxkIGJlIHNob3duLCBwcmlvciB0byB0aGUgc3RhdGUgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhZGRpdGlvbmFsUHJvcHMgQWRkaXRpb25hbCBwcm9wcyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgZG93biB0byB0aGUgYnV0dG9ucy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIGJ1dHRvbnMgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0VG9vbGJhckJ1dHRvbnMoYnV0dG9ucywgYWRkaXRpb25hbFByb3BzKSB7XG4gICAgICAgIHZhciBidXR0b25Qcm9wcyA9IHt9O1xuXG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgYnV0dG9uQ2ZnID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5idXR0b25DZmcgfHwge307XG5cbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihidXR0b25zKSkge1xuICAgICAgICAgICAgYnV0dG9ucyA9IGJ1dHRvbnMuY2FsbCh0aGlzKSB8fCBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b29sYmFyQnV0dG9ucyA9IHRoaXMuZmlsdGVyRXhjbHVzaXZlKFxuICAgICAgICAgICAgICAgIGJ1dHRvbnMuZmlsdGVyKGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uICYmIChBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbl0gfHwgQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuaXNTdHJpbmcoYnV0dG9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uUHJvcHNbYnV0dG9uXSA9IGJ1dHRvbkNmZ1tidXR0b25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b25dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKExhbmcuaXNTdHJpbmcoYnV0dG9uLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Qcm9wc1tBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbi5uYW1lXS5rZXldID0gQ0tFRElUT1IudG9vbHMubWVyZ2UoYnV0dG9uQ2ZnW2J1dHRvbl0sIGJ1dHRvbi5jZmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGJ1dHRvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoe1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGJ1dHRvbi5rZXkgIT09ICdzZXBhcmF0b3InID8gYnV0dG9uLmtleSA6IGAke2J1dHRvbi5rZXl9LSR7aW5kZXh9YCxcbiAgICAgICAgICAgICAgICAgICAgdGFiS2V5OiBidXR0b24ua2V5LFxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogKHRoaXMucHJvcHMudHJpZ2dlciAmJiB0aGlzLnByb3BzLnRyaWdnZXIucHJvcHMudGFiS2V5ID09PSBidXR0b24ua2V5KSA/IDAgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogdGhpcy5wcm9wcy50cmlnZ2VyXG4gICAgICAgICAgICAgICAgfSwgYnV0dG9uLmtleSk7XG5cbiAgICAgICAgICAgICAgICBwcm9wcyA9IHRoaXMubWVyZ2VEcm9wZG93blByb3BzKHByb3BzLCBidXR0b24ua2V5KTtcblxuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYWRkaXRpb25hbFByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9wcyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHByb3BzLCBidXR0b25Qcm9wc1tidXR0b24ua2V5XSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChidXR0b24sIHByb3BzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0b29sYmFyQnV0dG9ucztcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBkaXNwbGF5aW5nIFdpZGdldCBBcnJvdyBib3ggb24gdG9wIG9yIG9uIGJvdHRvbSBvZiB0aGUgd2lkZ2V0XG4gKiBkZXBlbmRpbmcgb24gdGhlIHBvaW50IG9mIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRBcnJvd0JveFxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBhcnJvdyBib3ggY2xhc3NlcyBhc3NvY2lhdGVkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQncyBzdGF0ZS4gSXQgcmVsaWVzXG4gICAgICogb24gdGhlIGdldEludGVyYWN0aW9uUG9pbnQgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgc2VsZWN0aW9uIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRBcnJvd0JveFxuICAgICAqIEBtZXRob2QgZ2V0QXJyb3dCb3hDbGFzc2VzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB3aXRoIHRoZSBhcnJvdyBib3ggQ1NTIGNsYXNzZXMuXG4gICAgICovXG4gICAgZ2V0QXJyb3dCb3hDbGFzc2VzKCkge1xuICAgICAgICB2YXIgYXJyb3dCb3hDbGFzc2VzID0gJ2FlLWFycm93LWJveCc7XG5cbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmdldEludGVyYWN0aW9uUG9pbnQpICYmIHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KCkuZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSkge1xuICAgICAgICAgICAgICAgIGFycm93Qm94Q2xhc3NlcyArPSAnIGFlLWFycm93LWJveC10b3AnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJvd0JveENsYXNzZXMgKz0gJyBhZS1hcnJvdy1ib3gtYm90dG9tJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJvd0JveENsYXNzZXM7XG4gICAgfVxufTsiLCJpbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtYW5hZ2luZyBkaWZmZXJlbnQgZHJvcGRvd25zIGluc2lkZSBhIHdpZGdldC5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0RHJvcGRvd25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGRyb3Bkb3duVHJpZ2dlcjogbnVsbCxcbiAgICAgICAgICAgIGl0ZW1Ecm9wZG93bjogbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RHJvcGRvd25cbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRyb3Bkb3duVHJpZ2dlcjogbnVsbCxcbiAgICAgICAgICAgIGl0ZW1Ecm9wZG93bjogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHR3byBtb3JlIHByb3BlcnRpZXM6XG4gICAgICogLSBleHBhbmRlZCAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cbiAgICAgKiAtIHRvZ2dsZURyb3Bkb3duIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIHdpZGdldCBpbiBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG4gICAgICogQG1ldGhvZCBtZXJnZURyb3Bkb3duUHJvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcbiAgICAgKiAgICB0byBkcm9wZG93biBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggY29udGFpbnMgdGhlIGRyb3Bkb3duLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG4gICAgICovXG4gICAgbWVyZ2VEcm9wZG93blByb3BzKG9iaiwgaXRlbUtleSkge1xuICAgICAgICByZXR1cm4gQ0tFRElUT1IudG9vbHMubWVyZ2Uob2JqLCB7XG4gICAgICAgICAgICBleHBhbmRlZDogdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPT09IGl0ZW1LZXkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICB0YWJJbmRleDogdGhpcy5zdGF0ZS5kcm9wZG93blRyaWdnZXIgPT09IGl0ZW1LZXkgPyAwIDogLTEsXG4gICAgICAgICAgICB0b2dnbGVEcm9wZG93bjogdGhpcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMsIGl0ZW1LZXkpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBkcm9wZG93biBvZiB0aGUgd2lkZ2V0IG9yIGRpc2NhcmRzIHRoZSB0b2dnbGVkIGl0ZW0gZnJvbSB0aGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RHJvcGRvd25cbiAgICAgKiBAbWV0aG9kIHRvZ2dsZURyb3Bkb3duXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1Ecm9wZG93biBUaGUgd2lkZ2V0IHdoaWNoIHJlcXVlc3RzIHRvIHRvZ2dsZSBpdHMgZHJvcGRvd24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvZ2dsZURpcmVjdGlvbiBVc2VyIG1vdmVtZW50IGRpcmVjdGlvbiB3aGVuIHRvZ2dsZWQgdmlhIGtleWJvYXJkLlxuICAgICAqL1xuICAgIHRvZ2dsZURyb3Bkb3duKGl0ZW1Ecm9wZG93biwgdG9nZ2xlRGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZHJvcGRvd25UcmlnZ2VyOiBpdGVtRHJvcGRvd24sXG4gICAgICAgICAgICBpdGVtRHJvcGRvd246IGl0ZW1Ecm9wZG93biAhPT0gdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPyBpdGVtRHJvcGRvd24gOiBudWxsXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLml0ZW1Ecm9wZG93bikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdmVGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVGb2N1cyh0b2dnbGVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtYW5hZ2luZyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuICogVGhlIGV4Y2x1c2l2ZSBzdGF0ZSBtZWFucyB0aGF0IGEgYnV0dG9uIG1heSByZXF1ZXN0IHRvIGJlIHRoZSBvbmx5IHJlbmRlcmVkXG4gKiB3aWRnZXQgaW4gaXRzIHBhcmVudCBjb250YWluZXIuIFdpZGdldEV4Y2x1c2l2ZSB3aWxsIG1hbmFnZSB0aGlzIHN0YXRlIGJ5XG4gKiBmaWx0ZXJpbmcgYW5kIHN1cHByZXNzaW5nIHRoZSBvdGhlciBzaWJsaW5nIHdpZGdldHMgZnJvbSBkaXNwbGF5aW5nLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRFeGNsdXNpdmVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENhbmNlbHMgdGhlIGV4Y2x1c2l2ZSBzdGF0ZSBvZiBhbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG4gICAgICogQG1ldGhvZCBjYW5jZWxFeGNsdXNpdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbUV4Y2x1c2l2ZSBUaGUgd2lkZ2V0IHdoaWNoIGV4Y2x1c2l2ZSBzdGF0ZSBzaG91bGQgYmUgY2FuY2VsZWQuXG4gICAgICovXG4gICAgY2FuY2VsRXhjbHVzaXZlKGl0ZW1FeGNsdXNpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaXRlbUV4Y2x1c2l2ZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgKiBDYWxsaW5nIHRoaXMuc2V0U3RhdGUoKSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGFuIGFkZGl0aW9uYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXh0UHJvcHMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2V0IG9mIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjZWl2aW5nIHByb3BlcnRpZXMgbWVhbnMgdGhhdCB0aGUgY29tcG9uZW50IGlzIGJlaW5nIHJlLXJlbmRlcmVkLlxuICAgICAgICAvLyBSZS1yZW5kZXJpbmcgaXMgdHJpZ2dlcmVkIGJ5IGVkaXRvckludGVyYWN0aW9uLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIHJlc2V0IHRoZSBleGNsdXNpdmUgc3RhdGUgYW5kIHJlbmRlciB0aGUgVUkgYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2VsZWN0aW9uLlxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGl0ZW1FeGNsdXNpdmU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyB0aGUgaXRlbXMgYW5kIHJldHVybnMgb25seSB0aG9zZSB3aXRoIGV4Y2x1c2l2ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcbiAgICAgKiBAbWV0aG9kIGZpbHRlckV4Y2x1c2l2ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIFRoZSB3aWRnZXRzIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fE9iamVjdH0gVGhlIGl0ZW0gd2l0aCBleGVjdXRpdmUgc3RhdGUuXG4gICAgICovXG4gICAgZmlsdGVyRXhjbHVzaXZlKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUgPT09IGl0ZW0ua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBwcm92aWRlZCBvYmplY3Qgd2l0aCB0aHJlZSBtb3JlIHByb3BlcnRpZXM6XG4gICAgICogLSBjYW5jZWxFeGNsdXNpdmUgLSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYSB3aWRnZXQgaW4gb3JkZXIgdG8gY2FuY2VsIGV4ZWN1dGl2ZSBzdGF0ZS5cbiAgICAgKiAtIHJlbmRlckV4Y2x1c2l2ZSAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cbiAgICAgKiAtIHJlcXVlc3RFeGNsdXNpdmUgLSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYSB3aWRnZXQgaW4gb3JkZXIgdG8gb2J0YWluIGV4Y2x1c2l2ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcbiAgICAgKiBAbWV0aG9kIG1lcmdlRXhjbHVzaXZlUHJvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcbiAgICAgKiAgICB0byBleGNsdXNpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1LZXkgVGhleSBrZXkgb2YgYW4gUmVhY3QgV2lkZ2V0IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIG1lcmdlRXhjbHVzaXZlUHJvcHMob2JqLCBpdGVtS2V5KSB7XG4gICAgICAgIHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShvYmosIHtcbiAgICAgICAgICAgIGNhbmNlbEV4Y2x1c2l2ZTogdGhpcy5jYW5jZWxFeGNsdXNpdmUuYmluZCh0aGlzLCBpdGVtS2V5KSxcbiAgICAgICAgICAgIHJlbmRlckV4Y2x1c2l2ZTogKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUtleSksXG4gICAgICAgICAgICByZXF1ZXN0RXhjbHVzaXZlOiB0aGlzLnJlcXVlc3RFeGNsdXNpdmUuYmluZCh0aGlzLCBpdGVtS2V5KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhbmQgc2V0cyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuICAgICAqIEBtZXRob2QgcmVxdWVzdEV4Y2x1c2l2ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRXhjbHVzaXZlIFRoZSB3aWRnZXQgd2hpY2ggcmVxdWVzdHMgZXhjbHVzaXZlIHN0YXRlLlxuICAgICAqL1xuICAgIHJlcXVlc3RFeGNsdXNpdmUoaXRlbUV4Y2x1c2l2ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGl0ZW1FeGNsdXNpdmU6IGl0ZW1FeGNsdXNpdmVcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIERJUkVDVElPTl9OT05FID0gMDtcbnZhciBESVJFQ1RJT05fTkVYVCA9IDE7XG52YXIgRElSRUNUSU9OX1BSRVYgPSAtMTtcblxudmFyIEFDVElPTl9OT05FID0gMDtcbnZhciBBQ1RJT05fTU9WRV9GT0NVUyA9IDE7XG52YXIgQUNUSU9OX0RJU01JU1NfRk9DVVMgPSAyO1xuXG4vKipcbiAqIFdpZGdldEZvY3VzTWFuYWdlciBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMga2V5Ym9hcmQgbmF2aWdhdGlvbiBpbnNpZGUgYSB3aWRnZXQuIFRvIGRvIHRoaXMsXG4gKiBpdCBleHBvc2VzIHRoZSBmb2xsb3dpbmcgcHJvcHMgYW5kIG1ldGhvZHM6XG4gKlxuICogQGNsYXNzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50RGlkTW91bnQpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuICAgICAqIFJlZnJlc2hlcyB0aGUgZGVzY2VuZGFudHMgbGlzdC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnREaWRVcGRhdGUpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnREaWRVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBjdXJyZW50IGFjdGl2ZSBkZXNjZW5kYW50LlxuICAgICAqXG4gICAgICogU2V2ZXJhbCBXaWRnZXRzIGNhbiBiZSBuZXN0ZWQgaW4gYSBjb21wb25lbnQgaGllcmFyY2h5IGJ5IGF0dGFjaGluZyB0aGlzIGZvY3VzIG1ldGhvZCB0b1xuICAgICAqIHRoZSB3aWRnZXQgRE9NIG5vZGUsIHRyYW5zZmVycmluZyB0aGUgRE9NIGZvY3VzIGNvbnRyb2wgdG8gdGhlIGlubmVyIEZvY3VzTWFuYWdlci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIGZvY3VzXG4gICAgICovXG4gICAgZm9jdXMoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCB0aGlzLl9pc1ZhbGlkVGFyZ2V0KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZXNjZW5kYW50cyAmJiB0aGlzLl9kZXNjZW5kYW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlRGVzY2VuZGFudEVsID0gdGhpcy5fZGVzY2VuZGFudHNbdGhpcy5fYWN0aXZlRGVzY2VuZGFudF07XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIGNsaWNrcyB3aXRoIHRoZSBtb3VzZSwgdGhlIGFjdGl2ZUVsZW1lbnQgaXMgYWxyZWFkeSBzZXQgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgLy8gaXMgbm8gbmVlZCB0byBmb2N1cyBpdC4gRm9jdXNpbmcgb2YgdGhlIGFjdGl2ZSBkZXNjZW5kYW50ICh1c3VhbGx5IHNvbWUgYnV0dG9uKSBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYmVjYXVzZSB0aGUgZm9jdXNlZCBlbGVtZW50IG1pZ2h0IGJlIG5vdCB0aGUgZmlyc3QgYnV0dG9uLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgZGl2IGVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b24uXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZURlc2NlbmRhbnRFbCAmJiAhdGhpcy5wcm9wcy5mb2N1c0ZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rlc2NlbmRhbnRzLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVEZXNjZW5kYW50RWwuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBrZXkgZXZlbnRzIG9uIGEgRE9NIG5vZGUgdG8gZXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgbmF2aWdhdGlvbiB3aGVuIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50IHRoYXQgd2FzIGRldGVjdGVkIG9uIHRoZSB3aWRnZXQgRE9NIG5vZGUuXG4gICAgICogQG1ldGhvZCBoYW5kbGVLZXlcbiAgICAgKi9cbiAgICBoYW5kbGVLZXkoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSAmJiB0aGlzLl9kZXNjZW5kYW50cykge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuX2dldEZvY3VzQWN0aW9uKGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX01PVkVfRk9DVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZUZvY3VzKGFjdGlvbi5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX0RJU01JU1NfRk9DVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRpc21pc3MoYWN0aW9uLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIG1vdmVGb2N1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAoMSBvciAtMSkgb2YgdGhlIGZvY3VzIG1vdmVtZW50IGFtb25nIGRlc2NlbmRhbnRzLlxuICAgICAqL1xuICAgIG1vdmVGb2N1cyhkaXJlY3Rpb24pIHtcbiAgICAgICAgZGlyZWN0aW9uID0gTGFuZy5pc051bWJlcihkaXJlY3Rpb24pID8gZGlyZWN0aW9uIDogMDtcblxuICAgICAgICB0aGlzLl9tb3ZlRm9jdXMoZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3Rpb24sIGlmIGFueSwgdGhhdCBhIGtleWJvYXJkIGV2ZW50IGluIHRoZSBjdXJyZW50IGZvY3VzIG1hbmFnZXIgc3RhdGVcbiAgICAgKiBzaG91bGQgcHJvZHVjZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIF9nZXRGb2N1c0FjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gYWN0aW9uIG9iamVjdCB3aXRoIHR5cGUgYW5kIGRpcmVjdGlvbiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIF9nZXRGb2N1c0FjdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX05PTkVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5rZXlzKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uKGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgYWN0aW9uLnR5cGUgPSBBQ1RJT05fTU9WRV9GT0NVUztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc21pc3NBY3Rpb24gPSB0aGlzLl9nZXRGb2N1c0Rpc21pc3NBY3Rpb24oZXZlbnQsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChkaXNtaXNzQWN0aW9uLmRpc21pc3MpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24uZGlyZWN0aW9uID0gZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgYWN0aW9uLnR5cGUgPSBBQ1RJT05fRElTTUlTU19GT0NVUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzbWlzcyBhY3Rpb24sIGlmIGFueSwgdGhlIGZvY3VzIG1hbmFnZXIgc2hvdWxkIGV4ZWN1dGUgdG8geWllbGQgdGhlIGZvY3VzLiBUaGlzXG4gICAgICogd2lsbCBoYXBwZW4gaW4gYW55IG9mIHRoZXNlIHNjZW5hcmlvcyBpZiBhIGRpc21pc3MgY2FsbGJhY2sgaGFzIGJlZW4gc3BlY2lmaWVkOlxuICAgICAqIC0gQSBkaXNtaXNzIGtleSBoYXMgYmVlbiBwcmVzc2VkXG4gICAgICogLSBJbiBhIG5vbi1jaXJjdWxhciBmb2N1cyBtYW5hZ2VyLCB3aGVuOlxuICAgICAqICAgICAtIFRoZSBhY3RpdmUgZGVzY2VuZGFudCBpcyB0aGUgZmlyc3Qgb25lIGFuZCBhIHByZXYga2V5IGhhcyBiZWVuIHByZXNzZWQuXG4gICAgICogICAgIC0gVGhlIGFjdGl2ZSBkZXNjZW5kYW50IGlzIHRoZSBsYXN0IG9uZSBhbmQgYSBuZXh0IGtleSBoYXMgYmVlbiBwcmVzc2VkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuICAgICAqIEBtZXRob2QgX2dldEZvY3VzRGlzbWlzc0FjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb2N1c01vdmVEaXJlY3Rpb24gVGhlIGZvY3VzIG1vdmVtZW50IGRpcmVjdGlvbiAoaWYgYW55KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgZGlzbWlzcyBhY3Rpb24gd2l0aCBkaXNtaXNzIGFuZCBkaXJlY3Rpb24gcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBfZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uKGV2ZW50LCBmb2N1c01vdmVEaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGRpc21pc3NBY3Rpb24gPSB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IGZvY3VzTW92ZURpcmVjdGlvbixcbiAgICAgICAgICAgIGRpc21pc3M6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25EaXNtaXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzcykpIHtcbiAgICAgICAgICAgICAgICBkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3NOZXh0KSkge1xuICAgICAgICAgICAgICAgIGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fTkVYVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5kaXNtaXNzUHJldikpIHtcbiAgICAgICAgICAgICAgICBkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpc21pc3NBY3Rpb24uZGlyZWN0aW9uID0gRElSRUNUSU9OX1BSRVY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGlzbWlzc0FjdGlvbi5kaXNtaXNzICYmICF0aGlzLnByb3BzLmNpcmN1bGFyICYmIGZvY3VzTW92ZURpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IChcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNNb3ZlRGlyZWN0aW9uID09PSBESVJFQ1RJT05fUFJFViAmJiB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzTW92ZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OX05FWFQgJiYgdGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9PT0gdGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzbWlzc0FjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXJlY3Rpb24sIGlmIGFueSwgaW4gd2hpY2ggdGhlIGZvY3VzIHNob3VsZCBiZSBtb3ZlZC4gSW4gcHJlc2VuY2Ugb2YgdGhlXG4gICAgICogc2hpZnQga2V5IG1vZGlmaWVyLCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtb3ZlbWVudCBpcyBpbnZlcnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIF9nZXRGb2N1c01vdmVEaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCBkaXJlY3Rpb24gb2YgdGhlIGV4cGVjdGVkIGZvY3VzIG1vdmVtZW50LlxuICAgICAqL1xuICAgIF9nZXRGb2N1c01vdmVEaXJlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5uZXh0KSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRElSRUNUSU9OX05FWFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLnByZXYpKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT05fUFJFVjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5zaGlmS2V5KSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gKj0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGtleUNvZGUgaXMgdmFsaWQgZm9yIHRoZSBnaXZlbiBzZXQgb2Yga2V5cy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIF9pc1ZhbGlkS2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ9IGtleXMgQSBrZXkgc2V0LiBDYW4gYmUgYSBudW1iZXIgYW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGFsbG93ZWQga2V5Q29kZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGUgQW4gZXZlbnQga2V5Q29kZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGtleSBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBfaXNWYWxpZEtleShrZXlDb2RlLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBMYW5nLmlzQXJyYXkoa2V5cykgPyAoa2V5cy5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkgOiAoa2V5Q29kZSA9PT0ga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyB2YWxpZCBmb3IgZm9jdXMgbWFuYWdlbWVudC4gVXNlciBpbnB1dCBlbGVtZW50cyBzdWNoIGFzXG4gICAgICogaW5wdXQsIHNlbGVjdCBvciB0ZXh0YXJlYSBhcmUgZXhjbHVkZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfaXNWYWxpZEtleVxuICAgICAqIEBwYXJhbSB7RE9NTm9kZX0gZWxlbWVudCBBIERPTSBlbGVtZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgZWxlbWVudCBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBfaXNWYWxpZFRhcmdldChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuICh0YWdOYW1lICE9PSAnaW5wdXQnICYmIHRhZ05hbWUgIT09ICdzZWxlY3QnICYmIHRhZ05hbWUgIT09ICd0ZXh0YXJlYScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyBhbW9uZyBkZXNjZW5kYW50cyBpbiB0aGUgZXNwZWNpZmllZCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfbW92ZUZvY3VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uICgxIG9yIC0xKSBvZiB0aGUgZm9jdXMgbW92ZW1lbnQgYW1vbmcgZGVzY2VuZGFudHMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9tb3ZlRm9jdXMoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBudW1EZXNjZW5kYW50cyA9IHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aDtcblxuICAgICAgICB2YXIgZGVzY2VuZGFudCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuXG4gICAgICAgIGRlc2NlbmRhbnQuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIC0xKTtcblxuICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICs9IGRpcmVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5jaXJjdWxhcikge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByb3BlciBtb2R1bG8gcmVzdWx0IHNpbmNlIHJlbWFpbmRlciBvcGVyYXRvciBkb2Vzbid0IGJlaGF2ZSBpbiB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgd2F5IGZvciBuZWdhdGl2ZSBudW1iZXJzXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gKCh0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICUgbnVtRGVzY2VuZGFudHMpICsgbnVtRGVzY2VuZGFudHMpICUgbnVtRGVzY2VuZGFudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5fYWN0aXZlRGVzY2VuZGFudCwgbnVtRGVzY2VuZGFudHMgLSAxKSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjZW5kYW50ID0gdGhpcy5fZGVzY2VuZGFudHNbdGhpcy5fYWN0aXZlRGVzY2VuZGFudF07XG5cbiAgICAgICAgZGVzY2VuZGFudC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgMCk7XG4gICAgICAgIGRlc2NlbmRhbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGRlc2NlbmRhbnRzIGxpc3QgYnkgZXhlY3V0aW5nIHRoZSBDU1Mgc2VsZWN0b3IgYWdhaW4gYW5kIHJlc2V0cyB0aGUgZGVzY2VuZGFudHMgdGFiSW5kZXguXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfcmVmcmVzaFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuICAgICAgICBpZiAoZG9tTm9kZSkge1xuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMucHJvcHMuZGVzY2VuZGFudHMpO1xuXG4gICAgICAgICAgICB2YXIgcHJpb3JpdHlEZXNjZW5kYW50cyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW5kYW50cyA9IFtdO1xuXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkZXNjZW5kYW50cykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUYWJJbmRleCA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVRhYkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5RGVzY2VuZGFudHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNjZW5kYW50cy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHByaW9yaXR5RGVzY2VuZGFudHMgPSBwcmlvcml0eURlc2NlbmRhbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoTGFuZy50b0ludChhLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpKSA+IExhbmcudG9JbnQoYi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFiaW5kZXgnKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbmRhbnRzID0gcHJpb3JpdHlEZXNjZW5kYW50cy5jb25jYXQodGhpcy5fZGVzY2VuZGFudHMpO1xuXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fZGVzY2VuZGFudHMuc29tZShmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsImltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIHdoZXJlIGFuIFdpZGdldCBzaG91bGQgYmUgZGlzcGxheWVkIGJhc2VkIG9uIHRoZSBwb2ludFxuICogd2hlcmUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0UG9zaXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5XcmFwcGVkQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgZ3V0dGVyOiB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAxMFxuICAgICAgICB9LFxuICAgICAgICBjb25zdHJhaW5Ub1ZpZXdwb3J0OiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBzY2hlZHVsZWQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBjYW5jZWxBbmltYXRpb25cbiAgICAgKi9cbiAgICBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZUlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBpbiBwYWdlIGNvb3JkaW5hdGVzLFxuICAgICAqIHJlc3RyaWN0ZWQgdG8gZml0IHRvIGdpdmVuIHZpZXdwb3J0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBnZXRDb25zdHJhaW5lZFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgcHJvdmlkZWQgYXMgbnVtYmVyczpcbiAgICAgKiAtIGhlaWdodFxuICAgICAqIC0gbGVmdFxuICAgICAqIC0gdG9wXG4gICAgICogLSB3aWR0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3UGFuZVNpemUgT3B0aW9uYWwuIElmIG5vdCBwcm92aWRlZCwgdGhlIGN1cnJlbnQgdmlld3BvcnQgd2lsbCBiZSB1c2VkLiBTaG91bGQgY29udGFpbiBhdCBsZWFzdCB0aGVzZSBwcm9wZXJ0aWVzOlxuICAgICAqIC0gd2lkdGhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIHdoaWNoIHJlcHJlc2VudCB0aGUgY29uc3RyYWluZWQgcG9zaXRpb24gb2YgdGhlXG4gICAgICogZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRDb25zdHJhaW5lZFBvc2l0aW9uKGF0dHJzLCB2aWV3UGFuZVNpemUpIHtcbiAgICAgICAgdmlld1BhbmVTaXplID0gdmlld1BhbmVTaXplIHx8IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0Vmlld1BhbmVTaXplKCk7XG5cbiAgICAgICAgdmFyIHggPSBhdHRycy5sZWZ0O1xuICAgICAgICB2YXIgeSA9IGF0dHJzLnRvcDtcblxuICAgICAgICBpZiAoYXR0cnMubGVmdCArIGF0dHJzLndpZHRoID4gdmlld1BhbmVTaXplLndpZHRoKSB7XG4gICAgICAgICAgICB4IC09IChhdHRycy5sZWZ0ICsgYXR0cnMud2lkdGggLSB2aWV3UGFuZVNpemUud2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uLCBpbiBwYWdlIGNvb3JkaW5hdGVzLCBhY2NvcmRpbmcgdG8gd2hpY2ggYSB3aWRnZXQgc2hvdWxkIGFwcGVhci5cbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLCB0aGUgd2RpZ2V0IG1heSBhcHBlYXIgYWJvdmUgb2Ygb3Igb24gYm90dG9tIG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJdCBkZXBlbmRzIG9uIHRoZSBwcm9wcyBlZGl0b3JFdmVudCB0byBhbmFseXplIHRoZSBmb2xsb3dpbmcgdXNlci1pbnRlcmFjdGlvbiBwYXJhbWV0ZXJzOlxuICAgICAqIC0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbVxuICAgICAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogLSB7TnVtYmVyfSBwb3MgQ29udGFpbnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3NpdGlvbiwgY29uc2lkZXJlZCBhcyBtb3N0IGFwcHJvcHJpYXRlLlxuICAgICAqIFRoaXMgbWF5IGJlIHRoZSBwb2ludCB3aGVyZSB0aGUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIG9yIGp1c3QgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mXG4gICAgICogdGhlIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQG1ldGhvZCBnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBPYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIGRpcmVjdGlvbiwgeCwgeSwgd2hlcmUgeCBhbmQgeSBhcmUgaW4gcGFnZSBjb29yZGluYXRlcyBhbmQgZGlyZWN0aW9uIGNhbiBiZSBvbmUgb2YgdGhlc2U6XG4gICAgICogQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Agb3IgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cbiAgICAgKi9cbiAgICBnZXRJbnRlcmFjdGlvblBvaW50KCkge1xuICAgICAgICB2YXIgZXZlbnRQYXlsb2FkID0gdGhpcy5wcm9wcy5lZGl0b3JFdmVudCA/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YSA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFldmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3Rpb25EYXRhID0gZXZlbnRQYXlsb2FkLnNlbGVjdGlvbkRhdGE7XG5cbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnRQYXlsb2FkLm5hdGl2ZUV2ZW50O1xuXG4gICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgICB4OiBldmVudFBheWxvYWQubmF0aXZlRXZlbnQucGFnZVgsXG4gICAgICAgICAgICB5OiBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3BcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZGlyZWN0aW9uO1xuXG4gICAgICAgIHZhciBlbmRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZW5kUmVjdDtcblxuICAgICAgICB2YXIgc3RhcnRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uc3RhcnRSZWN0O1xuXG4gICAgICAgIGlmIChlbmRSZWN0ICYmIHN0YXJ0UmVjdCAmJiBzdGFydFJlY3QudG9wID09PSBlbmRSZWN0LnRvcCkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDtcbiAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgcG9pbnQgd2hlcmUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIHNob3cgVG9vbGJhciBhdCB0aGlzIHBvaW50XG4gICAgICAgIC8vIG90aGVyd2lzZSBzaG93IGl0IG9uIHRoZSBtaWRkbGUgb2YgdGhlIHNlbGVjdGlvbi5cblxuICAgICAgICBpZiAocG9zLnggJiYgcG9zLnkpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLl9nZXRYUG9pbnQoc2VsZWN0aW9uRGF0YSwgcG9zLngpO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbihwb3MueSwgc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHBvcy55LCB0aGlzLl9nZXRZUG9pbnQoc2VsZWN0aW9uRGF0YSwgbmF0aXZlRXZlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5sZWZ0ICsgc2VsZWN0aW9uRGF0YS5yZWdpb24ud2lkdGggLyAyO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSkge1xuXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuX2dldFlQb2ludChzZWxlY3Rpb25EYXRhLCBuYXRpdmVFdmVudCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIFdpZGdldC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQG1ldGhvZCBfZ2V0WFBvaW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50WCBUaGUgWCBjb29yZGluYXRlIHJlY2VpdmVkIGZyb20gdGhlIG5hdGl2ZSBldmVudCAobW91c2V1cCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgX2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBldmVudFgpIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gcmVnaW9uLnN0YXJ0UmVjdCA/IHJlZ2lvbi5zdGFydFJlY3QubGVmdCA6IHJlZ2lvbi5sZWZ0O1xuICAgICAgICB2YXIgcmlnaHQgPSByZWdpb24uZW5kUmVjdCA/IHJlZ2lvbi5lbmRSZWN0LnJpZ2h0IDogcmVnaW9uLnJpZ2h0O1xuXG4gICAgICAgIHZhciB4O1xuXG4gICAgICAgIGlmIChsZWZ0IDwgZXZlbnRYICYmIHJpZ2h0ID4gZXZlbnRYKSB7XG4gICAgICAgICAgICB4ID0gZXZlbnRYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlZnREaXN0ID0gTWF0aC5hYnMobGVmdCAtIGV2ZW50WCk7XG4gICAgICAgICAgICB2YXIgcmlnaHREaXN0ID0gTWF0aC5hYnMocmlnaHQgLSBldmVudFgpO1xuXG4gICAgICAgICAgICBpZiAobGVmdERpc3QgPCByaWdodERpc3QpIHsgLy8gdXNlciByYWlzZWQgdGhlIG1vdXNlIG9uIGxlZnQgb24gdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHggPSBsZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEludGVyYWN0aW9uUG9pbnRcbiAgICAgKiBAbWV0aG9kIF9nZXRZUG9pbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmF0aXZlRXZlbnQgVGhlIGRhdGEgYWJvdXQgZXZlbnQgaXMgZmlyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjYWxjdWxhdGVkIFkgcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBfZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gMDtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uRGF0YSAmJiBuYXRpdmVFdmVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRUYXJnZXQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobmF0aXZlRXZlbnQudGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRUYXJnZXQuJCAmJiBlbGVtZW50VGFyZ2V0LmdldFN0eWxlKCdvdmVyZmxvdycpID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB5ID0gbmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldFRvcCArIG5hdGl2ZUV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0IHRha2luZyBpbiBjb25zaWRlcmF0aW9uIHRoZVxuICAgICAqIHt7I2Nyb3NzTGluayBcIldpZGdldFBvc2l0aW9uL2d1dHRlcjphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX0gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgIGdldFdpZGdldFhZUG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBUaGUgbGVmdCBvZmZzZXQgaW4gcGFnZSBjb29yZGluYXRlcyB3aGVyZSBUb29sYmFyIHNob3VsZCBiZSBzaG93bi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRoZSB0b3Agb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIE1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgKiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCBvciBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aXRoIGxlZnQgYW5kIHRvcCBvZmZzZXRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0V2lkZ2V0WFlQb2ludChsZWZ0LCB0b3AsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIHZhciBndXR0ZXIgPSB0aGlzLnByb3BzLmd1dHRlcjtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSB8fCBkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCAtIGd1dHRlci5sZWZ0IC0gKGRvbU5vZGUub2Zmc2V0V2lkdGggLyAyKTtcblxuICAgICAgICAgICAgdG9wID0gKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pID8gKHRvcCArIGd1dHRlci50b3ApIDpcbiAgICAgICAgICAgICAgICAodG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLSBndXR0ZXIudG9wKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFQgfHxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1JJR0hUX1RPX0xFRlQpIHtcblxuICAgICAgICAgICAgbGVmdCA9IChkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9MRUZUX1RPX1JJR0hUKSA/XG4gICAgICAgICAgICAgICAgKGxlZnQgKyBndXR0ZXIubGVmdCArIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMikgOlxuICAgICAgICAgICAgICAgIChsZWZ0IC0gMyAqIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMiAtIGd1dHRlci5sZWZ0KTtcblxuICAgICAgICAgICAgdG9wID0gdG9wIC0gZ3V0dGVyLnRvcCAtIChkb21Ob2RlLm9mZnNldEhlaWdodCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCB0b3BdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBpc1Zpc2libGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNWaXNpYmxlKCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuaGFzQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSB3aWRnZXQgZnJvbSBhIHN0YXJ0aW5nIHBvaW50IHRvIGEgZGVzdGluYXRpb24gcG9pbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cbiAgICAgKiBAbWV0aG9kIG1vdmVUb1BvaW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzdGFydFBvaW50IFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIG1vdmVtZW50LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZW5kUG9pbnQgVGhlIGRlc3RpbmF0aW9uIHBvaW50IGZvciB0aGUgbW92ZW1lbnQuXG4gICAgICovXG4gICAgbW92ZVRvUG9pbnQoc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcbiAgICAgICAgdmFyIGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpO1xuXG4gICAgICAgIGRvbUVsZW1lbnQuc2V0U3R5bGVzKHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YXJ0UG9pbnRbMF0gKyAncHgnLFxuICAgICAgICAgICAgdG9wOiBzdGFydFBvaW50WzFdICsgJ3B4JyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWxsb3ktZWRpdG9yLWludmlzaWJsZScpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LmFkZENsYXNzKCdhZS10b29sYmFyLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG4gICAgICAgICAgICBkb21FbGVtZW50LnNldFN0eWxlcyh7XG4gICAgICAgICAgICAgICAgbGVmdDogZW5kUG9pbnRbMF0gKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcDogZW5kUG9pbnRbMV0gKyAncHgnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgd2lkZ2V0IHdpdGggdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cbiAgICAgKiBAbWV0aG9kIHNob3dcbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICB2YXIgdWlOb2RlID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCd1aU5vZGUnKTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdWlOb2RlID8gdWlOb2RlLnNjcm9sbFRvcCA6IDA7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSgpICYmIGRvbU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvblBvaW50ID0gdGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvblBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluYWxYLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbFksXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxYLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsWTtcblxuICAgICAgICAgICAgICAgIGZpbmFsWCA9IGluaXRpYWxYID0gcGFyc2VGbG9hdChkb21FbGVtZW50LmdldFN0eWxlKCdsZWZ0JykpO1xuICAgICAgICAgICAgICAgIGZpbmFsWSA9IGluaXRpYWxZID0gcGFyc2VGbG9hdChkb21FbGVtZW50LmdldFN0eWxlKCd0b3AnKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5jb25zdHJhaW5Ub1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmdldENvbnN0cmFpbmVkUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KGRvbU5vZGUub2Zmc2V0SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZpbmFsWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZmluYWxZLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlRmxvYXQoZG9tTm9kZS5vZmZzZXRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmluYWxYID0gcmVzLng7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsWSA9IHJlcy55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvblBvaW50LmRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFkgPSB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uLmJvdHRvbSArIHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsWSA9IHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wICsgc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvUG9pbnQoW2luaXRpYWxYLCBpbml0aWFsWV0sIFtmaW5hbFgsIGZpbmFsWV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgd2lkZ2V0IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGludGVyYWN0aW9uIHBvaW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCB1cGRhdGVQb3NpdGlvblxuICAgICAqL1xuICAgIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb25Qb2ludCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpO1xuXG4gICAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgICAgaWYgKGludGVyYWN0aW9uUG9pbnQgJiYgZG9tTm9kZSkge1xuICAgICAgICAgICAgdmFyIHVpTm9kZSA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgndWlOb2RlJykgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIHZhciB1aU5vZGVTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodWlOb2RlKTtcbiAgICAgICAgICAgIHZhciB1aU5vZGVNYXJnaW5MZWZ0ID0gcGFyc2VJbnQodWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSwgMTApO1xuICAgICAgICAgICAgdmFyIHVpTm9kZU1hcmdpblJpZ2h0ID0gcGFyc2VJbnQodWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JyksIDEwKTtcbiAgICAgICAgICAgIHZhciB0b3RhbFdpZHRoID0gdWlOb2RlTWFyZ2luTGVmdCArIHVpTm9kZS5jbGllbnRXaWR0aCArIHVpTm9kZU1hcmdpblJpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdWlOb2RlID8gdWlOb2RlLnNjcm9sbFRvcCA6IDA7XG5cbiAgICAgICAgICAgIHZhciB4eSA9IHRoaXMuZ2V0V2lkZ2V0WFlQb2ludChpbnRlcmFjdGlvblBvaW50LngsIGludGVyYWN0aW9uUG9pbnQueSwgaW50ZXJhY3Rpb25Qb2ludC5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgeHlbMV0gKz0gc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICBpZiAoeHlbMF0gPCAwKSB7XG4gICAgICAgICAgICAgICAgeHlbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHh5WzBdID4gdG90YWxXaWR0aCAtIGRvbU5vZGUub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4eVswXSA9IHRvdGFsV2lkdGggLSBkb21Ob2RlLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkuc2V0U3R5bGVzKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB4eVswXSArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wOiB4eVsxXSArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYW4gYW5pbWF0aW9uIGZyYW1lLCBpZiBwb3NzaWJsZSwgdG8gc2ltdWxhdGUgYW4gYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBfYW5pbWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2NoZWR1bGVkIGZyYW1lLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYW5pbWF0ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Cb2xkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHN0eWxpbmcgYW4gc2VsZWN0aW9uIHdpdGggc3Ryb25nIChib2xkKSBzdHlsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQm9sZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkJvbGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5ib2xkfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1ib2xkXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYm9sZH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1ib2xkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJvbGRcbiAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkJvbGQua2V5ID0gJ2JvbGQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkJvbGRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkJvbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdib2xkJyxcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdleGVjQ29tbWFuZCcsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA2NiAvKkIqL1xuICAgIH0sXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX2JvbGQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbktleXN0cm9rZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbkJvbGRcbikpKSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNhbWVyYUltYWdlIGNsYXNzIHRha2VzIHBob3RvIGZyb20gY2FtZXJhIGFuZCBpbnNlcnRzIGl0IHRvIHRoZSBjb250ZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25DYW1lcmFJbWFnZVxuICovXG5jbGFzcyBCdXR0b25DYW1lcmFJbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgdGhlIHRha2UgcGhvdG8gYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzLnJlZnMuYnV0dG9uVGFrZVBob3RvKS5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLnN0b3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBnZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWE7XG5cbiAgICAgICAgZ2V0VXNlck1lZGlhLmNhbGwobmF2aWdhdG9yLCB7XG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICB9LCB0aGlzLl9oYW5kbGVTdHJlYW1TdWNjZXNzLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVN0cmVhbUVycm9yLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNhbWVyYVwiPlxuICAgICAgICAgICAgICAgIDx2aWRlbyByZWY9XCJ2aWRlb0NvbnRhaW5lclwiPlZpZGVvIHN0cmVhbSBub3QgYXZhaWxhYmxlLjwvdmlkZW8+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJhZS1jYW1lcmEtc2hvb3RcIiBvbkNsaWNrPXt0aGlzLnRha2VQaG90by5iaW5kKHRoaXMpfSByZWY9XCJidXR0b25UYWtlUGhvdG9cIj5UYWtlIHBob3RvPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGNhbnZhcyBjbGFzc05hbWU9XCJhZS1jYW1lcmEtY2FudmFzXCIgcmVmPVwiY2FudmFzQ29udGFpbmVyXCI+PC9jYW52YXM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBwaG90byBmcm9tIHRoZSB2aWRlbyBzdHJlYW0gYW5kIGluc2VydHMgaW4gaW50byBlZGl0b3IncyBjb250ZW50LlxuICAgICAqXG4gICAgICogQGZpcmVzIEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCB0YWtlUGhvdG9cbiAgICAgKi9cbiAgICB0YWtlUGhvdG8oKSB7XG4gICAgICAgIHZhciB2aWRlb0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLnZpZGVvQ29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl92aWRlb0hlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5wcm9wcy52aWRlb1dpZHRoO1xuXG4gICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgICAgIGNhbnZhc0VsLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvRWwsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgaW1nVVJMID0gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblxuICAgICAgICAgICAgdmFyIGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoJzxpbWcgc3JjPVwiJyArIGltZ1VSTCArICdcIj4nKTtcblxuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnaW1hZ2VDYW1lcmFBZGQnLCBlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdmlkZW8gc3RyZWFtIGNhcHR1cmluZyBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCBfaGFuZGxlU3RyZWFtRXJyb3JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlcnJvciBUaGUgZmlyZWQgZXZlbnQgaW4gY2FzZSBvZiBlcnJvci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmVhbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHdpbmRvdy5hbGVydCgnQW4gZXJyb3Igb2NjdXJyZWQhICcgKyBlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHN0cmVhbWluZyB2aWRlbyBpbiB0aGUgdmlkZW8gZWxlbWVudCBhbmQgc2V0cyB3aWR0aC9oZWlnaHQgdG8gdGhlIHZpZGVvXG4gICAgICogYW5kIGNhbnZhcyBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICAgICAqIEBtZXRob2QgX2hhbmRsZVN0cmVhbVN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtIFRoZSB2aWRlbyBzdHJlYW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmVhbVN1Y2Nlc3Moc3RyZWFtKSB7XG4gICAgICAgIHZhciB2aWRlb0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLnZpZGVvQ29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB2aWRlb0VsLnZpZGVvSGVpZ2h0IC8gKHZpZGVvRWwudmlkZW9XaWR0aC90aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucHJvcHMudmlkZW9XaWR0aCAvICg0LzMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWRlb0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuICAgICAgICAgICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgICAgICBjYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5wcm9wcy52aWRlb1dpZHRoKTtcbiAgICAgICAgICAgIGNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcblxuICAgICAgICAgICAgdGhpcy5fdmlkZW9IZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcblxuICAgICAgICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgICAgICAgICAgdmlkZW9FbC5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb0VsLnNyYyA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlkZW9FbC5wbGF5KCk7XG5cbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmJ1dHRvblRha2VQaG90bykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIHRha2VuIGZyb20gdGhlIGNhbWVyYSBhbmQgYWRkZWQgYXMgYW4gZWxlbWVudCB0byB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGV2ZW50IEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnQgaW4gZWRpdG9yLlxuICAgICAqL1xufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGNhbWVyYUltYWdlXG4gKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uQ2FtZXJhSW1hZ2Uua2V5ID0gJ2NhbWVyYUltYWdlJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uQ2FtZXJhSW1hZ2UuZGVmYXVsdFByb3BzID0ge1xuICAgIHZpZGVvV2lkdGg6IDMyMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2FtZXJhSW1hZ2U7XG4iLCJpbXBvcnQgQnV0dG9uQ2FtZXJhSW1hZ2UgZnJvbSAnLi9idXR0b24tY2FtZXJhLWltYWdlLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25DYW1lcmEgY2xhc3MgcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IHdheXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGUuXG4gKiAtIEV4Y2x1c2l2ZTogUmVuZGVycyBCdXR0b25DYW1lcmFJbWFnZSBpbiBvcmRlciB0byB0YWtlIHBob3RvIGZyb20gdGhlIGNhbWVyYS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ2FtZXJhXG4gKi9cbmNsYXNzIEJ1dHRvbkNhbWVyYSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJ1dHRvbkNhbWVyYUltYWdlIHsuLi50aGlzLnByb3BzfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9ICEobmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fFxuICAgICAgICAgICAgICAgIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhICYmIGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWEpO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkaXNhYmxlZCA/IEFsbG95RWRpdG9yLlN0cmluZ3MuY2FtZXJhRGlzYWJsZWQgOiBBbGxveUVkaXRvci5TdHJpbmdzLmNhbWVyYTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e2xhYmVsfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24taW1hZ2UtY2FtZXJhXCIgZGlzYWJsZWQ9e2Rpc2FibGVkfSBvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUuYmluZChCdXR0b25DYW1lcmEua2V5KX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtsYWJlbH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tY2FtZXJhXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBjYW1lcmFcbiAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uQ2FtZXJhLmtleSA9ICdjYW1lcmEnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25DYW1lcmE7XG4iLCJpbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQ29kZSBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgcHJlYCBlbGVtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db2RlXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25Db2RlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29kZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tY29kZVwiIG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZS5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1jb2RlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGNvZGVcbiAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkNvZGUua2V5ID0gJ2NvZGUnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkNvZGVcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkNvZGUuZGVmYXVsdFByb3BzID0ge1xuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICdwcmUnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25Db2RlXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3MgaXMgYSBVSSBjbGFzcyB0aGF0IHJlbmRlcnMgYSBCdXR0b25Db21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlXG4gKiBhIGxpc3QgYXMgYW4gaXRlbSwgd2l0aCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYmVoYXZpb3VyLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZExpc3RJdGVtXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuZGVzY3JpcHRpb259IGNsYXNzTmFtZT17dGhpcy5fZ2V0Q2xhc3NOYW1lKCl9IG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9Pnt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufTwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWUgb2YgV2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuICAgICAqIEBtZXRob2QgX2dldENsYXNzTmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBXaWRnZXQuXG4gICAgICovXG4gICAgX2dldENsYXNzTmFtZSgpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdhZS1jb250YWluZXIgYWUtdG9vbGJhci1lbGVtZW50JztcblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBidXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uQ29tbWFuZExpc3RJdGVtLmtleSA9ICdidXR0b25Db21tYW5kTGlzdEl0ZW0nO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGZyb20gJy4vYnV0dG9uLWNvbW1hbmQtbGlzdC1pdGVtLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kc0xpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBhIGxpc3Qgb2YgY29tbWFuZHMgdGhhdCBjYW4gYmVcbiAqIGV4ZWN1dGVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4uXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvbkNvbW1hbmRzTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgb24gdGhlIGxpc3Qgbm9kZSB0byBhbGxvdyBrZXlib2FyZCBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3RcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtZHJvcGRvd24gYWUtYXJyb3ctYm94IGFlLWFycm93LWJveC10b3AtbGVmdFwiIG9uRm9jdXM9e3RoaXMuZm9jdXMuYmluZCh0aGlzKX0gb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpfSB0YWJJbmRleD1cIjBcIj5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwiYWUtbGlzdGJveFwiIGlkPXt0aGlzLnByb3BzLmxpc3RJZH0gcm9sZT1cImxpc3Rib3hcIj5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMuX3JlbmRlckFjdGlvbnModGhpcy5wcm9wcy5jb21tYW5kcyl9XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgaW5zdGFuY2VzIG9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSB3aXRoIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcm93IGFjdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG4gICAgICogQG1ldGhvZCBfcmVuZGVyQWN0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmVuZGVyZWQgaW5zdGFuY2VzIG9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSBjbGFzc1xuICAgICAqL1xuICAgIF9yZW5kZXJBY3Rpb25zKGNvbW1hbmRzKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICAgICAgdmFyIGl0ZW1zO1xuXG4gICAgICAgIGlmIChjb21tYW5kcyAmJiBjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gY29tbWFuZHMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtpdGVtLmNvbW1hbmR9IHJvbGU9XCJvcHRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25Db21tYW5kTGlzdEl0ZW0gY29tbWFuZD17aXRlbS5jb21tYW5kfSBkZXNjcmlwdGlvbj17dHlwZW9mIGl0ZW0ubGFiZWwgPT09ICdzdHJpbmcnID8gaXRlbS5sYWJlbCA6IGl0ZW0ubGFiZWwoKX0gaWNvbj17aXRlbS5pY29ufSBlZGl0b3I9e2VkaXRvcn0gLz5cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25Db21tYW5kc0xpc3Qua2V5ID0gJ2J1dHRvbkNvbW1hbmRzTGlzdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25Db21tYW5kc0xpc3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvbkNvbW1hbmRzTGlzdFxuKTsiLCJpbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRHJvcGRvd24gY2xhc3MgcHJvdmlkZXMgbWFya3VwIGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uIGJlaGF2aW91ciB0byBhIGRyb3Bkb3duXG4gKiBvcGVuZWQgZnJvbSBhIGJ1dHRvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRHJvcGRvd25cbiAqL1xuY2xhc3MgQnV0dG9uRHJvcGRvd24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1kcm9wZG93biBhZS1hcnJvdy1ib3ggYWUtYXJyb3ctYm94LXRvcC1sZWZ0XCIgb25Gb2N1cz17dGhpcy5mb2N1cy5iaW5kKHRoaXMpfSBvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9IHRhYkluZGV4PVwiMFwiPlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJhZS1saXN0Ym94XCIgcm9sZT1cImxpc3Rib3hcIj5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGRyb3Bkb3duIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGRyb3Bkb3duXG4gKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uRHJvcGRvd24ua2V5ID0gJ2Ryb3Bkb3duJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uRHJvcGRvd24uZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvbkRyb3Bkb3duXG4pOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIEtFWV9FTlRFUiA9IDEzO1xudmFyIEtFWV9FU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRW1iZWRFZGl0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGFuIGVtYmVkIGxpbmsgaW4gYSBkb2N1bWVudC5cbiAqIFByb3ZpZGVzIFVJIGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhbiBlbWJlZCBsaW5rLlxuICpcbiAqIEBjbGFzcyBCdXR0b25FbWJlZEVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uRW1iZWRFZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5saW5rSW5wdXQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGNvbXBvbmVudFxuICAgICAqIGlzIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIHByZXZlbnQgYWdncmVzc2l2ZSBmb2N1cyBzdGVhbGluZy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSB8fCB0aGlzLnByb3BzLm1hbnVhbFNlbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYmVmb3JlIGZvY3VzaW5nIHRvIGF2b2lkIHVuZGVzaXJlZFxuICAgICAgICAgICAgLy8gc2Nyb2xscyBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2ZvY3VzTGlua0lucHV0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2ZvY3VzTGlua0lucHV0LmJpbmQodGhpcyksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmdldEluaXRpYWxTdGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoaXMuc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBnZXRJbml0aWFsU3RhdGVcbiAgICAgKi9cbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgZW1iZWQ7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZW1iZWQgPSBzZWxlY3RlZEVsZW1lbnQuZmluZE9uZSgnW2RhdGEtd2lkZ2V0PVwiYWVfZW1iZWRcIl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBocmVmID0gZW1iZWQgPyBlbWJlZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWUtZW1iZWQtdXJsJykgOiAnJztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudDogZW1iZWQsXG4gICAgICAgICAgICBpbml0aWFsTGluazoge1xuICAgICAgICAgICAgICAgIGhyZWY6IGhyZWZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rSHJlZjogaHJlZlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNsZWFyTGlua1N0eWxlID0ge1xuICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGF0ZS5saW5rSHJlZiA/IDEgOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGlua1wiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVFbWJlZH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGF0YS10eXBlPVwiYnV0dG9uLWVtYmVkLXJlbW92ZVwiIGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lbGVtZW50fSBvbkNsaWNrPXt0aGlzLl9yZW1vdmVFbWJlZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlRW1iZWR9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWJpblwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1pbnB1dCB4eGxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT1cImFlLWlucHV0XCIgb25DaGFuZ2U9e3RoaXMuX2hhbmRsZUxpbmtIcmVmQ2hhbmdlLmJpbmQodGhpcyl9IG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpfSBwbGFjZWhvbGRlcj17QWxsb3lFZGl0b3IuU3RyaW5ncy5lZGl0TGlua30gcmVmPXt0aGlzLmxpbmtJbnB1dH0gdHlwZT1cInRleHRcIiB2YWx1ZT17dGhpcy5zdGF0ZS5saW5rSHJlZn0+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1pY29uLXJlbW92ZVwiIG9uQ2xpY2s9e3RoaXMuX2NsZWFyTGluay5iaW5kKHRoaXMpfSBzdHlsZT17Y2xlYXJMaW5rU3R5bGV9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFyfT48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGlzYWJsZWQ9eyF0aGlzLl9pc1ZhbGlkU3RhdGUoKX0gb25DbGljaz17dGhpcy5fZW1iZWRMaW5rLmJpbmQodGhpcyl9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLW9rXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBsaW5rIGlucHV0LiBUaGlzIG9ubHkgY2hhbmdlcyB0aGUgY29tcG9uZW50IGludGVybmFsIHN0YXRlLCBidXQgZG9lcyBub3RcbiAgICAgKiBhZmZlY3QgdGhlIGxpbmsgZWxlbWVudCBvZiB0aGUgZWRpdG9yLiBPbmx5IHRoZSBfcmVtb3ZlTGluayBhbmQgX3VwZGF0ZUxpbmsgbWV0aG9kc1xuICAgICAqIGFyZSB0cmFuc2xhdGVkIHRvIHRoZSBlZGl0b3IgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIF9jbGVhckxpbmtcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NsZWFyTGluaygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsaW5rSHJlZjogJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgdGhlIGVtYmVkVXJsIGNvbW1hbmQgdG8gdHJhbnNmb3JtIHRoZSBsaW5rIGludG8gYW4gZW1iZWQgbWVkaWEgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBfZW1iZWRMaW5rXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9lbWJlZExpbmsoKSB7XG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIG5hdGl2ZUVkaXRvci5leGVjQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuc3RhdGUubGlua0hyZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuICAgICAgICAvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG4gICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX2ZvY3VzTGlua0lucHV0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9mb2N1c0xpbmtJbnB1dCgpIHtcbiAgICAgICAgdGhpcy5saW5rSW5wdXQuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcbiAgICAgKiAtIEVudGVyOiBDcmVhdGVzL3VwZGF0ZXMgdGhlIGxpbmsuXG4gICAgICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX2hhbmRsZUtleURvd25cbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtYmVkTGluaygpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG4gICAgICAgICAgICAvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayBpbnB1dCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlTGlua0hyZWZDaGFuZ2VcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFuZGxlTGlua0hyZWZDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsaW5rSHJlZjogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgbGluayBzdGF0ZSBpcyB2YWxpZCBzbyB0aGUgdXNlciBjYW4gc2F2ZSB0aGUgbGluay4gQSB2YWxpZCBzdGF0ZVxuICAgICAqIG1lYW5zIHRoYXQgd2UgaGF2ZSBhIG5vbi1lbXB0eSBocmVmIHRoYXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgb25lLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX2lzVmFsaWRTdGF0ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzdGF0ZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgX2lzVmFsaWRTdGF0ZSgpIHtcbiAgICAgICAgdmFyIHZhbGlkU3RhdGUgPVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5saW5rSHJlZiAmJiAoXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5saW5rSHJlZiAhPT0gdGhpcy5zdGF0ZS5pbml0aWFsTGluay5ocmVmXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB2YWxpZFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGVtYmVkIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIF9yZW1vdmVFbWJlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlRW1iZWQoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIHZhciBlbWJlZFdyYXBwZXIgPSB0aGlzLnN0YXRlLmVsZW1lbnQuZ2V0QXNjZW5kYW50KGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0NsYXNzKCdja2Vfd2lkZ2V0X3dyYXBwZXInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1iZWRXcmFwcGVyLnJlbW92ZSgpO1xuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgZW1iZWRFZGl0XG4gKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkVtYmVkRWRpdC5rZXkgPSAnZW1iZWRFZGl0JztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uRW1iZWRFZGl0O1xuIiwiaW1wb3J0IEJ1dHRvbkVtYmVkRWRpdCBmcm9tICcuL2J1dHRvbi1lbWJlZC1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25FbWJlZCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhbiBlbWJlZCBsaW5rIGluIGEgZG9jdW1lbnQuXG4gKiBCdXR0b25FbWJlZCByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgbW9kZXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGVcbiAqIC0gRXhjbHVzaXZlOiBUaGUgQnV0dG9uRW1iZWRFZGl0IFVJIHdpdGggYWxsIHRoZSBsaW5rIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkVtYmVkXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqL1xuY2xhc3MgQnV0dG9uRW1iZWQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJ1dHRvbkVtYmVkRWRpdCB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24tZW1iZWRcIiBvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hZGRcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdGhlIGxpbmsgYnV0dG9uIHRvIGJlIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIGFsbG93IHRoZSBlbWJlZGRpbmcgb2YgYSBsaW5rLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG4gICAgICogQG1ldGhvZCBfcmVxdWVzdEV4Y2x1c2l2ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVxdWVzdEV4Y2x1c2l2ZSgpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkVtYmVkLmtleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGVtYmVkXG4gKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uRW1iZWQgLmtleSA9ICdlbWJlZCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkVtYmVkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyBDS0VESVRPUi5TSElGVCArIDc2IC8qTCovXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uS2V5c3Ryb2tlKFxuICAgIEJ1dHRvbkVtYmVkXG4pOyIsImltcG9ydCBCdXR0b25BY3Rpb25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IMSBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgaDFgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkgxXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25IMSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkgxXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5oMX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24taDFcIiBvbkNsaWNrPXt0aGlzLmFwcGx5U3R5bGUuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmgxfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWgxXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGgxXG4gKiBAbWVtYmVyb2YgQnV0dG9uSDFcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSDEua2V5ID0gJ2gxJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25IMVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSDEuZGVmYXVsdFByb3BzID0ge1xuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICdoMSdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbkgxXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkgyIGNsYXNzIHByb3ZpZGVzIHdyYXBzIGEgc2VsZWN0aW9uIGluIGBoMmAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSDJcbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkgyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSDJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmgyfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1oMlwiIG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZS5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDJ9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24taDJcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaDJcbiAqIEBtZW1iZXJvZiBCdXR0b25IMlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25IMi5rZXkgPSAnaDInO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkgyXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25IMi5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgICAgZWxlbWVudDogJ2gyJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uSDJcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IbGluZSBjbGFzcyBwcm92aWRlcyBpbnNlcnRzIGhvcml6b250YWwgbGluZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSGxpbmVcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkhsaW5lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5ob3Jpem9udGFscnVsZX0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGF0YS10eXBlPVwiYnV0dG9uLWhsaW5lXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaG9yaXpvbnRhbHJ1bGV9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tc2VwYXJhdG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGhsaW5lXG4gKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSGxpbmUua2V5ID0gJ2hsaW5lJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25IbGluZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSGxpbmUuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdob3Jpem9udGFscnVsZScsXG4gICAgc3R5bGU6IHtcbiAgICAgICAgZWxlbWVudDogJ2hyJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbkhsaW5lXG4pKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGFuIGltYWdlIGluIHRoZSBjZW50ZXIuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlclwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduQ2VudGVyfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLWNlbnRlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpbWFnZUNlbnRlclxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSW1hZ2VBbGlnbkNlbnRlci5rZXkgPSAnaW1hZ2VDZW50ZXInO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkltYWdlQWxpZ25DZW50ZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdqdXN0aWZ5Y2VudGVyJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25MZWZ0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGFuIGltYWdlIG9uIGxlZnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnbkxlZnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduTGVmdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLWxlZnRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW1hZ2VMZWZ0XG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSW1hZ2VBbGlnbkxlZnQua2V5ID0gJ2ltYWdlTGVmdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkltYWdlQWxpZ25MZWZ0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeWxlZnQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRBY3RpdmUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgICAgICBCdXR0b25JbWFnZUFsaWduTGVmdFxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25SaWdodCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhbiBpbWFnZSBvbiByaWdodC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1hbGlnbi1yaWdodFwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tcmlnaHRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW1hZ2VSaWdodFxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JbWFnZUFsaWduUmlnaHQua2V5ID0gJ2ltYWdlUmlnaHQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSW1hZ2VBbGlnblJpZ2h0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeXJpZ2h0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4pKSk7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZSBjbGFzcyBpbnNlcnRzIGFuIGltYWdlIHRvIHRoZSBjb250ZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbWFnZVxuICovXG5jbGFzcyBCdXR0b25JbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmZpbGVJbnB1dCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgaW5wdXRTeWxlID0ge2Rpc3BsYXk6ICdub25lJ307XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmltYWdlfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24taW1hZ2VcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24taW1hZ2VcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICAgICAgICA8aW5wdXQgYWNjZXB0PVwiaW1hZ2UvKlwiIG9uQ2hhbmdlPXt0aGlzLl9vbklucHV0Q2hhbmdlLmJpbmQodGhpcyl9IHJlZj17dGhpcy5maWxlSW5wdXR9IHN0eWxlPXtpbnB1dFN5bGV9IHR5cGU9XCJmaWxlXCIvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltdWxhdGVzIGNsaWNrIG9uIHRoZSBpbnB1dCBlbGVtZW50LiBUaGlzIHdpbGwgb3BlbiBicm93c2VyJ3MgbmF0aXZlIGZpbGUgb3BlbiBkaWFsb2cuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VcbiAgICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIHJlY2VpdmVkIGNsaWNrIGV2ZW50IG9uIHRoZSBidXR0b24uXG4gICAgICovXG4gICAgaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuZmlsZUlucHV0LmN1cnJlbnQuY2xpY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbiBpbnB1dCBjaGFuZ2UsIHJlYWRzIHRoZSBjaG9zZW4gZmlsZSBhbmQgZmlyZXMgYW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aXRoIHRoZSBpbWFnZSB3aGljaCB3aWxsIGJlIGFkZGVkXG4gICAgICogdG8gdGhlIGNvbnRlbnQuIFRoZSBpbWFnZSBmaWxlIHdpbGwgYmUgcGFzc2VkIGluIHRoZSBgaW1hZ2VGaWxlc2AgcHJvcGVydHkuXG4gICAgICogSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnMgcmV0dXJucyBgZmFsc2VgIG9yIGNhbmNlbHMgdGhlIGV2ZW50LCB0aGUgaW1hZ2Ugd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGNvbnRlbnQuXG4gICAgICogT3RoZXJ3aXNlLCBhbiBldmVudCBgaW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgaW5zZXJ0ZWQgZWxlbWVudCBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLlxuICAgICAqIFRoZSBwYXNzZWQgcGFyYW1zIHdpbGwgYmU6XG4gICAgICogLSBgZWxgIC0gdGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnRcbiAgICAgKiAtIGBmaWxlYCAtIHRoZSBvcmlnaW5hbCBpbWFnZSBmaWxlIGZyb20gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBmaXJlcyBCdXR0b25JbWFnZSNiZWZvcmVJbWFnZUFkZFxuICAgICAqIEBmaXJlcyBCdXR0b25JbWFnZSNpbWFnZUFkZFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuICAgICAqIEBtZXRob2QgX29uSW5wdXRDaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX29uSW5wdXRDaGFuZ2UoKSB7XG4gICAgICAgIHZhciBpbnB1dEVsID0gdGhpcy5maWxlSW5wdXQuY3VycmVudDtcblxuICAgICAgICAvLyBPbiBJRTExIHRoZSBmdW5jdGlvbiBtaWdodCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhcnJheSBvZlxuICAgICAgICAvLyBmaWxlcy4gSW4gc3VjaCBhIGNhc2UsIG5vIGFjdGlvbnMgd2lsbCBiZSB0YWtlbi5cbiAgICAgICAgaWYgKCFpbnB1dEVsLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHZhciBmaWxlID0gaW5wdXRFbC5maWxlc1swXTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZWRpdG9yLmZpcmUoJ2JlZm9yZUltYWdlQWRkJywge1xuICAgICAgICAgICAgICAgIGltYWdlRmlsZXM6IGZpbGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoISFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbCgnPGltZyBzcmM9XCInICsgZXZlbnQudGFyZ2V0LnJlc3VsdCArICdcIj4nKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZVxuICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblxuICAgICAgICBpbnB1dEVsLnZhbHVlID0gJyc7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGltYWdlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSW1hZ2Uua2V5ID0gJ2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uSW1hZ2U7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbmRlbnRCbG9jayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBpbmRlbnRpbmcgdGhlIHNlbGVjdGVkIGJsb2Nrcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW5kZW50QmxvY2tcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbmRlbnRCbG9jayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkluZGVudEJsb2NrXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbmRlbnR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWluZGVudC1ibG9ja1wiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmluZGVudH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1pbmRlbnQtYmxvY2tcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW5kZW50QmxvY2tcbiAqIEBtZW1iZXJvZiBCdXR0b25JbmRlbnRCbG9ja1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JbmRlbnRCbG9jay5rZXkgPSAnaW5kZW50QmxvY2snO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkluZGVudEJsb2NrXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25JbmRlbnRCbG9jay5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2luZGVudCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvbkluZGVudEJsb2NrXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkl0YWxpYyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHlsaW5nIGFuIHNlbGVjdGlvbiB3aXRoIGl0YWxpYyAoZW0pIHN0eWxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25JdGFsaWNcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25JdGFsaWMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JdGFsaWNcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLml0YWxpY30gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24taXRhbGljXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaXRhbGljfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWl0YWxpY1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpdGFsaWNcbiAqIEBtZW1iZXJvZiBCdXR0b25JdGFsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSXRhbGljLmtleSA9ICdpdGFsaWMnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSXRhbGljLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnaXRhbGljJyxcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdleGVjQ29tbWFuZCcsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA3MyAvKkkqL1xuICAgIH0sXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX2l0YWxpYydcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uS2V5c3Ryb2tlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uSXRhbGljXG4pKSkpOyIsImltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHNob3dpbmcgYSBsaXN0IG9mXG4gKiBpdGVtcyB0aGF0IGNhbiBiZSBzZWxlY3RlZCBmb3IgdGhlIGxpbmsuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoIW5leHRQcm9wcy50ZXJtIHx8IG5leHRQcm9wcy50ZXJtICE9PSB0aGlzLnByb3BzLnRlcm0pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcblxuICAgICAgICAgICAgaWYgKG5leHRQcm9wcy50ZXJtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fdXBkYXRlSXRlbXMsIHRoaXMucHJvcHMuZGVsYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3BzLmF1dG9jb21wbGV0ZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZm9jdXMsIDApO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXRBdXRvY29tcGxldGVTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmV4cGFuZGVkIHx8ICF0aGlzLnN0YXRlLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJ1dHRvbkRyb3Bkb3duPlxuICAgICAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJBdXRvY29tcGxldGVJdGVtcyh0aGlzLnN0YXRlLml0ZW1zKX1cbiAgICAgICAgICAgIDwvQnV0dG9uRHJvcGRvd24+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGJlZm9yZSByZW5kZXJpbmcgd2hlbiBuZXcgcHJvcHMgb3Igc3RhdGUgYXJlIGJlaW5nIHJlY2VpdmVkLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlciBvciB3aGVuIGZvcmNlVXBkYXRlIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kICBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcyBhbmQgc3RhdGUgd2lsbCBub3RcbiAgICAgKiByZXF1aXJlIGEgY29tcG9uZW50IHVwZGF0ZS5cbiAgICAgKi9cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQcm9wcy5leHBhbmRlZCAhPT0gdGhpcy5wcm9wcy5leHBhbmRlZCB8fCBuZXh0UHJvcHMudGVybSAhPT0gdGhpcy5wcm9wcy50ZXJtIHx8IG5leHRTdGF0ZS5pdGVtcyAhPT0gdGhpcy5zdGF0ZS5pdGVtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc2V0IG9mIGxpc3QgaXRlbXMgZm9yIHRoZSBwcm92aWRlZCBpdGVtc1xuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gICAgICogQG1ldGhvZCBfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBMaXN0IG9mIGF1dG9jb21wbGV0ZSBpdGVtcyB0byByZW5kZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJlbmRlcmVkIGxpc3QgaXRlbSBpbnN0YW5jZXNcbiAgICAgKi9cbiAgICBfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaXRlbXMgPSBpdGVtcyB8fCBbXTtcblxuICAgICAgICB2YXIgaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrID0gdGhpcy5wcm9wcy5oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2s7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy50ZXJtID09PSBpdGVtLnVybCA/ICdhZS10b29sYmFyLWVsZW1lbnQgYWN0aXZlJyA6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW0udXJsfSByb2xlPVwib3B0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IG9uQ2xpY2s9e2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGlja30gZGF0YS12YWx1ZT17aXRlbS51cmx9PntpdGVtLnRpdGxlfTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGF0YSBhY2NvcmRpbmcgdG8ge3RoaXMucHJvcHMudGVybX0gYW5kIGNhbGxzIHNldFN0YXRlKCkgd2l0aCB0aGUgcmV0dXJuZWQgZGF0YVxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gICAgICogQG1ldGhvZCBfdXBkYXRlSXRlbXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUl0ZW1zKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy50ZXJtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzLnByb3BzLmRhdGEodGhpcy5wcm9wcy50ZXJtKSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLnByb3BzLmV4cGFuZGVkICYmIGluc3RhbmNlLnByb3BzLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluc3RhbmNlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpdGVtczogaXRlbXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgYnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdC5rZXkgPSAnYnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IGZhbHNlLFxuICAgIGRhdGE6IFtdLFxuICAgIGRlbGF5OiAxMDAsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50JyxcbiAgICBrZXlzOiB7XG4gICAgICAgIGRpc21pc3M6IFsyN10sXG4gICAgICAgIGRpc21pc3NOZXh0OiBbMzldLFxuICAgICAgICBkaXNtaXNzUHJldjogWzM3XSxcbiAgICAgICAgbmV4dDogWzQwXSxcbiAgICAgICAgcHJldjogWzM4XVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuKTsiLCJpbXBvcnQgQnV0dG9uQ2ZnUHJvcHMgZnJvbSAnLi4vYmFzZS9idXR0b24tcHJvcHMuanMnO1xuaW1wb3J0IEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IGZyb20gJy4vYnV0dG9uLWxpbmstYXV0b2NvbXBsZXRlLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25MaW5rVGFyZ2V0RWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLXRhcmdldC1lZGl0LmpzeCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0RHJvcGRvd24gZnJvbSAnLi4vYmFzZS93aWRnZXQtZHJvcGRvd24uanMnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua0VkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSBsaW5rIGluIGEgZG9jdW1lbnQuXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcsIGVkaXRpbmcgYW5kIHJlbW92aW5nIGEgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua0VkaXRcbiAqIEB1c2VzIEJ1dHRvbkNmZ1Byb3BzXG4gKiBAdXNlcyBXaWRnZXREcm9wZG93blxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmtFZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5saW5rSW5wdXQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuX2dldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBGb2N1c2VzIG9uIHRoZSBsaW5rIGlucHV0IHRvIGltbWVkaWF0ZWx5IGFsbG93IGVkaXRpbmcuIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBjb21wb25lbnRcbiAgICAgKiBpcyByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBwcmV2ZW50IGFnZ3Jlc3NpdmUgZm9jdXMgc3RlYWxpbmcuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSB8fCB0aGlzLnByb3BzLm1hbnVhbFNlbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYmVmb3JlIGZvY3VzaW5nIHRvIGF2b2lkIHVuZGVzaXJlZFxuICAgICAgICAgICAgLy8gc2Nyb2xscyBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgdGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRJbml0aWFsU3RhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB0YXJnZXRTZWxlY3RvciA9IHtcbiAgICAgICAgICAgIGFsbG93ZWRUYXJnZXRzOiB0aGlzLnByb3BzLmFsbG93ZWRUYXJnZXRzLFxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLnByb3BzLmVkaXRvcixcbiAgICAgICAgICAgIGhhbmRsZUxpbmtUYXJnZXRDaGFuZ2U6IHRoaXMuX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGVjdGVkVGFyZ2V0OiB0aGlzLnN0YXRlLmxpbmtUYXJnZXQgfHwgQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0RGVmYXVsdFxuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldFNlbGVjdG9yID0gdGhpcy5tZXJnZURyb3Bkb3duUHJvcHModGFyZ2V0U2VsZWN0b3IsIEJ1dHRvbkxpbmtUYXJnZXRFZGl0LmtleSk7XG5cbiAgICAgICAgdmFyIGF1dG9jb21wbGV0ZURyb3Bkb3duO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkYXRhRm4gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgICAgIGlmICghTGFuZy5pc0Z1bmN0aW9uKGRhdGFGbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgICAgICAgICBkYXRhRm4gPSAoKSA9PiBpdGVtcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IHRoaXMuc3RhdGUuYXV0b2NvbXBsZXRlU2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YUZuLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5wcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrOiB0aGlzLl9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2ssXG4gICAgICAgICAgICAgICAgb25EaXNtaXNzOiB0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLFxuICAgICAgICAgICAgICAgIHNldEF1dG9jb21wbGV0ZVN0YXRlOiB0aGlzLl9zZXRBdXRvY29tcGxldGVTdGF0ZSxcbiAgICAgICAgICAgICAgICB0ZXJtOiB0aGlzLnN0YXRlLmxpbmtIcmVmXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhdXRvY29tcGxldGVEcm9wZG93blByb3BzID0gdGhpcy5tZXJnZURyb3Bkb3duUHJvcHMoYXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wcywgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qua2V5KTtcblxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlRHJvcGRvd24gPSA8QnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qgey4uLmF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHN9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1dHRvbkNsZWFyTGluaztcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5saW5rSHJlZikge1xuICAgICAgICAgICAgYnV0dG9uQ2xlYXJMaW5rID0gPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1pY29uLXJlbW92ZVwiIG9uQ2xpY2s9e3RoaXMuX2NsZWFyTGluay5iaW5kKHRoaXMpfSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jbGVhcn0+PC9idXR0b24+O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyUHJvcCA9IHt9O1xuXG4gICAgICAgIGlmICghQ0tFRElUT1IuZW52LmllICYmIEFsbG95RWRpdG9yLlN0cmluZ3MpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyUHJvcC5wbGFjZWhvbGRlciA9IEFsbG95RWRpdG9yLlN0cmluZ3MuZWRpdExpbms7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZUxpbmt9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lbGVtZW50fSBvbkNsaWNrPXt0aGlzLl9yZW1vdmVMaW5rLmJpbmQodGhpcyl9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tdW5saW5rXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHh4bFwiPlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5zaG93VGFyZ2V0U2VsZWN0b3IgJiYgPEJ1dHRvbkxpbmtUYXJnZXRFZGl0IHsuLi50YXJnZXRTZWxlY3Rvcn0gLz59XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPVwiYWUtaW5wdXRcIiBvbkNoYW5nZT17dGhpcy5faGFuZGxlTGlua0hyZWZDaGFuZ2UuYmluZCh0aGlzKX0gb25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3duLmJpbmQodGhpcyl9IHsgLi4ucGxhY2Vob2xkZXJQcm9wIH0gcmVmPXt0aGlzLmxpbmtJbnB1dH0gdHlwZT1cInRleHRcIiB2YWx1ZT17dGhpcy5zdGF0ZS5saW5rSHJlZn0+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICAgICAgICAgIHthdXRvY29tcGxldGVEcm9wZG93bn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b25DbGVhckxpbmt9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRpc2FibGVkPXshdGhpcy5faXNWYWxpZFN0YXRlKCl9IG9uQ2xpY2s9e3RoaXMuX3VwZGF0ZUxpbmsuYmluZCh0aGlzKX0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tb2tcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGlzLnN0YXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfZ2V0SW5pdGlhbFN0YXRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBjb25zdCB7ZWRpdG9yLCBkZWZhdWx0TGlua1RhcmdldH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGxpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKSkuZ2V0RnJvbVNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCBocmVmID0gbGluayA/IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJykgOiAnJztcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbGluayA/IGxpbmsuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSA6IGRlZmF1bHRMaW5rVGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRvY29tcGxldGVTZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBlbGVtZW50OiBsaW5rLFxuICAgICAgICAgICAgaW5pdGlhbExpbms6IHtcbiAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlua0hyZWY6IGhyZWYsXG4gICAgICAgICAgICBsaW5rVGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGxpbmsgaW5wdXQuIFRoaXMgb25seSBjaGFuZ2VzIHRoZSBjb21wb25lbnQgaW50ZXJuYWwgc3RhdGUsIGJ1dCBkb2VzIG5vdFxuICAgICAqIGFmZmVjdCB0aGUgbGluayBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIE9ubHkgdGhlIF9yZW1vdmVMaW5rIGFuZCBfdXBkYXRlTGluayBtZXRob2RzXG4gICAgICogYXJlIHRyYW5zbGF0ZWQgdG8gdGhlIGVkaXRvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfY2xlYXJMaW5rXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jbGVhckxpbmsoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbGlua0hyZWY6ICcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfZm9jdXNMaW5rSW5wdXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZvY3VzTGlua0lucHV0KCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmb2N1c0xpbmtFbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5zdGFuY2UubGlua0lucHV0LmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmb2N1c0xpbmtFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZvY3VzTGlua0VsLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcbiAgICAgKiAtIEVudGVyOiBDcmVhdGVzL3VwZGF0ZXMgdGhlIGxpbmsuXG4gICAgICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzIHx8IGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5rKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZVNlbGVjdGVkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcikuYWR2YW5jZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlIGxpbmsgaW5wdXQgY2hhbmdlcyBvbiB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlTGlua0hyZWZDaGFuZ2VcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFuZGxlTGlua0hyZWZDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsaW5rSHJlZjogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlIGxpbmsgdGFyZ2V0IGNoYW5nZXMgb24gdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICAgICAqIEBtZXRob2QgX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2VcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXRlbURyb3Bkb3duOiBudWxsLFxuICAgICAgICAgICAgbGlua1RhcmdldDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gYW4gYXV0b2NvbXBsZXRlIGxpbmsgcmVzdWx0IGlzIHNlbGVjdGVkIGJ5IHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2tcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpdGVtRHJvcGRvd246IG51bGwsXG4gICAgICAgICAgICBsaW5rSHJlZjogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCBsaW5rIHN0YXRlIGlzIHZhbGlkIHNvIHRoZSB1c2VyIGNhbiBzYXZlIHRoZSBsaW5rLiBBIHZhbGlkIHN0YXRlXG4gICAgICogbWVhbnMgdGhhdCB3ZSBoYXZlIGEgbm9uLWVtcHR5IGhyZWYgYW5kIHRoYXQgZWl0aGVyIHRoYXQgb3IgdGhlIGxpbmsgdGFyZ2V0IGFyZSBkaWZmZXJlbnRcbiAgICAgKiBmcm9tIHRoZSBvcmlnaW5hbCBsaW5rLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfaXNWYWxpZFN0YXRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBfaXNWYWxpZFN0YXRlKCkge1xuICAgICAgICB2YXIgdmFsaWRTdGF0ZSA9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtIcmVmICYmIChcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtIcmVmICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLmhyZWYgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtUYXJnZXQgIT09IHRoaXMuc3RhdGUuaW5pdGlhbExpbmsudGFyZ2V0XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB2YWxpZFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpbmsgaW4gdGhlIGVkaXRvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfcmVtb3ZlTGlua1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlTGluaygpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciBsaW5rVXRpbHMgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgYm9va21hcmtzID0gc2VsZWN0aW9uLmNyZWF0ZUJvb2ttYXJrcygpO1xuXG4gICAgICAgIGxpbmtVdGlscy5yZW1vdmUodGhpcy5zdGF0ZS5lbGVtZW50LCB7IGFkdmFuY2U6IHRydWUgfSk7XG5cbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEJvb2ttYXJrcyhib29rbWFya3MpO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcbiAgICAgICAgLy8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGxpbmsgYnV0dG9uKVxuICAgICAgICB0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYXV0b2NvbXBsZXRlU2VsZWN0ZWQgc3RhdGUgdG8gZm9jdXMgYW5kIHNlbGVjdCBhdXRvY29tcGxldGXCtHMgZHJvcGRvd25cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICAgICAqIEBtZXRob2QgX3NldEF1dG9jb21wbGV0ZVN0YXRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRBdXRvY29tcGxldGVTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZVNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsaW5rIGluIHRoZSBlZGl0b3IgZWxlbWVudC4gSWYgdGhlIGVsZW1lbnQgZGlkbid0IGV4aXN0IHByZXZpb3VzbHksIGl0IHdpbGxcbiAgICAgKiBjcmVhdGUgYSBuZXcgPGE+IGVsZW1lbnQgd2l0aCB0aGUgaHJlZiBzcGVjaWZpZWQgaW4gdGhlIGxpbmsgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVMaW5rXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVMaW5rKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvciwge2FwcGVuZFByb3RvY29sOiB0aGlzLnByb3BzLmFwcGVuZFByb3RvY29sfSk7XG4gICAgICAgIHZhciBsaW5rQXR0cnMgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuc3RhdGUubGlua1RhcmdldFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbW9kaWZ5U2VsZWN0aW9uID0geyBhZHZhbmNlOiB0cnVlIH07XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubGlua0hyZWYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsaW5rQXR0cnMuaHJlZiA9IHRoaXMuc3RhdGUubGlua0hyZWY7XG5cbiAgICAgICAgICAgICAgICBsaW5rVXRpbHMudXBkYXRlKGxpbmtBdHRycywgdGhpcy5zdGF0ZS5lbGVtZW50LCBtb2RpZnlTZWxlY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5rVXRpbHMuY3JlYXRlKHRoaXMuc3RhdGUubGlua0hyZWYsIGxpbmtBdHRycywgbW9kaWZ5U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuICAgICAgICAvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG4gICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGxpbmtFZGl0XG4gKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uTGlua0VkaXQua2V5ID0gJ2xpbmtFZGl0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uTGlua0VkaXQuZGVmYXVsdFByb3BzID0ge1xuICAgIGFwcGVuZFByb3RvY29sOiB0cnVlLFxuICAgIGF1dG9jb21wbGV0ZVVybDogJycsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgY3VzdG9tSW5kZXhTdGFydDogdHJ1ZSxcbiAgICBkZWZhdWx0TGlua1RhcmdldDogJycsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50JyxcbiAgICBrZXlzOiB7XG4gICAgICAgIGRpc21pc3M6IFsyN10sXG4gICAgICAgIGRpc21pc3NOZXh0OiBbMzldLFxuICAgICAgICBkaXNtaXNzUHJldjogWzM3XSxcbiAgICAgICAgbmV4dDogWzQwXSxcbiAgICAgICAgcHJldjogWzM4XVxuICAgIH0sXG4gICAgc2hvd1RhcmdldFNlbGVjdG9yOiB0cnVlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25DZmdQcm9wcyhcbiAgICBXaWRnZXREcm9wZG93bihcbiAgICBXaWRnZXRGb2N1c01hbmFnZXIoXG4gICAgICAgIEJ1dHRvbkxpbmtFZGl0XG4pKSk7XG4iLCJpbXBvcnQgQnV0dG9uVGFyZ2V0TGlzdCBmcm9tICcuL2J1dHRvbi10YXJnZXQtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua1RhcmdldEVkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGhlIHRhcmdldCBvZiBhIGxpbmtcbiAqIGluIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua1RhcmdldEVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uTGlua1RhcmdldEVkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgaGFuZGxlTGlua1RhcmdldENoYW5nZSA9IHRoaXMucHJvcHMuaGFuZGxlTGlua1RhcmdldENoYW5nZTtcbiAgICAgICAgdmFyIGFsbG93ZWRMaW5rVGFyZ2V0cyA9IHRoaXMucHJvcHMuYWxsb3dlZFRhcmdldHM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGluay10YXJnZXQgYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWNvbnRhaW5lci1kcm9wZG93bi1tZWRpdW0gYWUtaGFzLWRyb3Bkb3duXCIgdGFiSW5kZXg9XCIwXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfSBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fSBjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIiBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLmJpbmQodGhpcyl9IHJvbGU9XCJjb21ib2JveFwiIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPnt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYXJyb3dcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmV4cGFuZGVkICYmIChcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblRhcmdldExpc3QgZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSBhbGxvd2VkTGlua1RhcmdldHM9e2FsbG93ZWRMaW5rVGFyZ2V0c30gaGFuZGxlTGlua1RhcmdldENoYW5nZT17aGFuZGxlTGlua1RhcmdldENoYW5nZX0gc2VsZWN0ZWRUYXJnZXQ9e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9Lz5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGJlZm9yZSByZW5kZXJpbmcgd2hlbiBuZXcgcHJvcHMgb3Igc3RhdGUgYXJlIGJlaW5nIHJlY2VpdmVkLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlciBvciB3aGVuIGZvcmNlVXBkYXRlIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1RhcmdldEVkaXRcbiAgICAgKiBAbWV0aG9kICBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcyBhbmQgc3RhdGUgd2lsbCBub3RcbiAgICAgKiByZXF1aXJlIGEgY29tcG9uZW50IHVwZGF0ZS5cbiAgICAgKi9cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBuZXh0UHJvcHMuZXhwYW5kZWQgIT09IHRoaXMucHJvcHMuZXhwYW5kZWQgfHwgbmV4dFByb3BzLnNlbGVjdGVkVGFyZ2V0ICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBsaW5rVGFyZ2V0RWRpdFxuICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtUYXJnZXRFZGl0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkxpbmtUYXJnZXRFZGl0LmtleSA9ICdsaW5rVGFyZ2V0RWRpdCc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkxpbmtUYXJnZXRFZGl0O1xuIiwiaW1wb3J0IEJ1dHRvbkNmZ1Byb3BzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXByb3BzLmpzJztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25LZXlzdHJva2UgZnJvbSAnLi4vYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgbGluayBpbiBhIGRvY3VtZW50LiBCdXR0b25MaW5rXG4gKiByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgbW9kZXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGVcbiAqIC0gRXhjbHVzaXZlOiBUaGUgQnV0dG9uTGlua0VkaXQgVUkgd2l0aCBhbGwgdGhlIGxpbmsgZWRpdGlvbiBjb250cm9scy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua1xuICogQHVzZXMgQnV0dG9uQ2ZnUHJvcHNcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmsgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgY29udGFpbmVkIHdpdGhpbiBhIGxpbmsuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuICAgICAqIEBtZXRob2QgaXNBY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgbGluaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gKG5ldyBDS0VESVRPUi5MaW5rKHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykpLmdldEZyb21TZWxlY3Rpb24oKSAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMubWVyZ2VCdXR0b25DZmdQcm9wcygpO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxCdXR0b25MaW5rRWRpdCB7Li4ucHJvcHN9IC8+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MubGlua30gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWxpbmtcIiBvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1saW5rXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIHRoZSBsaW5rIGJ1dHRvbiB0byBiZSByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYSBsaW5rLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcbiAgICAgKiBAbWV0aG9kIF9yZXF1ZXN0RXhjbHVzaXZlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZXF1ZXN0RXhjbHVzaXZlKCkge1xuICAgICAgICB0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUoQnV0dG9uTGluay5rZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBsaW5rXG4gKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25MaW5rLmtleSA9ICdsaW5rJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25MaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA3NiAvKkwqL1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNmZ1Byb3BzKFxuICAgIEJ1dHRvbktleXN0cm9rZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvbkxpbmtcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uT3JkZXJlZExpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgb3JkZXJlZCBsaXN0cyBpbiBhbiBlZGl0b3IuXG4gKlxuICogQGNsYXNzIEJ1dHRvbk9yZGVyZWRMaXN0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbk9yZGVyZWRMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLm51bWJlcmVkbGlzdH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tb2xcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5udW1iZXJlZGxpc3R9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tbnVtYmVyZWQtbGlzdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBvbFxuICogQG1lbWJlcm9mIEJ1dHRvbk9yZGVyZWRMaXN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbk9yZGVyZWRMaXN0LmtleSA9ICdvbCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3RcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbk9yZGVyZWRMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnbnVtYmVyZWRsaXN0JyxcbiAgICBzdHlsZToge1xuICAgICAgICBlbGVtZW50OiAnb2wnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbk9yZGVyZWRMaXN0XG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uT3V0ZGVudEJsb2NrIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG91dGRlbnRpbmcgYmxvY2tzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25PdXRkZW50QmxvY2tcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25PdXRkZW50QmxvY2sgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25PdXRkZW50QmxvY2tcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLm91dGRlbnR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLW91dGRlbnQtYmxvY2tcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5vdXRkZW50fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLW91dGRlbnQtYmxvY2tcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW5kZW50QmxvY2tcbiAqIEBtZW1iZXJvZiBCdXR0b25PdXRkZW50QmxvY2tcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uT3V0ZGVudEJsb2NrLmtleSA9ICdvdXRkZW50QmxvY2snO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uT3V0ZGVudEJsb2NrLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnb3V0ZGVudCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvbk91dGRlbnRCbG9ja1xuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYSBwYXJhZ3JhcGggb24gbGVmdC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1sZWZ0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLWxlZnRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgcGFyYWdyYXBoTGVmdFxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQua2V5ID0gJ3BhcmFncmFwaExlZnQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeWxlZnQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRBY3RpdmUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgICAgICBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnRcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhIHBhcmFncmFwaCBvbiByaWdodC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tcmlnaHRcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHBhcmFncmFwaFJpZ2h0XG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0LmtleSA9ICdwYXJhZ3JhcGhSaWdodCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2p1c3RpZnlyaWdodCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2VudGVyaW5nIGEgcGFyYWdyYXBoLlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduQ2VudGVyfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1wYXJhZ3JhcGgtY2VudGVyXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tY2VudGVyXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHBhcmFncmFwaENlbnRlclxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaENlbnRlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25QYXJhZ3JhcGhDZW50ZXIua2V5ID0gJ3BhcmFncmFwaENlbnRlcic7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25QYXJhZ3JhcGhDZW50ZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdqdXN0aWZ5Y2VudGVyJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBqdXN0ZnlpbmcgYSBwYXJhZ3JhcGguXG4gKlxuICogQGNsYXNzIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25KdXN0aWZ5fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeVwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduSnVzdGlmeX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hbGlnbi1qdXN0aWZpZWRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgcGFyYWdyYXBoSnVzdGlmeVxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uUGFyYWdyYXBoSnVzdGlmeS5rZXkgPSAncGFyYWdyYXBoSnVzdGlmeSc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUGFyYWdyYXBoSnVzdGlmeS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2p1c3RpZnlibG9jaydcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUXVvdGUgY2xhc3Mgd3JhcHMgYSBzZWxlY3Rpb24gaW4gYGJsb2NrcXVvdGVgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblF1b3RlXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblF1b3RlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uUXVvdGVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnF1b3RlfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1xdW90ZVwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnF1b3RlfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXF1b3RlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHF1b3RlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUXVvdGVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uUXVvdGUua2V5ID0gJ3F1b3RlJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25RdW90ZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUXVvdGUuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdibG9ja3F1b3RlJyxcbiAgICBzdHlsZToge1xuICAgICAgICBlbGVtZW50OiAnYmxvY2txdW90ZSdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uUXVvdGVcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblJlbW92ZUZvcm1hdCBjbGFzcyByZW1vdmVzIHN0eWxlIGZvcm1hdHRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25SZW1vdmVGb3JtYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25SZW1vdmVGb3JtYXRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVmb3JtYXR9IGNsYXNzTmFtZT0nYWUtYnV0dG9uJyBkYXRhLXR5cGU9XCJidXR0b24tcmVtb3ZlZm9ybWF0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlZm9ybWF0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXJlbW92ZWZvcm1hdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCByZW1vdmVGb3JtYXRcbiAqIEBtZW1iZXJvZiBCdXR0b25SZW1vdmVGb3JtYXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uUmVtb3ZlRm9ybWF0LmtleSA9ICdyZW1vdmVGb3JtYXQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUmVtb3ZlRm9ybWF0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAncmVtb3ZlRm9ybWF0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25SZW1vdmVGb3JtYXRcbik7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU2VwYXJhdG9yIGNsYXNzIHJlbmRlcnMgYSBzaW1wbGUgc2VwYXJhdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TZXBhcmF0b3JcbiAqL1xuY2xhc3MgQnV0dG9uU2VwYXJhdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBzZXBhcmF0b3IuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU2VwYXJhdG9yXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1zZXBhcmF0b3JcIj48L3NwYW4+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHNlcGFyYXRvclxuICogQG1lbWJlcm9mIEJ1dHRvblNlcGFyYXRvclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25TZXBhcmF0b3Iua2V5ID0gJ3NlcGFyYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblNlcGFyYXRvcjsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3RyaWtlIGNsYXNzIHN0eWxlcyBhIHNlbGVjdGlvbiB3aXRoIHN0cmlrZSBzdHlsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3RyaWtlXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN0cmlrZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2VcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0cmlrZX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tc3RyaWtlXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3RyaWtlfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXN0cmlrZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzdHJpa2VcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU3RyaWtlLmtleSA9ICdzdHJpa2UnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblN0cmlrZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uU3RyaWtlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnc3RyaWtlJyxcbiAgICBzdHlsZTogJ2NvcmVTdHlsZXNfc3RyaWtlJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvblN0cmlrZVxuKSkpOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGNsYXNzIHByb3ZpZGVzIHRoZSBoZWFkZXIgb2YgYW4gbGlzdCBvZiBzdHlsZSBpdGVtcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXJcbiAqL1xuY2xhc3MgQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25zU3R5bGVzTGlzdEhlYWRlclxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zdHlsZXMgJiYgdGhpcy5wcm9wcy5zdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWxpc3QtaGVhZGVyXCI+e3RoaXMucHJvcHMubmFtZX08L3NwYW4+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyLmtleSA9ICdidXR0b25TdHlsZXNMaXN0SGVhZGVyJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXI7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcHJldmlld2luZyBhIHN0eWxlIGRlZmluaXRpb25cbiAqIGluc2lkZSBhIGxpc3QgYW5kIGFwcGx5aW5nIGl0IHRvIHRoZSBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsaSByb2xlPVwib3B0aW9uXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIiBvbkNsaWNrPXt0aGlzLl9yZW1vdmVTdHlsZXMuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9PntBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbH08L2J1dHRvbj5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaW5saW5lIHN0eWxlcyBhbmQgY29uZmlndXJlZCBibG9jayBlbGVtZW50cyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuICAgICAqIEBtZXRob2QgX3JlbW92ZVN0eWxlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlU3R5bGVzKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ3JlbW92ZUZvcm1hdCcpO1xuXG4gICAgICAgIHRoaXMucHJvcHMucmVtb3ZlQmxvY2tzLmZvckVhY2goZnVuY3Rpb24oYmxvY2tJdGVtKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tTdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7ZWxlbWVudDogYmxvY2tJdGVtfSk7XG5cbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTdHlsZShibG9ja1N0eWxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLmtleSA9ICdidXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLmRlZmF1bHRQcm9wcyA9IHtcbiAgICByZW1vdmVCbG9ja3M6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAncHJlJ11cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlO1xuIiwiaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcHJldmlld2luZyBhIHN0eWxlIGRlZmluaXRpb25cbiAqIGluc2lkZSBhIGxpc3QgYW5kIGFwcGx5aW5nIGl0IHRvIHRoZSBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgLy8gU3R5bGVzIHdpdGggd2lsZGNhcmQgZWxlbWVudCAoKikgZ2VuZXJhdGUgYW4gZW1wdHkgdGFnIGluIHRoZWlyIHByZXZpZXcgPCBjbGFzcz1cImN1c3RvbS1jbGFzc1wiIC8+LlxuICAgICAgICAvLyBXZSBkZWZhdWx0IHRvIGVsZW1lbnQgc3BhbiBhbmQgcmVtb3ZlIHRoZSBtYXJnaW5zIHRvIG9idGFpbiBhIG1vcmUgY29uc2lzdGVudCBzZXQgb2YgcHJldmlld3MuXG4gICAgICAgIHZhciBzdHlsZUNmZyA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6ICdzcGFuJyxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN0eWxlQ2ZnID0gQ0tFRElUT1IudG9vbHMubWVyZ2Uoc3R5bGVDZmcsIHRoaXMucHJvcHMuc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuX3ByZXZpZXcgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDZmcpLmJ1aWxkUHJldmlldyh0aGlzLnByb3BzLm5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBkYW5nZXJvdXNlbHlTZXRJbm50ZXJIVE1MIHNpbmNlIHdlJ3JlIG5vdCBpbiBjb250cm9sIG9mIHRoZSBzdHlsZVxuICAgICAgICAvLyBwcmV2aWV3IHRoYXQgaXMgZ2VuZXJhdGVkIGJ5IENLRWRpdG9yLlxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5uYW1lID09PSB0aGlzLnByb3BzLmFjdGl2ZVN0eWxlID8gJ2FlLXRvb2xiYXItZWxlbWVudCBhY3RpdmUnIDogJ2FlLXRvb2xiYXItZWxlbWVudCc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7X19odG1sOiB0aGlzLl9wcmV2aWV3fX0gb25DbGljaz17dGhpcy5fb25DbGljay5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0+PC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgaXRlbSBzdHlsZSB0byB0aGUgZWRpdG9yIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuICAgICAqIEBtZXRob2QgX29uQ2xpY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX29uQ2xpY2soKSB7XG4gICAgICAgIC8vIFR5cGljYWxseSwgd2Ugd2FudCB0aGUgc3R5bGUgdG8gYmUgdGhlIG9ubHkgb25lIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBzb1xuICAgICAgICAvLyB3ZSBleGVjdXRlIHRoZSAncmVtb3ZlRm9ybWF0JyBjb21tYW5kIGZpcnN0LiBOb3RlIHRoYXQgYmxvY2sgc3R5bGVzIHdvbid0IGJlIGNsZWFuZWQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgaXMgY29uc2lzdGVudCB3aXRoIG90aGVyIGVkaXRvcnMgaW1wbGVtZW50YXRpb25zIG9mIHRoaXMgZmVhdHVyZS5cbiAgICAgICAgdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5leGVjQ29tbWFuZCgncmVtb3ZlRm9ybWF0Jyk7XG5cbiAgICAgICAgdGhpcy5hcHBseVN0eWxlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJ1dHRvblN0eWxlc0xpc3RJdGVtXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU3R5bGVzTGlzdEl0ZW0ua2V5ID0gJ2J1dHRvblN0eWxlc0xpc3RJdGVtJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG4pKTsiLCJpbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SXRlbSBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS1yZW1vdmUuanN4JztcbmltcG9ydCBCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1oZWFkZXIuanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0eWxlc0xpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBhIGxpc3Qgb2Ygc3R5bGVzIHRoYXQgY2FuIGJlXG4gKiBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc0xpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25TdHlsZXNMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogRm9jdXNlcyBvbiB0aGUgbGlzdCBub2RlIHRvIGFsbG93IGtleWJvYXJkIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHZhciBibG9ja1N0eWxlcyA9IFtdO1xuICAgICAgICB2YXIgaW5saW5lU3R5bGVzID0gW107XG4gICAgICAgIHZhciBvYmplY3RTdHlsZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnByb3BzLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShpdGVtLnN0eWxlKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLnR5cGUgPT09IENLRURJVE9SLlNUWUxFX0JMT0NLKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tTdHlsZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUudHlwZSA9PT0gQ0tFRElUT1IuU1RZTEVfSU5MSU5FKSB7XG4gICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLnR5cGUgPT09IENLRURJVE9SLlNUWUxFX09CSkVDVCkge1xuICAgICAgICAgICAgICAgIG9iamVjdFN0eWxlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ibG9ja1N0eWxlcyA9IGJsb2NrU3R5bGVzO1xuICAgICAgICB0aGlzLl9pbmxpbmVTdHlsZXMgPSBpbmxpbmVTdHlsZXM7XG4gICAgICAgIHRoaXMuX29iamVjdFN0eWxlcyA9IG9iamVjdFN0eWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHJlbW92ZVN0eWxlc0l0ZW07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd1JlbW92ZVN0eWxlc0l0ZW0pIHtcbiAgICAgICAgICAgIHJlbW92ZVN0eWxlc0l0ZW0gPSA8QnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8QnV0dG9uRHJvcGRvd24gey4uLnRoaXMucHJvcHN9PlxuICAgICAgICAgICAgICAgIHtyZW1vdmVTdHlsZXNJdGVtfVxuXG4gICAgICAgICAgICAgICAgPEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIG5hbWU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYmxvY2tTdHlsZXN9IHN0eWxlcz17dGhpcy5fYmxvY2tTdHlsZXN9IC8+XG4gICAgICAgICAgICAgICAge3RoaXMuX3JlbmRlclN0eWxlc0l0ZW1zKHRoaXMuX2Jsb2NrU3R5bGVzKX1cblxuICAgICAgICAgICAgICAgIDxCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBuYW1lPXtBbGxveUVkaXRvci5TdHJpbmdzLmlubGluZVN0eWxlc30gc3R5bGVzPXt0aGlzLl9pbmxpbmVTdHlsZXN9IC8+XG4gICAgICAgICAgICAgICAge3RoaXMuX3JlbmRlclN0eWxlc0l0ZW1zKHRoaXMuX2lubGluZVN0eWxlcyl9XG5cbiAgICAgICAgICAgICAgICA8QnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIgbmFtZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5vYmplY3RTdHlsZXN9IHN0eWxlcz17dGhpcy5fb2JqZWN0U3R5bGVzfSAvPlxuICAgICAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9vYmplY3RTdHlsZXMpfVxuICAgICAgICAgICAgPC9CdXR0b25Ecm9wZG93bj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGluc3RhbmNlcyBvZiBCdXR0b25TdHlsZXNMaXN0SXRlbSB3aXRoIHRoZSBwcmV2aWV3IG9mIHRoZSBjb3JyZXNwb25kZW50IGJsb2NrLCBpbmxpbmUgb3Igb2JqZWN0IHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG4gICAgICogQG1ldGhvZCBfcmVuZGVyU3R5bGVzSXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZXMgTGlzdCBvZiBzdHlsZXMgZm9yIHdoaWNoIHByZXZpZXcgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmVuZGVyZWQgaW5zdGFuY2VzIG9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtIGNsYXNzXG4gICAgICovXG4gICAgX3JlbmRlclN0eWxlc0l0ZW1zKHN0eWxlcykge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3I7XG4gICAgICAgIHZhciBpdGVtcztcblxuICAgICAgICBpZiAoc3R5bGVzICYmIHN0eWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gc3R5bGVzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGxpIGtleT17aXRlbS5uYW1lfSByb2xlPVwib3B0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uU3R5bGVzTGlzdEl0ZW0gYWN0aXZlU3R5bGU9e3RoaXMucHJvcHMuYWN0aXZlU3R5bGV9IGVkaXRvcj17ZWRpdG9yfSBuYW1lPXtpdGVtLm5hbWV9IHN0eWxlPXtpdGVtLnN0eWxlfSAvPlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQGRlZmF1bHQgYnV0dG9uU3R5bGVzTGlzdFxuICovXG5CdXR0b25TdHlsZXNMaXN0LmtleSA9ICdidXR0b25TdHlsZXNMaXN0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25TdHlsZXNMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50JyxcbiAgICBrZXlzOiB7XG4gICAgICAgIGRpc21pc3M6IFsyN10sXG4gICAgICAgIGRpc21pc3NOZXh0OiBbMzldLFxuICAgICAgICBkaXNtaXNzUHJldjogWzM3XSxcbiAgICAgICAgbmV4dDogWzQwXSxcbiAgICAgICAgcHJldjogWzM4XVxuICAgIH0sXG4gICAgc2hvd1JlbW92ZVN0eWxlc0l0ZW06IHRydWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBCdXR0b25TdHlsZXNMaXN0XG4pOyIsImltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXMgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc3R5bGluZyBhIHNlbGVjdGlvbiB3aXRoIGEgbGlzdCBvZlxuICogY29uZmlndXJhYmxlIGFuZCBjdXN0b21pemFibGUgc3R5bGVzLiBUaGUgYWxsb3dlZCBzdHlsZXMgZm9sbG93IENLRURJVE9SLlN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIChodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlKVxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBhY3RpdmVTdHlsZSA9IEFsbG95RWRpdG9yLlN0cmluZ3Mubm9ybWFsO1xuXG4gICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLl9nZXRTdHlsZXMoKTtcblxuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tBY3RpdmUoaXRlbS5zdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdHlsZSA9IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB2YXIgYnV0dG9uU3R5bGVzTGlzdDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgYnV0dG9uU3R5bGVzTGlzdCA9IDxCdXR0b25TdHlsZXNMaXN0IGFjdGl2ZVN0eWxlPXthY3RpdmVTdHlsZX0gZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSBzaG93UmVtb3ZlU3R5bGVzSXRlbT17dGhpcy5wcm9wcy5zaG93UmVtb3ZlU3R5bGVzSXRlbX0gc3R5bGVzPXtzdHlsZXN9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWhhcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH0gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHlsZXMgKyAnICcgKyBhY3RpdmVTdHlsZX0gY2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCIgb25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMpfSByb2xlPVwiY29tYm9ib3hcIiB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzICsgJyAnICsgYWN0aXZlU3R5bGV9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duLXNlbGVjdGVkLWl0ZW1cIj57YWN0aXZlU3R5bGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hcnJvd1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge2J1dHRvblN0eWxlc0xpc3R9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gaXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcbiAgICAgKiBAbWV0aG9kIF9jaGVja0FjdGl2ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZUNvbmZpZyBTdHlsZSBkZWZpbml0aW9uIGFzIHBlciBodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHN0eWxlIGlzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIF9jaGVja0FjdGl2ZShzdHlsZUNvbmZpZykge1xuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICAvLyBTdHlsZXMgd2l0aCB3aWxkY2FyZCBlbGVtZW50ICgqKSB3b24ndCBiZSBjb25zaWRlcmVkIGFjdGl2ZSBieSBDS0VkaXRvci4gRGVmYXVsdGluZ1xuICAgICAgICAvLyB0byBhICdzcGFuJyBlbGVtZW50IHdvcmtzIGZvciBtb3N0IG9mIHRob3NlIGNhc2VzIHdpdGggbm8gZGVmaW5lZCBlbGVtZW50LlxuICAgICAgICBzdHlsZUNvbmZpZyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHtlbGVtZW50OiAnc3Bhbid9LCBzdHlsZUNvbmZpZyk7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ29uZmlnKTtcblxuICAgICAgICByZXR1cm4gc3R5bGUuY2hlY2tBY3RpdmUobmF0aXZlRWRpdG9yLmVsZW1lbnRQYXRoKCksIG5hdGl2ZUVkaXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHlsZXMuIEVhY2ggc3R5bGUgY29uc2lzdHMgZnJvbSB0d28gcHJvcGVydGllczpcbiAgICAgKiAtIG5hbWUgLSB0aGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJoMVwiXG4gICAgICogLSBzdHlsZSAtIGFuIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSwgY2FsbGVkIGBlbGVtZW50YCB3aGljaCB2YWx1ZVxuICAgICAqIHJlcHJlc2VudHMgdGhlIHN0eWxlIHdoaWNoIGhhdmUgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcbiAgICAgKiBAbWV0aG9kIF9nZXRTdHlsZXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXk8b2JqZWN0Pn0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBzdHlsZXMuXG4gICAgICovXG4gICAgX2dldFN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc3R5bGVzIHx8IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmgxLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdoMSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuaDIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ2gyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5mb3JtYXR0ZWQsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ3ByZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2l0ZSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAnY2l0ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29kZSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAnY29kZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHN0eWxlc1xuICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25TdHlsZXMua2V5ID0gJ3N0eWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblN0eWxlczsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3Vic2NyaXB0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFwcGx5aW5nIHN1YnNjcmlwdCBzdHlsZSB0byBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdWJzY3JpcHRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uU3Vic2NyaXB0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3Vic2NyaXB0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdWJzY3JpcHR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXN1YnNjcmlwdFwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1YnNjcmlwdH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1zdWJzY3JpcHRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgc3Vic2NyaXB0XG4gKiBAbWVtYmVyb2YgQnV0dG9uU3Vic2NyaXB0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblN1YnNjcmlwdC5rZXkgPSAnc3Vic2NyaXB0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25TdWJzY3JpcHRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblN1YnNjcmlwdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ3N1YnNjcmlwdCcsXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX3N1YnNjcmlwdCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25TdWJzY3JpcHRcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3VwZXJzY3JpcHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYXBwbHlpbmcgc3VwZXJzY3JpcHQgc3R5bGUgdG8gYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3VwZXJzY3JpcHRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uU3VwZXJzY3JpcHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdXBlcnNjcmlwdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3VwZXJzY3JpcHR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXN1cGVyc2NyaXB0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3VwZXJzY3JpcHR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tc3VwZXJzY3JpcHRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgc3VwZXJzY3JpcHRcbiAqIEBtZW1iZXJvZiBCdXR0b25TdXBlcnNjcmlwdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25TdXBlcnNjcmlwdC5rZXkgPSAnc3VwZXJzY3JpcHQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblN1cGVyc2NyaXB0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25TdXBlcnNjcmlwdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ3N1cGVyc2NyaXB0JyxcbiAgICBzdHlsZTogJ2NvcmVTdHlsZXNfc3VwZXJzY3JpcHQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uU3VwZXJzY3JpcHRcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlQ2VsbCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSBjZWxscy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVDZWxsXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlQ2VsbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ2VsbFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgYnV0dG9uQ29tbWFuZHNMaXN0O1xuICAgICAgICB2YXIgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdElkID0gQnV0dG9uVGFibGVDZWxsLmtleSArICdMaXN0JztcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdCA9IDxCdXR0b25Db21tYW5kc0xpc3QgY29tbWFuZHM9e3RoaXMuX2dldENvbW1hbmRzKCl9IGVkaXRvcj17dGhpcy5wcm9wcy5lZGl0b3J9IGxpc3RJZD17YnV0dG9uQ29tbWFuZHNMaXN0SWR9IG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfSBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNlbGx9IGFyaWEtb3ducz17YnV0dG9uQ29tbWFuZHNMaXN0SWR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNlbGx9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWNlbGxcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge2J1dHRvbkNvbW1hbmRzTGlzdH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuICAgICAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ2VsbFxuICAgICAqIEBtZXRob2QgX2dldENvbW1hbmRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG4gICAgICovXG4gICAgX2dldENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jb21tYW5kcyB8fCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxJbnNlcnRCZWZvcmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxJbnNlcnRCZWZvcmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxJbnNlcnRBZnRlcicsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbEluc2VydEFmdGVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsRGVsZXRlJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsRGVsZXRlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsTWVyZ2UnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxNZXJnZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbE1lcmdlRG93bicsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbE1lcmdlRG93blxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbE1lcmdlUmlnaHQnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxNZXJnZVJpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsSG9yaXpvbnRhbFNwbGl0JyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsU3BsaXRIb3Jpem9udGFsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsVmVydGljYWxTcGxpdCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbFNwbGl0VmVydGljYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdGFibGVDZWxsXG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDZWxsXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhYmxlQ2VsbC5rZXkgPSAndGFibGVDZWxsJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVDZWxsOyIsImltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVDb2x1bW4gY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgY29sdW1ucy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVDb2x1bW5cbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVDb2x1bW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgYnV0dG9uQ29tbWFuZHNMaXN0LFxuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdElkID0gQnV0dG9uVGFibGVDb2x1bW4ua2V5ICsgJ0xpc3QnO1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0ID0gPEJ1dHRvbkNvbW1hbmRzTGlzdCBjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX0gZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gbGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1oYXMtZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1ufSBhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLmJpbmQodGhpcyl9IHJvbGU9XCJsaXN0Ym94XCIgdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbn0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tY29sdW1uXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHtidXR0b25Db21tYW5kc0xpc3R9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcbiAgICAgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuICAgICAqIEBtZXRob2QgX2dldENvbW1hbmRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG4gICAgICovXG4gICAgX2dldENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jb21tYW5kcyB8fCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NvbHVtbkluc2VydEJlZm9yZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1uSW5zZXJ0QmVmb3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb2x1bW5JbnNlcnRBZnRlcicsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1uSW5zZXJ0QWZ0ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NvbHVtbkRlbGV0ZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1uRGVsZXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHRhYmxlQ29sdW1uXG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDb2x1bW5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFibGVDb2x1bW4ua2V5ID0gJ3RhYmxlQ29sdW1uJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVDb2x1bW47IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgS0VZX0VOVEVSID0gMTM7XG52YXIgS0VZX0VTQyA9IDI3O1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZUVkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSB0YWJsZSBpbiBhIGRvY3VtZW50LlxuICogUHJvdmlkZXMgVUkgZm9yIGNyZWF0aW5nIGEgdGFibGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlRWRpdFxuICovXG5jbGFzcyBCdXR0b25UYWJsZUVkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gICAgICogQG1ldGhvZCBnZXRJbml0aWFsU3RhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5yb3dzUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuY29sc1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29sczogMyxcbiAgICAgICAgICAgIHJvd3M6IDNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50IChub3Qgb24gdGhlIHNlcnZlciksXG4gICAgICogaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMucm93c1JlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRhYmxlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICAgICAqIEBtZXRob2QgX2NyZWF0ZVRhYmxlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVUYWJsZSgpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciB0YWJsZVV0aWxzID0gbmV3IENLRURJVE9SLlRhYmxlKGVkaXRvcik7XG5cbiAgICAgICAgdGFibGVVdGlscy5jcmVhdGUoe1xuICAgICAgICAgICAgYXR0cnM6IHRoaXMucHJvcHMudGFibGVBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY29sczogdGhpcy5zdGF0ZS5jb2xzLFxuICAgICAgICAgICAgcm93czogdGhpcy5zdGF0ZS5yb3dzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBjaGFuZ2UgaW4gaW5wdXQgdmFsdWUuIFNldHMgdGhlIHByb3ZpZGVkIHZhbHVlIGZyb20gdGhlIHVzZXIgYmFjayB0byB0aGUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlQ2hhbmdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXQgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFuZGxlQ2hhbmdlKGlucHV0TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge307XG4gICAgICAgIHN0YXRlW2lucHV0TmFtZV0gPSBldmVudC50YXJnZXQudmFsdWU7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuICAgICAqIC0gRW50ZXI6IENyZWF0ZXMgdGhlIHRhYmxlLlxuICAgICAqIC0gRXNjYXBlOiBEaXNjYXJkcyB0aGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVLZXlEb3duXG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGtleWJvYXJkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVUYWJsZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHJvd3NJZCA9IHRpbWUgKyAncm93cyc7XG4gICAgICAgIHZhciBjb2xzSWQgPSB0aW1lICsgJ2NvbHMnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1lZGl0LXRhYmxlXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e3Jvd3NJZH0+e0FsbG95RWRpdG9yLlN0cmluZ3Mucm93c308L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHNtYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzc05hbWU9XCJhZS1pbnB1dFwiIGlkPXtyb3dzSWR9IG9uQ2hhbmdlPXt0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCAncm93cycpfSBtaW49XCIxXCIgb25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3duLmJpbmQodGhpcyl9IHBsYWNlaG9sZGVyPVwiUm93c1wiIHJlZj17dGhpcy5yb3dzUmVmfSB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RoaXMuc3RhdGUucm93c30+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPXtjb2xzSWR9PntBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbnN9PC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1pbnB1dCBzbWFsbFwiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPVwiYWUtaW5wdXRcIiBpZD17Y29sc0lkfSBvbkNoYW5nZT17dGhpcy5faGFuZGxlQ2hhbmdlLmJpbmQodGhpcywgJ2NvbHMnKX0gbWluPVwiMVwiIG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpfSBwbGFjZWhvbGRlcj1cIkNvbHVtc1wiIHJlZj17dGhpcy5jb2xzUmVmfSB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RoaXMuc3RhdGUuY29sc30+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD1cIkNvbmZpcm1cIiBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBvbkNsaWNrPXt0aGlzLl9jcmVhdGVUYWJsZS5iaW5kKHRoaXMpfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1va1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0YWJsZUVkaXRcbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFibGVFZGl0LmtleSA9ICd0YWJsZUVkaXQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uVGFibGVFZGl0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICB0YWJsZUF0dHJpYnV0ZXM6IHtcbiAgICAgICAgYm9yZGVyOiAxLFxuICAgICAgICBjZWxsUGFkZGluZzogMCxcbiAgICAgICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgICAgIHN0eWxlOiAnd2lkdGg6IDEwMCUnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVFZGl0O1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZUhlYWRpbmcgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgaGVhZGluZy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVIZWFkaW5nXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlSGVhZGluZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgYnV0dG9uQ29tbWFuZHNMaXN0O1xuICAgICAgICB2YXIgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdElkID0gQnV0dG9uVGFibGVIZWFkaW5nLmtleSArICdMaXN0JztcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdCA9IDxCdXR0b25Db21tYW5kc0xpc3QgY29tbWFuZHM9e3RoaXMuX2dldENvbW1hbmRzKCl9IGVkaXRvcj17dGhpcy5wcm9wcy5lZGl0b3J9IGxpc3RJZD17YnV0dG9uQ29tbWFuZHNMaXN0SWR9IG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aXZlSGVhZGluZyA9IG5ldyBDS0VESVRPUi5UYWJsZSh0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpKS5nZXRIZWFkaW5nKCk7XG4gICAgICAgIHZhciBhY3RpdmVIZWFkaW5nSW50cm8gPSBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnMgKyAnOic7XG4gICAgICAgIHZhciBhY3RpdmVIZWFkaW5nTGFiZWwgPSBBbGxveUVkaXRvci5TdHJpbmdzWydoZWFkZXJzJyArIGFjdGl2ZUhlYWRpbmddO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi14bCBhZS1oYXMtZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9XCJcIiBjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIiBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLmJpbmQodGhpcyl9IHJvbGU9XCJjb21ib2JveFwiIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT1cIlwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duLXNlbGVjdGVkLWl0ZW1cIj57YWN0aXZlSGVhZGluZ0ludHJvfSA8c3Ryb25nPnthY3RpdmVIZWFkaW5nTGFiZWx9PC9zdHJvbmc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hcnJvd1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge2J1dHRvbkNvbW1hbmRzTGlzdH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuICAgICAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuICAgICAqIEBtZXRob2QgX2dldENvbW1hbmRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG4gICAgICovXG4gICAgX2dldENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jb21tYW5kcyB8fCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3RhYmxlSGVhZGluZ05vbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNOb25lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdSb3cnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNSb3dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3RhYmxlSGVhZGluZ0NvbHVtbicsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc0NvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndGFibGVIZWFkaW5nQm90aCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc0JvdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdGFibGVSb3dcbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUhlYWRpbmdcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFibGVIZWFkaW5nLmtleSA9ICd0YWJsZUhlYWRpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZUhlYWRpbmc7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVSZW1vdmUgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcmVtb3ZpbmcgYSB0YWJsZVxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZVJlbW92ZVxuICovXG5jbGFzcyBCdXR0b25UYWJsZVJlbW92ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlUmVtb3ZlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlVGFibGV9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRhdGEtdHlwZT1cImJ1dHRvbi10YWJsZS1yZW1vdmVcIiBvbkNsaWNrPXt0aGlzLl9yZW1vdmVUYWJsZS5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlVGFibGV9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYmluXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgdGFibGUgaW4gdGhlIGVkaXRvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlUmVtb3ZlXG4gICAgICogQG1ldGhvZCBfcmVtb3ZlVGFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlbW92ZVRhYmxlKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIHRhYmxlVXRpbHMgPSBuZXcgQ0tFRElUT1IuVGFibGUoZWRpdG9yKTtcblxuICAgICAgICB0YWJsZVV0aWxzLnJlbW92ZSgpO1xuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdGFibGVSZW1vdmVcbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYWJsZVJlbW92ZS5rZXkgPSAndGFibGVSZW1vdmUnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZVJlbW92ZTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlUm93IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIHJvd3MuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlUm93XG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSb3dcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkNvbW1hbmRzTGlzdDtcbiAgICAgICAgdmFyIGJ1dHRvbkNvbW1hbmRzTGlzdElkO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlUm93LmtleSArICdMaXN0JztcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdCA9IDxCdXR0b25Db21tYW5kc0xpc3QgY29tbWFuZHM9e3RoaXMuX2dldENvbW1hbmRzKCl9IGVkaXRvcj17dGhpcy5wcm9wcy5lZGl0b3J9IGxpc3RJZD17YnV0dG9uQ29tbWFuZHNMaXN0SWR9IG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfSBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd30gYXJpYS1vd25zPXtidXR0b25Db21tYW5kc0xpc3RJZH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgb25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMpfSByb2xlPVwiY29tYm9ib3hcIiB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Mucm93fT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1yb3dcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge2J1dHRvbkNvbW1hbmRzTGlzdH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuICAgICAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlUm93XG4gICAgICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGF2YWlsYWJsZSBjb21tYW5kcy5cbiAgICAgKi9cbiAgICBfZ2V0Q29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAncm93SW5zZXJ0QmVmb3JlJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dJbnNlcnRCZWZvcmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3Jvd0luc2VydEFmdGVyJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dJbnNlcnRBZnRlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAncm93RGVsZXRlJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dEZWxldGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdGFibGVSb3dcbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJvd1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYWJsZVJvdy5rZXkgPSAndGFibGVSb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZVJvdzsiLCJpbXBvcnQgQnV0dG9uVGFibGVFZGl0IGZyb20gJy4vYnV0dG9uLXRhYmxlLWVkaXQuanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgdGFibGUgaW4gYSBkb2N1bWVudC4gQnV0dG9uVGFibGVcbiAqIHJlbmRlcnMgaW4gdHdvIGRpZmZlcmVudCBtb2RlczpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZVxuICogLSBFeGNsdXNpdmU6IFRoZSBCdXR0b25UYWJsZUVkaXQgVUkgd2l0aCBhbGwgdGhlIHRhYmxlIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxCdXR0b25UYWJsZUVkaXQgey4uLnRoaXMucHJvcHN9IC8+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MudGFibGV9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRhdGEtdHlwZT1cImJ1dHRvbi10YWJsZVwiIG9uQ2xpY2s9e3RoaXMucHJvcHMucmVxdWVzdEV4Y2x1c2l2ZX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnRhYmxlfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi10YWJsZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdGFibGVcbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYWJsZS5rZXkgPSAndGFibGUnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZTsiLCJpbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhcmdldExpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGhlIHRhcmdldCBvZiBhIGxpbmtcbiAqIGluIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFyZ2V0TGlzdFxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvblRhcmdldExpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgbGlzdFRhcmdldHMgPSB0aGlzLl9yZW5kZXJMaXN0VGFyZ2V0cygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8QnV0dG9uRHJvcGRvd24gey4uLnRoaXMucHJvcHN9PlxuICAgICAgICAgICAgICAgIHtsaXN0VGFyZ2V0c31cbiAgICAgICAgICAgIDwvQnV0dG9uRHJvcGRvd24+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGhlIGFsbG93ZWQgbGluayB0YXJnZXQgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuICAgICAqIEBtZXRob2QgX2dldEFsbG93ZWRUYXJnZXRJdGVtc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFsbG93ZWQgdGFyZ2V0IGl0ZW1zLlxuICAgICAqL1xuICAgIF9nZXRBbGxvd2VkVGFyZ2V0SXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmFsbG93ZWRMaW5rVGFyZ2V0cyB8fCBbe1xuICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MubGlua1RhcmdldERlZmF1bHQsXG4gICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MubGlua1RhcmdldFNlbGYsXG4gICAgICAgICAgICB2YWx1ZTogJ19zZWxmJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0QmxhbmssXG4gICAgICAgICAgICB2YWx1ZTogJ19ibGFuaydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MubGlua1RhcmdldFBhcmVudCxcbiAgICAgICAgICAgIHZhbHVlOiAnX3BhcmVudCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MubGlua1RhcmdldFRvcCxcbiAgICAgICAgICAgIHZhbHVlOiAnX3RvcCdcbiAgICAgICAgfV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgYWxsb3dlZCBsaW5rIHRhcmdldCBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG4gICAgICogQG1ldGhvZCBfcmVuZGVyTGlzdFRhcmdldHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSByZW5kZXJlZCBsaW5rIGl0ZW1zXG4gICAgICovXG4gICAgX3JlbmRlckxpc3RUYXJnZXRzKCkge1xuICAgICAgICB2YXIgdGFyZ2V0cyA9IHRoaXMuX2dldEFsbG93ZWRUYXJnZXRJdGVtcygpO1xuXG4gICAgICAgIHZhciBoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlID0gdGhpcy5wcm9wcy5oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlO1xuXG4gICAgICAgIHRhcmdldHMgPSB0YXJnZXRzLm1hcChmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0ID09PSB0YXJnZXQudmFsdWUgPyAnYWUtdG9vbGJhci1lbGVtZW50IGFjdGl2ZScgOiAnYWUtdG9vbGJhci1lbGVtZW50JztcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8bGkga2V5PXt0YXJnZXQudmFsdWV9IHJvbGU9XCJvcHRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gZGF0YS12YWx1ZT17dGFyZ2V0LnZhbHVlfSBvbkNsaWNrPXtoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlfT57dGFyZ2V0LmxhYmVsfTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBsaW5rVGFyZ2V0RWRpdFxuICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFyZ2V0TGlzdC5rZXkgPSAndGFyZ2V0TGlzdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uVGFyZ2V0TGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50JyxcbiAgICBrZXlzOiB7XG4gICAgICAgIGRpc21pc3M6IFsyN10sXG4gICAgICAgIGRpc21pc3NOZXh0OiBbMzldLFxuICAgICAgICBkaXNtaXNzUHJldjogWzM3XSxcbiAgICAgICAgbmV4dDogWzQwXSxcbiAgICAgICAgcHJldjogWzM4XVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBCdXR0b25UYXJnZXRMaXN0XG4pOyIsImltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5cbmNvbnN0IE1BWF9UV0VFVF9MRU5HVEggPSAyODA7XG5cbi8qKlxuICogVGhlIEJ1dHRvblR3aXR0ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYSBsaW5rIHdoaWNoXG4gKiBhbGxvd3MgcGVvcGxlIHRvIHR3ZWV0IHBhcnQgb2YgdGhlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVHdpdHRlclxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblR3aXR0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgcmVtb3ZlcyB0aGUgdHdpdHRlciBsaW5rIG9uIHRoZSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICAgICAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljaygpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgdmFyIGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgbGlua1V0aWxzLnJlbW92ZShsaW5rVXRpbHMuZ2V0RnJvbVNlbGVjdGlvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmtVdGlscy5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0SHJlZigpLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2FlLXR3aXR0ZXItbGluaycsXG4gICAgICAgICAgICAgICAgICAgICd0YXJnZXQnOiAnX2JsYW5rJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgbGluayB0aGF0IHBvaW50cyB0byB0d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICAgICAqIEBtZXRob2QgaXNBY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgdHdpdHRlciBsaW5rLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICAgIHZhciBsaW5rID0gbmV3IENLRURJVE9SLkxpbmsodGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKSkuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgICAgIHJldHVybiAobGluayAmJiAobGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKS5pbmRleE9mKCd0d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQnKSAhPT0gLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MudHdpdHRlcn0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXR3aXR0ZXJcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy50d2l0dGVyfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXR3aXR0ZXJcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIGFwcHJvcHJpYXRlIHR3aXR0ZXIgdXJsIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCB0ZXh0IGFuZCB0aGUgY29uZmlndXJhdGlvblxuICAgICAqIG9wdGlvbnMgcmVjZWl2ZWQgdmlhIHByb3BzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcbiAgICAgKiBAbWV0aG9kIF9nZXRIcmVmXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQSB2YWxpZCB0d2l0dGVyIHVybCB3aXRoIHRoZSBzZWxlY3RlZCB0ZXh0IGFuZCBnaXZlbiBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIF9nZXRIcmVmKCkge1xuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkVGV4dCA9IG5hdGl2ZUVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRTZWxlY3RlZFRleHQoKS5zdWJzdHJpbmcoMCwgTUFYX1RXRUVUX0xFTkdUSCk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnByb3BzLnVybDtcbiAgICAgICAgdmFyIHZpYSA9IHRoaXMucHJvcHMudmlhO1xuICAgICAgICB2YXIgdHdpdHRlckhyZWYgPSAnaHR0cHM6Ly90d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQ/dGV4dD0nICsgc2VsZWN0ZWRUZXh0O1xuXG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHR3aXR0ZXJIcmVmICs9ICcmdXJsPScgKyB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmlhKSB7XG4gICAgICAgICAgICB0d2l0dGVySHJlZiArPSAnJnZpYT0nICsgdmlhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR3aXR0ZXJIcmVmO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0d2l0dGVyXG4gKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25Ud2l0dGVyLmtleSA9ICd0d2l0dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblR3aXR0ZXJcbik7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblVub3JkZXJlZGxpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgdW5vcmRlcmVkIGxpc3RzIGluIGFuIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVW5vcmRlcmVkbGlzdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25Vbm9yZGVyZWRsaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYnVsbGV0ZWRsaXN0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi11bFwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmJ1bGxldGVkbGlzdH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1idWxsZXRlZC1saXN0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHVsXG4gKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25Vbm9yZGVyZWRsaXN0LmtleSA9ICd1bCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uVW5vcmRlcmVkbGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2J1bGxldGVkbGlzdCcsXG4gICAgc3R5bGU6IHtcbiAgICAgICAgZWxlbWVudDogJ3VsJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25Vbm9yZGVyZWRsaXN0XG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblVuZGVybGluZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciB1bmRlcmx5aW5nIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblVuZGVybGluZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblVuZGVybGluZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVW5kZXJsaW5lXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy51bmRlcmxpbmV9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXVuZGVybGluZVwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnVuZGVybGluZX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi11bmRlcmxpbmVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdW5kZXJsaW5lXG4gKiBAbWVtYmVyb2YgQnV0dG9uVW5kZXJsaW5lXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblVuZGVybGluZS5rZXkgPSAndW5kZXJsaW5lJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblVuZGVybGluZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ3VuZGVybGluZScsXG4gICAga2V5c3Ryb2tlOiB7XG4gICAgICAgIGZuOiAnZXhlY0NvbW1hbmQnLFxuICAgICAgICBrZXlzOiBDS0VESVRPUi5DVFJMICsgODUgLypVKi9cbiAgICB9LFxuICAgIHN0eWxlOiAnY29yZVN0eWxlc191bmRlcmxpbmUnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbktleXN0cm9rZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvblVuZGVybGluZVxuKSkpKTsiLCJpbXBvcnQgQnV0dG9uQm9sZCBmcm9tICcuL2J1dHRvbi1ib2xkLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ2FtZXJhSW1hZ2UgZnJvbSAnLi9idXR0b24tY2FtZXJhLWltYWdlLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ2FtZXJhIGZyb20gJy4vYnV0dG9uLWNhbWVyYS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNvZGUgZnJvbSAnLi9idXR0b24tY29kZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSBmcm9tICcuL2J1dHRvbi1jb21tYW5kLWxpc3QtaXRlbS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBCdXR0b25FbWJlZEVkaXQgZnJvbSAnLi9idXR0b24tZW1iZWQtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkVtYmVkIGZyb20gJy4vYnV0dG9uLWVtYmVkLmpzeCc7XG5pbXBvcnQgQnV0dG9uSDEgZnJvbSAnLi9idXR0b24taDEuanN4JztcbmltcG9ydCBCdXR0b25IMiBmcm9tICcuL2J1dHRvbi1oMi5qc3gnO1xuaW1wb3J0IEJ1dHRvbkhsaW5lIGZyb20gJy4vYnV0dG9uLWhsaW5lLmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciBmcm9tICcuL2J1dHRvbi1pbWFnZS1hbGlnbi1jZW50ZXIuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZUFsaWduTGVmdCBmcm9tICcuL2J1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGZyb20gJy4vYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2UgZnJvbSAnLi9idXR0b24taW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25JbmRlbnRCbG9jayBmcm9tICcuL2J1dHRvbi1pbmRlbnQtYmxvY2suanN4JztcbmltcG9ydCBCdXR0b25JdGFsaWMgZnJvbSAnLi9idXR0b24taXRhbGljLmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZnJvbSAnLi9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtFZGl0IGZyb20gJy4vYnV0dG9uLWxpbmstZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtUYXJnZXRFZGl0IGZyb20gJy4vYnV0dG9uLWxpbmstdGFyZ2V0LWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25MaW5rIGZyb20gJy4vYnV0dG9uLWxpbmsuanN4JztcbmltcG9ydCBCdXR0b25PbCBmcm9tICcuL2J1dHRvbi1vbC5qc3gnO1xuaW1wb3J0IEJ1dHRvbk91dGRlbnRCbG9jayBmcm9tICcuL2J1dHRvbi1vdXRkZW50LWJsb2NrLmpzeCc7XG5pbXBvcnQgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0IGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1sZWZ0LmpzeCc7XG5pbXBvcnQgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tcmlnaHQuanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgZnJvbSAnLi9idXR0b24tcGFyYWdyYXBoLWNlbnRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEp1c3RpZnkgZnJvbSAnLi9idXR0b24tcGFyYWdyYXBoLWp1c3RpZnkuanN4JztcbmltcG9ydCBCdXR0b25RdW90ZSBmcm9tICcuL2J1dHRvbi1xdW90ZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblJlbW92ZUZvcm1hdCBmcm9tICcuL2J1dHRvbi1yZW1vdmUtZm9ybWF0LmpzeCc7XG5pbXBvcnQgQnV0dG9uU2VwYXJhdG9yIGZyb20gJy4vYnV0dG9uLXNlcGFyYXRvci5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0cmlrZSBmcm9tICcuL2J1dHRvbi1zdHJpa2UuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SGVhZGVyIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWhlYWRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXMgZnJvbSAnLi9idXR0b24tc3R5bGVzLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3Vic2NyaXB0IGZyb20gJy4vYnV0dG9uLXN1YnNjcmlwdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblN1cGVyc2NyaXB0IGZyb20gJy4vYnV0dG9uLXN1cGVyc2NyaXB0LmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVDZWxsIGZyb20gJy4vYnV0dG9uLXRhYmxlLWNlbGwuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUNvbHVtbiBmcm9tICcuL2J1dHRvbi10YWJsZS1jb2x1bW4uanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUVkaXQgZnJvbSAnLi9idXR0b24tdGFibGUtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlSGVhZGluZyBmcm9tICcuL2J1dHRvbi10YWJsZS1oZWFkaW5nLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVSZW1vdmUgZnJvbSAnLi9idXR0b24tdGFibGUtcmVtb3ZlLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVSb3cgZnJvbSAnLi9idXR0b24tdGFibGUtcm93LmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGUgZnJvbSAnLi9idXR0b24tdGFibGUuanN4JztcbmltcG9ydCBCdXR0b25UYXJnZXRMaXN0IGZyb20gJy4vYnV0dG9uLXRhcmdldC1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uVHdpdHRlciBmcm9tICcuL2J1dHRvbi10d2l0dGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uVWwgZnJvbSAnLi9idXR0b24tdWwuanN4JztcbmltcG9ydCBCdXR0b25VbmRlcmxpbmUgZnJvbSAnLi9idXR0b24tdW5kZXJsaW5lLmpzeCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBbQnV0dG9uQm9sZC5rZXldOiBCdXR0b25Cb2xkLFxuICAgIFtCdXR0b25DYW1lcmFJbWFnZS5rZXldOiBCdXR0b25DYW1lcmFJbWFnZSxcbiAgICBbQnV0dG9uQ2FtZXJhLmtleV06IEJ1dHRvbkNhbWVyYSxcbiAgICBbQnV0dG9uQ29kZS5rZXldOiBCdXR0b25Db2RlLFxuICAgIFtCdXR0b25Db21tYW5kTGlzdEl0ZW0ua2V5XTogQnV0dG9uQ29tbWFuZExpc3RJdGVtLFxuICAgIFtCdXR0b25Db21tYW5kc0xpc3Qua2V5XTogQnV0dG9uQ29tbWFuZHNMaXN0LFxuICAgIFtCdXR0b25Ecm9wZG93bi5rZXldOiBCdXR0b25Ecm9wZG93bixcbiAgICBbQnV0dG9uRW1iZWRFZGl0LmtleV06IEJ1dHRvbkVtYmVkRWRpdCxcbiAgICBbQnV0dG9uRW1iZWQua2V5XTogQnV0dG9uRW1iZWQsXG4gICAgW0J1dHRvbkgxLmtleV06IEJ1dHRvbkgxLFxuICAgIFtCdXR0b25IMi5rZXldOiBCdXR0b25IMixcbiAgICBbQnV0dG9uSGxpbmUua2V5XTogQnV0dG9uSGxpbmUsXG4gICAgW0J1dHRvbkltYWdlQWxpZ25DZW50ZXIua2V5XTogQnV0dG9uSW1hZ2VBbGlnbkNlbnRlcixcbiAgICBbQnV0dG9uSW1hZ2VBbGlnbkxlZnQua2V5XTogQnV0dG9uSW1hZ2VBbGlnbkxlZnQsXG4gICAgW0J1dHRvbkltYWdlQWxpZ25SaWdodC5rZXldOiBCdXR0b25JbWFnZUFsaWduUmlnaHQsXG4gICAgW0J1dHRvbkltYWdlLmtleV06IEJ1dHRvbkltYWdlLFxuICAgIFtCdXR0b25JbmRlbnRCbG9jay5rZXldOiBCdXR0b25JbmRlbnRCbG9jayxcbiAgICBbQnV0dG9uSXRhbGljLmtleV06IEJ1dHRvbkl0YWxpYyxcbiAgICBbQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qua2V5XTogQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QsXG4gICAgW0J1dHRvbkxpbmtFZGl0LmtleV06IEJ1dHRvbkxpbmtFZGl0LFxuICAgIFtCdXR0b25MaW5rVGFyZ2V0RWRpdC5rZXldOiBCdXR0b25MaW5rVGFyZ2V0RWRpdCxcbiAgICBbQnV0dG9uTGluay5rZXldOiBCdXR0b25MaW5rLFxuICAgIFtCdXR0b25PbC5rZXldOiBCdXR0b25PbCxcbiAgICBbQnV0dG9uT3V0ZGVudEJsb2NrLmtleV06IEJ1dHRvbk91dGRlbnRCbG9jayxcbiAgICBbQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0LmtleV06IEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCxcbiAgICBbQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodC5rZXldOiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0LFxuICAgIFtCdXR0b25QYXJhZ3JhcGhDZW50ZXIua2V5XTogQnV0dG9uUGFyYWdyYXBoQ2VudGVyLFxuICAgIFtCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LmtleV06IEJ1dHRvblBhcmFncmFwaEp1c3RpZnksXG4gICAgW0J1dHRvblF1b3RlLmtleV06IEJ1dHRvblF1b3RlLFxuICAgIFtCdXR0b25SZW1vdmVGb3JtYXQua2V5XTogQnV0dG9uUmVtb3ZlRm9ybWF0LFxuICAgIFtCdXR0b25TZXBhcmF0b3Iua2V5XTogQnV0dG9uU2VwYXJhdG9yLFxuICAgIFtCdXR0b25TdHJpa2Uua2V5XTogQnV0dG9uU3RyaWtlLFxuICAgIFtCdXR0b25TdHlsZXNMaXN0SGVhZGVyLmtleV06IEJ1dHRvblN0eWxlc0xpc3RIZWFkZXIsXG4gICAgW0J1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLmtleV06IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLFxuICAgIFtCdXR0b25TdHlsZXNMaXN0SXRlbS5rZXldOiBCdXR0b25TdHlsZXNMaXN0SXRlbSxcbiAgICBbQnV0dG9uU3R5bGVzTGlzdC5rZXldOiBCdXR0b25TdHlsZXNMaXN0LFxuICAgIFtCdXR0b25TdHlsZXMua2V5XTogQnV0dG9uU3R5bGVzLFxuICAgIFtCdXR0b25TdWJzY3JpcHQua2V5XTogQnV0dG9uU3Vic2NyaXB0LFxuICAgIFtCdXR0b25TdXBlcnNjcmlwdC5rZXldOiBCdXR0b25TdXBlcnNjcmlwdCxcbiAgICBbQnV0dG9uVGFibGVDZWxsLmtleV06IEJ1dHRvblRhYmxlQ2VsbCxcbiAgICBbQnV0dG9uVGFibGVDb2x1bW4ua2V5XTogQnV0dG9uVGFibGVDb2x1bW4sXG4gICAgW0J1dHRvblRhYmxlRWRpdC5rZXldOiBCdXR0b25UYWJsZUVkaXQsXG4gICAgW0J1dHRvblRhYmxlSGVhZGluZy5rZXldOiBCdXR0b25UYWJsZUhlYWRpbmcsXG4gICAgW0J1dHRvblRhYmxlUmVtb3ZlLmtleV06IEJ1dHRvblRhYmxlUmVtb3ZlLFxuICAgIFtCdXR0b25UYWJsZVJvdy5rZXldOiBCdXR0b25UYWJsZVJvdyxcbiAgICBbQnV0dG9uVGFibGUua2V5XTogQnV0dG9uVGFibGUsXG4gICAgW0J1dHRvblRhcmdldExpc3Qua2V5XTogQnV0dG9uVGFyZ2V0TGlzdCxcbiAgICBbQnV0dG9uVHdpdHRlci5rZXldOiBCdXR0b25Ud2l0dGVyLFxuICAgIFtCdXR0b25VbC5rZXldOiBCdXR0b25VbCxcbiAgICBbQnV0dG9uVW5kZXJsaW5lLmtleV06IEJ1dHRvblVuZGVybGluZVxufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBXaWRnZXRFeGNsdXNpdmUgZnJvbSAnLi9iYXNlL3dpZGdldC1leGNsdXNpdmUuanMnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUaGUgbWFpbiBlZGl0b3IgVUkgY2xhc3MgbWFuYWdlcyBhIGhpZXJhcmNoeSBvZiB3aWRnZXRzICh0b29sYmFycyBhbmQgYnV0dG9ucykuXG4gKlxuICogQGNsYXNzIFVJXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBVSSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoaWRkZW46IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdlZGl0b3JJbnRlcmFjdGlvbicsIHRoaXMuX29uRWRpdG9ySW50ZXJhY3Rpb24sIHRoaXMpO1xuICAgICAgICBlZGl0b3Iub24oJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMuX29uQWN0aW9uUGVyZm9ybWVkLCB0aGlzKTtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXknLCB0aGlzLl9vbkVkaXRvcktleSwgdGhpcyk7XG5cbiAgICAgICAgLy8gU2V0IHVwIGV2ZW50cyBmb3IgaGlkaW5nIHRoZSBVSSB3aGVuIHVzZXIgc3RvcHMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZWRpdG9yLlxuICAgICAgICAvLyBUaGlzIG1heSBoYXBwZW4gd2hlbiBoZSBqdXN0IGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuIEhvd2V2ZXIsXG4gICAgICAgIC8vIHRoaXMgZG9lcyBub3QgaW5jbHVkZSBhIHNpdHVhdGlvbiB3aGVuIGhlIGNsaWNrcyBvbiBzb21lIGJ1dHRvbiwgcGFydCBvZlxuICAgICAgICAvLyBlZGl0b3IncyBVSS5cblxuICAgICAgICAvLyBJdCBpcyBub3QgZWFzeSB0byBkZWJvdW5jZSBfc2V0VUlIaWRkZW4gb24gbW91c2Vkb3duLCBiZWNhdXNlIGlmIHdlXG4gICAgICAgIC8vIGRlYm91bmNlIGl0LCB3aGVuIHRoZSBoYW5kbGVyIGlzIGJlaW5nIGludm9rZWQsIHRoZSB0YXJnZXQgbWlnaHQgYmUgbm8gbW9yZSBwYXJ0XG4gICAgICAgIC8vIG9mIHRoZSBlZGl0b3IncyBVSSAtIG9uQWN0aW9uUGVyZm9ybWVkIGNhdXNlcyByZS1yZW5kZXIuXG4gICAgICAgIHRoaXMuX21vdXNlZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRVSUhpZGRlbihldmVudC50YXJnZXQpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fa2V5RG93bkxpc3RlbmVyID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFVJSGlkZGVuKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9LCB0aGlzLnByb3BzLmV2ZW50c0RlbGF5LCB0aGlzKTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlEb3duTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuICAgICAqIEZpcmVzIGBhcmlhVXBkYXRlYCBldmVudCBwYXNzaW5nIEFSSUEgcmVsYXRlZCBtZXNzYWdlcy5cbiAgICAgKiBGaXJlcyBgZWRpdG9yVXBkYXRlYCBldmVudCBwYXNzaW5nIHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCBwcm9wZXJ0aWVzIGFuZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnYXJpYVVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLl9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2UoZG9tTm9kZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2VkaXRvclVwZGF0ZScsIHtcbiAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgcHJldlN0YXRlOiBwcmV2U3RhdGUsXG4gICAgICAgICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXRBcmlhVXBkYXRlVGVtcGxhdGUoYXJpYVVwZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2FyaWFVcGRhdGVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FyaWFVcGRhdGVUZW1wbGF0ZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlc1thcmlhVXBkYXRlXSkge1xuICAgICAgICAgICAgdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlc1thcmlhVXBkYXRlXSA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZSh0aGlzLl9nZXRBcmlhVXBkYXRlcygpW2FyaWFVcGRhdGVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlcyBmb3IgQVJJQSBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9nZXRBcmlhVXBkYXRlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gQVJJQSByZWxhdGVzIG1lc3NhZ2VzLiBEZWZhdWx0OlxuICAgICAqIHtcbiAgICAgKiAgICAgIG5vVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTm9Ub29sYmFyLFxuICAgICAqICAgICAgb25lVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlT25lVG9vbGJhcixcbiAgICAgKiAgICAgIG1hbnlUb29sYmFyczogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTWFueVRvb2xiYXJzXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBfZ2V0QXJpYVVwZGF0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmFyaWFVcGRhdGVzIHx8IHtcbiAgICAgICAgICAgIG5vVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTm9Ub29sYmFyLFxuICAgICAgICAgICAgb25lVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlT25lVG9vbGJhcixcbiAgICAgICAgICAgIG1hbnlUb29sYmFyczogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTWFueVRvb2xiYXJzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBUklBIG1lc3NhZ2Ugd2hpY2ggcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhdmFpbGFibGUgdG9vbGJhcnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAbWV0aG9kIF9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZG9tTm9kZSBUaGUgRE9NIG5vZGUgZnJvbSB3aGljaCB0aGUgYXZhaWxhYmxlIHRvb2xiYXJzIHdpbGwgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEFSSUEgbWVzc2FnZSBmb3IgdGhlIG51bWJlciBvZiBhdmFpbGFibGUgdG9vbGJhcnNcbiAgICAgKi9cbiAgICBfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlKGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIHRvb2xiYXJzTm9kZUxpc3QgPSBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbGJhclwiXScpO1xuXG4gICAgICAgIGlmICghdG9vbGJhcnNOb2RlTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBcmlhVXBkYXRlcygpLm5vVG9vbGJhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b29sYmFyTmFtZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0b29sYmFyc05vZGVMaXN0KS5tYXAoZnVuY3Rpb24odG9vbGJhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sYmFyLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhcmlhVXBkYXRlID0gdG9vbGJhck5hbWVzLmxlbmd0aCA9PT0gMSA/ICdvbmVUb29sYmFyJyA6ICdtYW55VG9vbGJhcnMnO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXJpYVVwZGF0ZVRlbXBsYXRlKGFyaWFVcGRhdGUpLm91dHB1dCh7XG4gICAgICAgICAgICAgICAgdG9vbGJhcnM6IHRvb2xiYXJOYW1lcy5qb2luKCcsJykucmVwbGFjZSgvLChbXixdKikkLywgJyBhbmQgJyArICckMScpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlZG93bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fa2V5RG93bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlEb3duTGlzdGVuZXIuZGV0YWNoKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5RG93bkxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGVkaXRvci4gVGhpcyBtYXkgaW5jbHVkZSBzZXZlcmFsIHRvb2xiYXJzIGFuZCBidXR0b25zLlxuICAgICAqIFRoZSBlZGl0b3IncyBVSSBhbHNvIHRha2VzIGNhcmUgb2YgcmVuZGVyaW5nIHRoZSBpdGVtcyBpbiBleGNsdXNpdmUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvb2xiYXJzID0gT2JqZWN0LmtleXModGhpcy5wcm9wcy50b29sYmFycykubWFwKGZ1bmN0aW9uKHRvb2xiYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBBbGxveUVkaXRvci5Ub29sYmFyc1t0b29sYmFyXSB8fCB3aW5kb3dbdG9vbGJhcl07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRvb2xiYXJzID0gdGhpcy5maWx0ZXJFeGNsdXNpdmUodG9vbGJhcnMpLm1hcChmdW5jdGlvbih0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoe1xuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5wcm9wcy50b29sYmFyc1t0b29sYmFyLmtleV0sXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLnByb3BzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBlZGl0b3JFdmVudDogdGhpcy5zdGF0ZS5lZGl0b3JFdmVudCxcbiAgICAgICAgICAgICAgICBrZXk6IHRvb2xiYXIua2V5LFxuICAgICAgICAgICAgICAgIG9uRGlzbWlzczogdGhpcy5fb25EaXNtaXNzVG9vbGJhckZvY3VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IHRoaXMuc3RhdGUuc2VsZWN0aW9uRGF0YVxuICAgICAgICAgICAgfSwgdG9vbGJhci5rZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh0b29sYmFyLCBwcm9wcyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtdG9vbGJhcnNcIiBvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgIHt0b29sYmFyc31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRvIHRoZSBlZGl0b3IncyBgYWN0aW9uUGVyZm9ybWVkYCBldmVudC4gU2V0cyBzdGF0ZSBhbmQgcmVkcmF3cyB0aGUgVUkgb2YgdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9vbkFjdGlvblBlcmZvcm1lZFxuICAgICAqIEBwYXJhbSB7U3ludGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50XG4gICAgICovXG4gICAgX29uQWN0aW9uUGVyZm9ybWVkKGV2ZW50KSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXRlbUV4Y2x1c2l2ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZWQgd2hlbiBhIGRpc21pc3Mga2V5IGlzIHByZXNzZWQgb3ZlciBhIHRvb2xiYXIgdG8gcmV0dXJuIHRoZSBmb2N1cyB0byB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX29uRGlzbWlzc1Rvb2xiYXJGb2N1c1xuICAgICAqL1xuICAgIF9vbkRpc21pc3NUb29sYmFyRm9jdXMoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRvIHRoZSBlZGl0b3IncyBgdXNlckludGVyYWN0aW9uYCBldmVudC4gUmV0cmlldmVzIHRoZSBkYXRhIGFib3V0IHRoZSB1c2VyIHNlbGVjdGlvbiBhbmRcbiAgICAgKiBwcm92aWRlcyBpdCB2aWEgY29tcG9uZW50J3Mgc3RhdGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfb25FZGl0b3JJbnRlcmFjdGlvblxuICAgICAqIEBwYXJhbSB7U3ludGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50XG4gICAgICovXG4gICAgX29uRWRpdG9ySW50ZXJhY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBlZGl0b3JFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgaXRlbUV4Y2x1c2l2ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IGV2ZW50LmRhdGEuc2VsZWN0aW9uRGF0YVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIG9uIHRoZSBhY3RpdmUgdG9vbGJhciB3aGVuIHRoZSBjb21iaW5hdGlvbiBBTFQrRjEwIGlzIHByZXNzZWQgaW5zaWRlIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfb25FZGl0b3JLZXlcbiAgICAgKi9cbiAgICBfb25FZGl0b3JLZXkoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS5kb21FdmVudC4kO1xuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5hbHRLZXkgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gMTIxKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHRhcmdldCB3aXRoIHdoaWNoIHRoZSB1c2VyIGludGVyYWN0ZWQgaXMgcGFydCBvZiBlZGl0b3IncyBVSSBvciBpdCBpc1xuICAgICAqIHRoZSBlZGl0YWJsZSBhcmVhLiBJZiBub25lIG9mIHRoZXNlLCBzZXRzIHRoZSBzdGF0ZSBvZiBlZGl0b3IncyBVSSB0byBiZSBoaWRkZW4uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfc2V0VUlIaWRkZW5cbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHRhcmdldCBUaGUgRE9NIGVsZW1lbnQgd2l0aCB3aGljaCB1c2VyIGludGVyYWN0ZWQgbGFzdGx5LlxuICAgICAqL1xuICAgIF9zZXRVSUhpZGRlbih0YXJnZXQpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuICAgICAgICBpZiAoZG9tTm9kZSkge1xuICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5lZGl0YWJsZSgpO1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gbmV3IENLRURJVE9SLmRvbS5ub2RlKHRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmICghZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSAoZWRpdGFibGUuJCA9PT0gdGFyZ2V0KSB8fCBlZGl0YWJsZS5jb250YWlucyh0YXJnZXROb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAobmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpKS5jb250YWlucyh0YXJnZXROb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcyB8fCBwYXJlbnROb2RlLmlkID09PSBcImNraW1ncnN6XCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIFVJXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5VSS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgZGVzY2VuZGFudHM6ICdbY2xhc3NePWFlLXRvb2xiYXItXScsXG4gICAgZXZlbnRzRGVsYXk6IDAsXG4gICAga2V5czoge1xuICAgICAgICBuZXh0OiA5XG4gICAgfVxufTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIGNvbXBvbmVudCB1cGRhdGVzIGFuZCB3aGVuIGl0IGlzIHJlbmRlcmVkIGluIHRoZSBET00uXG4gKiBUaGUgcGF5bG9hZCBjb25zaXN0cyBmcm9tIGEgYG1lc3NhZ2VgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIEFSSUEgbWVzc2FnZS5cbiAqXG4gKiBAZXZlbnQgYXJpYVVwZGF0ZVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBjb21wb25lbnQgdXBkYXRlcy4gVGhlIHBheWxvYWQgY29uc2lzdHMgZnJvbSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICogLSBwcmV2UHJvcHMgLSBUaGUgcHJldmlvdXMgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByZXZTdGF0ZSAtIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByb3BzIC0gVGhlIGN1cnJlbnQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBldmVudCBhcmlhVXBkYXRlXG4gKi9cblxuVUkucHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIExvY2FsaXplZCBtZXNzYWdlcyBmb3IgbGl2ZSBhcmlhIHVwZGF0ZXMuIFNob3VsZCBpbmNsdWRlIHRoZSBmb2xsb3dpbmcgbWVzc2FnZXM6XG4gICAgICogLSBub1Rvb2xiYXI6IE5vdGlmaWNhdGlvbiBmb3Igbm8gYXZhaWxhYmxlIHRvb2xiYXIgaW4gdGhlIGVkaXRvci5cbiAgICAgKiAtIG9uZVRvb2xiYXI6IE5vdGlmaWNhdGlvbiBmb3IganVzdCBvbmUgYXZhaWxhYmxlIHRvb2xiYXIgaW4gdGhlIGVkaXRvci5cbiAgICAgKiAtIG1hbnlUb29sYmFyczogTm90aWZpY2F0aW9uIGZvciBtb3JlIHRoYW4gb25lIGF2YWlsYWJsZSB0b29sYmFyIGluIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gYXJpYVVwZGF0ZXNcbiAgICAgKi9cbiAgICBhcmlhVXBkYXRlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaW5zdGFuY2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyBiZWluZyB1c2VkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGVkaXRvclxuICAgICAqL1xuICAgIGVkaXRvcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlbGF5IChtcyksIGFmdGVyIHdoaWNoIGtleSBvciBtb3VzZSBldmVudHMgd2lsbCBiZSBwcm9jZXNzZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZXZlbnRzRGVsYXlcbiAgICAgKi9cbiAgICBldmVudHNEZWxheTogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29sYmFycyBjb25maWd1cmF0aW9uIGZvciB0aGlzIGVkaXRvciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHRvb2xiYXJzXG4gICAgICovXG4gICAgdG9vbGJhcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0RXhjbHVzaXZlKFxuICAgIFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICAgICAgVUlcbikpOyIsImltcG9ydCBUb29sYmFyQWRkIGZyb20gJy4vdG9vbGJhci1hZGQuanN4JztcbmltcG9ydCBUb29sYmFyU3R5bGVzIGZyb20gJy4vdG9vbGJhci1zdHlsZXMuanN4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFtUb29sYmFyQWRkLmtleV06IFRvb2xiYXJBZGQsXG4gICAgW1Rvb2xiYXJTdHlsZXMua2V5XTogVG9vbGJhclN0eWxlc1xufTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgVG9vbGJhckJ1dHRvbnMgZnJvbSAnLi4vYmFzZS90b29sYmFyLWJ1dHRvbnMuanMnO1xuaW1wb3J0IFdpZGdldEFycm93Qm94IGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWFycm93LWJveC5qcyc7XG5pbXBvcnQgV2lkZ2V0RHJvcGRvd24gZnJvbSAnLi4vYmFzZS93aWRnZXQtZHJvcGRvd24uanMnO1xuaW1wb3J0IFdpZGdldEV4Y2x1c2l2ZSBmcm9tICcuLi9iYXNlL3dpZGdldC1leGNsdXNpdmUuanMnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcbmltcG9ydCBXaWRnZXRQb3NpdGlvbiBmcm9tICcuLi9iYXNlL3dpZGdldC1wb3NpdGlvbi5qcyc7XG5cbnZhciBQT1NJVElPTl9MRUZUID0gMTtcbnZhciBQT1NJVElPTl9SSUdIVCA9IDI7XG5cbi8qKlxuICogVGhlIFRvb2xiYXJBZGQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWRkaW5nIGNvbnRlbnQgdG8gdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckFkZFxuICogQHVzZXMgVG9vbGJhckJ1dHRvbnNcbiAqIEB1c2VzIFdpZGdldEFycm93Qm94XG4gKiBAdXNlcyBXaWRnZXREcm9wZG93blxuICogQHVzZXMgV2lkZ2V0RXhjbHVzaXZlXG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqIEB1c2VzIFdpZGdldFBvc2l0aW9uXG4gKi9cbmNsYXNzIFRvb2xiYXJBZGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnR7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50IChub3Qgb24gdGhlIHNlcnZlciksXG4gICAgICogaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRVcGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlByb3BzIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0YXRlIENvbXBvbmVudCdzIHByZXZpb3VzIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZXhjbHVzaXZlIHJlbmRlcmluZywgZm9jdXMgdGhlIGZpcnN0IGRlc2NlbmRhbnQgKGJ1dHRvbilcbiAgICAgICAgLy8gc28gdGhlIHVzZXIgd2lsbCBiZSBhYmxlIHRvIHN0YXJ0IGludGVyYWN0aW5nIHdpdGggdGhlIGJ1dHRvbnMgaW1tZWRpYXRlbHkuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBidXR0b25zIGZvciBhZGRpbmcgY29udGVudCBvciBoaWRlcyB0aGUgdG9vbGJhclxuICAgICAqIGlmIHVzZXIgaW50ZXJhY3RlZCB3aXRoIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIFNvbWUgb3BlcmF0aW9ucyBzdWNoIGFzIGByZXF1ZXN0RXhjbHVzaXZlYCBtYXkgZm9yY2UgZWRpdG9yIHRvIGJsdXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBpbnZhbGlkYXRlIHRoZSBgcHJvcHMuZWRpdG9yRXZlbnRgIHN0b3JlZCB2YWx1ZSwgd2l0aG91dCBjYXVzaW5nIGEgYHByb3BzYCBjaGFuZ2UuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBpZiB0aGUgZWRpdG9yIGlzIGVtcHR5LCBgYWVfcGxhY2Vob2xkZXJgIHBsdWdpbiB3aWxsIHJlbW92ZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IGZyb20gdGhlIERPTSBhbmQgd2lsbCBwcmV2ZW50IGBhZGRgIHRvb2xiYXIgZnJvbSByZW5kZXJpbmcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0IHNob3VsZCBiZSBzYWZlIHRvIGFzc3VtZSB0aGF0IGlmIHlvdSBoYXZlIGJlZW4gYWJsZSB0byByZW5kZXIgdGhlIHRvb2xiYXJcbiAgICAgICAgLy8gYW5kIHJlcXVlc3QgdGhlIGV4Y2x1c2l2ZSBtb2RlLCB0aGVuIHJlbmRlcmluZyBtaWdodCBiZSBrZXB0IHVudGlsIHRoZSBleGNsdXNpdmUgbW9kZSBpcyBsZWZ0LlxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZWRpdG9yRXZlbnQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGEubmF0aXZlRXZlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YS5uYXRpdmVFdmVudC50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1dHRvbnMgPSB0aGlzLl9nZXRCdXR0b25zKCk7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLl9nZXRUb29sYmFyQ2xhc3NOYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hZGR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBkYXRhLXRhYmluZGV4PXt0aGlzLnByb3BzLmNvbmZpZy50YWJJbmRleCB8fCAwfSBvbkZvY3VzPXt0aGlzLmZvY3VzLmJpbmQodGhpcyl9IG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKX0gcm9sZT1cInRvb2xiYXJcIiB0YWJJbmRleD1cIi0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbnN9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBidXR0b25zIHRoYXQgd2lsbCBldmVudHVhbGx5IHJlbmRlciB0byBIVE1MLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIF9nZXRCdXR0b25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGJ1dHRvbnMgd2hpY2ggaGF2ZSB0byBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBfZ2V0QnV0dG9ucygpIHtcbiAgICAgICAgdmFyIGJ1dHRvbnM7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBidXR0b25zID0gdGhpcy5nZXRUb29sYmFyQnV0dG9ucyh0aGlzLnByb3BzLmNvbmZpZy5idXR0b25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEgJiYgdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbikge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAoXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hZGR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1idXR0b24tYWRkXCIgb25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcywgVG9vbGJhckFkZC5rZXkpfSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hZGR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hZGRcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnV0dG9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGFzcyBuYW1lIG9mIHRoZSB0b29sYmFyIGluIGNhc2Ugb2YgYm90aCBleGNsdXNpdmUgYW5kIG5vcm1hbCBtb2RlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIF9nZXRUb29sYmFyQ2xhc3NOYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNsYXNzIG5hbWUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0VG9vbGJhckNsYXNzTmFtZSgpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLXRvb2xiYXItYWRkJztcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGNzc0NsYXNzID0gJ2FlLXRvb2xiYXIgJyArIHRoaXMuZ2V0QXJyb3dCb3hDbGFzc2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzQ2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgaW4gZXhjbHVzaXZlIG9yIG5vcm1hbCBtb2RlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVQb3NpdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIHZhciByZWdpb247XG5cbiAgICAgICAgLy8gSWYgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmICghUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uID0gdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlZ2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGFydFJlY3QgPSByZWdpb24uc3RhcnRSZWN0IHx8IHJlZ2lvbjtcblxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBuYXRpdmVFZGl0b3IuZWRpdGFibGUoKS5nZXRDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdDtcblxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucHJvcHMuY29uZmlnLnBvc2l0aW9uIHx8IHRoaXMucHJvcHMucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFBPU0lUSU9OX0xFRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IGNsaWVudFJlY3QubGVmdCAtIGRvbU5vZGUub2Zmc2V0V2lkdGggLSB0aGlzLnByb3BzLmd1dHRlckV4Y2x1c2l2ZS5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gY2xpZW50UmVjdC5yaWdodCArIHRoaXMucHJvcHMuZ3V0dGVyRXhjbHVzaXZlLmxlZnQgKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUubGVmdCA9IG9mZnNldExlZnQ7XG5cbiAgICAgICAgICAgICAgICBkb21Ob2RlLnN0eWxlLnRvcCA9IE1hdGguZmxvb3IoKHJlZ2lvbi5ib3R0b20gKyByZWdpb24udG9wKSAvIDIpICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVpTm9kZSA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgndWlOb2RlJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSB1aU5vZGUgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFZGl0b3IuZWxlbWVudC5nZXRTdHlsZSgnb3ZlcmZsb3cnKSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUudG9wID0gTWF0aC5mbG9vcihyZWdpb24udG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQvMiArIChzdGFydFJlY3QuaGVpZ2h0LzIpICsgc2Nyb2xsVG9wKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS50b3AgPSBNYXRoLmZsb29yKG5hdGl2ZUVkaXRvci5lbGVtZW50LiQub2Zmc2V0VG9wICsgKHN0YXJ0UmVjdC5oZWlnaHQgLyAyKSAtIChkb21Ob2RlLm9mZnNldEhlaWdodCAvIDIpKSArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS5vcGFjaXR5ID0gMTtcblxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2FlLWFycm93LWJveCcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBhZGRcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJBZGQua2V5ID0gJ2FkZCc7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY29uc3RhbnQgZm9yIHBvc2l0aW9uaW5nIHRoZSBUb29sYmFyIG9uIGxlZnQgb2YgdGhlIGVkaXRhYmxlIGFyZWEuXG4gKlxuICogQGRlZmF1bHQgMVxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsZWZ0XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJBZGQubGVmdCA9IFBPU0lUSU9OX0xFRlQ7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY29uc3RhbnQgZm9yIHBvc2l0aW9uaW5nIHRoZSBUb29sYmFyIG9uIHJpZ2h0IG9mIHRoZSBlZGl0YWJsZSBhcmVhLlxuICpcbiAqIEBkZWZhdWx0IDJcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmlnaHRcbiAqIEBzdGF0aWNcbiAqL1xuVG9vbGJhckFkZC5yaWdodCA9IFBPU0lUSU9OX1JJR0hUO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cblRvb2xiYXJBZGQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIGRlc2NlbmRhbnRzOiAnLmFlLWJ1dHRvbicsXG4gICAgZ3V0dGVyRXhjbHVzaXZlOiB7XG4gICAgICAgIGxlZnQ6IDEwLFxuICAgICAgICB0b3A6IDBcbiAgICB9LFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgbmV4dDogWzM5LCA0MF0sXG4gICAgICAgIHByZXY6IFszNywgMzhdXG4gICAgfSxcbiAgICBwb3NpdGlvbjogUE9TSVRJT05fTEVGVFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0QXJyb3dCb3goXG4gICAgV2lkZ2V0RHJvcGRvd24oXG4gICAgV2lkZ2V0RXhjbHVzaXZlKFxuICAgIFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBXaWRnZXRQb3NpdGlvbihcbiAgICBUb29sYmFyQnV0dG9ucyhcbiAgICAgICAgVG9vbGJhckFkZFxuKSkpKSkpOyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBUb29sYmFyQnV0dG9ucyBmcm9tICcuLi9iYXNlL3Rvb2xiYXItYnV0dG9ucy5qcyc7XG5pbXBvcnQgV2lkZ2V0QXJyb3dCb3ggZnJvbSAnLi4vYmFzZS93aWRnZXQtYXJyb3ctYm94LmpzJztcbmltcG9ydCBXaWRnZXREcm9wZG93biBmcm9tICcuLi9iYXNlL3dpZGdldC1kcm9wZG93bi5qcyc7XG5pbXBvcnQgV2lkZ2V0RXhjbHVzaXZlIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZS5qcyc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFdpZGdldFBvc2l0aW9uIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LXBvc2l0aW9uLmpzJztcblxuLyoqXG4gKiBUaGUgVG9vbGJhclN0eWxlcyBjbGFzcyBob3N0cyB0aGUgYnV0dG9ucyBmb3Igc3R5bGluZyBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBUb29sYmFyU3R5bGVzXG4gKiBAdXNlcyBUb29sYmFyQnV0dG9uc1xuICogQHVzZXMgV2lkZ2V0QXJyb3dCb3hcbiAqIEB1c2VzIFdpZGdldERyb3Bkb3duXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICogQHVzZXMgV2lkZ2V0UG9zaXRpb25cbiAqL1xuY2xhc3MgVG9vbGJhclN0eWxlcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQgKG5vdCBvbiB0aGUgc2VydmVyKSxcbiAgICAgKiBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQncyB1cGRhdGVzIGFyZSBmbHVzaGVkIHRvIHRoZSBET00uXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2UHJvcHMgVGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3RhdGUgQ29tcG9uZW50J3MgcHJldmlvdXMgc3RhdGUuXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBidXR0b25zIGZvciBhZGRpbmcgY29udGVudCBvciBoaWRlcyB0aGUgdG9vbGJhclxuICAgICAqIGlmIHVzZXIgaW50ZXJhY3RlZCB3aXRoIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gdGhpcy5fZ2V0Q3VycmVudFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZ2V0QXJyb3dCb3hDbGFzc2VzRm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihjdXJyZW50U2VsZWN0aW9uLmdldEFycm93Qm94Q2xhc3Nlcyk7XG4gICAgICAgICAgICB2YXIgYXJyb3dCb3hDbGFzc2VzO1xuXG4gICAgICAgICAgICBpZiAoZ2V0QXJyb3dCb3hDbGFzc2VzRm4pIHtcbiAgICAgICAgICAgICAgICBhcnJvd0JveENsYXNzZXMgPSBnZXRBcnJvd0JveENsYXNzZXNGbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJvd0JveENsYXNzZXMgPSB0aGlzLmdldEFycm93Qm94Q2xhc3NlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3NzQ2xhc3NlcyA9ICdhZS10b29sYmFyLXN0eWxlcyAnICsgYXJyb3dCb3hDbGFzc2VzO1xuXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IGN1cnJlbnRTZWxlY3Rpb24uYnV0dG9ucztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBidXR0b25zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShidXR0b25zKSkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSBidXR0b25zW3RoaXMucHJvcHMuZWRpdG9yLmdldCgnbW9kZScpXSB8fCBidXR0b25zWydzaW1wbGUnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJ1dHRvbnNHcm91cCA9IHRoaXMuZ2V0VG9vbGJhckJ1dHRvbkdyb3VwcyhcbiAgICAgICAgICAgICAgICBidXR0b25zLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFudWFsU2VsZWN0aW9uOiB0aGlzLnByb3BzLmVkaXRvckV2ZW50ID8gdGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhLm1hbnVhbFNlbGVjdGlvbiA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblR5cGU6IGN1cnJlbnRTZWxlY3Rpb24ubmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBoYXNHcm91cHMgPSBidXR0b25zR3JvdXAuZmlsdGVyKGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGJ1dHRvbik7XG4gICAgICAgICAgICB9KS5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ2FlLWNvbnRhaW5lcic7XG5cbiAgICAgICAgICAgIGlmIChoYXNHcm91cHMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBhZS1jb250YWluZXItY29sdW1uJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzfSBjbGFzc05hbWU9e2Nzc0NsYXNzZXN9IGRhdGEtdGFiaW5kZXg9e3RoaXMucHJvcHMuY29uZmlnLnRhYkluZGV4IHx8IDB9IG9uRm9jdXM9e3RoaXMuZm9jdXMuYmluZCh0aGlzKX0gb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpfSByb2xlPVwidG9vbGJhclwiIHRhYkluZGV4PVwiLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uc0dyb3VwLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLXJvd1wiIGtleT17aW5kZXgudG9TdHJpbmcoKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm1hcChmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIGZ1bmN0aW9uIGZyb20gU3RyaW5nLiBJdCBjb252ZXJ0cyBhIGZ1bGx5IHF1YWxpZmllZCBzdHJpbmcgaW50byB0aGUgbWFwcGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIF9nZXRTZWxlY3Rpb25GdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBzZWxlY3Rpb25GbiBBIGZ1bmN0aW9uLCBvciBhIGZ1bGx5IHF1YWxpZmllZCBzdHJpbmcgcG9pbnRpbmcgdG8gdGhlIGRlc2lyZWQgb25lIChlLmcuICdBbGxveUVkaXRvci5TZWxlY3Rpb25UZXN0LmltYWdlJykuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbWFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRTZWxlY3Rpb25GdW5jdGlvbihzZWxlY3Rpb25Gbikge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRnVuY3Rpb247XG5cbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzZWxlY3Rpb25GbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbkZ1bmN0aW9uID0gc2VsZWN0aW9uRm47XG5cbiAgICAgICAgfSBlbHNlIGlmIChMYW5nLmlzU3RyaW5nKHNlbGVjdGlvbkZuKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gc2VsZWN0aW9uRm4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWVtYmVyID0gd2luZG93O1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgd2hpbGUgKHByb3BlcnR5ICYmIExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiYgTGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKGN1cnJlbnRNZW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRnVuY3Rpb24gPSBjdXJyZW50TWVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkZ1bmN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5emVzIHRoZSBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24gYW5kIHJldHVybnMgdGhlIHNlbGVjdGlvbiBjb25maWd1cmF0aW9uIHRoYXQgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gICAgICogQG1ldGhvZCBfZ2V0Q3VycmVudFNlbGVjdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYXRjaGVkIHNlbGVjdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIF9nZXRDdXJyZW50U2VsZWN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnRQYXlsb2FkID0gdGhpcy5wcm9wcy5lZGl0b3JFdmVudCA/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YSA6IG51bGw7XG4gICAgICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKGV2ZW50UGF5bG9hZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5jb25maWcuc2VsZWN0aW9ucy5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdEZuID0gdGhpcy5fZ2V0U2VsZWN0aW9uRnVuY3Rpb24oaXRlbS50ZXN0KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRlc3RGbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmVudFBheWxvYWQubWFudWFsU2VsZWN0aW9uID09PSBpdGVtLm5hbWUgfHzCoHRlc3RGbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBldmVudFBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVQb3NpdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIC8vIElmIGNvbXBvbmVudCBpcyBub3QgbW91bnRlZCwgdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoIVJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuX2dldEN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyBJZiBjdXJyZW50IHNlbGVjdGlvbiBoYXMgYSBmdW5jdGlvbiBjYWxsZWQgYHNldFBvc2l0aW9uYCwgY2FsbCBpdFxuICAgICAgICAvLyBhbmQgY2hlY2sgdGhlIHJldHVybmVkIHZhbHVlLiBJZiBmYWxzZSwgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb25pbmcgbG9naWMuXG4gICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2V0UG9zaXRpb25GbiA9IHRoaXMuX2dldFNlbGVjdGlvbkZ1bmN0aW9uKGN1cnJlbnRTZWxlY3Rpb24uc2V0UG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoc2V0UG9zaXRpb25Gbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldFBvc2l0aW9uRm4uY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5wcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvckV2ZW50OiB0aGlzLnByb3BzLmVkaXRvckV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25EYXRhOiB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5Ub29sYmFyU3R5bGVzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS1pbnB1dCwgLmFlLWJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIC5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgbmV4dDogWzM5LCA0MF0sXG4gICAgICAgIHByZXY6IFszNywgMzhdXG4gICAgfVxufTtcblxuLyoqXG4qIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuKlxuKiBAZGVmYXVsdCBzdHlsZXNcbiogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuKiBAc3RhdGljXG4qL1xuVG9vbGJhclN0eWxlcy5rZXkgPSAnc3R5bGVzJztcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0QXJyb3dCb3goXG4gICAgV2lkZ2V0RHJvcGRvd24oXG4gICAgV2lkZ2V0RXhjbHVzaXZlKFxuICAgIFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBXaWRnZXRQb3NpdGlvbihcbiAgICBUb29sYmFyQnV0dG9ucyhcbiAgICAgICAgVG9vbGJhclN0eWxlc1xuKSkpKSkpOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3JlYXRlUmVhY3RDbGFzcyBmcm9tICdjcmVhdGUtcmVhY3QtY2xhc3MnO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9idXR0b25icmlkZ2UnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge31cblxuICAgIC8vIEFQSSBub3QgeWV0IGltcGxlbWVudGVkIGluc2lkZSB0aGUgYnV0dG9uIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kcywgd2VcbiAgICAvLyBwcmV2ZW50IHBsdWdpbnMgZnJvbSBjcmFzaGluZyBpZiB0aGV5IG1ha2UgdXNlIG9mIHRoZW0uXG4gICAgLy9cbiAgICAvLyBTb21lIG1ldGhvZHMgbGlrZSBgZ2V0U3RhdGVgIGFuZCBgc2V0U3RhdGVgIGNsYXNoIHdpdGggUmVhY3QncyBvd24gc3RhdGUgbWV0aG9kcy4gRm9yIHRoZW0sXG4gICAgLy8gdW5zdXBwb3J0ZWQgbWVhbnMgdGhhdCB3ZSBkb24ndCBhY2NvdW50IGZvciB0aGUgZGlmZmVyZW50IG1lYW5pbmcgaW4gdGhlIHBhc3NlZCBvciByZXR1cm5lZFxuICAgIC8vIGFyZ3VtZW50cy5cbiAgICB2YXIgVU5TVVBQT1JURURfQlVUVE9OX0FQSSA9IHtcbiAgICAgICAgLy9nZXRTdGF0ZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgLy9zZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHt9LFxuICAgICAgICB0b0ZlYXR1cmU6IG5vb3BcbiAgICB9O1xuXG4gICAgdmFyIEJVVFRPTl9ERUZTID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBCdXR0b25CcmlkZ2UgUmVhY3QgY2xhc3MgZm9yIGEgZ2l2ZW4gYnV0dG9uIGRlZmluaXRpb24gaWYgaXQgaGFzIG5vdCBiZWVuXG4gICAgICogYWxyZWFkeSBjcmVhdGVkIGJhc2VkIG9uIHRoZSBidXR0b24gbmFtZSBhbmQgZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBnZW5lcmF0ZUJ1dHRvbkJyaWRnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b25OYW1lIFRoZSBidXR0b24ncyBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJ1dHRvbkRlZmluaXRpb24gVGhlIGJ1dHRvbidzIGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBCdXR0b24gQ2xhc3NcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQnV0dG9uQnJpZGdlKGJ1dHRvbk5hbWUsIGJ1dHRvbkRlZmluaXRpb24sIGVkaXRvcikge1xuICAgICAgICB2YXIgQnV0dG9uQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b25OYW1lXTtcblxuICAgICAgICBCVVRUT05fREVGU1tlZGl0b3IubmFtZV0gPSBCVVRUT05fREVGU1tlZGl0b3IubmFtZV0gfHwge307XG4gICAgICAgIEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXSA9IEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXSB8fCBidXR0b25EZWZpbml0aW9uO1xuXG4gICAgICAgIGlmICghQnV0dG9uQnJpZGdlKSB7XG4gICAgICAgICAgICBCdXR0b25CcmlkZ2UgPSBjcmVhdGVSZWFjdENsYXNzKFxuICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLm1lcmdlKFVOU1VQUE9SVEVEX0JVVFRPTl9BUEksIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGJ1dHRvbk5hbWUsXG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljczoge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBidXR0b25OYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NOYW1lID0gJ2FlLWJ1dHRvbiBhZS1idXR0b24tYnJpZGdlJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkRpc3BsYXlOYW1lID0gQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLm5hbWUgfHwgQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLmNvbW1hbmQgfHwgYnV0dG9uTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkxhYmVsID0gQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLmxhYmVsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uVHlwZSA9ICdidXR0b24tJyArIGJ1dHRvbkRpc3BsYXlOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWNvbkNsYXNzTmFtZSA9ICdhZS1pY29uLScgKyBidXR0b25EaXNwbGF5TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGljb25TdHlsZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzU3R5bGUgPSBDS0VESVRPUi5za2luLmdldEljb25TdHlsZShidXR0b25EaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3NTdHlsZVBhcnRzID0gY3NzU3R5bGUuc3BsaXQoJzsnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBjc3NTdHlsZVBhcnRzWzBdLnN1YnN0cmluZyhjc3NTdHlsZVBhcnRzWzBdLmluZGV4T2YoJzonKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjc3NTdHlsZVBhcnRzWzFdLnN1YnN0cmluZyhjc3NTdHlsZVBhcnRzWzFdLmluZGV4T2YoJzonKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGNzc1N0eWxlUGFydHNbMl0uc3Vic3RyaW5nKGNzc1N0eWxlUGFydHNbMl0uaW5kZXhPZignOicpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtidXR0b25MYWJlbH0gY2xhc3NOYW1lPXtidXR0b25DbGFzc05hbWV9IGRhdGEtdHlwZT17YnV0dG9uVHlwZX0gb25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17YnV0dG9uTGFiZWx9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2ljb25DbGFzc05hbWV9IHN0eWxlPXtpY29uU3R5bGV9Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgX2hhbmRsZUNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25Db21tYW5kID0gQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLmNvbW1hbmQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25PbkNsaWNrID0gQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLm9uQ2xpY2s7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25PbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uT25DbGljay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoYnV0dG9uQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbk5hbWVdID0gQnV0dG9uQnJpZGdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJ1dHRvbkJyaWRnZTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2J1dHRvbicpKSB7XG4gICAgICAgIENLRURJVE9SLlVJX0JVVFRPTiA9ICdidXR0b24nO1xuXG4gICAgICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdidXR0b24nLCB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHRoYXQgYnJpZGdlcyB0aGUgc3VwcG9ydCBvZmZlcmVkIGJ5IENLRWRpdG9yIEJ1dHRvbiBwbHVnaW4uIEl0IHRha2VzIG92ZXIgdGhlXG4gICAgICogcmVzcG9uc2liaWxpdHkgb2YgcmVnaXN0ZXJpbmcgYW5kIGNyZWF0aW5nIGJ1dHRvbnMgdmlhOlxuICAgICAqIC0gZWRpdG9yLnVpLmFkZEJ1dHRvbihuYW1lLCBkZWZpbml0aW9uKVxuICAgICAqIC0gZWRpdG9yLnVpLmFkZChuYW1lLCBDS0VESVRPUi5VSV9CVVRUT04sIGRlZmluaXRpb24pXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9idXR0b25icmlkZ2VcbiAgICAgKiBAcmVxdWlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV91aWJyaWRnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9idXR0b25icmlkZ2UnLCB7XG4gICAgICAgIHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgYWRkIGhhbmRsZXIgZm9yIFVJX0JVVFRPTiB0byBvdXIgb3duLiBXZSBkbyB0aGlzIGluIHRoZSBpbml0IHBoYXNlIHRvIG92ZXJyaWRlXG4gICAgICAgICAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlSW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3IudWkuYWRkQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uTmFtZSwgYnV0dG9uRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGJ1dHRvbk5hbWUsIENLRURJVE9SLlVJX0JVVFRPTiwgYnV0dG9uRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlZGl0b3IudWkuYWRkSGFuZGxlcihDS0VESVRPUi5VSV9CVVRUT04sIHtcbiAgICAgICAgICAgICAgICBhZGQ6IGdlbmVyYXRlQnV0dG9uQnJpZGdlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oYnV0dG9uRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uTmFtZSA9ICdidXR0b25CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBCdXR0b25CcmlkZ2UgPSBnZW5lcmF0ZUJ1dHRvbkJyaWRnZShidXR0b25OYW1lLCBidXR0b25EZWZpbml0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1dHRvbkJyaWRnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59KCkpO1xuIiwiaW1wb3J0IGJ1dHRvbiBmcm9tICcuL2J1dHRvbi5qc3gnO1xuaW1wb3J0IG1lbnVCdXR0b24gZnJvbSAnLi9tZW51LWJ1dHRvbi5qc3gnO1xuaW1wb3J0IG1lbnUgZnJvbSAnLi9tZW51LmpzeCc7XG5pbXBvcnQgcGFuZWxNZW51QnV0dG9uIGZyb20gJy4vcGFuZWwtbWVudS1idXR0b24uanN4JztcbmltcG9ydCByaWNoY29tYm8gZnJvbSAnLi9yaWNoY29tYm8uanN4JztcbmltcG9ydCB1aWJyaWRnZSBmcm9tICcuL3VpYnJpZGdlJztcblxuZXhwb3J0IHtcbiAgICBidXR0b24sXG4gICAgbWVudUJ1dHRvbixcbiAgICBtZW51LFxuICAgIHBhbmVsTWVudUJ1dHRvbixcbiAgICByaWNoY29tYm8sXG4gICAgdWlicmlkZ2Vcbn07IiwiaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNyZWF0ZVJlYWN0Q2xhc3MgZnJvbSAnY3JlYXRlLXJlYWN0LWNsYXNzJztcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfbWVudWJ1dHRvbmJyaWRnZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gICAgLy8gQVBJIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW5zaWRlIHRoZSBtZW51YnV0dG9uIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kcywgd2VcbiAgICAvLyBwcmV2ZW50IHBsdWdpbnMgZnJvbSBjcmFzaGluZyBpZiB0aGV5IG1ha2UgdXNlIG9mIHRoZW0uXG4gICAgLy9cbiAgICAvLyBTb21lIG1ldGhvZHMgbGlrZSBgZ2V0U3RhdGVgIGFuZCBgc2V0U3RhdGVgIGNsYXNoIHdpdGggUmVhY3QncyBvd24gc3RhdGUgbWV0aG9kcy4gRm9yIHRoZW0sXG4gICAgLy8gdW5zdXBwb3J0ZWQgbWVhbnMgdGhhdCB3ZSBkb24ndCBhY2NvdW50IGZvciB0aGUgZGlmZmVyZW50IG1lYW5pbmcgaW4gdGhlIHBhc3NlZCBvciByZXR1cm5lZFxuICAgIC8vIGFyZ3VtZW50cy5cbiAgICB2YXIgVU5TVVBQT1JURURfTUVOVUJVVFRPTl9BUEkgPSB7XG4gICAgICAgIC8vZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIC8vc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7fSxcbiAgICAgICAgdG9GZWF0dXJlOiBub29wXG4gICAgfTtcblxuICAgIHZhciBNRU5VQlVUVE9OX0RFRlMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIE1lbnVCdXR0b25CcmlkZ2UgUmVhY3QgY2xhc3MgZm9yIGEgZ2l2ZW4gbWVudUJ1dHRvbiBkZWZpbml0aW9uIGlmIGl0IGhhcyBub3QgYmVlblxuICAgICAqIGFscmVhZHkgY3JlYXRlZCBiYXNlZCBvbiB0aGUgYnV0dG9uIG5hbWUgYW5kIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgZ2VuZXJhdGVNZW51QnV0dG9uQnJpZGdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lbnVCdXR0b25OYW1lIFRoZSBtZW51QnV0dG9uJ3MgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZW51QnV0dG9uRGVmaW5pdGlvbiBUaGUgbWVudUJ1dHRvbidzIGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBNZW51QnV0dG9uIENsYXNzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVNZW51QnV0dG9uQnJpZGdlKG1lbnVCdXR0b25OYW1lLCBtZW51QnV0dG9uRGVmaW5pdGlvbiwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBNZW51QnV0dG9uQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1ttZW51QnV0dG9uTmFtZV07XG5cbiAgICAgICAgTUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXSA9IE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV0gfHwge307XG4gICAgICAgIE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bbWVudUJ1dHRvbk5hbWVdID0gTUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV0gfHwgbWVudUJ1dHRvbkRlZmluaXRpb247XG5cbiAgICAgICAgaWYgKCFNZW51QnV0dG9uQnJpZGdlKSB7XG4gICAgICAgICAgICBNZW51QnV0dG9uQnJpZGdlID0gY3JlYXRlUmVhY3RDbGFzcyhcbiAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5tZXJnZShVTlNVUFBPUlRFRF9NRU5VQlVUVE9OX0FQSSwge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbWVudUJ1dHRvbk5hbWUsXG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljczoge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBtZW51QnV0dG9uTmFtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lID0gTUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV0ubmFtZSB8fCBNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXS5jb21tYW5kIHx8IG1lbnVCdXR0b25OYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NOYW1lID0gJ2FlLWJ1dHRvbiBhZS1idXR0b24tYnJpZGdlJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGljb25DbGFzc05hbWUgPSAnYWUtaWNvbi0nICsgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpY29uU3R5bGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1N0eWxlID0gQ0tFRElUT1Iuc2tpbi5nZXRJY29uU3R5bGUocGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzU3R5bGVQYXJ0cyA9IGNzc1N0eWxlLnNwbGl0KCc7Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3R5bGUuYmFja2dyb3VuZEltYWdlID0gY3NzU3R5bGVQYXJ0c1swXS5zdWJzdHJpbmcoY3NzU3R5bGVQYXJ0c1swXS5pbmRleE9mKCc6JykgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gY3NzU3R5bGVQYXJ0c1sxXS5zdWJzdHJpbmcoY3NzU3R5bGVQYXJ0c1sxXS5pbmRleE9mKCc6JykgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3R5bGUuYmFja2dyb3VuZFNpemUgPSBjc3NTdHlsZVBhcnRzWzJdLnN1YnN0cmluZyhjc3NTdHlsZVBhcnRzWzJdLmluZGV4T2YoJzonKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9e01FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bbWVudUJ1dHRvbk5hbWVdLmxhYmVsfSBjbGFzc05hbWU9e2J1dHRvbkNsYXNzTmFtZX0gb25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0gcm9sZT1cImNvbWJvYm94XCIgdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXS5sYWJlbH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2ljb25DbGFzc05hbWV9IHN0eWxlPXtpY29uU3R5bGV9Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmV4cGFuZGVkICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25Ecm9wZG93biBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLl9nZXRNZW51SXRlbXMoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uRHJvcGRvd24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIF9nZXRNZW51SXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBtZW51QnV0dG9uRGVmaW5pdGlvbi5vbk1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZW51SXRlbXMgPSBPYmplY3Qua2V5cyhpdGVtcykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZW51SXRlbSA9IGVkaXRvci5nZXRNZW51SXRlbShrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW51SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVudUl0ZW1EZWZpbml0aW9uID0gbWVudUl0ZW0uZGVmaW5pdGlvbiB8fCBtZW51SXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVudUl0ZW1TdGF0ZSA9IGl0ZW1zW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ2FlLXRvb2xiYXItZWxlbWVudCAnICsgKG1lbnVJdGVtU3RhdGUgPT09IENLRURJVE9SLlRSSVNUQVRFX09OID8gJ2FjdGl2ZScgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gbWVudUl0ZW1TdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfRElTQUJMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtRGVmaW5pdGlvbi5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQobWVudUl0ZW1EZWZpbml0aW9uLmNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lbnVJdGVtRGVmaW5pdGlvbi5vbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51SXRlbURlZmluaXRpb24ub25DbGljay5hcHBseShtZW51SXRlbURlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e21lbnVJdGVtLm5hbWV9IHJvbGU9XCJvcHRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGRpc2FibGVkPXtkaXNhYmxlZH0gb25DbGljaz17b25DbGlja30+e21lbnVJdGVtRGVmaW5pdGlvbi5sYWJlbH08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbnVJdGVtcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBBbGxveUVkaXRvci5CdXR0b25zW21lbnVCdXR0b25OYW1lXSA9IE1lbnVCdXR0b25CcmlkZ2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWVudUJ1dHRvbkJyaWRnZTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ21lbnVidXR0b24nKSkge1xuICAgICAgICBDS0VESVRPUi5VSV9NRU5VX0JVVFRPTiA9ICdtZW51YnV0dG9uJztcblxuICAgICAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgnbWVudWJ1dHRvbicsIHt9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgTWVudUJ1dHRvbiBwbHVnaW4uIEl0IHRha2VzIG92ZXIgdGhlXG4gICAgICogcmVzcG9uc2liaWxpdHkgb2YgcmVnaXN0ZXJpbmcgYW5kIGNyZWF0aW5nIG1lbnVCdXR0b25zIHZpYTpcbiAgICAgKiAtIGVkaXRvci51aS5hZGRNZW51QnV0dG9uKG5hbWUsIGRlZmluaXRpb24pXG4gICAgICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIENLRURJVE9SLlVJX01FTlVCVVRUT04sIGRlZmluaXRpb24pXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9tZW51YnV0dG9uYnJpZGdlXG4gICAgICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2VcbiAgICAgKiBAcmVxdWlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9tZW51YnJpZGdlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX21lbnVidXR0b25icmlkZ2UnLCB7XG4gICAgICAgIHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJywgJ2FlX21lbnVicmlkZ2UnXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfTUVOVUJVVFRPTiB0byBvdXIgb3duLiBXZSBkbyB0aGlzIGluIHRoZSBpbml0IHBoYXNlIHRvIG92ZXJyaWRlXG4gICAgICAgICAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlSW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3IudWkuYWRkTWVudUJ1dHRvbiA9IGZ1bmN0aW9uKG1lbnVCdXR0b25OYW1lLCBtZW51QnV0dG9uRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKG1lbnVCdXR0b25OYW1lLCBDS0VESVRPUi5VSV9NRU5VQlVUVE9OLCBtZW51QnV0dG9uRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlZGl0b3IudWkuYWRkSGFuZGxlcihDS0VESVRPUi5VSV9NRU5VQlVUVE9OLCB7XG4gICAgICAgICAgICAgICAgYWRkOiBnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UsXG4gICAgICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihtZW51QnV0dG9uRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVudUJ1dHRvbk5hbWUgPSAnYnV0dG9uQnJpZGdlJyArICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTWVudUJ1dHRvbkJyaWRnZSA9IGdlbmVyYXRlTWVudUJ1dHRvbkJyaWRnZShtZW51QnV0dG9uTmFtZSwgbWVudUJ1dHRvbkRlZmluaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVudUJ1dHRvbkJyaWRnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfbWVudWJyaWRnZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgTWVudSBwbHVnaW4uIEl0IHRha2VzIG92ZXIgdGhlXG4gICAgICogcmVzcG9uc2liaWxpdHkgb2YgYWRkaW5nLCByZW1vdmluZyBhbmQgcmV0cmlldmluZyBtZW51IGdyb3VwcyBhbmQgaXRlbXNcbiAgICAgKiAtIGVkaXRvci5hZGRNZW51R3JvdXAobmFtZSwgb3JkZXIpXG4gICAgICogLSBlZGl0b3IuYWRkTWVudUl0ZW0obmFtZSwgZGVmaW5pdGlvbilcbiAgICAgKiAtIGVkaXRvci5hZGRNZW51SXRlbXMoZGVmaW5pdGlvbnMpXG4gICAgICogLSBlZGl0b3IuZ2V0TWVudUl0ZW0obmFtZSlcbiAgICAgKiAtIGVkaXRvci5yZW1vdmVNZW51SXRlbShuYW1lKVxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfbWVudWJyaWRnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9tZW51YnJpZGdlJywge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfQlVUVE9OIHRvIG91ciBvd24uIFdlIGRvIHRoaXMgaW4gdGhlIGluaXQgcGhhc2UgdG8gb3ZlcnJpZGVcbiAgICAgICAgICogdGhlIG9uZSBpbiB0aGUgbmF0aXZlIHBsdWdpbiBpbiBjYXNlIGl0J3MgcHJlc2VudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlIGJlaW5nIGluaXRpYWxpemVkXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVJbml0OiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSByZWFsIG1lbnUgcGx1Z2luIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnbWVudScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgICAgICB2YXIgZ3JvdXBzT3JkZXIgPSBlZGl0b3IuXy5tZW51R3JvdXBzID0ge307XG4gICAgICAgICAgICB2YXIgbWVudUl0ZW1zID0gZWRpdG9yLl8ubWVudUl0ZW1zID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzT3JkZXJbZ3JvdXBzW2ldXSA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlZ2lzdGVycyBhbiBpdGVtIGdyb3VwIHRvIHRoZSBlZGl0b3IgY29udGV4dCBtZW51IGluIG9yZGVyIHRvIG1ha2UgaXRcbiAgICAgICAgICAgICAqIHBvc3NpYmxlIHRvIGFzc29jaWF0ZSBpdCB3aXRoIG1lbnUgaXRlbXMgbGF0ZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRNZW51R3JvdXBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFNwZWNpZnkgYSBncm91cCBuYW1lLlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcj0xMDBdIERlZmluZSB0aGUgZGlzcGxheSBzZXF1ZW5jZSBvZiB0aGlzIGdyb3VwXG4gICAgICAgICAgICAgKiBpbnNpZGUgdGhlIG1lbnUuIEEgc21hbGxlciB2YWx1ZSBnZXRzIGRpc3BsYXllZCBmaXJzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWRpdG9yLmFkZE1lbnVHcm91cCA9IGZ1bmN0aW9uIChuYW1lLCBvcmRlcikge1xuICAgICAgICAgICAgICAgIGdyb3Vwc09yZGVyW25hbWVdID0gb3JkZXIgfHwgMTAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGRzIGFuIGl0ZW0gZnJvbSB0aGUgc3BlY2lmaWVkIGRlZmluaXRpb24gdG8gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRNZW51SXRlbVxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG1lbnUgaXRlbSBuYW1lLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gVGhlIG1lbnUgaXRlbSBkZWZpbml0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlZGl0b3IuYWRkTWVudUl0ZW0gPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChncm91cHNPcmRlcltkZWZpbml0aW9uLmdyb3VwXSkge1xuICAgICAgICAgICAgICAgICAgICBtZW51SXRlbXNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkcyBvbmUgb3IgbW9yZSBpdGVtcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGVmaW5pdGlvbiBvYmplY3QgdG8gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRNZW51SXRlbXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9ucyBPYmplY3Qgd2hlcmUga2V5cyBhcmUgdXNlZCBhcyBpdGVtTmFtZSBhbmQgY29ycmVzcG9uZGluZyB2YWx1ZXMgYXMgZGVmaW5pdGlvbiBmb3IgYSB7QGxpbmsgI2FkZE1lbnVJdGVtfSBjYWxsLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlZGl0b3IuYWRkTWVudUl0ZW1zID0gZnVuY3Rpb24gKGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaXRlbU5hbWUgaW4gZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNZW51SXRlbShpdGVtTmFtZSwgZGVmaW5pdGlvbnNbaXRlbU5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyBhIHBhcnRpY3VsYXIgbWVudSBpdGVtIGRlZmluaXRpb24gZnJvbSB0aGUgZWRpdG9yIGNvbnRleHQgbWVudS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldE1lbnVJdGVtXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVzaXJlZCBtZW51IGl0ZW0uXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVkaXRvci5nZXRNZW51SXRlbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbnVJdGVtc1tuYW1lXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBhIHBhcnRpY3VsYXIgbWVudSBpdGVtIGFkZGVkIGJlZm9yZSBmcm9tIHRoZSBlZGl0b3IgY29udGV4dCBtZW51LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgIHJlbW92ZU1lbnVJdGVtXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVzaXJlZCBtZW51IGl0ZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVNZW51SXRlbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lbnVJdGVtc1tuYW1lXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn0oKSk7IiwiaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgY3JlYXRlUmVhY3RDbGFzcyBmcm9tICdjcmVhdGUtcmVhY3QtY2xhc3MnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcGFuZWxtZW51YnV0dG9uYnJpZGdlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgICAvLyBBUEkgbm90IHlldCBpbXBsZW1lbnRlZCBpbnNpZGUgdGhlIHBhbmVsIG1lbnUgYnV0dG9uIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kcywgd2VcbiAgICAvLyBwcmV2ZW50IHBsdWdpbnMgZnJvbSBjcmFzaGluZyBpZiB0aGV5IG1ha2UgdXNlIG9mIHRoZW0uXG4gICAgdmFyIFVOU1VQUE9SVEVEX1BBTkVMX01FTlVfQlVUVE9OX0FQSSA9IHtcbiAgICAgICAgY3JlYXRlUGFuZWw6IG5vb3BcbiAgICB9O1xuXG4gICAgdmFyIFBBTkVMX01FTlVfREVGUyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgUGFuZWxNZW51QnV0dG9uQnJpZGdlIFJlYWN0IGNsYXNzIGZvciBhIGdpdmVuIHBhbmVsbWVudWJ1dHRvbiBkZWZpbml0aW9uIGlmIGl0IGhhcyBub3QgYmVlblxuICAgICAqIGFscmVhZHkgY3JlYXRlZCBiYXNlZCBvbiB0aGUgcGFuZWxtZW51YnV0dG9uIG5hbWUgYW5kIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFuZWxNZW51QnV0dG9uTmFtZSBUaGUgcGFuZWwgYnV0dG9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvbiBUaGUgcGFuZWwgYnV0dG9uIGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBQYW5lbE1lbnVCdXR0b24gQ2xhc3NcbiAgICAgKi9cbiAgICB2YXIgZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UgPSBmdW5jdGlvbihwYW5lbE1lbnVCdXR0b25OYW1lLCBwYW5lbE1lbnVCdXR0b25EZWZpbml0aW9uLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIFBhbmVsTWVudUJ1dHRvbkJyaWRnZSA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbcGFuZWxNZW51QnV0dG9uTmFtZV07XG5cbiAgICAgICAgUEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXSA9IFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV0gfHwge307XG4gICAgICAgIFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV0gPSBQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW3BhbmVsTWVudUJ1dHRvbk5hbWVdIHx8IHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb247XG5cbiAgICAgICAgaWYgKCFQYW5lbE1lbnVCdXR0b25CcmlkZ2UpIHtcbiAgICAgICAgICAgIFBhbmVsTWVudUJ1dHRvbkJyaWRnZSA9IGNyZWF0ZVJlYWN0Q2xhc3MoXG4gICAgICAgICAgICAgICAgQ0tFRElUT1IudG9vbHMubWVyZ2UoVU5TVVBQT1JURURfUEFORUxfTUVOVV9CVVRUT05fQVBJLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBwYW5lbE1lbnVCdXR0b25OYW1lLFxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcGFuZWxNZW51QnV0dG9uTmFtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lID0gUEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXVtwYW5lbE1lbnVCdXR0b25OYW1lXS5uYW1lIHx8IFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV0uY29tbWFuZCB8fCBwYW5lbE1lbnVCdXR0b25OYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NOYW1lID0gJ2FlLWJ1dHRvbiBhZS1idXR0b24tYnJpZGdlJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGljb25DbGFzc05hbWUgPSAnYWUtaWNvbi0nICsgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpY29uU3R5bGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1N0eWxlID0gQ0tFRElUT1Iuc2tpbi5nZXRJY29uU3R5bGUocGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzU3R5bGVQYXJ0cyA9IGNzc1N0eWxlLnNwbGl0KCc7Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3R5bGUuYmFja2dyb3VuZEltYWdlID0gY3NzU3R5bGVQYXJ0c1swXS5zdWJzdHJpbmcoY3NzU3R5bGVQYXJ0c1swXS5pbmRleE9mKCc6JykgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gY3NzU3R5bGVQYXJ0c1sxXS5zdWJzdHJpbmcoY3NzU3R5bGVQYXJ0c1sxXS5pbmRleE9mKCc6JykgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3R5bGUuYmFja2dyb3VuZFNpemUgPSBjc3NTdHlsZVBhcnRzWzJdLnN1YnN0cmluZyhjc3NTdHlsZVBhcnRzWzJdLmluZGV4T2YoJzonKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSB0aGlzLl9nZXRQYW5lbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9e1BBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV0ubGFiZWx9IGNsYXNzTmFtZT17YnV0dG9uQ2xhc3NOYW1lfSBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSByb2xlPVwiY29tYm9ib3hcIiB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e1BBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV0ubGFiZWx9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtpY29uQ2xhc3NOYW1lfSBzdHlsZT17aWNvblN0eWxlfT48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cGFuZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIF9nZXRQYW5lbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmVsTWVudUJ1dHRvbk9uQmxvY2sgPSBQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW3BhbmVsTWVudUJ1dHRvbk5hbWVdLm9uQmxvY2s7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiB0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRoaXMucHJvcHMudG9nZ2xlRHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0VsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogYmxvY2tFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsTWVudUJ1dHRvbk9uQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lbE1lbnVCdXR0b25PbkJsb2NrLmNhbGwodGhpcywgcGFuZWwsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGJsb2NrLmtleXMgdG8gY29uZmlndXJlIHRoZSBwYW5lbCBrZXlib2FyZCBuYXZpZ2F0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbkRyb3Bkb3duIG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtibG9ja0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpfSBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogYmxvY2tFbGVtZW50LmdldEh0bWwoKX19IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b25Ecm9wZG93bj5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgQWxsb3lFZGl0b3IuQnV0dG9uc1twYW5lbE1lbnVCdXR0b25OYW1lXSA9IFBhbmVsTWVudUJ1dHRvbkJyaWRnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYW5lbE1lbnVCdXR0b25CcmlkZ2U7XG4gICAgfTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgncGFuZWxtZW51YnV0dG9uJykpIHtcbiAgICAgICAgQ0tFRElUT1IuVUlfUEFORUxCVVRUT04gPSAncGFuZWxtZW51YnV0dG9uJztcblxuICAgICAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgncGFuZWxtZW51YnV0dG9uJywge30pO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgncGFuZWxidXR0b24nKSnCoHtcbiAgICAgICAgQ0tFRElUT1IuVUlfUEFORUxCVVRUT04gPSAncGFuZWxidXR0b24nO1xuXG4gICAgICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdwYW5lbGJ1dHRvbicsIHt9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgUGFuZWxCdXR0b24gcGx1Z2luLiBJdCB0YWtlcyBvdmVyIHRoZVxuICAgICAqIHJlc3BvbnNpYmlsaXR5IG9mIHJlZ2lzdGVyaW5nIGFuZCBjcmVhdGluZyBidXR0b25zIHZpYTpcbiAgICAgKiAtIGVkaXRvci51aS5hZGRQYW5lbE1lbnVCdXR0b24obmFtZSwgZGVmaW5pdGlvbilcbiAgICAgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgQ0tFRElUT1IuVUlfUEFORUxCVVRUT04sIGRlZmluaXRpb24pXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9wYW5lbG1lbnVidXR0b25icmlkZ2VcbiAgICAgKiBAcmVxdWlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV91aWJyaWRnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9wYW5lbG1lbnVidXR0b25icmlkZ2UnLCB7XG4gICAgICAgIHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJ10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgYWRkIGhhbmRsZXIgZm9yIFVJX1BBTkVMQlVUVE9OIHRvIG91ciBvd24uIFdlIGRvIHRoaXMgaW4gdGhlIGluaXQgcGhhc2UgdG8gb3ZlcnJpZGVcbiAgICAgICAgICogdGhlIG9uZSBpbiB0aGUgbmF0aXZlIHBsdWdpbiBpbiBjYXNlIGl0J3MgcHJlc2VudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UgYmVpbmcgaW5pdGlhbGl6ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLnVpLmFkZFBhbmVsTWVudUJ1dHRvbiA9IGZ1bmN0aW9uKHBhbmVsTWVudUJ1dHRvbk5hbWUsIHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChwYW5lbE1lbnVCdXR0b25OYW1lLCBDS0VESVRPUi5VSV9QQU5FTEJVVFRPTiwgcGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlZGl0b3IudWkuYWRkSGFuZGxlcihDS0VESVRPUi5VSV9QQU5FTEJVVFRPTiwge1xuICAgICAgICAgICAgICAgIGFkZDogZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UsXG4gICAgICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihwYW5lbE1lbnVCdXR0b25EZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYW5lbE1lbnVCdXR0b25OYW1lID0gJ3BhbmVsTWVudUJ1dHRvbkJyaWRnZScgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFBhbmVsTWVudUJ1dHRvbkJyaWRnZSA9IGdlbmVyYXRlUGFuZWxNZW51QnV0dG9uQnJpZGdlKHBhbmVsTWVudUJ1dHRvbk5hbWUsIHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFuZWxNZW51QnV0dG9uQnJpZGdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0oKSk7XG4iLCJpbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi4vYnV0dG9ucy9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBjcmVhdGVSZWFjdENsYXNzIGZyb20gJ2NyZWF0ZS1yZWFjdC1jbGFzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9yaWNoY29tYm9icmlkZ2UnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge31cblxuICAgIC8vIEFQSSBub3QgeWV0IGltcGxlbWVudGVkIGluc2lkZSB0aGUgcmljaGNvbWJvIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kcywgd2VcbiAgICAvLyBwcmV2ZW50IHBsdWdpbnMgZnJvbSBjcmFzaGluZyBpZiB0aGV5IG1ha2UgdXNlIG9mIHRoZW0uXG4gICAgLy9cbiAgICAvLyBTb21lIG1ldGhvZHMgbGlrZSBgc2V0U3RhdGVgIGNsYXNoIHdpdGggUmVhY3QncyBvd24gc3RhdGUgbWV0aG9kcy4gRm9yIHRoZW0sIHVuc3VwcG9ydGVkIG1lYW5zXG4gICAgLy8gdGhhdCB3ZSBkb24ndCBhY2NvdW50IGZvciB0aGUgZGlmZmVyZW50IG1lYW5pbmcgaW4gdGhlIHBhc3NlZCBvciByZXR1cm5lZCBhcmd1bWVudHMuXG4gICAgdmFyIFVOU1VQUE9SVEVEX1JJQ0hDT01CT19BUEkgPSB7XG4gICAgICAgIGNvbW1pdDogbm9vcCxcbiAgICAgICAgY3JlYXRlUGFuZWw6IG5vb3AsXG4gICAgICAgIGRpc2FibGU6IG5vb3AsXG4gICAgICAgIGVuYWJsZTogbm9vcCxcbiAgICAgICAgZ2V0U3RhdGU6IG5vb3AsXG4gICAgICAgIGhpZGVHcm91cDogbm9vcCxcbiAgICAgICAgaGlkZUl0ZW06IG5vb3AsXG4gICAgICAgIG1hcms6IG5vb3AsXG4gICAgICAgIC8vc2V0U3RhdGU6IG5vb3AsXG4gICAgICAgIHNob3dBbGw6IG5vb3AsXG4gICAgICAgIHN0YXJ0R3JvdXA6IG5vb3AsXG4gICAgICAgIHVubWFya0FsbDogbm9vcFxuICAgIH07XG5cbiAgICB2YXIgUklDSF9DT01CT19ERUZTID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBSaWNoQ29tYm9CcmlkZ2UgUmVhY3QgY2xhc3MgZm9yIGEgZ2l2ZW4gcmljaGNvbWJvIGRlZmluaXRpb24gaWYgaXQgaGFzIG5vdCBiZWVuXG4gICAgICogYWxyZWFkeSBjcmVhdGVkIGJhc2VkIG9uIHRoZSByaWNoY29tYm8gbmFtZSBhbmQgZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2VuZXJhdGVSaWNoQ29tYm9CcmlkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByaWNoQ29tYm9OYW1lIFRoZSByaWNoIGNvbWJvIG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmljaENvbWJvRGVmaW5pdGlvbiBUaGUgcmljaCBjb21ibyBkZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZ2VuZXJhdGVkIG9yIGFscmVhZHkgZXhpc3RpbmcgUmVhY3QgUmljaENvbWJvIENsYXNzXG4gICAgICovXG4gICAgdmFyIGdlbmVyYXRlUmljaENvbWJvQnJpZGdlID0gZnVuY3Rpb24ocmljaENvbWJvTmFtZSwgcmljaENvbWJvRGVmaW5pdGlvbiwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBSaWNoQ29tYm9CcmlkZ2UgPSBBbGxveUVkaXRvci5CdXR0b25zW3JpY2hDb21ib05hbWVdO1xuXG4gICAgICAgIFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV0gPSBSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdIHx8IHt9O1xuICAgICAgICBSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdID0gUklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXVtyaWNoQ29tYm9OYW1lXSB8fCByaWNoQ29tYm9EZWZpbml0aW9uO1xuICAgICAgICBSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdLmN1cnJlbnRWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIVJpY2hDb21ib0JyaWRnZSkge1xuICAgICAgICAgICAgUmljaENvbWJvQnJpZGdlID0gY3JlYXRlUmVhY3RDbGFzcyhcbiAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5tZXJnZShVTlNVUFBPUlRFRF9SSUNIQ09NQk9fQVBJLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiByaWNoQ29tYm9OYW1lLFxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcmljaENvbWJvTmFtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24odmFsdWUsIHByZXZpZXcsIHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3OiBwcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0b3JDb21ibyA9IFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRvckNvbWJvLmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JDb21iby5pbml0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3JDb21iby5vblJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvckNvbWJvLm9uUmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlVmFsdWUodGhpcy5zdGF0ZS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9jYWNoZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdLmN1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWNoQ29tYm9MYWJlbCA9IFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV0uY3VycmVudFZhbHVlIHx8IHJpY2hDb21ib0RlZmluaXRpb24ubGFiZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtaGFzLWRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH0gYXJpYS1sYWJlbD17cmljaENvbWJvTGFiZWx9IGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiIG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IHJvbGU9XCJjb21ib2JveFwiIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17cmljaENvbWJvTGFiZWx9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPntyaWNoQ29tYm9MYWJlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hcnJvd1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuZXhwYW5kZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbkRyb3Bkb3duIG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuX2dldEl0ZW1zKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbkRyb3Bkb3duPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBfY2FjaGVWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIF9nZXRJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmljaENvbWJvID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAnYWUtdG9vbGJhci1lbGVtZW50ICcgKyAoaXRlbS52YWx1ZSA9PT0gdGhpcy5zdGF0ZS52YWx1ZSA/ICdhY3RpdmUnIDogJycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGtleT17aXRlbS50aXRsZX0gcm9sZT1cIm9wdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tfX2h0bWw6IGl0ZW0ucHJldmlld319IGRhdGEtdmFsdWU9e2l0ZW0udmFsdWV9IG9uQ2xpY2s9e3JpY2hDb21iby5fb25DbGlja30+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBfb25DbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yQ29tYm8gPSBSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yQ29tYm8ub25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JDb21iby5vbkNsaWNrLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXVtyaWNoQ29tYm9OYW1lXS5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBfc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVZhbHVlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBBbGxveUVkaXRvci5CdXR0b25zW3JpY2hDb21ib05hbWVdID0gUmljaENvbWJvQnJpZGdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJpY2hDb21ib0JyaWRnZTtcbiAgICB9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdyaWNoY29tYm8nKSkge1xuICAgICAgICBDS0VESVRPUi5VSV9SSUNIQ09NQk8gPSAncmljaGNvbWJvJztcblxuICAgICAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgncmljaGNvbWJvJywge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBSaWNoQ29tYm8gcGx1Z2luLiBJdCB0YWtlcyBvdmVyIHRoZVxuICAgICAqIHJlc3BvbnNpYmlsaXR5IG9mIHJlZ2lzdGVyaW5nIGFuZCBjcmVhdGluZyByaWNoIGNvbWJvIGVsZW1lbnRzIHZpYTpcbiAgICAgKiAtIGVkaXRvci51aS5hZGRSaWNoQ29tYm8obmFtZSwgZGVmaW5pdGlvbilcbiAgICAgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgQ0tFRElUT1IuVUlfUklDSENPTUJPLCBkZWZpbml0aW9uKVxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfcmljaGNvbWJvYnJpZGdlXG4gICAgICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfcmljaGNvbWJvYnJpZGdlJywge1xuICAgICAgICByZXF1aXJlczogWydhZV91aWJyaWRnZSddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGFkZCBoYW5kbGVyIGZvciBVSV9SSUNIQ09NQk8gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuICAgICAgICAgKiB0aGUgb25lIGluIHRoZSBvcmlnaW5hbCBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlIGJlaW5nIGluaXRpYWxpemVkXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVJbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci51aS5hZGRSaWNoQ29tYm8gPSBmdW5jdGlvbihyaWNoQ29tYm9OYW1lLCByaWNoQ29tYm9EZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQocmljaENvbWJvTmFtZSwgQ0tFRElUT1IuVUlfUklDSENPTUJPLCByaWNoQ29tYm9EZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVkaXRvci51aS5hZGRIYW5kbGVyKENLRURJVE9SLlVJX1JJQ0hDT01CTywge1xuICAgICAgICAgICAgICAgIGFkZDogZ2VuZXJhdGVSaWNoQ29tYm9CcmlkZ2UsXG4gICAgICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihyaWNoQ29tYm9EZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaWNoQ29tYm9OYW1lID0gJ3JpY2hDb21ib0JyaWRnZScgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFJpY2hDb21ib0JyaWRnZSA9IGdlbmVyYXRlUmljaENvbWJvQnJpZGdlKHJpY2hDb21ib05hbWUsIHJpY2hDb21ib0RlZmluaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmljaENvbWJvQnJpZGdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV91aWJyaWRnZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBleHRlbmRzIENLRURJVE9SLnVpLmFkZCBmdW5jdGlvbiBzbyBhbiBhZGQgaGFuZGxlciBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICogb24gdG9wIG9mIHRoZSBvcmlnaW5hbCBvbmVzLiBJdCBicmlkZ2VzIHRoZSBjYWxscyB0byBhZGQgY29tcG9uZW50cyB2aWE6XG4gICAgICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIHR5cGUsIGRlZmluaXRpb24pXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV91aWJyaWRnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV91aWJyaWRnZScsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBiZWZvcmVJbml0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVJbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFVJQWRkRm4gPSBlZGl0b3IudWkuYWRkO1xuXG4gICAgICAgICAgICBlZGl0b3IudWkuYWRkID0gZnVuY3Rpb24obmFtZSwgdHlwZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVUlBZGRGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVIYW5kbGVyID0gdGhpcy5fLmhhbmRsZXJzW3R5cGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVIYW5kbGVyICYmIHR5cGVIYW5kbGVyLmFkZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlSGFuZGxlci5hZGQobmFtZSwgZGVmaW5pdGlvbiwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgQWxsb3lFZGl0b3IucmVnaXN0ZXJCcmlkZ2VCdXR0b24obmFtZSwgZWRpdG9yLl9fcHJvY2Vzc2luZ1BsdWdpbl9fLnBsdWdpbi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBEZWJvdW5jZSB1dGlsIGZ1bmN0aW9uLiBJZiBhIGZ1bmN0aW9uIGV4ZWN1dGlvbiBpcyBleHBlbnNpdmUsIGl0IG1pZ2h0IGJlIGRlYm91bmNlZC4gVGhpcyBtZWFuc1xuICAgICAqIHRoYXQgaXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lIGFmdGVyIGl0cyBsYXN0IGNhbGwuIEZvciBleGFtcGxlLCBpZiB3ZSBhdHRhY2ggYVxuICAgICAqIGEgZnVuY3Rpb24gb24gc2Nyb2xsIGV2ZW50LCBpdCBtaWdodCBiZSBjYWxsZWQgaHVuZHJlZHMgdGltZXMgcGVyIHNlY29uZC4gSW4gdGhpcyBjYXNlIGl0IG1heSBiZVxuICAgICAqIGRlYm91bmNlZCB3aXRoLCBsZXQncyBzYXkgMTAwbXMuIFRoZSByZWFsIGV4ZWN1dGlvbiBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgaGFwcGVuIDEwMG1zIGFmdGVyIGxhc3RcbiAgICAgKiBzY3JvbGwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAgICAgKiBAbWV0aG9kIGRlYm91bmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgd2hpY2ggdGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgd2hpY2ggaGFzIHRvIGJlIGNhbGxlZCBhZnRlciBnaXZlbiB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENLRURJVE9SLnRvb2xzLmRlYm91bmNlID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UgfHwgZnVuY3Rpb24oY2FsbGJhY2ssIHRpbWVvdXQsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGRlYm91bmNlSGFuZGxlO1xuXG4gICAgICAgIHZhciBjYWxsRm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYWxsQ29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlSGFuZGxlKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdGFydEluZGV4ID0gMDsgc3RhcnRJbmRleCA8IGxlbjsgKytzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJndW1lbnRzW3N0YXJ0SW5kZXhdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNhbGxBcmdzID0gcmVzdWx0LmNvbmNhdChhcmdzIHx8IFtdKTtcblxuICAgICAgICAgICAgZGVib3VuY2VIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNhbGxDb250ZXh0LCBjYWxsQXJncyk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjYWxsRm4uZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VIYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjYWxsRm47XG4gICAgfTtcbn0oKSk7IiwiaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UnO1xuaW1wb3J0IGxpbmsgZnJvbSAnLi9saW5rJztcbmltcG9ydCBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucyc7XG5pbXBvcnQgc2VsZWN0aW9uUmVnaW9uIGZyb20gJy4vc2VsZWN0aW9uLXJlZ2lvbic7XG5pbXBvcnQgdGFibGUgZnJvbSAnLi90YWJsZSc7XG5pbXBvcnQgdG9vbHMgZnJvbSAnLi90b29scyc7XG5pbXBvcnQgdWljb3JlIGZyb20gJy4vdWljb3JlJztcblxuZXhwb3J0IHtcbiAgICBkZWJvdW5jZSxcbiAgICBsaW5rLFxuICAgIHBsdWdpbnMsXG4gICAgc2VsZWN0aW9uUmVnaW9uLFxuICAgIHRhYmxlLFxuICAgIHRvb2xzLFxuICAgIHVpY29yZVxufTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFJFR0VYX0JPT0tNQVJLX1NDSEVNRSA9IC9eIy4qL2k7XG4gICAgdmFyIFJFR0VYX0VNQUlMX1NDSEVNRSA9IC9eW2EtejAtOVxcdTA0MzAtXFx1MDQ0RlxcLl8tXStAL2k7XG4gICAgdmFyIFJFR0VYX1VSSV9TQ0hFTUUgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSopXFw6fF5cXC8vaTtcblxuICAgIC8qKlxuICAgICAqIExpbmsgY2xhc3MgdXRpbGl0eS4gUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRlLCBkZWxldGUgYW5kIHVwZGF0ZSBsaW5rcy5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5MaW5rXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGluayhlZGl0b3IsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuYXBwZW5kUHJvdG9jb2wgPSBjb25maWcgJiYgY29uZmlnLmFwcGVuZFByb3RvY29sID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBMaW5rLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IExpbmssXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkdmFuY2VzIHRoZSBlZGl0b3Igc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGF2YWlsYWJsZSBwb3NpdGlvbiBhZnRlciBhXG4gICAgICAgICAqIGdpdmVuIGxpbmsgb3IgdGhlIG9uZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIGFkdmFuY2VTZWxlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGluayBUaGUgbGluayBlbGVtZW50IHdoaWNoIGxpbmsgc3R5bGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBhZHZhbmNlU2VsZWN0aW9uOiBmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICBsaW5rID0gbGluayB8fCB0aGlzLmdldEZyb21TZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVUb0VsZW1lbnRFZGl0RW5kKGxpbmspO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHROb2RlID0gcmFuZ2UuZ2V0TmV4dEVkaXRhYmxlTm9kZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlICYmICF0aGlzLl9lZGl0b3IuZWxlbWVudC5lcXVhbHMobmV4dE5vZGUuZ2V0Q29tbW9uQW5jZXN0b3IobGluaykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZXNwYWNlID0gL1xccy8uZXhlYyhuZXh0Tm9kZS5nZXRUZXh0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB3aGl0ZXNwYWNlID8gd2hpdGVzcGFjZS5pbmRleCArIDEgOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5leHROb2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobmV4dE5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0UmFuZ2VzKFtyYW5nZV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBsaW5rIHdpdGggZ2l2ZW4gVVJJIGFzIGhyZWYuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgQSBjb25maWcgb2JqZWN0IHdpdGggbGluayBhdHRyaWJ1dGVzLiBUaGVzZSBtaWdodCBiZSBhcmJpdHJhcnkgRE9NIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RpZnlTZWxlY3Rpb24gQSBjb25maWcgb2JqZWN0IHdpdGggYW4gYWR2YW5jZSBhdHRyaWJ1dGUgdG8gaW5kaWNhdGUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgbW92ZWQgYWZ0ZXIgdGhlIGxpbmsgY3JlYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBVUkkgVGhlIFVSSSBvZiB0aGUgbGluay5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oVVJJLCBhdHRycywgbW9kaWZ5U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG5ldyBDS0VESVRPUi5kb20udGV4dChVUkksIHRoaXMuX2VkaXRvci5kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFVSSSA9IHRoaXMuX2dldENvbXBsZXRlVVJJKFVSSSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rQXR0cnMgPSBDS0VESVRPUi50b29scy5tZXJnZSh7XG4gICAgICAgICAgICAgICAgJ2RhdGEtY2tlLXNhdmVkLWhyZWYnOiBVUkksXG4gICAgICAgICAgICAgICAgaHJlZjogVVJJXG4gICAgICAgICAgICB9LCBhdHRycyk7XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogbGlua0F0dHJzLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdhJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN0eWxlLnR5cGUgPSBDS0VESVRPUi5TVFlMRV9JTkxJTkU7XG4gICAgICAgICAgICBzdHlsZS5hcHBseVRvUmFuZ2UocmFuZ2UsIHRoaXMuX2VkaXRvcik7XG5cbiAgICAgICAgICAgIGlmIChtb2RpZnlTZWxlY3Rpb24gJiYgbW9kaWZ5U2VsZWN0aW9uLmFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIGxpbmsgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIGdldEZyb21TZWxlY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IFRoZSByZXRyaWV2ZWQgbGluayBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEZyb21TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCAmJiBzZWxlY3RlZEVsZW1lbnQuaXMoJ2EnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQgJiYgQ0tFRElUT1IuZW52LmllKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gc2VsZWN0ZWRFbGVtZW50LmdldENoaWxkcmVuKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBjaGlsZHJlbi5jb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY291bnQgOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjaGlsZHJlbi5nZXRJdGVtKGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlzKCdhJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNocmluayhDS0VESVRPUi5TSFJJTktfVEVYVCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmVsZW1lbnRQYXRoKHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCkpLmNvbnRhaW5zKCdhJywgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgbGluayBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBsaW5rIFRoZSBsaW5rIGVsZW1lbnQgd2hpY2ggbGluayBzdHlsZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGlmeVNlbGVjdGlvbiBBIGNvbmZpZyBvYmplY3Qgd2l0aCBhbiBhZHZhbmNlIGF0dHJpYnV0ZSB0byBpbmRpY2F0ZSBpZiB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb3ZlZCBhZnRlciB0aGUgbGluayBjcmVhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obGluaywgbW9kaWZ5U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZnlTZWxlY3Rpb24gJiYgbW9kaWZ5U2VsZWN0aW9uLmFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluay5yZW1vdmUoZWRpdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzUmVtb3ZlRWxlbWVudDogMSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ2EnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDS0VESVRPUi5TVFlMRV9JTkxJTkVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vICdyZW1vdmVTdHlsZSgpJyByZW1vdmVzIHRoZSBzdHlsZSBmcm9tIHRoZSBlZGl0b3IncyBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyAgV2UgbmVlZCB0byBmb3JjZSB0aGUgc2VsZWN0aW9uIHRvIGJlIHRoZSB3aG9sZSBsaW5rIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyAgdG8gcmVtb3ZlIGl0IHByb3Blcmx5LlxuXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0RWxlbWVudChzZWxlY3Rpb24uZ2V0U3RhcnRFbGVtZW50KCkpO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVN0eWxlKHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgaHJlZiBvZiBhbiBhbHJlYWR5IGV4aXN0aW5nIGxpbmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBsaW5rIFRoZSBsaW5rIGVsZW1lbnQgd2hpY2ggaHJlZiBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhdHRycyBUaGUgYXR0cmlidXRlcyB0byB1cGRhdGUgb3IgcmVtb3ZlLiBBdHRyaWJ1dGVzIHdpdGggbnVsbCB2YWx1ZXMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kaWZ5U2VsZWN0aW9uIEEgY29uZmlnIG9iamVjdCB3aXRoIGFuIGFkdmFuY2UgYXR0cmlidXRlIHRvIGluZGljYXRlIGlmIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vdmVkIGFmdGVyIHRoZSBsaW5rIGNyZWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihhdHRycywgbGluaywgbW9kaWZ5U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSAgdGhpcztcblxuICAgICAgICAgICAgbGluayA9IGxpbmsgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVyaSA9IGluc3RhbmNlLl9nZXRDb21wbGV0ZVVSSShhdHRycyk7XG5cbiAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAnZGF0YS1ja2Utc2F2ZWQtaHJlZic6IHVyaSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlQXR0cnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBzZXRBdHRycyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyc1trZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBdHRycy5wdXNoKCdkYXRhLWNrZS1zYXZlZC1ocmVmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmkgPSBpbnN0YW5jZS5fZ2V0Q29tcGxldGVVUkkoYXR0cnNba2V5XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyc1snZGF0YS1ja2Utc2F2ZWQtaHJlZiddID0gdXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJzW2tleV0gPSB1cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJzW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsaW5rLnJlbW92ZUF0dHJpYnV0ZXMocmVtb3ZlQXR0cnMpO1xuICAgICAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlcyhzZXRBdHRycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RpZnlTZWxlY3Rpb24gJiYgbW9kaWZ5U2VsZWN0aW9uLmFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTZWxlY3Rpb24obGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgVVJJIGJlZ2lucyB3aXRoIGEgJyMnIHN5bWJvbCB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBvbiBwYWdlIGJvb2ttYXJrLlxuICAgICAgICAgKiBJZiBpdCBkb2Vzbid0LCBpdCB0aGVuIGNoZWNrcyBpZiB0aGUgVVJJIGhhcyBhbiAnQCcgc3ltYm9sLiBJZiBpdCBkb2VzIGFuZCB0aGUgVVJJXG4gICAgICAgICAqIGxvb2tzIGxpa2UgYW4gZW1haWwgYW5kIGRvZXNuJ3QgaGF2ZSAnbWFpbHRvOicsICdtYWlsdG86JyBpcyBhZGRlZCB0byB0aGUgVVJJLlxuICAgICAgICAgKiBJZiBpdCBkb2Vzbid0IGFuZCB0aGUgVVJJIGRvZXNuJ3QgaGF2ZSBhIHNjaGVtZSwgdGhlIGRlZmF1bHQgJ2h0dHAnIHNjaGVtZSB3aXRoXG4gICAgICAgICAqIGhpZXJhcmNoaWNhbCBwYXRoICcvLycgaXMgYWRkZWQgdG8gdGhlIFVSSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG4gICAgICAgICAqIEBtZXRob2QgX2dldENvbXBsZXRlVVJJXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBVUkkgVGhlIFVSSSBvZiB0aGUgbGluay5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBVUkkgdXBkYXRlZCB3aXRoIHRoZSBwcm90b2NvbC5cbiAgICAgICAgICovXG4gICAgICAgIF9nZXRDb21wbGV0ZVVSSTogZnVuY3Rpb24oVVJJKSB7XG4gICAgICAgICAgICBpZiAoUkVHRVhfQk9PS01BUktfU0NIRU1FLnRlc3QoVVJJKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVUkk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFJFR0VYX0VNQUlMX1NDSEVNRS50ZXN0KFVSSSkpIHtcbiAgICAgICAgICAgICAgICBVUkkgPSAnbWFpbHRvOicgKyBVUkk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFSRUdFWF9VUklfU0NIRU1FLnRlc3QoVVJJKSkge1xuICAgICAgICAgICAgICAgIFVSSSA9IHRoaXMuYXBwZW5kUHJvdG9jb2wgPyAnaHR0cDovLycgKyBVUkkgOiBVUkk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBVUkk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ0tFRElUT1IuTGluayA9IENLRURJVE9SLkxpbmsgfHwgTGluaztcbn0oKSk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFdyYXBzIGVhY2ggb2YgdGhlIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBpbiBhIGNsb3N1cmUgdGhhdCB3aWxsXG4gICAgLy8gc2V0IHVwIHRoZSBlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18gdmFyaWFibGUgc28gaXQgY2FuIGJlIGdsb2JhbGx5XG4gICAgLy8gYWNjZXNzZWQgZXhwb3NpbmcgdGhlIHBsdWdpbiBiZWluZyBwcm9jZXNzZWQgYW5kIHRoZSBsaWZlY3ljbGUgcGhhc2VcbiAgICAvLyBpbiB3aGljaCBpdCBpcyBoYXBwZW5pbmdcbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gVGhlIHBsdWdpbiB0byB3cmFwIGxpZmVjeWNsZSBtZXRob2RzXG4gICAgdmFyIHdyYXBQbHVnaW5MaWZlY3ljbGUgPSBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBbJ2JlZm9yZUluaXQnLCAnaW5pdCcsICdhZnRlckluaXQnXTtcblxuICAgICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgaWYgKHBsdWdpblttZXRob2ROYW1lXSkge1xuICAgICAgICAgICAgICAgIHBsdWdpblttZXRob2ROYW1lXSA9IENLRURJVE9SLnRvb2xzLm92ZXJyaWRlKHBsdWdpblttZXRob2ROYW1lXSwgZnVuY3Rpb24ob3JpZ2luYWxQbHVnaW5NZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjogcGx1Z2luXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLl9fcHJvY2Vzc2luZ1BsdWdpbl9fID0gcGF5bG9hZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxQbHVnaW5NZXRob2QuY2FsbCh0aGlzLCBlZGl0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRmlsdGVycyB0aGUgcmVxdWlyZXMgb2JqZWN0IHRvIHJlbW92ZSB1bndhbnRlZCBkZXBlbmRlbmNpZXMuIEF0IHRoaXMgcG9pbnRcbiAgICAvLyBvbmx5ICd0b29sYmFyJyBoYXMgYmVlbiBpZGVudGlmaWVkLCBidXQgbW9yZSBjYW4gYXBwZWFyLiBBbiB1bndhbnRlZCBwbHVnaW5cbiAgICAvLyBkZXBlbmRlbmN5IGlzIG9uZSB0aGF0IHByZXZlbnRzIGEgbmVjZXNzYXJ5IHBsdWdpbiBmcm9tIGJlaW5nIHJlbW92ZWRcbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHJlcXVpcmVzIFRoZSByZXF1aXJlcyBvYmplY3RcbiAgICAvLyBAcmV0dXJuIHtzdHJpbmd9IFRoZSBmaWx0ZXJlZCByZXF1aXJlcyBvYmplY3RcbiAgICB2YXIgZmlsdGVyVW53YW50ZWREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihyZXF1aXJlcykge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVxdWlyZXMgPSByZXF1aXJlcy5zcGxpdCgnLCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcXVpcmVzLmZpbHRlcihmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZSAhPT0gJ3Rvb2xiYXInO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ0tFRElUT1IucGx1Z2lucyBjbGFzcyB1dGlsaXR5IHdoaWNoIGFkZHMgYWRkaXRpb25hbCBtZXRob2RzIHRvIHRob3NlIG9mIENLRWRpdG9yLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBDS0VESVRPUi5wbHVnaW5zLmxvYWQgbWV0aG9kIHNvIHdlIGNhbiBleHRlbmQgdGhlIGxpZmVjeWNsZSBtZXRob2RzIG9mXG4gICAgICogdGhlIGxvYWRlZCBwbHVnaW5zIHRvIGFkZCBzb21lIG1ldGFpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGx1Z2luIGJlaW5nIHByb2Nlc3NlZFxuICAgICAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nL0FycmF5fSBuYW1lcyBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZC4gSXQgbWF5IGJlIGFcblx0ICogc3RyaW5nIHdpdGggYSBzaW5nbGUgcmVzb3VyY2UgbmFtZSwgb3IgYW4gYXJyYXkgd2l0aCBzZXZlcmFsIG5hbWVzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGFsbCByZXNvdXJjZXNcblx0ICogYXJlIGxvYWRlZC4gVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBsb2FkZWQgbmFtZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFRoZSBzY29wZSBvYmplY3QgdG8gYmUgdXNlZCBmb3IgdGhlIGNhbGxiYWNrIGNhbGwuXG4gICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnNcbiAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5sb2FkID0gQ0tFRElUT1IudG9vbHMub3ZlcnJpZGUoQ0tFRElUT1IucGx1Z2lucy5sb2FkLCBmdW5jdGlvbihwbHVnaW5zTG9hZCl7XG4gICAgICAgIC8vIFdyYXAgb3JpZ2luYWwgbG9hZCBmdW5jdGlvbiBzbyB3ZSBjYW4gdHJhbnNmb3JtIHRoZSBwbHVnaW4gaW5wdXQgcGFyYW1ldGVyXG4gICAgICAgIC8vIGJlZm9yZSBwYXNzaW5nIGl0IGRvd24gdG8gdGhlIG9yaWdpbmFsIGNhbGxiYWNrXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lcywgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgICAgICBwbHVnaW5zTG9hZC5jYWxsKHRoaXMsIG5hbWVzLCBmdW5jdGlvbihwbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luTmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ucmVxdWlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4ucmVxdWlyZXMgPSBmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyhwbHVnaW4ucmVxdWlyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwUGx1Z2luTGlmZWN5Y2xlKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIHBsdWdpbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9zZWxlY3Rpb25yZWdpb24nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00gPSAwO1xuICAgIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QID0gMTtcbiAgICBDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVCA9IDI7XG4gICAgQ0tFRElUT1IuU0VMRUNUSU9OX1JJR0hUX1RPX0xFRlQgPSAzO1xuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW9uUmVnaW9uIHV0aWxpdHkgY2xhc3Mgd2hpY2ggcHJvdmlkZXMgbWV0YWRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbi4gVGhlIG1ldGFkYXRhIG1heSBiZSB0aGUgc3RhcnQgYW5kIGVuZFxuICAgICAqIHJlY3RhbmdsZXMsIGNhcmV0IHJlZ2lvbiwgZXRjLiAqKlRoaXMgY2xhc3MgaXMgbm90IGludGVuZGVkIHRvIGJlIHVzZWQgc3RhbmRhbG9uZS4gSXRzIGZ1bmN0aW9ucyB3aWxsXG4gICAgICogYmUgbWVyZ2VkIGludG8gZWFjaCBlZGl0b3IgaW5zdGFuY2UsIHNvIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSB0aGVtIGRpcmVjdGx5IHZpYSB0aGUgZWRpdG9yLCB3aXRob3V0IG1ha2luZ1xuICAgICAqIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MqKi5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBTZWxlY3Rpb25SZWdpb25cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25SZWdpb24oKSB7fVxuXG4gICAgU2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFNlbGVjdGlvblJlZ2lvbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSB0d28gcG9pbnRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlU2VsZWN0aW9uRnJvbVBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb2ludCBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU2VsZWN0aW9uRnJvbVBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNlbGVjdGlvbkZyb21SYW5nZSh4LCB5LCB4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSByYW5nZS4gQSByYW5nZSBjb25zaXN0cyBmcm9tIHR3byBwb2ludHMgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2VcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0WCBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRZIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRYIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kWSBZIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNlbGVjdGlvbkZyb21SYW5nZTogZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkpIHtcbiAgICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgICB2YXIgZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGVuZE9mZnNldDtcbiAgICAgICAgICAgIHZhciByYW5nZTtcbiAgICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICAgIHZhciBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHN0YXJ0WCwgc3RhcnRZKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KGVuZFgsIGVuZFkpO1xuXG4gICAgICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydC5vZmZzZXROb2RlO1xuICAgICAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGVuZC5vZmZzZXROb2RlO1xuXG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBzdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gZW5kLm9mZnNldDtcblxuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChlbmRYLCBlbmRZKTtcblxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnQuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kLnN0YXJ0Q29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBzdGFydC5zdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBlbmQuc3RhcnRPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJhbmdlICYmIGRvY3VtZW50LmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5ldyBDS0VESVRPUi5kb20ubm9kZShzdGFydENvbnRhaW5lciksIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobmV3IENLRURJVE9SLmRvbS5ub2RlKGVuZENvbnRhaW5lciksIGVuZE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdldFNlbGVjdGlvbigpLnNlbGVjdFJhbmdlcyhbcmFuZ2VdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24udW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UubW92ZVRvUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVuZFJhbmdlID0gcmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgICAgICAgICAgZW5kUmFuZ2UubW92ZVRvUG9pbnQoZW5kWCwgZW5kWSk7XG5cbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9FbmQnLCBlbmRSYW5nZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdldFNlbGVjdGlvbigpLmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVnaW9uIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBjYXJldC4gVGhlIHBvaW50cyBhcmUgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRDYXJldFJlZ2lvblxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiAtIGJvdHRvbVxuICAgICAgICAgKiAtIGxlZnRcbiAgICAgICAgICogLSByaWdodFxuICAgICAgICAgKiAtIHRvcFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2FyZXRSZWdpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciByZWdpb24gPSB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYm9va21hcmtzID0gc2VsZWN0aW9uLmNyZWF0ZUJvb2ttYXJrcygpO1xuXG4gICAgICAgICAgICBpZiAoIWJvb2ttYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYm9va21hcmtOb2RlRWwgPSBib29rbWFya3NbMF0uc3RhcnROb2RlLiQ7XG5cbiAgICAgICAgICAgIGJvb2ttYXJrTm9kZUVsLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcblxuICAgICAgICAgICAgcmVnaW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGJvb2ttYXJrTm9kZUVsKS5nZXRDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIGJvb2ttYXJrTm9kZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYm9va21hcmtOb2RlRWwpO1xuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsUG9zID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3cod2luZG93KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICByZWdpb24uYm90dG9tID0gc2Nyb2xsUG9zLnkgKyByZWdpb24uYm90dG9tO1xuICAgICAgICAgICAgcmVnaW9uLmxlZnQgPSBzY3JvbGxQb3MueCArIHJlZ2lvbi5sZWZ0O1xuICAgICAgICAgICAgcmVnaW9uLnJpZ2h0ID0gc2Nyb2xsUG9zLnggKyByZWdpb24ucmlnaHQ7XG4gICAgICAgICAgICByZWdpb24udG9wID0gc2Nyb2xsUG9zLnkgKyByZWdpb24udG9wO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGRhdGEgZm9yIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRTZWxlY3Rpb25EYXRhXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdHxudWxsfSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZGF0YTpcbiAgICAgICAgICogLSBlbGVtZW50IC0gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbGVtZW50LCBpZiBhbnlcbiAgICAgICAgICogLSB0ZXh0IC0gVGhlIHNlbGVjdGVkIHRleHRcbiAgICAgICAgICogLSByZWdpb24gLSBUaGUgZGF0YSwgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25SZWdpb246bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25EYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5nZXROYXRpdmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRUZXh0KClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlc3VsdC5yZWdpb24gPSB0aGlzLmdldFNlbGVjdGlvblJlZ2lvbihzZWxlY3Rpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZWdpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdoaWNoIGlzIGJlaW5nIHJldHVybmVkIGZyb21cbiAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0Q2xpZW50UmVjdHNSZWdpb246bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319IHdpdGggdGhyZWUgbW9yZSBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiAtIGRpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvbi4gQ2FuIGJlIG9uZSBvZiB0aGVzZTpcbiAgICAgICAgICogICAxLiBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuICAgICAgICAgKiAgIDIuIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QXG4gICAgICAgICAqIC0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgc2VsZWN0aW9uIHJlZ2lvblxuICAgICAgICAgKiAtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gcmVnaW9uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25SZWdpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHRoaXMuZ2V0Q2xpZW50UmVjdHNSZWdpb24oKTtcblxuICAgICAgICAgICAgcmVnaW9uLmRpcmVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uRGlyZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHJlZ2lvbi5oZWlnaHQgPSByZWdpb24uYm90dG9tIC0gcmVnaW9uLnRvcDtcbiAgICAgICAgICAgIHJlZ2lvbi53aWR0aCA9IHJlZ2lvbi5yaWdodCAtIHJlZ2lvbi5sZWZ0O1xuXG4gICAgICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgaXNTZWxlY3Rpb25FbXB0eVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBpc1NlbGVjdGlvbkVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByYW5nZXM7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICByZXR1cm4gKHNlbGVjdGlvbi5nZXRUeXBlKCkgPT09IENLRURJVE9SLlNFTEVDVElPTl9OT05FKSB8fFxuICAgICAgICAgICAgICAgICgocmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpKSAmJiByYW5nZXMubGVuZ3RoID09PSAxICYmIHJhbmdlc1swXS5jb2xsYXBzZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIG9iamVjdCB3aXRoIGRhdGEgYWJvdXQgdGhlIFtjbGllbnQgcmVjdGFuZ2xlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQuZ2V0Q2xpZW50UmVjdHMpIG9mIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAqIG5vcm1hbGl6ZWQgYWNyb3NzIGJyb3dzZXMuIEFsbCBvZmZzZXRzIGJlbG93IGFyZSBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGdldENsaWVudFJlY3RzUmVnaW9uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGRhdGE6XG4gICAgICAgICAqIC0gYm90dG9tIC0gYm90dG9tIG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcbiAgICAgICAgICogLSBsZWZ0IC0gbGVmdCBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG4gICAgICAgICAqIC0gcmlnaHQgLSByaWdodCBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG4gICAgICAgICAqIC0gdG9wIC0gdG9wIG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcbiAgICAgICAgICogLSBzdGFydFJlY3QgLSBBbiBPYmplY3QsIHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG4gICAgICAgICAqICAgICArIGJvdHRvbSAtIGJvdHRvbSBvZmZzZXRcbiAgICAgICAgICogICAgICsgaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAqICAgICArIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqICAgICArIHJpZ2h0IC0gcmlnaHQgb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogICAgICsgdG9wIC0gdG9wIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqICAgICArIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICogLSBlbmRSZWN0IC0gQW4gT2JqZWN0LCB3aGljaCBjb250YWlucyB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uOlxuICAgICAgICAgKiAgICAgKyBib3R0b20gLSBib3R0b20gb2Zmc2V0XG4gICAgICAgICAqICAgICArIGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgICAgKiAgICAgKyBsZWZ0IC0gbGVmdCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKiAgICAgKyByaWdodCAtIHJpZ2h0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqICAgICArIHRvcCAtIHRvcCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKiAgICAgKyB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBzZWxlY3Rpb24sIHRoZSBvYmplY3RzIHdpbGwgYmUgZmlsbGVkIHdpdGggMC5cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaWVudFJlY3RzUmVnaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVNlbGVjdGlvbiA9IHNlbGVjdGlvbi5nZXROYXRpdmUoKTtcblxuICAgICAgICAgICAgdmFyIGRlZmF1bHRSZWN0ID0ge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZWdpb24gPSB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICAgIGVuZFJlY3Q6IGRlZmF1bHRSZWN0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdDogZGVmYXVsdFJlY3RcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghbmF0aXZlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IDA7XG4gICAgICAgICAgICB2YXIgY2xpZW50UmVjdHM7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHJhbmdlQ291bnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgdG9wID0gSW5maW5pdHk7XG5cbiAgICAgICAgICAgIGlmIChuYXRpdmVTZWxlY3Rpb24uY3JlYXRlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRSZWN0cyA9IG5hdGl2ZVNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlQ291bnQgPSBuYXRpdmVTZWxlY3Rpb24ucmFuZ2VDb3VudDtcbiAgICAgICAgICAgICAgICBjbGllbnRSZWN0cyA9IChuYXRpdmVTZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApID8gbmF0aXZlU2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKSA6IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uID0gdGhpcy5nZXRDYXJldFJlZ2lvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gY2xpZW50UmVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjbGllbnRSZWN0c1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5sZWZ0IDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGl0ZW0ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJpZ2h0ID4gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gaXRlbS5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRvcCA8IHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gaXRlbS50b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5ib3R0b20gPiBib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IGl0ZW0uYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFBvcyA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgICAgIHJlZ2lvbi5ib3R0b20gPSBzY3JvbGxQb3MueSArIGJvdHRvbTtcbiAgICAgICAgICAgICAgICByZWdpb24ubGVmdCA9IHNjcm9sbFBvcy54ICsgbGVmdDtcbiAgICAgICAgICAgICAgICByZWdpb24ucmlnaHQgPSBzY3JvbGxQb3MueCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgIHJlZ2lvbi50b3AgPSBzY3JvbGxQb3MueSArIHRvcDtcblxuICAgICAgICAgICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5lbmRSZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzY3JvbGxQb3MueSArIGVuZFJlY3QuYm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBlbmRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNjcm9sbFBvcy54ICsgZW5kUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNjcm9sbFBvcy54ICsgZW5kUmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogc2Nyb2xsUG9zLnkgKyBlbmRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbmRSZWN0LndpZHRoXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnN0YXJ0UmVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2Nyb2xsUG9zLnkgKyBzdGFydFJlY3QuYm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzdGFydFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2Nyb2xsUG9zLnggKyBzdGFydFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzY3JvbGxQb3MueCArIHN0YXJ0UmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogc2Nyb2xsUG9zLnkgKyBzdGFydFJlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHN0YXJ0UmVjdC53aWR0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvbi4gVGhlIGRpcmVjdGlvbiBpcyBmcm9tIHRvcCB0byBib3R0b20gb3IgZnJvbSBib3R0b20gdG8gdG9wLlxuICAgICAgICAgKiBGb3IgSUUgPCA5IGl0IGlzIG5vdCBwb3NzaWJsZSwgc28gdGhlIGRpcmVjdGlvbiBmb3IgdGhlc2UgYnJvd3NlcnMgd2lsbCBiZSBhbHdheXMgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2VsZWN0aW9uRGlyZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyBhIG51bWJlciB3aGljaCByZXByZXNlbnRzIHNlbGVjdGlvbiBkaXJlY3Rpb24uIEl0IG1pZ2h0IGJlIG9uZSBvZiB0aGVzZTpcbiAgICAgICAgICogLSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTTtcbiAgICAgICAgICogLSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcbiAgICAgICAgICovXG4gICAgICAgIGdldFNlbGVjdGlvbkRpcmVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT007XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBuYXRpdmVTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0TmF0aXZlKCk7XG5cbiAgICAgICAgICAgIGlmICghbmF0aXZlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuY2hvck5vZGU7XG5cbiAgICAgICAgICAgIGlmICgoYW5jaG9yTm9kZSA9IG5hdGl2ZVNlbGVjdGlvbi5hbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gYW5jaG9yTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuYXRpdmVTZWxlY3Rpb24uZm9jdXNOb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmICghcG9zaXRpb24gJiYgbmF0aXZlU2VsZWN0aW9uLmFuY2hvck9mZnNldCA+IG5hdGl2ZVNlbGVjdGlvbi5mb2N1c09mZnNldCB8fCBwb3NpdGlvbiA9PT0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfc2VsZWN0aW9ucmVnaW9uJywge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHIsXG4gICAgICAgICAgICAgICAgICAgIGhhc093blByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgZm9yIChhdHRyIGluIFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoU2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZSwgYXR0cikgJiYgdHlwZW9mIGVkaXRvclthdHRyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvclthdHRyXSA9IFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGVbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIElFX05PTl9ESVJFQ1RMWV9FRElUQUJMRV9FTEVNRU5UID0ge1xuICAgICAgICAndGFibGUnOiAxLFxuICAgICAgICAnY29sJzogMSxcbiAgICAgICAgJ2NvbGdyb3VwJzogMSxcbiAgICAgICAgJ3Rib2R5JzogMSxcbiAgICAgICAgJ3RkJzogMSxcbiAgICAgICAgJ3Rmb290JzogMSxcbiAgICAgICAgJ3RoJzogMSxcbiAgICAgICAgJ3RoZWFkJzogMSxcbiAgICAgICAgJ3RyJzogMVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUYWJsZSBjbGFzcyB1dGlsaXR5LiBQcm92aWRlcyBtZXRob2RzIGZvciBjcmVhdGUsIGRlbGV0ZSBhbmQgdXBkYXRlIHRhYmxlcy5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5UYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVGFibGUoZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcbiAgICB9XG5cbiAgICBUYWJsZS5IRUFESU5HX0JPVEggPSAnQm90aCc7XG4gICAgVGFibGUuSEVBRElOR19DT0wgPSAnQ29sdW1uJztcbiAgICBUYWJsZS5IRUFESU5HX05PTkUgPSAnTm9uZSc7XG4gICAgVGFibGUuSEVBRElOR19ST1cgPSAnUm93JztcblxuICAgIFRhYmxlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFRhYmxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUYWJsZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjcmVhdGVkIHRhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fMKge307XG5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSByb3dzIGFuZCBjb2xzLlxuICAgICAgICAgICAgdmFyIHRib2R5ID0gdGFibGUuYXBwZW5kKHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3Rib2R5JykpO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSBjb25maWcucm93cyB8fCAxO1xuICAgICAgICAgICAgdmFyIGNvbHMgPSBjb25maWcuY29scyB8fCAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSB0Ym9keS5hcHBlbmQodGhpcy5fY3JlYXRlRWxlbWVudCgndHInKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2xzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSByb3cuYXBwZW5kKHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3RkJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNlbGwuYXBwZW5kQm9ndXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh0YWJsZSwgY29uZmlnLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGluZyh0YWJsZSwgY29uZmlnLmhlYWRpbmcpO1xuXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIHRhYmxlIGVsZW1lbnQgaWYgd2UncmUgY3JlYXRpbmcgb25lLlxuICAgICAgICAgICAgZWRpdG9yLmluc2VydEVsZW1lbnQodGFibGUpO1xuXG4gICAgICAgICAgICB2YXIgZmlyc3RDZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1swXS5jZWxsc1swXSk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVUb1Bvc2l0aW9uKGZpcnN0Q2VsbCwgQ0tFRElUT1IuUE9TSVRJT05fQUZURVJfU1RBUlQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgdGFibGUgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQG1ldGhvZCBnZXRGcm9tU2VsZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBUaGUgcmV0cmlldmVkIHRhYmxlIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RnJvbVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGFibGU7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuaXMoJ3RhYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlYmtpdCBjb3VsZCByZXBvcnQgdGhlIGZvbGxvd2luZyByYW5nZSBvbiBjZWxsIHNlbGVjdGlvbiAoIzQ5NDgpOlxuICAgICAgICAgICAgICAgICAgICAvLyA8dGFibGU+PHRyPjx0ZD5bJm5ic3A7PC90ZD48L3RyPjwvdGFibGU+XVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChDS0VESVRPUi5lbnYud2Via2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXNbMF0uc2hyaW5rKENLRURJVE9SLk5PREVfRUxFTUVOVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHRoaXMuX2VkaXRvci5lbGVtZW50UGF0aChyYW5nZXNbMF0uZ2V0Q29tbW9uQW5jZXN0b3IodHJ1ZSkpLmNvbnRhaW5zKCd0YWJsZScsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB0YWJsZSBjYW4gYmUgY29uc2lkZXJlZCBhcyBlZGl0YWJsZS4gVGhpcyBtZXRob2RcbiAgICAgICAgICogd29ya2Fyb3VuZHMgYSBsaW1pdGF0aW9uIG9mIElFIHdoZXJlIGZvciBzb21lIGVsZW1lbnRzIChsaWtlIHRhYmxlKSxcbiAgICAgICAgICogYGlzQ29udGVudEVkaXRhYmxlYCByZXR1cm5zIGFsd2F5cyBmYWxzZS4gVGhpcyBpcyBiZWNhdXNlIElFIGRvZXMgbm90IHN1cHBvcnRcbiAgICAgICAgICogYGNvbnRlbnRlZGl0YWJsZWAgb24gc3VjaCBlbGVtZW50cy4gSG93ZXZlciwgZGVzcGl0ZSBzdWNoIGVsZW1lbnRzXG4gICAgICAgICAqIGNhbm5vdCBiZSBzZXQgYXMgY29udGVudCBlZGl0YWJsZSBkaXJlY3RseSwgYSBjb250ZW50IGVkaXRhYmxlIFNQQU4sXG4gICAgICAgICAqIG9yIERJViBlbGVtZW50IGNhbiBiZSBwbGFjZWQgaW5zaWRlIHRoZSBpbmRpdmlkdWFsIHRhYmxlIGNlbGxzLlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzgzNyUyOHY9VlMuODUlMjkuYXNweFxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBtZXRob2QgaXNFZGl0YWJsZVxuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBUaGUgdGFibGUgZWxlbWVudCB0byB0ZXN0IGlmIGVkaXRhYmxlXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0VkaXRhYmxlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICghQ0tFRElUT1IuZW52LmllIHx8ICFlbC5pcyhJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmlzUmVhZE9ubHkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgIT09ICdmYWxzZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0VkaXRhYmxlKGVsLmdldFBhcmVudCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB3aGljaCBoZWFkaW5nIHN0eWxlIGlzIHNldCBmb3IgdGhlIGdpdmVuIHRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBtZXRob2QgZ2V0SGVhZGluZ1xuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZSBUaGUgdGFibGUgdG8gZ2F0aGVyIHRoZSBoZWFkaW5nIGZyb20uIElmIG51bGwsIGl0IHdpbGwgYmUgcmV0cmlldmVkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBoZWFkaW5nIG9mIHRoZSB0YWJsZS4gRXhwZWN0ZWQgdmFsdWVzIGFyZSBgQ0tFRElUT1IuVGFibGUuTk9ORWAsIGBDS0VESVRPUi5UYWJsZS5ST1dgLCBgQ0tFRElUT1IuVGFibGUuQ09MYCBhbmQgYENLRURJVE9SLlRhYmxlLkJPVEhgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVhZGluZzogZnVuY3Rpb24odGFibGUpIHtcbiAgICAgICAgICAgIHRhYmxlID0gdGFibGUgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICghdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJvd0hlYWRpbmdTZXR0aW5ncyA9IHRhYmxlLiQudEhlYWQgIT09IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBjb2xIZWFkaW5nU2V0dGluZ3MgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgb2YgdGhlIGZpcnN0IGNlbGxzIGluIGV2ZXJ5IHJvdyBhcmUgVEhcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRhYmxlLiQucm93cy5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYganVzdCBvbmUgY2VsbCBpc24ndCBhIFRIIHRoZW4gaXQgaXNuJ3QgYSBoZWFkZXIgY29sdW1uXG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0YWJsZS4kLnJvd3Nbcm93XS5jZWxsc1swXTtcblxuICAgICAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3RoJykge1xuICAgICAgICAgICAgICAgICAgICBjb2xIZWFkaW5nU2V0dGluZ3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGVhZGluZ1NldHRpbmdzID0gVGFibGUuSEVBRElOR19OT05FO1xuXG4gICAgICAgICAgICBpZiAocm93SGVhZGluZ1NldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZ1NldHRpbmdzID0gVGFibGUuSEVBRElOR19ST1c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2xIZWFkaW5nU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBoZWFkaW5nU2V0dGluZ3MgPSAoaGVhZGluZ1NldHRpbmdzID09PSBUYWJsZS5IRUFESU5HX1JPVyA/IFRhYmxlLkhFQURJTkdfQk9USCA6IFRhYmxlLkhFQURJTkdfQ09MKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhlYWRpbmdTZXR0aW5ncztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHRhYmxlIGZyb20gdGhlIGVkaXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZSBUaGUgdGFibGUgZWxlbWVudCB3aGljaCB0YWJsZSBzdHlsZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24odGFibGUpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG5cbiAgICAgICAgICAgIGlmICh0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRhYmxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWJsZSA9IGVkaXRvci5lbGVtZW50UGF0aCgpLmNvbnRhaW5zKCd0YWJsZScsIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YWJsZSdzIHBhcmVudCBoYXMgb25seSBvbmUgY2hpbGQgcmVtb3ZlIGl0IGFzIHdlbGwgKHVubGVzcyBpdCdzIGEgdGFibGUgY2VsbCwgb3IgdGhlIGVkaXRhYmxlIGVsZW1lbnQpICgjNTQxNiwgIzYyODksICMxMjExMClcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRhYmxlLmdldFBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmdldENoaWxkQ291bnQoKSA9PT0gMSAmJiAhcGFyZW50LmlzKCd0ZCcsICd0aCcpICYmICFwYXJlbnQuZXF1YWxzKGVkaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubW92ZVRvUG9zaXRpb24odGFibGUsIENLRURJVE9SLlBPU0lUSU9OX0JFRk9SRV9TVEFSVCk7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbnMgcHJvdmlkZWQgYXR0cmlidXRlcyB0byBhIHRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QXR0cmlidXRlc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFibGUgVGhlIHRhYmxlIHRvIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhc3NpZ25lZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgd2hpY2ggaGF2ZSB0byBiZSBhc3NpZ25lZCB0byB0aGUgdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIHNldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHRhYmxlLCBhdHRycykge1xuICAgICAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBhcHByb3ByaWF0ZSB0YWJsZSBoZWFkaW5nIHN0eWxlIHRvIGEgdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRIZWFkaW5nXG4gICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IHRhYmxlIFRoZSB0YWJsZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBoZWFkaW5nIHNob3VsZCBiZSBzZXQuIElmIG51bGwsIGl0IHdpbGwgYmUgcmV0cmlldmVkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGVhZGluZyBUaGUgdGFibGUgaGVhZGluZyB0byBiZSBzZXQuIEFjY2VwdGVkIHZhbHVlcyBhcmU6IGBDS0VESVRPUi5UYWJsZS5OT05FYCwgYENLRURJVE9SLlRhYmxlLlJPV2AsIGBDS0VESVRPUi5UYWJsZS5DT0xgIGFuZCBgQ0tFRElUT1IuVGFibGUuQk9USGAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRIZWFkaW5nOiBmdW5jdGlvbih0YWJsZSwgaGVhZGluZykge1xuICAgICAgICAgICAgdGFibGUgPSB0YWJsZSB8fCB0aGlzLmdldEZyb21TZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgdmFyIGksIG5ld0NlbGw7XG4gICAgICAgICAgICB2YXIgdGFibGVIZWFkO1xuICAgICAgICAgICAgdmFyIHRhYmxlQm9keSA9IHRhYmxlLmdldEVsZW1lbnRzQnlUYWcoJ3Rib2R5JykuZ2V0SXRlbSgwKTtcblxuICAgICAgICAgICAgdmFyIHRhYmxlSGVhZGluZyA9IHRoaXMuZ2V0SGVhZGluZyh0YWJsZSk7XG4gICAgICAgICAgICB2YXIgaGFkQ29sSGVhZGluZyA9ICh0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQ09MIHx8IHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIKTtcblxuICAgICAgICAgICAgdmFyIG5lZWRDb2xIZWFkaW5nID0gaGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19DT0wgfHwgaGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIO1xuICAgICAgICAgICAgdmFyIG5lZWRSb3dIZWFkaW5nID0gaGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19ST1cgfHwgaGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBuZWVkIHJvdyBoZWFkaW5nIGFuZCBkb24ndCBoYXZlIGEgPHRoZWFkPiBlbGVtZW50IHlldCwgbW92ZSB0aGVcbiAgICAgICAgICAgIC8vIGZpcnN0IHJvdyBvZiB0aGUgdGFibGUgdG8gdGhlIGhlYWQgYW5kIGNvbnZlcnQgdGhlIG5vZGVzIHRvIDx0aD4gb25lcy5cbiAgICAgICAgICAgIGlmICghdGFibGUuJC50SGVhZCAmJiBuZWVkUm93SGVhZGluZykge1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZUZpcnN0Um93ID0gdGFibGVCb2R5LmdldEVsZW1lbnRzQnlUYWcoJ3RyJykuZ2V0SXRlbSgwKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVGaXJzdFJvd0NoaWxkQ291bnQgPSB0YWJsZUZpcnN0Um93LmdldENoaWxkQ291bnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBURCB0byBUSDpcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFibGVGaXJzdFJvd0NoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRhYmxlRmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBib29rbWFyayBub2Rlcy4gKCM2MTU1KVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC50eXBlID09PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiYgIWNlbGwuZGF0YSgnY2tlLWJvb2ttYXJrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwucmVuYW1lTm9kZSgndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKCdzY29wZScsICdjb2wnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhYmxlSGVhZCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFibGUuJC5jcmVhdGVUSGVhZCgpKTtcbiAgICAgICAgICAgICAgICB0YWJsZUhlYWQuYXBwZW5kKHRhYmxlRmlyc3RSb3cucmVtb3ZlKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBuZWVkIHJvdyBoZWFkaW5nIGFuZCB3ZSBoYXZlIGEgPHRoZWFkPiBlbGVtZW50LCBtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gcm93IG91dCBvZiB0aGVyZSBhbmQgaW50byB0aGUgPHRib2R5PiBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKHRhYmxlLiQudEhlYWQgIT09IG51bGwgJiYgIW5lZWRSb3dIZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgcm93IG91dCBvZiB0aGUgVEhlYWQgYW5kIHB1dCBpdCBpbiB0aGUgVEJvZHk6XG4gICAgICAgICAgICAgICAgdGFibGVIZWFkID0gdGhpcy5fY3JlYXRlRWxlbWVudCh0YWJsZS4kLnRIZWFkKTtcblxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Um93ID0gdGFibGVCb2R5LmdldEZpcnN0KCk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAodGFibGVIZWFkLmdldENoaWxkQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0Um93ID0gdGFibGVIZWFkLmdldEZpcnN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdFJvd0NoaWxkQ291bnQgPSBuZXdGaXJzdFJvdy5nZXRDaGlsZENvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld0ZpcnN0Um93Q2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsID0gbmV3Rmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDZWxsLnR5cGUgPT09IENLRURJVE9SLk5PREVfRUxFTUVOVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwucmVuYW1lTm9kZSgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLnJlbW92ZUF0dHJpYnV0ZSgnc2NvcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpcnN0Um93Lmluc2VydEJlZm9yZShwcmV2aW91c0ZpcnN0Um93KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YWJsZUhlYWQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhYmxlSGVhZGluZyA9IHRoaXMuZ2V0SGVhZGluZyh0YWJsZSk7XG4gICAgICAgICAgICB2YXIgaGFzQ29sSGVhZGluZyA9ICh0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQ09MIHx8IHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIKTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgbmVlZCBjb2x1bW4gaGVhZGluZyBhbmQgdGhlIHRhYmxlIGRvZXNuJ3QgaGF2ZSBpdCwgY29udmVydCBldmVyeSBmaXJzdCBjZWxsIGluXG4gICAgICAgICAgICAvLyBldmVyeSByb3cgaW50byBhIGA8dGggc2NvcGU9XCJyb3dcIj5gIGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoIWhhc0NvbEhlYWRpbmcgJiYgbmVlZENvbEhlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFibGUuJC5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZS4kLnJvd3NbaV0uY2VsbHNbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3RoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbaV0uY2VsbHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5yZW5hbWVOb2RlKCd0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgJ3JvdycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBuZWVkIGNvbHVtbiBoZWFkaW5nIGJ1dCB0aGUgdGFibGUgaGFzIGl0LCBjb252ZXJ0IGV2ZXJ5IGZpcnN0IGNlbGwgaW4gZXZlcnlcbiAgICAgICAgICAgIC8vIHJvdyBiYWNrIGludG8gYSBgPHRkPmAgZWxlbWVudC5cbiAgICAgICAgICAgIGlmIChoYWRDb2xIZWFkaW5nICYmICFuZWVkQ29sSGVhZGluZykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0UGFyZW50KCkuZ2V0TmFtZSgpID09PSAndGJvZHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHJvdy4kLmNlbGxzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwucmVuYW1lTm9kZSgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCdzY29wZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50IHVzaW5nIHRoZSBwYXNzZWQgdGFnIG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWV0aG9kIF9jcmVhdGVFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSB0YWcgbmFtZSBmcm9tIHdoaWNoIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgICAgICAgICogQHJldHVybiB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IEluc3RhbmNlIG9mIENLRURJVE9SIERPTSBlbGVtZW50IGNsYXNzXG4gICAgICAgICAqL1xuICAgICAgICBfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChuYW1lLCB0aGlzLl9lZGl0b3IuZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENLRURJVE9SLm9uKCdpbnN0YW5jZVJlYWR5JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGhlYWRpbmdDb21tYW5kcyA9IFtUYWJsZS5IRUFESU5HX05PTkUsIFRhYmxlLkhFQURJTkdfUk9XLCBUYWJsZS5IRUFESU5HX0NPTCwgVGFibGUuSEVBRElOR19CT1RIXTtcblxuICAgICAgICB2YXIgdGFibGVVdGlscyA9IG5ldyBUYWJsZShldmVudC5lZGl0b3IpO1xuXG4gICAgICAgIGhlYWRpbmdDb21tYW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRpbmcpIHtcbiAgICAgICAgICAgIGV2ZW50LmVkaXRvci5hZGRDb21tYW5kKCd0YWJsZUhlYWRpbmcnICsgaGVhZGluZywge1xuICAgICAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZVV0aWxzLnNldEhlYWRpbmcobnVsbCwgaGVhZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgQ0tFRElUT1IuVGFibGUgPSBDS0VESVRPUi5UYWJsZSB8fCBUYWJsZTtcbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ0tFRElUT1IudG9vbHMgY2xhc3MgdXRpbGl0eSB3aGljaCBhZGRzIGFkZGl0aW9uYWwgbWV0aG9kcyB0byB0aG9zZSBvZiBDS0VkaXRvci5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi50b29sc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSByZXF1ZXN0IHVzaW5nIHRoZSBKU09OUCB0ZWNobmlxdWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAgICAgKiBAbWV0aG9kIGpzb25wXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi50ZW1wbGF0ZX0gdXJsVGVtcGxhdGUgVGhlIHRlbXBsYXRlIG9mIHRoZSBVUkwgdG8gYmUgcmVxdWVzdGVkLiBBbGwgcHJvcGVydGllcyBwYXNzZWQgaW4gYHVybFBhcmFtc2AgY2FuIGJlIHVzZWQsIHBsdXMgYSBge2NhbGxiYWNrfWAsIHdoaWNoIHJlcHJlc2VudCBhIEpTT05QIGNhbGxiYWNrLCBtdXN0IGJlIGRlZmluZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gY2FzZSBvZiBzdWNjZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1cmxQYXJhbXMgUGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIGB1cmxUZW1wbGF0ZWAuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogIC0gaWQ6IHRoZSB0cmFuc2FjdGlvbiBJRFxuICAgICAqICAtIGEgYGNhbmNlbCgpYCBtZXRob2RcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQ0tFRElUT1IudG9vbHMuanNvbnAgPSBmdW5jdGlvbih1cmxUZW1wbGF0ZSwgdXJsUGFyYW1zLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgY2FsbGJhY2tLZXkgPSBDS0VESVRPUi50b29scy5nZXROZXh0TnVtYmVyKCk7XG5cbiAgICAgICAgdXJsUGFyYW1zID0gdXJsUGFyYW1zIHx8IHt9O1xuICAgICAgICB1cmxQYXJhbXMuY2FsbGJhY2sgPSAnQ0tFRElUT1IuXy5qc29ucENhbGxiYWNrc1snICsgY2FsbGJhY2tLZXkgKyAnXSc7XG5cbiAgICAgICAgaWYgKCFDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzW2NhbGxiYWNrS2V5XSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNsZWFuVXAoKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzY3JpcHRFbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHVybFRlbXBsYXRlLm91dHB1dCh1cmxQYXJhbXMpKTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5vbignZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFuVXAoKTtcblxuICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgICAgICBpZiAoc2NyaXB0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIENLRURJVE9SLl8uanNvbnBDYWxsYmFja3NbY2FsbGJhY2tLZXldO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQ0tFRElUT1IuZG9jdW1lbnQuZ2V0Qm9keSgpLmFwcGVuZChzY3JpcHRFbGVtZW50KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FuY2VsOiBjbGVhblVwLFxuICAgICAgICAgICAgaWQ6IGNhbGxiYWNrS2V5XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCB0aGUgc3VwcGxpZWRcbiAgICAgKiBvYmplY3RzLiBUaGUgcHJvcGVydGllcyBmcm9tIGxhdGVyIG9iamVjdHMgd2lsbCBvdmVyd3JpdGUgdGhvc2UgaW4gZWFybGllclxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBQYXNzaW5nIGluIGEgc2luZ2xlIG9iamVjdCB3aWxsIGNyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBpdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICAgICAqIEBtZXRob2QgbWVyZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyogT25lIG9yIG1vcmUgb2JqZWN0cyB0byBtZXJnZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG1lcmdlZCBvYmplY3QuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENLRURJVE9SLnRvb2xzLm1lcmdlID0gQ0tFRElUT1IudG9vbHMubWVyZ2UgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2ltdWxhdGVzIGV2ZW50IG9uIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAgICAgKiBAbWV0aG9kIHNpbXVsYXRlXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCBzaG91ZCBiZSBzaW11YWx0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudCB3aGljaCBoYXZlIHRvIGJlIHNpbXVsYXRlZC5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQ0tFRElUT1IudG9vbHMuc2ltdWxhdGUgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudCkge1xuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgZXZlbnRJbnN0YW5jZS5pbml0RXZlbnQoZXZlbnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50SW5zdGFuY2UpO1xuICAgIH07XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3VpY29yZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVSUNvcmUgY2xhc3Mgd2hpY2ggd2lsbCBoYW5kbGUgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgZWRpdG9yLiBUaGVzZSBpbnRlcmFjdGlvbnNcbiAgICAgKiBtaWdodCBiZSB0cmlnZ2VyZWQgdmlhIG1vdXNlLCBrZXlib2FyZCBvciB0b3VjaCBkZXZpY2VzLiBUaGUgY2xhc3MgZmlsbCBmaXJlIGFuIGV2ZW50IHZpYVxuICAgICAqIENLRWRpdG9yJ3MgZXZlbnQgc3lzdGVtIC0gXCJlZGl0b3JJbnRlcmFjdGlvblwiLiBUaGUgVUkgbWF5IGxpc3RlbiB0byB0aGlzIGV2ZW50IGFuZFxuICAgICAqIGV4ZWN1dGUgc29tZSBhY3Rpb25zIC0gZm9yIGV4YW1wbGUgdG8gc2hvdy9oaWRlIHRvb2xiYXJzLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBpZiB1c2VyIHByZXNzZXMgdGhlIEVzYyBrZXksICdlZGl0b3JJbnRlcmFjdGlvbicgZXZlbnQgd29uJ3QgYmUgZmlyZWQuIEhvd2V2ZXIsIHRoaXMgYmVoYXZpb3VyIGNhbiBiZSBjaGFuZ2VkXG4gICAgICogYnkgc2V0dGluZyB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS9hbGxvd0VzYzphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX0gY29uZmlnIHByb3BlcnR5IGluIGVkaXRvcidzIGNvbmZpZ3VyYXRpb24gdG8gdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBhZV91aWNvcmVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdXNlciBpbnRlcmFjdHMgc29tZWhvdyB3aXRoIHRoZSBicm93c2VyLiBUaGlzIG1heSBiZSBjbGlja2luZyB3aXRoIHRoZSBtb3VzZSwgcHJlc3Npbmcga2V5Ym9hcmQgYnV0dG9uLFxuICAgICAqIG9yIHRvdWNoaW5nIHNjcmVlbi4gVGhpcyBldmVuIHdpbGwgYmUgbm90IGZpcmVkIGFmdGVyIGVhY2ggaW50ZXJhY3Rpb24uIEl0IHdpbGwgYmUgZGVib3VuY2VkLiBCeSBkZWZhdWx0IHRoZSB0aW1lb3V0XG4gICAgICogaXMgNTBtcy4gVGhpcyB2YWx1ZSBjYW4gYmUgb3ZlcndyaXR0ZW4gdmlhIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL3RpbWVvdXQ6YXR0cmlidXRlXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogcHJvcGVydHkgb2YgZWRpdG9yJ3MgY29uZmlndXJhdGlvbiwgbGlrZTogZWRpdG9yLmNvbmZpZy51aWNvcmUudGltZW91dCA9IDEwMFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGFlX3VpY29yZVxuICAgICAqIEBldmVudCBhZV91aWNvcmUjZWRpdG9ySW50ZXJhY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIC0gbmF0aXZlRXZlbnQgLSBUaGUgZXZlbnQgYXMgcmVjZWl2ZWQgZnJvbSBDS0VkaXRvci5cbiAgICAgKiAtIHNlbGVjdGlvbkRhdGEgLSBUaGUgZGF0YSwgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYnkgVUkgZWxlbWVudHMgbGlrZSBUb29sYmFycyBvciBCdXR0b25zIHdoZW4gdGhlaXIgc3RhdGUgY2hhbmdlcy4gVGhlIGxpc3RlbmVyIHVwZGF0ZXMgdGhlIGxpdmUgcmVnaW9uIHdpdGggdGhlIHByb3ZpZGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG4gICAgICogQGV2ZW50IGFlX3VpY29yZSNhcmlhVXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAtIG1lc3NhZ2UgLSBUaGUgcHJvdmlkZWQgbWVzc2FnZSBmcm9tIHRoZSBVSSBlbGVtZW50LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBlZGl0b3Igd2lsbCBzdGlsbCBmaXJlIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL2VkaXRvckludGVyYWN0aW9uOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LFxuICAgICAqIGlmIHVzZXIgcHJlc3NlcyBFc2Mga2V5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIGFlX3VpY29yZVxuICAgICAqIEBhdHRyaWJ1dGUgYWxsb3dFc2NcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZGVmYXVsdCB0aW1lb3V0IGFmdGVyIHdoaWNoIHRoZSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS9lZGl0b3JJbnRlcmFjdGlvbjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuICAgICAqIHdpbGwgYmUgZmlyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG4gICAgICogQGF0dHJpYnV0ZSB0aW1lb3V0XG4gICAgICogQGRlZmF1bHQgNTAgKG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV91aWNvcmUnLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVyIGxpZmVjeWNsZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFVJQ29yZSBwbHVnaW4uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIGFlX3VpY29yZVxuICAgICAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IENLRWRpdG9yIGluc3RhbmNlLlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJpYVN0YXRlID0gW107XG5cbiAgICAgICAgICAgICAgICB2YXIgYXJpYUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVBcmlhRWxlbWVudChlZGl0b3IuaWQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHVpVGFza3NUaW1lb3V0ID0gZWRpdG9yLmNvbmZpZy51aWNvcmUgPyBlZGl0b3IuY29uZmlnLnVpY29yZS50aW1lb3V0IDogNTA7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlVUkgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubmFtZSAhPT0gJ2tleXVwJyB8fCBldmVudC5kYXRhLiQua2V5Q29kZSAhPT0gMjcgfHwgZWRpdG9yLmNvbmZpZy5hbGxvd0VzYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25EYXRhID0gZWRpdG9yLmdldFNlbGVjdGlvbkRhdGEoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudC5kYXRhLiQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25EYXRhOiBzZWxlY3Rpb25EYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdWlUYXNrc1RpbWVvdXRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZUFyaWEgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFFbGVtZW50LmlubmVySFRNTCA9IGFyaWFTdGF0ZS5qb2luKCcuICcpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1aVRhc2tzVGltZW91dFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlTW91c2VMZWF2ZSA9IENLRURJVE9SLnRvb2xzLmRlYm91bmNlKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFlVUlOb2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hZS11aScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWVVSU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFlVUlOb2Rlc1tpXS5jb250YWlucyhldmVudC5kYXRhLiQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVVSShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVpVGFza3NUaW1lb3V0XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5vbignYXJpYVVwZGF0ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZUFyaWEgaXMgZGVib3VuY2VkIGZ1bmN0aW9uLCBzbyBpZiBpdCBpcyBiZWluZyBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIGl0IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgY2FuY2VsZWQgdW50aWwgc29tZSB0aW1lIHBhc3Nlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIGhlcmUgd2UgZXhwbGljaXRseSBhcHBlbmQgdGhlIGN1cnJlbnQgbWVzc2FnZSB0byB0aGUgbGlzdCBvZiBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY2FsbCBoYW5kbGVBcmlhLiBTaW5jZSBpdCBpcyBkZWJvdW5jZWQsIHdoZW4gc29tZSB0aW1lb3V0IHBhc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIHRoZSBtZXNzYWdlcyB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGxpdmUgcmVnaW9uIGFuZCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlLnB1c2goZXZlbnQuZGF0YS5tZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVBcmlhKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9jdXNIYW5kbGVyID0gZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdmb2N1cycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNIYW5kbGVyLnJlbW92ZUxpc3RlbmVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAna2V5dXAnLCBoYW5kbGVVSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ21vdXNldXAnLCBoYW5kbGVVSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ21vdXNlbGVhdmUnLCBoYW5kbGVNb3VzZUxlYXZlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVUkoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5vbignZGVzdHJveScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYXJpYUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVVJLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGFuZCBhcHBsaWVzIGFuIEhUTUwgZWxlbWVudCB0byB0aGUgYm9keSBvZiB0aGUgZG9jdW1lbnQgd2hpY2ggd2lsbCBjb250YWluIEFSSUEgbWVzc2FnZXMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIGFlX3VpY29yZVxuICAgICAgICAgICAgICogQG1ldGhvZCBfY3JlYXRlQXJpYUVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgcHJvdmlkZWQgaWQgb2YgdGhlIGVsZW1lbnQuIEl0IHdpbGwgYmUgdXNlZCBhcyBwcmVmaXggZm9yIHRoZSBmaW5hbCBlbGVtZW50IElkLlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBjcmVhdGVkIGFuZCBhcHBsaWVkIHRvIERPTSBlbGVtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfY3JlYXRlQXJpYUVsZW1lbnQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgICAgIHN0YXR1c0VsZW1lbnQuY2xhc3NOYW1lID0gJ2FlLXNyLW9ubHknO1xuXG4gICAgICAgICAgICAgICAgc3RhdHVzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdzdGF0dXMnKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBpZCArICdMaXZlUmVnaW9uJyk7XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0VsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1c0VsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuL2xhbmcuanMnO1xuXG4vKipcbiAqIEF0dHJpYnV0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAY2xhc3MgQXR0cmlidXRlXG4gKiBAY29uc3RydWN0b3JcbiovXG5mdW5jdGlvbiBBdHRyaWJ1dGUoY29uZmlnKSB7XG4gICAgdGhpcy5fX2NvbmZpZ19fID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuX19BVFRSU19fID0ge307XG59XG5cbkF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEF0dHJpYnV0ZSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB3aGljaCB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge0FueX0gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIHZhciBjdXJyZW50QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuQVRUUlNbYXR0cl07XG5cbiAgICAgICAgaWYgKCFjdXJyZW50QXR0cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKGF0dHIpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KGF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1clZhbHVlID0gdGhpcy5fX0FUVFJTX19bYXR0cl07XG5cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLmdldHRlcikge1xuICAgICAgICAgICAgY3VyVmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci5nZXR0ZXIsIGN1clZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2V0LlxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggc2hvdWxkIGJlIHNldCB0byB0aGUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5BVFRSU1thdHRyXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRBdHRyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQoYXR0cikpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXQoYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEF0dHIucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci53cml0ZU9uY2UgJiYgdGhpcy5faXNJbml0aWFsaXplZChhdHRyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLnZhbGlkYXRvciAmJiAhdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIudmFsaWRhdG9yLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci5zZXR0ZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIuc2V0dGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgcHJvdmlkZWQgcGFyYW0gYXMgZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqIElmIHBhcmFtIHByb3ZpZGVkIGFzIHN0cmluZywgYSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uIGluIHRoaXMgb2JqZWN0IHdpbGxcbiAgICAgKiBiZSBjYWxsZWQuIElmIHByb3ZpZGVkIHBhcmFtIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgZGlyZWN0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuICAgICAqIEBtZXRob2QgX2NhbGxTdHJpbmdPckZ1bmN0aW9uXG4gICAgICogQHBhcmFtICB7QW55fEFycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgd2hpY2ggd2lsbCBiZSBwcm92aWRlZCB0byB0aGUgY2FsbGVkIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfEZ1bmN0aW9ufSBzdHJpbmdPckZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgY2FsbGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FueX0gVGhlIHJldHVybmVkIHZhbHVlIGZyb20gdGhlIGNhbGxlZCBmdW5jdGlvblxuICAgICAqL1xuICAgIF9jYWxsU3RyaW5nT3JGdW5jdGlvbjogZnVuY3Rpb24oc3RyaW5nT3JGdW5jdGlvbiwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICBpZiAoIUxhbmcuaXNBcnJheShhcmdzKSkge1xuICAgICAgICAgICAgYXJncyA9IFthcmdzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChMYW5nLmlzU3RyaW5nKHN0cmluZ09yRnVuY3Rpb24pICYmIExhbmcuaXNGdW5jdGlvbih0aGlzW3N0cmluZ09yRnVuY3Rpb25dKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpc1tzdHJpbmdPckZ1bmN0aW9uXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChMYW5nLmlzRnVuY3Rpb24oc3RyaW5nT3JGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0cmluZ09yRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhdHRyaWJ1dGUuIFNldHMgaXRzIGRlZmF1bHQgdmFsdWUgZGVwZW5kaW5nIG9uIHRoZSBmbGFncyBvZiB0aGVcbiAgICAgKiBhdHRyaWJ1dGUgYW5kIHRoZSBwYXNzZWQgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHdoaWNoIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICB2YXIgY3VycmVudEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLkFUVFJTW2F0dHJdO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGRlZmF1bHQgdmFsdWUgb3IgcGFzc2VkIG9uZSB2aWEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgdmFyIGhhc0RlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50QXR0ciwgJ3ZhbHVlJyk7XG4gICAgICAgIHZhciBoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9fY29uZmlnX18sIGF0dHIpO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIHZhbHVlRm4sIHNldCB0aGUgdmFsdWUgdG8gYmUgdGhlIHJlc3VsdCBvZiBpbnZvY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLnZhbHVlRm4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIudmFsdWVGbiwgdmFsdWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgcmVhZE9ubHkgZmxhZywgc2V0IHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gdGhlIGF0dHJpYnV0ZSxcbiAgICAgICAgLy8gcmVnYXJkbGVzcyBpZiB0aGVyZSBpcyB2YWx1ZSBvciBub3RcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEF0dHIucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY3VycmVudEF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBpZiB0aGUgYXR0cmlidXRlIGhhcyB3cml0ZU9uY2UgdmFsdWUsIHNldCBpdCBmcm9tIHRoZSBwYXNzZWQgY29uZmlndXJhdGlvbiBvciBmcm9tIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlLCBpbiB0aGlzIG9yZGVyLiBPdGhlcndpc2UsIHJldHVybiBtaXNlcmFibGUuXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRBdHRyLndyaXRlT25jZSkge1xuICAgICAgICAgICAgaWYgKGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fY29uZmlnX19bYXR0cl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0RlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3VycmVudEF0dHIudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSB0d28gY2FzZXMgYmVsb3cgYXJlIGVhc3kgLSBzZXQgdGhlIHZhbHVlIHRvIGJlIGZyb20gdGhlIHBhc3NlZCBjb25maWcgb3JcbiAgICAgICAgLy8gZnJvbSB0aGUgZGVmYXVsdCB2YWx1ZSwgaW4gdGhpcyBvcmRlci5cbiAgICAgICAgZWxzZSBpZiAoaGFzUGFzc2VkVmFsdWVWaWFDb25maWcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX2NvbmZpZ19fW2F0dHJdO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0RlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50QXR0ci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIHZhbGlkYXRvciwgYW5kIHVzZXIgcGFzc2VkIGNvbmZpZyBvYmplY3QgLSBjaGVjayB0aGUgcmV0dXJuZWQgdmFsdWUuXG4gICAgICAgIC8vIElmIGl0IGlzIGZhbHNlLCB0aGVuIHNldCBhcyBpbml0aWFsIHZhbHVlIHRoZSBkZWZhdWx0IG9uZS5cbiAgICAgICAgLy8gSG93ZXZlciwgaWYgdGhlcmUgaXMgbm8gZGVmYXVsdCB2YWx1ZSwganVzdCByZXR1cm4uXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci52YWxpZGF0b3IgJiYgaGFzUGFzc2VkVmFsdWVWaWFDb25maWcgJiYgIXRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnZhbGlkYXRvciwgdmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50QXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgc2V0dGVyIGFuZCB1c2VyIHBhc3NlZCBjb25maWcgb2JqZWN0IC0gcGFzcyB0aGUgdmFsdWUgdGhvdWdodCB0aGUgc2V0dGVyLlxuICAgICAgICAvLyBUaGUgdmFsdWUgbWlnaHQgYmUgb25lIGZyb20gZGVmYXVsdEZuLCBkZWZhdWx0IHZhbHVlIG9yIHByb3ZpZGVkIGZyb20gdGhlIGNvbmZpZy5cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLnNldHRlciAmJiBoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci5zZXR0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIHNldCB0aGUgdmFsdWUgYXMgaW5pdGlhbCB2YWx1ZSB0byB0aGUgc3RvcmFnZSB3aXRoIHZhbHVlcy5cbiAgICAgICAgdGhpcy5fX0FUVFJTX19bYXR0cl0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFuIGF0dHJpYnV0ZSBpcyBpbml0aWFsaXplZC4gQW4gYXR0cmlidXRlIGlzIGNvbnNpZGVyZWQgYXMgaW5pdGlhbGl6ZWRcbiAgICAgKiB3aGVuIHRoZXJlIGlzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoaXMgbmFtZSBpbiB0aGUgbG9jYWwgY29sbGVjdGlvbiBvZiBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICogZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuICAgICAqIEBtZXRob2QgX2lzSW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIHdoaWNoIHNob3VsZCBiZSBjaGVja2VkIGlmIGl0IGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgYmVlbiBpbml0aWFsaXplZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIF9pc0luaXRpYWxpemVkOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX0FUVFJTX18sIGF0dHIpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJpYnV0ZTsiLCJpbXBvcnQgQXR0cmlidXRlIGZyb20gJy4vYXR0cmlidXRlLmpzJztcbmltcG9ydCBMYW5nIGZyb20gJy4vbGFuZy5qcyc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4vb29wLmpzJztcblxuLyoqXG4gKiBRdWljayBhbmQgZGlydHkgaW1wbCBvZiBCYXNlIGNsYXNzLlxuICpcbiAqIEBjbGFzcyBCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmFzZShjb25maWcpIHtcbiAgICBCYXNlLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gICAgdGhpcy5pbml0KGNvbmZpZyk7XG59XG5cbmV4dGVuZChCYXNlLCBBdHRyaWJ1dGUsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgYGluaXRpYWxpemVyYCBtZXRob2Qgb2YgZWFjaCBjbGFzcyB3aGljaCBleHRlbmRzIEJhc2Ugc3RhcnRpbmcgZnJvbSB0aGUgcGFyZW50IHRvIHRoZSBjaGlsZC5cbiAgICAgKiBXaWxsIHBhc3MgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRvIGVhY2ggaW5pdGlhbGl6ZXIgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJhc2VcbiAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2NhbGxDaGFpbignaW5pdGlhbGl6ZXInLCBjb25maWcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgYGRlc3RydWN0b3JgIG1ldGhvZCBvZiBlYWNoIGNsYXNzIHdoaWNoIGV4dGVuZHMgQmFzZSBzdGFydGluZyBmcm9tIHRoZSBwYXJlbnQgdG8gdGhlIGNoaWxkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJhc2VcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY2FsbENoYWluKCdkZXN0cnVjdG9yJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxzIGEgbWV0aG9kIG9mIGVhY2ggY2xhc3MsIHdoaWNoIGlzIGJlaW5nIHByZXNlbnQgaW4gdGhlIGhpZXJhcmNoeSBzdGFydGluZyBmcm9tIHBhcmVudCB0byB0aGUgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQmFzZVxuICAgICAqIEBtZXRob2QgX2NhbGxDaGFpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCB0aGUgbWV0aG9kIHNob3VsZCBiZSBpbnZva2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdhdCAgVGhlIG1ldGhvZCwgd2hpY2ggc2hvdWxkIGJlIGludm9rZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NhbGxDaGFpbjogZnVuY3Rpb24od2F0LCBhcmdzKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICAgICAgd2hpbGUgKGN0b3IpIHtcbiAgICAgICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oY3Rvci5wcm90b3R5cGVbd2F0XSkpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChjdG9yLnByb3RvdHlwZVt3YXRdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3RvciA9IGN0b3Iuc3VwZXJjbGFzcyA/IGN0b3Iuc3VwZXJjbGFzcy5jb25zdHJ1Y3RvciA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBhcnIgPSBhcnIucmV2ZXJzZSgpO1xuXG4gICAgICAgIGFyZ3MgPSBMYW5nLmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFycltpXTtcblxuICAgICAgICAgICAgaXRlbS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlOyIsIi8qKlxuICogUHJvdmlkZXMgY29yZSBsYW5ndWFnZSB1dGlsaXRpZXMuXG4gKlxuICogQGNsYXNzIExhbmdcbiAqL1xuY29uc3QgTGFuZyA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIGlzQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNBcnJheTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYm9vbGVhbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBpc0Jvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYm9vbGVhbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIGlzRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBOVUxMLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIGlzTnVsbFxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBOVUxMLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGlzTnVsbDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBpc051bWJlclxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBpc09iamVjdFxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiAodmFsdWVUeXBlID09PSAnb2JqZWN0JyB8fCBMYW5nLmlzRnVuY3Rpb24odmFsdWUpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgaXNTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHN1cHBsaWVyIHRvIHRoZSByZWNlaXZlci5cbiAgICAgKiBUaGUgZnVuY3Rpb24gd2lsbCBhZGQgYWxsIHByb3BlcnRpZXMsIG5vdCBvbmx5IHRoZXNlIG93bmVkIGJ5IHRoZSBzdXBwbGllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBtaXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjZWl2ZXIgVGhlIG9iamVjdCB3aGljaCB3aWxsIHJlY2VpdmUgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3VwcGxpZXIgVGhlIG9iamVjdCB3aGljaCBwcm92aWRlcyBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1vZGlmaWVkIHJlY2VpdmVyLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBtaXg6IGZ1bmN0aW9uKHJlY2VpdmVyLCBzdXBwbGllcikge1xuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdXBwbGllcikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3VwcGxpZXIsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcltrZXldID0gc3VwcGxpZXJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB2YWx1ZSB0byBJbnRlZ2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIHRvSW50XG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNvbnZlcnRlZCB0byBJbnRlZ2VyLlxuICAgICAqIEByZXR1cm4ge0ludGVnZXJ9IFRoZSBjb252ZXJ0ZWQgdmFsdWUuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHRvSW50OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYW5nOyIsImltcG9ydCBMYW5nIGZyb20gJy4vbGFuZyc7XG5cbi8qKlxuICogU2V0cyB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvIHN1cHBvcnQgYW4gaW5oZXJpdGFuY2Ugc3RyYXRlZ3lcbiAqIHRoYXQgY2FuIGNoYWluIGNvbnN0cnVjdG9ycyBhbmQgbWV0aG9kcy4gU3RhdGljIG1lbWJlcnMgd2lsbCBub3QgYmUgaW5oZXJpdGVkLlxuICpcbiAqIEBtZW1iZXJvZiBPT1BcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNlaXZlciBUaGUgY2xhc3Mgd2hpY2ggd2lsbCBleHRlbmQgYW5vdGhlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cHBsaWVyIFRoZSBjbGFzcyB3aGljaCB3aWxsIHByb3ZpZGUgdGhlIHByb3BlcnRpZXMgdGhlIGNoaWxkIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvUHJvcHMgUHJvdG90eXBlIHByb3BlcnRpZXMgdG8gYWRkL292ZXJyaWRlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRpY1Byb3BzIFN0YXRpYyBwcm9wZXJ0aWVzIHRvIGFkZC9vdmVyd3JpdGUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGV4dGVuZGVkIGNsYXNzLlxuICogQHN0YXRpY1xuICovXG5jb25zdCBleHRlbmQgPSBmdW5jdGlvbihyZWNlaXZlciwgc3VwcGxpZXIsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKCFzdXBwbGllciB8fCAhcmVjZWl2ZXIpIHtcbiAgICAgICAgdGhyb3cgJ2V4dGVuZCBmYWlsZWQsIHZlcmlmeSBkZXBlbmRlbmNpZXMnO1xuICAgIH1cblxuICAgIHZhciBzdXBwbGllclByb3RvID0gc3VwcGxpZXIucHJvdG90eXBlLCByZWNlaXZlclByb3RvID0gT2JqZWN0LmNyZWF0ZShzdXBwbGllclByb3RvKTtcbiAgICByZWNlaXZlci5wcm90b3R5cGUgPSByZWNlaXZlclByb3RvO1xuXG4gICAgcmVjZWl2ZXJQcm90by5jb25zdHJ1Y3RvciA9IHJlY2VpdmVyO1xuICAgIHJlY2VpdmVyLnN1cGVyY2xhc3MgPSBzdXBwbGllclByb3RvO1xuXG4gICAgLy8gYXNzaWduIGNvbnN0cnVjdG9yIHByb3BlcnR5XG4gICAgaWYgKHN1cHBsaWVyICE9PSBPYmplY3QgJiYgc3VwcGxpZXJQcm90by5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBzdXBwbGllclByb3RvLmNvbnN0cnVjdG9yID0gc3VwcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gYWRkIHByb3RvdHlwZSBvdmVycmlkZXNcbiAgICBpZiAocHJvdG9Qcm9wcykge1xuICAgICAgICBMYW5nLm1peChyZWNlaXZlclByb3RvLCBwcm90b1Byb3BzKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgb2JqZWN0IG92ZXJyaWRlc1xuICAgIGlmIChzdGF0aWNQcm9wcykge1xuICAgICAgICBMYW5nLm1peChyZWNlaXZlciwgc3RhdGljUHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWNlaXZlcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4dGVuZDsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGlzSUUgPSBDS0VESVRPUi5lbnYuaWU7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2FkZGltYWdlcycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWxsb3dzIERyYWcmRHJvcCBvZiBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgZWRpdGFibGUgYXJlYS4gVGhlIGltYWdlIHdpbGwgYmUgZW5jb2RlZFxuICAgICAqIGFzIERhdGEgVVJJLiBBbiBldmVudCBgYmVmb3JlSW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgbGlzdCBvZiBkcm9wcGVkIGltYWdlcy4gSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiByZXR1cm5zIGBmYWxzZWAgb3IgY2FuY2VscyB0aGUgZXZlbnQsIHRoZSBpbWFnZXMgd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGNvbnRlbnQuIE90aGVyd2lzZSxcbiAgICAgKiBhbiBldmVudCBgaW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgaW5zZXJ0ZWQgZWxlbWVudCBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBiZWZvcmUgYWRkaW5nIGltYWdlcyB0byB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGV2ZW50IENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzI2JlZm9yZUltYWdlQWRkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VGaWxlcyBBcnJheSBvZiBpbWFnZSBmaWxlc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhbiBpbWFnZSBpcyBiZWluZyBhZGRlZCB0byB0aGUgZWRpdG9yIHN1Y2Nlc3NmdWxseS5cbiAgICAgKlxuICAgICAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNpbWFnZUFkZFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSBjcmVhdGVkIGltYWdlIHdpdGggc3JjIGFzIERhdGEgVVJJXG4gICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIFRoZSBpbWFnZSBmaWxlXG4gICAgICovXG5cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2FkZGltYWdlcycsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdkcmFnZW50ZXInLCAnZHJhZ292ZXInLCAnZHJvcCcgYW5kIGBwYXN0ZWAgZXZlbnRzIG9uIHRoZSBlZGl0aW5nIGFyZWEuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlciwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdkcmFnb3ZlcicsIHRoaXMuX29uRHJhZ092ZXIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAnZHJvcCcsIHRoaXMuX29uRHJhZ0Ryb3AsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAncGFzdGUnLCB0aGlzLl9vblBhc3RlLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBY2NlcHRzIGFuIGFycmF5IG9mIGRyb3BwZWQgZmlsZXMgdG8gdGhlIGVkaXRvci4gVGhlbiwgaXQgZmlsdGVycyB0aGUgaW1hZ2VzIGFuZCBzZW5kcyB0aGVtIGZvciBmdXJ0aGVyXG4gICAgICAgICAgICAgKiBwcm9jZXNzaW5nIHRvIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzL19wcm9jZXNzRmlsZTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjYmVmb3JlSW1hZ2VBZGRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9oYW5kbGVGaWxlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gZmlsZXMgQXJyYXkgb2YgZHJvcHBlZCBmaWxlcy4gT25seSB0aGUgaW1hZ2VzIGZyb20gdGhpcyBsaXN0IHdpbGwgYmUgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2hhbmRsZUZpbGVzOiBmdW5jdGlvbihmaWxlcywgZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGU7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VGaWxlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRmlsZXM6IGltYWdlRmlsZXNcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW1hZ2VGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGltYWdlRmlsZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NGaWxlKGZpbGUsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZXMgZHJhZyBkcm9wIGV2ZW50LiBUaGUgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSB0aGUgY3VycmVudFxuICAgICAgICAgICAgICogcG9pbnQgYW5kIHdpbGwgc2VuZCBhIGxpc3Qgb2YgZmlsZXMgdG8gYmUgcHJvY2Vzc2VkIHRvXG4gICAgICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcy9faGFuZGxlRmlsZXM6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBfb25EcmFnRHJvcFxuICAgICAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGV2ZW50IGRyYWdkcm9wIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbkRyYWdEcm9wOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVFdmVudCA9IGV2ZW50LmRhdGEuJDtcblxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2ZlckZpbGVzID0gbmF0aXZlRXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgQ0tFRElUT1IuZG9tLmV2ZW50KG5hdGl2ZUV2ZW50KS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3IuY3JlYXRlU2VsZWN0aW9uRnJvbVBvaW50KG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZpbGVzKHRyYW5zZmVyRmlsZXMsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGRyYWcgZW50ZXIgZXZlbnQuIEluIGNhc2Ugb2YgSUUsIHRoaXMgZnVuY3Rpb24gd2lsbCBwcmV2ZW50IHRoZSBldmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBfb25EcmFnRW50ZXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBkcmFnZW50ZXIgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3JcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX29uRHJhZ0VudGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0lFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGRyYWcgb3ZlciBldmVudC4gSW4gY2FzZSBvZiBJRSwgdGhpcyBmdW5jdGlvbiB3aWxsIHByZXZlbnQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9vbkRyYWdPdmVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgZHJhZ292ZXIgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3JcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmVudEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgcGFzdGVkIGRhdGEgaXMgaW1hZ2UgYW5kIHBhc3NlcyBpdCB0b1xuICAgICAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMvX3Byb2Nlc3NGaWxlOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBfb25QYXN0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGV2ZW50IEEgYHBhc3RlYCBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfb25QYXN0ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLiQgJiYgZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEgJiYgZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEuaXRlbXMgJiYgZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFzdGVkRGF0YSA9IGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXN0ZWREYXRhLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRmlsZSA9IHBhc3RlZERhdGEuZ2V0QXNGaWxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NGaWxlKGltYWdlRmlsZSwgZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZXZlbnRzIGEgbmF0aXZlIGV2ZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9wcmV2ZW50RXZlbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gYmUgcHJldmVudGVkLlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcHJldmVudEV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IENLRURJVE9SLmRvbS5ldmVudChldmVudC5kYXRhLiQpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvY2Vzc2VzIGFuIGltYWdlIGZpbGUuIFRoZSBmdW5jdGlvbiBjcmVhdGVzIGFuIGltZyBlbGVtZW50IGFuZCBzZXRzIGFzIHNvdXJjZVxuICAgICAgICAgICAgICogYSBEYXRhIFVSSSwgdGhlbiBmaXJlcyBhbiAnaW1hZ2VBZGQnIGV2ZW50IHZpYSBDS0VkaXRvcidzIGV2ZW50IHN5c3RlbS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjaW1hZ2VBZGRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9wcmV2ZW50RXZlbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gYmUgcHJldmVudGVkLlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcHJvY2Vzc0ZpbGU6IGZ1bmN0aW9uKGZpbGUsIGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbiA9IHJlYWRlci5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoJzxpbWcgc3JjPVwiJyArIGJpbiArICdcIj4nKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5zZXJ0RWxlbWVudChlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZmlyZSgnaW1hZ2VBZGQnLCBpbWFnZURhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9hdXRvbGluaycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlcyB0aGUgYXV0byBVUkwgZGV0ZWN0aW9uIGZlYXR1cmUgaW4gSUUsIHRoZWlyIGxhY2tzIGZ1bmN0aW9uYWxpdHk6XG4gICAgLy8gVGhleSBjb252ZXJ0IHRoZSBsaW5rcyBvbmx5IG9uIHNwYWNlLiBXZSBkbyBvbiBzcGFjZSwgY29tbWEsIHNlbWljb2xvbiBhbmQgRW50ZXIuXG4gICAgaWYgKC9NU0lFIChbXjtdKil8VHJpZGVudC4qOyBydjooWzAtOS5dKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ0F1dG9VcmxEZXRlY3QnLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBLRVlfQkFDSyA9IDg7XG5cbiAgICB2YXIgS0VZX0NPTU1BID0gMTg4O1xuXG4gICAgdmFyIEtFWV9FTlRFUiA9IDEzO1xuXG4gICAgdmFyIEtFWV9TRU1JQ09MT04gPSAxODY7XG5cbiAgICB2YXIgS0VZX1NQQUNFID0gMzI7XG5cbiAgICB2YXIgREVMSU1JVEVSUyA9IFtLRVlfQ09NTUEsIEtFWV9FTlRFUiwgS0VZX1NFTUlDT0xPTiwgS0VZX1NQQUNFXTtcblxuICAgIHZhciBSRUdFWF9MQVNUX1dPUkQgPSAvW15cXHNdKy9naW07XG5cbiAgICB2YXIgUkVHRVhfVVJMID0gLygoKFtBIC0gWmEgLSB6XXsgMywgOX06ICg/OiBcXC9cXC8pPykoPzpbLTs6Jj1cXCtcXCQsXFx3XStAKT9bQS1aYS16MC05Li1dK3woaHR0cHM/XFw6XFwvXFwvfHd3dy58Wy07OiY9LlxcK1xcJCxcXHddK0ApW0EtWmEtejAtOS4tXSspKCg/OlxcL1tcXCt+JVxcLy5cXHctX10qKT9cXD8/KD86Wy1cXCs9JjslQC5cXHdfXSopIz8oPzpbXFx3XSopKSgoLiopOihcXGQqKVxcLz8oLiopKT8pL2k7XG5cbiAgICB2YXIgUkVHRVhfRU1BSUwgPSAvW2EtekEtWjAtOS5fLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWl17Miw0fS9pO1xuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGxpbmtzIHdoZW4gdXNlciB0eXBlcyB0ZXh0IHdoaWNoIGxvb2tzIGxpa2UgVVJMLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2F1dG9saW5rJywge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGBrZXl1cGAgZXZlbnQgb24gdGhlIGVkaXRpbmcgYXJlYS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAna2V5dXAnLCB0aGlzLl9vbktleVVwLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdwYXN0ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5tZXRob2QgPT09ICdwYXN0ZScpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZGF0YVZhbHVlLmluZGV4T2YoJzwnKSA+IC0xIHx8IGV2ZW50LmRhdGEuZGF0YVZhbHVlLmluZGV4T2YoJyZsdDsnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXZlbnQuZGF0YS5kYXRhVmFsdWUuaW5kZXhPZignPHU+PGZvbnQgY29sb3I9XFxcIicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5kYXRhVmFsdWUgPSBldmVudC5kYXRhLmRhdGFWYWx1ZS5yZXBsYWNlKC88dT48Zm9udCBjb2xvcj1cXFwiIyguKj8pXFxcIj58PFxcL2ZvbnQ+PFxcL3U+L2csJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuZGF0YVZhbHVlID0gZXZlbnQuZGF0YS5kYXRhVmFsdWUucmVwbGFjZShSZWdFeHAoUkVHRVhfVVJMLCAnZ2ltJyksIGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX2lzVmFsaWRVUkwodXJsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX2lzVmFsaWRFbWFpbCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XFxcIm1haWx0bzonICsgdXJsICsgJ1xcXCI+JyArIHVybCArICc8L2E+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj1cXFwiJyArIHVybCArICdcXFwiPicgKyB1cmwgKyAnPC9hPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgbGFzdCB3b3JkIGludHJvZHVjZWQgYnkgdGhlIHVzZXIuIFJlYWRzIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAqIGNhcmV0IHBvc2l0aW9uIGJhY2t3YXJkcyB1bnRpbCBpdCBmaW5kcyB0aGUgZmlyc3Qgd2hpdGUgc3BhY2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBfZ2V0TGFzdFdvcmRcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGxhc3Qgd29yZCBpbnRyb2R1Y2VkIGJ5IHVzZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2dldExhc3RXb3JkOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNUZXh0ID0gJyc7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBwcmVzc2VkIEVudGVyLCBzbyB3ZSBoYXZlIHRvIGxvb2sgb24gdGhlIHByZXZpb3VzIG5vZGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIuZ2V0UHJldmlvdXMoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIG5vZGUgaXMgYSBTUEFDRSwgKGl0IGRvZXMgbm90IGhhdmUgJ2dldExhc3QnIG1ldGhvZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgaXQgYW5kIGZpbmQgdGhlIHByZXZpb3VzIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcmV2aW91c05vZGUuZ2V0TGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHByZXZpb3VzTm9kZS5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBwcmV2aW91c05vZGUuZ2V0TGFzdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIsIHRoZSBsYXN0IGNoaWxkIG5vZGUgbWF5IGJlIGEgPEJSPlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIGRvZXMgbm90IGhhdmUgJ2dldFRleHQnIG1ldGhvZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBpZ25vcmUgaXQgYW5kIGZpbmQgdGhlIHByZXZpb3VzIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxhc3RDaGlsZCAmJiAhbGFzdENoaWxkLmdldFRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGlsZCA9IGxhc3RDaGlsZC5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxhc3RDaGlsZCBpcyBhbHJlYWR5IGEgbGlua1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLiQuaHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Q29udGFpbmVyID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUZXh0ID0gbGFzdENoaWxkID8gbGFzdENoaWxkLmdldFRleHQoKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gcHJldmlvdXNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgaXMgdGhlIGRlbGltaXRlciwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVGV4dCA9IHRoaXMuX3N0YXJ0Q29udGFpbmVyLmdldFRleHQoKS5zdWJzdHJpbmcoMCwgb2Zmc2V0IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdFdvcmQgPSAnJztcblxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHByZXZpb3VzVGV4dC5tYXRjaChSRUdFWF9MQVNUX1dPUkQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RXb3JkID0gbWF0Y2gucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RXb3JkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGxpbmsgaXMgYSB2YWxpZCBFbWFpbC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGlzVmFsaWRFbWFpbFxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmsgVGhlIGVtYWlsIHdlIHdhbnQgdG8ga25vdyBpZiBpdCBpcyBhIHZhbGlkIEVtYWlsXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGVtYWlsIGlzIGEgdmFsaWQgRW1haWwsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfaXNWYWxpZEVtYWlsOiBmdW5jdGlvbihlbWFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRUdFWF9FTUFJTC50ZXN0KGVtYWlsKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBsaW5rIGlzIGEgdmFsaWQgVVJMLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgaXNWYWxpZFVSTFxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmsgVGhlIGxpbmsgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgVVJMXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGxpbmsgaXMgYSB2YWxpZCBVUkwsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfaXNWYWxpZFVSTDogZnVuY3Rpb24obGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRUdFWF9VUkwudGVzdChsaW5rKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdGVucyB0byB0aGUgYGtleWRvd25gIGV2ZW50IGFuZCBpZiB0aGUga2V5Y29kZSBpcyBgQmFja3NwYWNlYCwgcmVtb3ZlcyB0aGUgcHJldmlvdXNseVxuICAgICAgICAgICAgICogY3JlYXRlZCBsaW5rLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uS2V5RG93blxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZlbnQgRXZlbnRGYWNhZGUgb2JqZWN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbktleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgIGVkaXRhYmxlLnJlbW92ZUxpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcblxuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFdmVudC5rZXlDb2RlID09PSBLRVlfQkFDSykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpbmsoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9ja0xpbmsgPSBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0ZW5zIHRvIHRoZSBgRW50ZXJgIGFuZCBgU3BhY2VgIGtleSBldmVudHMgaW4gb3JkZXIgdG8gY2hlY2sgaWYgdGhlIGxhc3Qgd29yZFxuICAgICAgICAgICAgICogaW50cm9kdWNlZCBieSB0aGUgdXNlciBzaG91bGQgYmUgcmVwbGFjZWQgYnkgYSBsaW5rIGVsZW1lbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBfb25LZXlVcFxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZlbnQgRXZlbnRGYWNhZGUgb2JqZWN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbktleVVwOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVFdmVudCA9IGV2ZW50LmRhdGEuJDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRLZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICAgICAgICAgICAgICAgIGlmIChERUxJTUlURVJTLmluZGV4T2YodGhpcy5fY3VycmVudEtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFdvcmQgPSB0aGlzLl9nZXRMYXN0V29yZChlZGl0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkVVJMKGxhc3RXb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwbGFjZUNvbnRlbnRCeUxpbmsoZWRpdG9yLCBsYXN0V29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlcGxhY2VzIGNvbnRlbnQgYnkgYSBsaW5rIGVsZW1lbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGZpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmsjYXV0b2xpbmtBZGRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlcGxhY2VDb250ZW50QnlMaW5rXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBUaGUgdGV4dCB0aGF0IGhhcyB0byBiZSByZXBsYWNlZCBieSBhbiBsaW5rIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3JlcGxhY2VDb250ZW50QnlMaW5rOiBmdW5jdGlvbihlZGl0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IENLRURJVE9SLmRvbS5lbGVtZW50LmdldCh0aGlzLl9zdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgY29udGVudCwgc28gQ0tFRElUT1IuTGluayBjYW4gcHJvcGVybHkgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgICAgIHZhciBja0xpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuICAgICAgICAgICAgICAgIGNrTGluay5jcmVhdGUoY29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2tMaW5rID0gY2tMaW5rO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmtOb2RlID0gY2tMaW5rLmdldEZyb21TZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZmlyZSgnYXV0b2xpbmtBZGQnLCBsaW5rTm9kZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0tleUV2ZW50KGVkaXRvcik7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgcmFuZ2UgaXMgb24gdGhlIGxpbmsgYW5kIGl0IGlzIHNlbGVjdGVkLiBXZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGZvY3VzIHRvIHRoZSBjYXJldCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHVzZXIgcHJlc3NlZCBgRW50ZXJgLCBnZXQgdGhlIG5leHQgZWRpdGFibGUgbm9kZSBhdCBwb3NpdGlvbiAwLFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIGN1cnNvciBhdCB0aGUgbmV4dCBjaGFyYWN0ZXIgb2YgdGhlIGxpbmsgKHRoZSB3aGl0ZSBzcGFjZSlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEVkaXRhYmxlTm9kZSA9IHJhbmdlLmdldE5leHRFZGl0YWJsZU5vZGUoKTtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChuZXh0RWRpdGFibGVOb2RlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5leHRFZGl0YWJsZU5vZGUsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IHJhbmdlLmdldE5leHROb2RlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobmV4dE5vZGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobmV4dE5vZGUsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaXJlZCB3aGVuIGEgVVJMIGlzIGRldGVjdGVkIGluIHRleHQgYW5kIGNvbnZlcnRlZCB0byBhIGxpbmsuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmsjYXV0b2xpbmtBZGRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBOb2RlIG9mIHRoZSBjcmVhdGVkIGxpbmsuXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBjcmVhdGVkIGxpbmsgZWxlbWVudCwgYW5kIHJlcGxhY2VzIGl0IGJ5IGl0cyB0ZXh0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlbW92ZUxpbmtcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3JlbW92ZUxpbms6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgY2FyZXRPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgbGluaywgc28gQ0tFRElUT1IuTGluayBjYW4gcHJvcGVybHkgcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtOb2RlID0gdGhpcy5fc3RhcnRDb250YWluZXIuZ2V0TmV4dCgpIHx8IHRoaXMuX3N0YXJ0Q29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5ld1JhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQobGlua05vZGUsIDApO1xuICAgICAgICAgICAgICAgIG5ld1JhbmdlLnNldEVuZEFmdGVyKGxpbmtOb2RlKTtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NrTGluay5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBmb2N1cyB0byB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIGNhcmV0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgY2FyZXRPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN1YnNjcmliZSB0byBhIGtleSBldmVudCBvZiB0aGUgZWRpdGFibGUgYXJpYS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9zdWJzY3JpYmVUb0tleUV2ZW50XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9zdWJzY3JpYmVUb0tleUV2ZW50OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgcHJpb3JpdHkgb2Yga2V5ZG93biBsaXN0ZW5lciAtIDEgbWVhbnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgLy8gSW4gQ2hyb21lIG9uIHByZXNzaW5nIGBFbnRlcmAgdGhlIGxpc3RlbmVyIGlzIG5vdCBiZWluZyBpbnZva2VkLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vZGV2LmNrZWRpdG9yLmNvbS90aWNrZXQvMTE4NjEgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9hdXRvbGlzdCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgS0VZX0JBQ0sgPSA4O1xuXG4gICAgdmFyIEtFWV9TUEFDRSA9IDMyO1xuXG4gICAgdmFyIERFRkFVTFRfQ09ORklHID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICByZWdleDogL15cXCokLyxcbiAgICAgICAgICAgIHR5cGU6ICdidWxsZXRlZGxpc3QnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlZ2V4OiAvXjFcXC4kLyxcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXJlZGxpc3QnXG4gICAgICAgIH1cbiAgICBdO1xuXG5cdC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBvcmRlcmVkL3Vub3JkZXJlZCBsaXN0IHdoZW4gdXNlciB0eXBlcyB0ZXh0IHdoaWNoIGxvb2tzIGxpa2UgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3RcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2F1dG9saXN0Jywge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tlZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGBrZXlkb3duYCBldmVudCBvbiB0aGUgY29udGVudCBlZGl0aW5nIGFyZWEuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2tzIGZvciBwcmVzc2luZyB0aGUgYEJhY2tzcGFjZWAga2V5IGluIG9yZGVyIHRvIHVuZG8gdGhlIGxpc3QgY3JlYXRpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAgICAgICAgICogQG1ldGhvZCBfY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2NoZWNrRm9yQmFja3NwYWNlQW5kVW5kbzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVFdmVudCA9IGV2ZW50LmRhdGEuJDtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUucmVtb3ZlTGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9CQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgndW5kbycpO1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5zZXJ0SHRtbChldmVudC5saXN0ZW5lckRhdGEuYnVsbGV0ICsgJyZuYnNwOycpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgY3VycmVudCBsaW5lIHRvIGZpbmQgbWF0Y2ggd2l0aCBNQVRDSEVTIG9iamVjdCB0byBjcmVhdGUgT0wgb3IgVUwuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAgICAgICAgICogQG1ldGhvZCBfY2hlY2tMaW5lXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2VkaXRvcn0gRWRpdG9yIG9iamVjdFxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBkZXRlY3RlZCBsaXN0IGNvbmZpZyBpZiBhbnlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2dldExpc3RDb25maWc6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWdSZWdleCA9IGVkaXRvci5jb25maWcuYXV0b2xpc3QgfHwgREVGQVVMVF9DT05GSUc7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lci5nZXRUZXh0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYnVsbGV0ID0gdGV4dENvbnRhaW5lci5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZyhyYW5nZS5zdGFydE9mZnNldCwgdGV4dENvbnRhaW5lci5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciByZWdleExlbiA9IGNvbmZpZ1JlZ2V4Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHZhciBhdXRvbGlzdENmZyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIWF1dG9saXN0Q2ZnICYmIHJlZ2V4TGVuID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4SXRlbSA9IGNvbmZpZ1JlZ2V4W2luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhJdGVtLnJlZ2V4LnRlc3QoYnVsbGV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b2xpc3RDZmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0OiBidWxsZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZWdleEl0ZW0udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhdXRvbGlzdENmZztcbiAgICAgICAgICAgIH0sXG5cblx0XHRcdC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGxpc3Qgd2l0aCBkaWZmZXJlbnQgdHlwZXM6IEJ1bGxldGVkIG9yIE51bWJlcmVkIGxpc3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9jcmVhdGVMaXN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGlzdENvbmZpZyBPYmplY3QgdGhhdCBjb250YWlucyBidWxsZXQsIHRleHQgYW5kIHR5cGUgZm9yIGNyZWF0aW5nIHRoZSBsaXN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG5cdFx0XHQgKi9cbiAgICAgICAgICAgIF9jcmVhdGVMaXN0OiBmdW5jdGlvbihsaXN0Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IGxpc3RDb25maWcuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyLnNldFRleHQobGlzdENvbmZpZy50ZXh0KTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQobGlzdENvbmZpZy50eXBlKTtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGtleWRvd24gaW4gb3JkZXIgdG8gY2hlY2sgaWYgdGhlIG5leHQga2V5IHByZXNzIGlzIGBCYWNrc3BhY2VgLlxuICAgICAgICAgICAgICAgIC8vIElmIHNvLCB0aGUgY3JlYXRpb24gb2YgdGhlIGxpc3Qgd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdrZXlkb3duJywgdGhpcy5fY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBidWxsZXQ6IGxpc3RDb25maWcuYnVsbGV0XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9LFxuXG5cdFx0XHQvKipcbiAgICAgICAgICAgICAqIExpc3RlbnMgdG8gdGhlIGBTcGFjZWAga2V5IGV2ZW50cyB0byBjaGVjayBpZiB0aGUgbGFzdCB3b3JkXG4gICAgICAgICAgICAgKiBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyIHNob3VsZCBiZSByZXBsYWNlZCBieSBhIGxpc3QgKE9MIG9yIFVMKVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3RcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uS2V5RG93blxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbktleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9TUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdENvbmZpZyA9IHRoaXMuX2dldExpc3RDb25maWcoZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxpc3QobGlzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblx0KTtcbn0oKSk7IiwiLyoqXG4gKiBDS0VkaXRvciBwbHVnaW46IERyYWdhYmxlIGltYWdlIHJlc2l6aW5nXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3N0dXIvY2stZHJhZ3Jlc2l6ZVxuICogLSBTaG93cyBzZW1pLXRyYW5zcGFyZW50IG92ZXJsYXkgd2hpbGUgcmVzaXppbmdcbiAqIC0gRW5mb3JjZXMgQXNwZWN0IFJhdGlvICh1bmxlc3MgaG9sZGluZyBzaGlmdClcbiAqIC0gU25hcCB0byBzaXplIG9mIG90aGVyIGltYWdlcyBpbiBlZGl0b3JcbiAqIC0gRXNjYXBlIHdoaWxlIGRyYWdnaW5nIGNhbmNlbHMgcmVzaXplXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2RyYWdyZXNpemUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIElNQUdFX0hBTkRMRVMgPSB7XG4gICAgICAgIGJvdGg6IFsndGwnLCAndG0nLCAndHInLCAnbG0nLCAncm0nLCAnYmwnLCAnYm0nLCAnYnInXSxcbiAgICAgICAgaGVpZ2h0OiBbJ3RsJywgJ3RtJywgJ3RyJywgJ2JsJywgJ2JtJywgJ2JyJ10sXG4gICAgICAgIHNjYWxlOiBbJ3RsJywgJ3RyJywgJ2JsJywgJ2JyJ10sXG4gICAgICAgIHdpZHRoOiBbJ3RsJywgJ3RyJywgJ2xtJywgJ3JtJywgJ2JsJywgJ2JyJ10sXG4gICAgfTtcblxuICAgIHZhciBQT1NJVElPTl9FTEVNRU5UX0ZOID0ge1xuICAgICAgICBibDogZnVuY3Rpb24oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KGhhbmRsZSwgLTMgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBNYXRoLnJvdW5kKGJveC53aWR0aCAvIDIpIC0gMyArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgYnI6IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCAtMyArIGxlZnQsIE1hdGgucm91bmQoYm94LmhlaWdodCAvIDIpIC0gMyArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRsOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBsZWZ0IC0gMywgdG9wIC0gMyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBNYXRoLnJvdW5kKGJveC53aWR0aCAvIDIpIC0gMyArIGxlZnQsIC0zICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHI6IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCAtMyArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBib3gud2lkdGggLSA0ICsgbGVmdCwgTWF0aC5yb3VuZChib3guaGVpZ2h0IC8gMikgLSAzICsgdG9wKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgSU1BR0VfU05BUF9UT19TSVpFID0gNztcblxuICAgIHZhciBpc0ZpcmVmb3ggPSAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG5cbiAgICB2YXIgaXNXZWJLaXQgPSAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG5cbiAgICB2YXIgZW5hYmxlUGx1Z2luID0gaXNXZWJLaXQgfHwgaXNGaXJlZm94O1xuXG4gICAgaWYgKGVuYWJsZVBsdWdpbikge1xuICAgICAgICAvLyBDU1MgaXMgYWRkZWQgaW4gYSBjb21wcmVzc2VkIGZvcm1cbiAgICAgICAgQ0tFRElUT1IuYWRkQ3NzKCdpbWc6OnNlbGVjdGlvbntjb2xvcjpyZ2JhKDAsMCwwLDApfWltZy5ja2ltZ3JzentvdXRsaW5lOjFweCBkYXNoZWQgIzAwMH0jY2tpbWdyc3p7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MDtoZWlnaHQ6MDtjdXJzb3I6ZGVmYXVsdDt6LWluZGV4OjEwMDAxfSNja2ltZ3JzeiBzcGFue2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MDtoZWlnaHQ6MDtiYWNrZ3JvdW5kLXNpemU6MTAwJSAxMDAlO29wYWNpdHk6LjY1O291dGxpbmU6MXB4IGRhc2hlZCAjMDAwfSNja2ltZ3JzeiBpe3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NXB4O2hlaWdodDo1cHg7YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzAwMH0jY2tpbWdyc3ogaS5hY3RpdmUsI2NraW1ncnN6IGk6aG92ZXJ7YmFja2dyb3VuZDojMDAwfSNja2ltZ3JzeiBpLmJyLCNja2ltZ3JzeiBpLnRse2N1cnNvcjpud3NlLXJlc2l6ZX0jY2tpbWdyc3ogaS5ibSwjY2tpbWdyc3ogaS50bXtjdXJzb3I6bnMtcmVzaXplfSNja2ltZ3JzeiBpLmJsLCNja2ltZ3JzeiBpLnRye2N1cnNvcjpuZXN3LXJlc2l6ZX0jY2tpbWdyc3ogaS5sbSwjY2tpbWdyc3ogaS5ybXtjdXJzb3I6ZXctcmVzaXplfWJvZHkuZHJhZ2dpbmctYnIsYm9keS5kcmFnZ2luZy1iciAqLGJvZHkuZHJhZ2dpbmctdGwsYm9keS5kcmFnZ2luZy10bCAqe2N1cnNvcjpud3NlLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibSxib2R5LmRyYWdnaW5nLWJtICosYm9keS5kcmFnZ2luZy10bSxib2R5LmRyYWdnaW5nLXRtICp7Y3Vyc29yOm5zLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibCxib2R5LmRyYWdnaW5nLWJsICosYm9keS5kcmFnZ2luZy10cixib2R5LmRyYWdnaW5nLXRyICp7Y3Vyc29yOm5lc3ctcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWxtLGJvZHkuZHJhZ2dpbmctbG0gKixib2R5LmRyYWdnaW5nLXJtLGJvZHkuZHJhZ2dpbmctcm0gKntjdXJzb3I6ZXctcmVzaXplIWltcG9ydGFudH0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2RyYWdyZXNpemUnLCB7XG4gICAgICAgIG9uTG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZVBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZVBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICBpbml0KGVkaXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaW5pdChlZGl0b3IpIHtcbiAgICAgICAgdmFyIHdpbmRvdyA9IGVkaXRvci53aW5kb3cuJCxcbiAgICAgICAgICAgIGRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50LiQ7XG5cbiAgICAgICAgaWYgKGlzRmlyZWZveCkge1xuICAgICAgICAgICAgLy8gRGlzYWJsZSB0aGUgbmF0aXZlIGltYWdlIHJlc2l6aW5nXG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNuYXBUb1NpemUgPSAodHlwZW9mIElNQUdFX1NOQVBfVE9fU0laRSA9PT0gJ3VuZGVmaW5lZCcpID8gbnVsbCA6IElNQUdFX1NOQVBfVE9fU0laRTtcblxuICAgICAgICBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUgPSBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUgfHwgJ2JvdGgnO1xuXG4gICAgICAgIHZhciByZXNpemVyID0gbmV3IFJlc2l6ZXIoZWRpdG9yLCB7XG4gICAgICAgICAgICBpbWFnZVNjYWxlUmVzaXplOiBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUsXG4gICAgICAgICAgICBzbmFwVG9TaXplOiBzbmFwVG9TaXplXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtb3VzZURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChyZXNpemVyLmlzSGFuZGxlKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaW5pdERyYWcoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duTGlzdGVuZXIsIGZhbHNlKTtcblxuICAgICAgICBmdW5jdGlvbiBzZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgYW4gZWxlbWVudCBpcyBzZWxlY3RlZCBhbmQgdGhhdCBlbGVtZW50IGlzIGFuIElNR1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5nZXRUeXBlKCkgIT09IENLRURJVE9SLlNFTEVDVElPTl9OT05FICYmIHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKS5pcygnaW1nJykpIHtcbiAgICAgICAgICAgICAgICAvLyBBbmQgd2UncmUgbm90IHJpZ2h0IG9yIG1pZGRsZSBjbGlja2luZyBvbiB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5ldmVudCB8fCAhd2luZG93LmV2ZW50LmJ1dHRvbiB8fCB3aW5kb3cuZXZlbnQuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZXIuc2hvdyhzZWxlY3Rpb24uZ2V0U3RhcnRFbGVtZW50KCkuJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNpemVyLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5vbignc2VsZWN0aW9uQ2hhbmdlJywgc2VsZWN0aW9uQ2hhbmdlKTtcblxuICAgICAgICBlZGl0b3Iub24oJ2dldERhdGEnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGUuZGF0YS5kYXRhVmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC88ZGl2IGlkPVwiY2tpbWdyc3pcIihbXFxzXFxTXSo/KTxcXC9kaXY+L2ksICcnKTtcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcYihja2ltZ3JzeilcXGIvZywgJycpO1xuICAgICAgICAgICAgZS5kYXRhLmRhdGFWYWx1ZSA9IGh0bWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5vbignYmVmb3JlVW5kb0ltYWdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGhhbmRsZXMgYmVmb3JlIHVuZG8gaW1hZ2VzIGFyZSBzYXZlZFxuICAgICAgICAgICAgcmVzaXplci5oaWRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5vbignYWZ0ZXJVbmRvSW1hZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGhhbmRsZXMgYWZ0ZXIgdW5kbyBpbWFnZXMgYXJlIHNhdmVkXG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGhhbmRsZXMgd2hlbiBlZGl0b3IgbG9zZXMgZm9jdXNcbiAgICAgICAgICAgIHJlc2l6ZXIuaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlZGl0b3Iub24oJ2JlZm9yZU1vZGVVbmxvYWQnLCBmdW5jdGlvbiBzZWxmKCkge1xuICAgICAgICAgICAgZWRpdG9yLnJlbW92ZUxpc3RlbmVyKCdiZWZvcmVNb2RlVW5sb2FkJywgc2VsZik7XG4gICAgICAgICAgICByZXNpemVyLmhpZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzaXplRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdja2ltZ3JzeicpO1xuXG4gICAgICAgICAgICBpZiAocmVzaXplRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0ZpcmVmb3gpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgcmVzaXplZFxuICAgICAgICB2YXIgcmVzaXplVGltZW91dDtcbiAgICAgICAgZWRpdG9yLndpbmRvdy5vbigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgYW55IHJlc2l6ZSB3YWl0aW5nIHRvIGhhcHBlblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICAgICAgLy8gRGVsYXkgcmVzaXplIHRvIFwiZGVib3VuY2VcIlxuICAgICAgICAgICAgcmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoc2VsZWN0aW9uQ2hhbmdlLCA1MCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlc2l6ZXIoZWRpdG9yLCBjZmcpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMud2luZG93ID0gZWRpdG9yLndpbmRvdy4kO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50LiQ7XG4gICAgICAgIHRoaXMuY2ZnID0gY2ZnIHx8IHt9O1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBSZXNpemVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICBjb250YWluZXIuaWQgPSAnY2tpbWdyc3onO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3KTtcblxuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXMgPSB7fTtcblxuICAgICAgICAgICAgSU1BR0VfSEFORExFU1t0aGlzLmNmZy5pbWFnZVNjYWxlUmVzaXplXS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOYW1lLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXNbaGFuZGxlTmFtZV0gPSBpbnN0YW5jZS5oYW5kbGVzW2hhbmRsZU5hbWVdID0gaW5zdGFuY2UuY3JlYXRlSGFuZGxlKGhhbmRsZU5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoYW5kbGVzW25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlSGFuZGxlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGlzSGFuZGxlOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIGhhbmRsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlc1tuXSA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBzaG93OiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIHVpTm9kZSA9IHRoaXMuZWRpdG9yLmNvbmZpZy51aU5vZGU7XG5cbiAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB1aU5vZGUgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2ZnLnNuYXBUb1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm90aGVySW1hZ2VzID0gdG9BcnJheSh0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vdGhlckltYWdlcy5zcGxpY2UodGhpcy5vdGhlckltYWdlcy5pbmRleE9mKGVsKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5ib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgZWwpO1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KHRoaXMuY29udGFpbmVyLCBib3gubGVmdCwgYm94LnRvcCArIHNjcm9sbFRvcCk7XG5cbiAgICAgICAgICAgIHVpTm9kZSA9IHVpTm9kZSB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAgICAgICB1aU5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2NraW1ncnN6Jyk7XG4gICAgICAgICAgICB0aGlzLnNob3dIYW5kbGVzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGNsYXNzIGZyb20gYWxsIGltZy5ja2ltZ3JzelxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdja2ltZ3JzeicpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2NraW1ncnN6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhpZGVIYW5kbGVzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0RHJhZzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy9yaWdodC1jbGljayBvciBtaWRkbGUtY2xpY2tcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzaXplciA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZHJhZyA9IG5ldyBEcmFnRXZlbnQodGhpcy53aW5kb3csIHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgZHJhZy5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5zaG93UHJldmlldygpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzaXplci5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRyYWcub25EcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5jYWxjdWxhdGVTaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIudXBkYXRlUHJldmlldygpO1xuICAgICAgICAgICAgICAgIHZhciBib3ggPSByZXNpemVyLnByZXZpZXdCb3g7XG4gICAgICAgICAgICAgICAgcmVzaXplci51cGRhdGVIYW5kbGVzKGJveCwgYm94LmxlZnQsIGJveC50b3ApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRyYWcub25SZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzaXplci5oaWRlUHJldmlldygpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgYW4gdW5kbyBzbmFwc2hvdCBiZWZvcmUgdGhlIGltYWdlIGlzIHBlcm1hbmVudGx5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICByZXNpemVyLmVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkcmFnLm9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNpemVyLnJlc2l6ZUNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBhbm90aGVyIHNuYXBzaG90IGFmdGVyIHRoZSBpbWFnZSBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgcmVzaXplci5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZHJhZy5zdGFydChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlSGFuZGxlczogZnVuY3Rpb24oYm94LCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgICAgICAgICB0b3AgPSB0b3AgfHwgMDtcbiAgICAgICAgICAgIHZhciBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBoYW5kbGUgaW4gaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIFBPU0lUSU9OX0VMRU1FTlRfRk5baGFuZGxlXShoYW5kbGVzW2hhbmRsZV0sIGxlZnQsIHRvcCwgYm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvd0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXModGhpcy5ib3gpO1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBoYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlc1tuXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGlkZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIGhhbmRsZXMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVzW25dLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dQcmV2aWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIHRoaXMuZWwuc3JjICsgJ1wiKSc7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVNpemUoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldygpO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVQcmV2aWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLnByZXZpZXdCb3g7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQodGhpcy5wcmV2aWV3LCBib3gubGVmdCwgYm94LnRvcCk7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuc3R5bGUud2lkdGggPSB0aGlzLnByZXZpZXdCb3gud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnN0eWxlLmhlaWdodCA9IHRoaXMucHJldmlld0JveC5oZWlnaHQgKyAncHgnO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlUHJldmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdCb3godGhpcy53aW5kb3csIHRoaXMucHJldmlldyk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYm94LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm94LmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVTaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5wcmV2aWV3Qm94ID0ge1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYm94LmhlaWdodFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBhdHRyID0gZGF0YS50YXJnZXQuY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZigncicpKSB7XG4gICAgICAgICAgICAgICAgYm94LndpZHRoID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LndpZHRoICsgZGF0YS5kZWx0YS54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh+YXR0ci5pbmRleE9mKCdiJykpIHtcbiAgICAgICAgICAgICAgICBib3guaGVpZ2h0ID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LmhlaWdodCArIGRhdGEuZGVsdGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZignbCcpKSB7XG4gICAgICAgICAgICAgICAgYm94LndpZHRoID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LndpZHRoIC0gZGF0YS5kZWx0YS54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh+YXR0ci5pbmRleE9mKCd0JykpIHtcbiAgICAgICAgICAgICAgICBib3guaGVpZ2h0ID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LmhlaWdodCAtIGRhdGEuZGVsdGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIGRyYWdnaW5nIGNvcm5lciwgZW5mb3JjZSBhc3BlY3QgcmF0aW8gKHVubGVzcyBzaGlmdCBrZXkgaXMgYmVpbmcgaGVsZClcbiAgICAgICAgICAgIGlmIChhdHRyLmluZGV4T2YoJ20nKSA8IDAgJiYgIWRhdGEua2V5cy5zaGlmdCkge1xuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHRoaXMuYm94LndpZHRoIC8gdGhpcy5ib3guaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChib3gud2lkdGggLyBib3guaGVpZ2h0ID4gcmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgYm94LmhlaWdodCA9IE1hdGgucm91bmQoYm94LndpZHRoIC8gcmF0aW8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJveC53aWR0aCA9IE1hdGgucm91bmQoYm94LmhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwVG9TaXplID0gdGhpcy5jZmcuc25hcFRvU2l6ZTtcblxuICAgICAgICAgICAgaWYgKHNuYXBUb1NpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJzID0gdGhpcy5vdGhlckltYWdlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgb3RoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGJveC53aWR0aCAtIG90aGVyLndpZHRoKSA8PSBzbmFwVG9TaXplICYmIE1hdGguYWJzKGJveC5oZWlnaHQgLSBvdGhlci5oZWlnaHQpIDw9IHNuYXBUb1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveC53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94LmhlaWdodCA9IG90aGVyLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JlY2FsY3VsYXRlIGxlZnQgb3IgdG9wIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZignbCcpKSB7XG4gICAgICAgICAgICAgICAgYm94LmxlZnQgPSB0aGlzLmJveC53aWR0aCAtIGJveC53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh+YXR0ci5pbmRleE9mKCd0JykpIHtcbiAgICAgICAgICAgICAgICBib3gudG9wID0gdGhpcy5ib3guaGVpZ2h0IC0gYm94LmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzaXplQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzaXplRWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuZWwsIHRoaXMucmVzdWx0LndpZHRoLCB0aGlzLnJlc3VsdC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIERyYWdFdmVudCh3aW5kb3csIGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgbW91c2Vtb3ZlOiBiaW5kKHRoaXMubW91c2Vtb3ZlLCB0aGlzKSxcbiAgICAgICAgICAgIGtleWRvd246IGJpbmQodGhpcy5rZXlkb3duLCB0aGlzKSxcbiAgICAgICAgICAgIG1vdXNldXA6IGJpbmQodGhpcy5tb3VzZXVwLCB0aGlzKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIERyYWdFdmVudC5wcm90b3R5cGUgPSB7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuYXR0ciA9IGUudGFyZ2V0LmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGUpO1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldmVudHMubW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudHMua2V5ZG93biwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRzLm1vdXNldXAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdkcmFnZ2luZy0nICsgdGhpcy5hdHRyKTtcbiAgICAgICAgICAgIHRoaXMub25TdGFydCAmJiB0aGlzLm9uU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5jbGllbnRYIC0gdGhpcy5zdGFydFBvcy54LFxuICAgICAgICAgICAgICAgIHk6IGUuY2xpZW50WSAtIHRoaXMuc3RhcnRQb3MueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IHtcbiAgICAgICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICBjdHJsOiBlLmN0cmxLZXksXG4gICAgICAgICAgICAgICAgYWx0OiBlLmFsdEtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShlKTtcbiAgICAgICAgICAgIHRoaXMub25EcmFnICYmIHRoaXMub25EcmFnKCk7XG4gICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vbW91c2UgYnV0dG9uIHJlbGVhc2VkIG91dHNpZGUgd2luZG93OyBtb3VzZXVwIHdhc24ndCBmaXJlZCAoQ2hyb21lKVxuICAgICAgICAgICAgICAgIHRoaXMubW91c2V1cChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy9lc2NhcGUga2V5IGNhbmNlbHMgZHJhZ2dpbmdcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGUpO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUgJiYgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnaW5nLScgKyB0aGlzLmF0dHIpO1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldmVudHMubW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudHMua2V5ZG93biwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRzLm1vdXNldXAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMub25SZWxlYXNlICYmIHRoaXMub25SZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9oZWxwZXIgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGgsXG4gICAgICAgICAgICBhcnIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG4gICAgICAgIGlmIChmbi5iaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZChjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkVsZW1lbnQoZWwsIGxlZnQsIHRvcCkge1xuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gU3RyaW5nKGxlZnQpICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUudG9wID0gU3RyaW5nKHRvcCkgKyAncHgnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGltYWdlU2NhbGVSZXNpemUgPSB0aGlzLmVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZTtcbiAgICAgICAgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJykge1xuICAgICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBTdHJpbmcod2lkdGgpICsgJ3B4JztcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IFN0cmluZyhoZWlnaHQpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnd2lkdGgnIHx8IGltYWdlU2NhbGVSZXNpemUgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gU3RyaW5nKHdpZHRoKSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IFN0cmluZyhoZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3god2luZG93LCBlbCkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG4iLCIvKipcbiAqIENLRWRpdG9yIHBsdWdpbjogSW1hZ2UyXG4gKiAtIFNob3cgZ3JpcHBlciB0byByZXNpemUgaW1hZ2VzIG9uIElFXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9kcmFncmVzaXplX2llJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbGlnbm1lbnRzT2JqID0ge1xuICAgICAgICBjZW50ZXI6IDEsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAyXG4gICAgfTtcblxuICAgIC8qXG4gICAgICogU2V0IGN1cnNvciBjc3MgZGVwZW5kIG9uIGltYWdlU2NhbGVSZXNpemUgY29uZmlnXG4gICAgICoqL1xuXG4gICAgdmFyIGN1cnNvciA9IHtcbiAgICAgICAgYm90aDogJ253c2UtcmVzaXplJyxcbiAgICAgICAgaGVpZ2h0OiAnbnMtcmVzaXplJyxcbiAgICAgICAgc2NhbGU6ICdud3NlLXJlc2l6ZScsXG4gICAgICAgIHdpZHRoOiAnZXctcmVzaXplJyxcbiAgICB9O1xuXG4gICAgdmFyIHJlZ2V4UGVyY2VudCA9IC9eXFxzKihcXGQrXFwlKVxccyokL2k7XG5cbiAgICB2YXIgdGVtcGxhdGUgPSAnPGltZyBhbHQ9XCJcIiBzcmM9XCJcIiAvPic7XG5cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfZHJhZ3Jlc2l6ZV9pZScsIHtcbiAgICAgICAgaGlkcGk6IHRydWUsXG5cbiAgICAgICAgaWNvbnM6ICdpbWFnZScsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIGltYWdlID0gd2lkZ2V0RGVmKGVkaXRvcik7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSB3aWRnZXQuXG4gICAgICAgICAgICBlZGl0b3Iud2lkZ2V0cy5hZGQoJ2ltYWdlJywgaW1hZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQ0tFRElUT1IuYWRkQ3NzKFxuICAgICAgICAgICAgICAgICcuY2tlX2ltYWdlX3Jlc2l6ZXJfbndzZS1yZXNpemV7JyArXG4gICAgICAgICAgICAgICAgJ2N1cnNvcjogbndzZS1yZXNpemU7JyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV9pbWFnZV9yZXNpemVyX25zLXJlc2l6ZXsnICtcbiAgICAgICAgICAgICAgICAnY3Vyc29yOiBucy1yZXNpemU7JyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV9pbWFnZV9yZXNpemVyX253c2UtcmVzaXpleycgK1xuICAgICAgICAgICAgICAgICdjdXJzb3I6IG53c2UtcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplcl9ldy1yZXNpemV7JyArXG4gICAgICAgICAgICAgICAgJ2N1cnNvcjogZXctcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2Vfbm9jYXB0aW9ueycgK1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gcmVtb3ZlIHVud2FudGVkIHNwYWNlIHNvIHJlc2l6ZVxuICAgICAgICAgICAgICAgIC8vIHdyYXBwZXIgaXMgZGlzcGxheWVkIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICdsaW5lLWhlaWdodDowJyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV9pbWFnZV9yZXNpemVyeycgK1xuICAgICAgICAgICAgICAgICdkaXNwbGF5Om5vbmU7JyArXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uOmFic29sdXRlOycgK1xuICAgICAgICAgICAgICAgICd3aWR0aDoxMHB4OycgK1xuICAgICAgICAgICAgICAgICdoZWlnaHQ6MTBweDsnICtcbiAgICAgICAgICAgICAgICAnYm90dG9tOi01cHg7JyArXG4gICAgICAgICAgICAgICAgJ3JpZ2h0Oi01cHg7JyArXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmQ6IzAwMDsnICtcbiAgICAgICAgICAgICAgICAnb3V0bGluZToxcHggc29saWQgI2ZmZjsnICtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRyYWcgaGFuZGxlciBmcm9tIGJlaW5nIG1pc3BsYWNlZCAoIzExMjA3KS5cbiAgICAgICAgICAgICAgICAnbGluZS1oZWlnaHQ6MDsnICtcbiAgICAgICAgICAgICAgICAnY3Vyc29yOm53c2UtcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplcl93cmFwcGVyeycgK1xuICAgICAgICAgICAgICAgICdwb3NpdGlvbjpyZWxhdGl2ZTsnICtcbiAgICAgICAgICAgICAgICAnZGlzcGxheTppbmxpbmUtYmxvY2s7JyArXG4gICAgICAgICAgICAgICAgJ2xpbmUtaGVpZ2h0OjA7JyArXG4gICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAnLmNrZV93aWRnZXRfd3JhcHBlcjpob3ZlciAuY2tlX2ltYWdlX3Jlc2l6ZXIsJyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXppbmd7JyArXG4gICAgICAgICAgICAgICAgJ2Rpc3BsYXk6YmxvY2snICtcbiAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVxdWlyZXM6ICd3aWRnZXQnXG4gICAgfSk7XG5cbiAgICAvLyBXaWdldCBzdGF0ZXMgKGZvcm1zKSBkZXBlbmRpbmcgb24gYWxpZ25tZW50IGFuZCBjb25maWd1cmF0aW9uLlxuICAgIC8vXG4gICAgLy8gTm9uLWNhcHRpb25lZCB3aWRnZXQgKGlubGluZSBzdHlsZXMpXG4gICAgLy8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdPiAgIOKUgjxpbWcgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnSAvPiAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPHAgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8cCBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4g4pSCICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCICAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdPiAg4pSCPGltZyBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnSAvPiAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgLy9cbiAgICAvLyBOb24tY2FwdGlvbmVkIHdpZGdldCAoY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXMgZGVmaW5lZClcbiAgICAvLyBcdFx04pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgLy8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIGNsYXNzPeKAnWxlZnTigJ0+ICAgICAgICAg4pSCPGltZyBjbGFzcz3igJ1sZWZ04oCdIC8+ICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8cCBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxwIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgY2xhc3M94oCdcmlnaHTigJ0+ICAgICAgICDilII8aW1nIGNsYXNzPeKAnXJpZ2h04oCdIC8+ICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAvL1xuICAgIC8vIENhcHRpb25lZCB3aWRnZXQgKGlubGluZSBzdHlsZXMpXG4gICAgLy8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0+ICAgICAgICAgICAg4pSCPGZpZ3VyZSBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdIC8+ICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiAgICAg4pSCPGRpdiBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4gICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgc3R5bGU94oCdZGlzcGxheTppbmxpbmUtYmxvY2vigJ0gLz7ilIIgPGZpZ3VyZSBzdHlsZT3igJ1kaXNwbGF5OmlubGluZS1ibG9ja+KAnSAvPuKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0+ICAgICAgICAgICDilII8ZmlndXJlIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdIC8+ICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAvL1xuICAgIC8vIENhcHRpb25lZCB3aWRnZXQgKGNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzIGRlZmluZWQpXG4gICAgLy8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIGNsYXNzPeKAnWxlZnTigJ0+ICAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSBjbGFzcz3igJ1sZWZ04oCdIC8+ICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICAgICAg4pSCPGRpdiBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIGNsYXNzPeKAnXJpZ2h04oCdPiAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSBjbGFzcz3igJ1yaWdodOKAnSAvPiAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cbiAgICAvLyBAcmV0dXJucyB7T2JqZWN0fVxuICAgIGZ1bmN0aW9uIHdpZGdldERlZihlZGl0b3IpIHtcbiAgICAgICAgZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplID0gZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplIHx8ICdib3RoJztcblxuICAgICAgICBlZGl0b3Iub24oJ2ltYWdlQWRkJywgZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICAgICAgZWRpdG9yLndpZGdldHMuaW5pdE9uKGltYWdlRGF0YS5kYXRhLmVsLCAnaW1hZ2UnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuICAgICAgICB2YXIgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWxwZXJzID0gQ0tFRElUT1IucGx1Z2lucy5pbWFnZTI7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLnBhcnRzLmltYWdlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdhbHQnKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2FwdGlvbjogISF0aGlzLnBhcnRzLmNhcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9jayByYXRpbyBpcyBvbiBieSBkZWZhdWx0ICgjMTA4MzMpLlxuICAgICAgICAgICAgICAgICAgICBsb2NrOiB0aGlzLnJlYWR5ID8gaGVscGVycy5jaGVja0hhc05hdHVyYWxSYXRpbyhpbWFnZSkgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzcmM6IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgdXNlZCAnYScgaW4gd2lkZ2V0I3BhcnRzIGRlZmluaXRpb24sIGl0IGNvdWxkIGhhcHBlbiB0aGF0XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHdpZGdldC5wYXJ0cyNjYXB0aW9uLiBTaW5jZSB0aGVyZSdzIG5vIGNsZXZlclxuICAgICAgICAgICAgICAgIC8vIHdheSB0byBzb2x2ZSBpdCB3aXRoIENTUyBzZWxlY3RvcnMsIGl0J3MgZG9uZSBsaWtlIHRoYXQuICgjMTE3ODMpLlxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gaW1hZ2UuZ2V0QXNjZW5kYW50KCdhJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobGluayAmJiB0aGlzLndyYXBwZXIuY29udGFpbnMobGluaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gY29uZmlndXJhdGlvbiwgcmVhZCBzdHlsZS9jbGFzcyBmcm9tIGVsZW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgaXQuIFJlbW92ZWQgc3R5bGUvY2xhc3Mgd2lsbCBiZSBzZXQgb24gd3JhcHBlciBpbiAjZGF0YSBsaXN0ZW5lci5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBDZW50ZXIgYWxpZ25tZW50IGlzIGRldGVjdGVkIGR1cmluZyB1cGNhc3QsIHNvIG9ubHkgbGVmdC9yaWdodCBjYXNlc1xuICAgICAgICAgICAgICAgIC8vIGFyZSBjaGVja2VkIGJlbG93LlxuICAgICAgICAgICAgICAgIGlmICghZGF0YS5hbGlnbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ25FbGVtZW50ID0gZGF0YS5oYXNDYXB0aW9uID8gdGhpcy5lbGVtZW50IDogaW1hZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgaW5pdGlhbCBsZWZ0L3JpZ2h0IGFsaWdubWVudCBmcm9tIHRoZSBjbGFzcyBzZXQgb24gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWduQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWduRWxlbWVudC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ25FbGVtZW50Lmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkVsZW1lbnQucmVtb3ZlQ2xhc3MoYWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbZGF0YS5hbGlnbl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hbGlnbiA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIGluaXRpYWwgZmxvYXQgc3R5bGUgZnJvbSBmaWd1cmUvaW1hZ2UgYW5kIHRoZW4gcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYWxpZ24gPSBhbGlnbkVsZW1lbnQuZ2V0U3R5bGUoJ2Zsb2F0JykgfHwgJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25FbGVtZW50LnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHJpZCBvZiBleHRyYSB2ZXJ0aWNhbCBzcGFjZSB3aGVuIHRoZXJlJ3Mgbm8gY2FwdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBJdCB3aWxsIGltcHJvdmUgdGhlIGxvb2sgb2YgdGhlIHJlc2l6ZXIuXG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyWyhkYXRhLmhhc0NhcHRpb24gPyAncmVtb3ZlJyA6ICdhZGQnKSArICdDbGFzcyddKCdja2VfaW1hZ2Vfbm9jYXB0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmNvbmZpZy5pbWFnZTJfZGlzYWJsZVJlc2l6ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNpemVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBJbWFnZTIuXG4gICAgICAgICAgICAvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2FkZENsYXNzXG4gICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFsbG93ZWRDb250ZW50OiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpLFxuXG4gICAgICAgICAgICAvLyBUaGlzIHdpZGdldCBjb252ZXJ0cyBzdHlsZS1kcml2ZW4gZGltZW5zaW9ucyB0byBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgY29udGVudFRyYW5zZm9ybWF0aW9uczogW1xuICAgICAgICAgICAgICAgIFsnaW1nW3dpZHRoXTogc2l6ZVRvQXR0cmlidXRlJ11cbiAgICAgICAgICAgIF0sXG5cbiAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuXG4gICAgICAgICAgICAgICAgLy8gSW1hZ2UgY2FuJ3QgYmUgY2FwdGlvbmVkIHdoZW4gZmlnY2FwdGlvbiBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGFzQ2FwdGlvbiAmJiAhZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuY2FwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmhhc0NhcHRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJbWFnZSBjYW4ndCBiZSBhbGlnbmVkIHdoZW4gZmxvYXRpbmcgaXMgZGlzYWxsb3dlZCAoIzExMDA0KS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLmFsaWduICE9ICdub25lJyAmJiAhZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hbGlnbiA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd2lkZ2V0LnBhcnRzLmxpbmsgc2luY2UgaXQgd2lsbCBub3QgYXV0by11cGRhdGUgdW5sZXNzIHdpZGdldFxuICAgICAgICAgICAgICAgIC8vIGlzIGRlc3Ryb3llZCBhbmQgcmUtaW5pdGVkLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kYXRhLmxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFydHMubGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucGFydHMubGluaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJ0cy5saW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLmxpbmsgPSB0aGlzLnBhcnRzLmltYWdlLmdldFBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5pbWFnZS5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgYWx0OiB0aGlzLmRhdGEuYWx0LFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID8gdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpIDogdHJ1ZSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGludGVybmFsIGlzIHJlcXVpcmVkIGJ5IHRoZSBlZGl0b3IuXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLWNrZS1zYXZlZC1zcmMnOiB0aGlzLmRhdGEuc3JjLFxuXG4gICAgICAgICAgICAgICAgICAgIHNyYzogdGhpcy5kYXRhLnNyY1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2hpZnRpbmcgbm9uLWNhcHRpb25lZCAtPiBjYXB0aW9uZWQsIHJlbW92ZSBjbGFzc2VzXG4gICAgICAgICAgICAgICAgLy8gcmVsYXRlZCB0byBzdHlsZXMgZnJvbSA8aW1nLz4uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2xkRGF0YSAmJiAhdGhpcy5vbGREYXRhLmhhc0NhcHRpb24gJiYgdGhpcy5kYXRhLmhhc0NhcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyBpbiB0aGlzLmRhdGEuY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5pbWFnZS5yZW1vdmVDbGFzcyhjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNldCBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZSBhY2NvcmRpbmcgdG8gZ2F0aGVyZWQgZGF0YS5cbiAgICAgICAgICAgICAgICAvLyBEbyBpdCBvbmx5IHdoZW4gdGhlIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQgKCMxMTAwNCkuXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmRpbWVuc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGltZW5zaW9ucyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWNoZSBjdXJyZW50IGRhdGEuXG4gICAgICAgICAgICAgICAgdGhpcy5vbGREYXRhID0gQ0tFRElUT1IudG9vbHMuZXh0ZW5kKHt9LCB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZG93bmNhc3Q6IGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBUaGlzIHdpZGdldCBoYXMgYW4gZWRpdGFibGUgY2FwdGlvbi5cbiAgICAgICAgICAgIGVkaXRhYmxlczoge1xuICAgICAgICAgICAgICAgIGNhcHRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWdjYXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZENvbnRlbnQ6ICdiciBlbSBzdHJvbmcgc3ViIHN1cCB1IHM7IGFbIWhyZWYsdGFyZ2V0XSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmZWF0dXJlczogZ2V0V2lkZ2V0RmVhdHVyZXMoZWRpdG9yKSxcblxuICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIEltYWdlMi5cbiAgICAgICAgICAgIC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjZ2V0Q2xhc3Nlc1xuICAgICAgICAgICAgZ2V0Q2xhc3NlczogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIFtdLmNvbmNhdChjYXB0aW9uZWRDbGFzcywgYWxpZ25DbGFzc2VzKS5qb2luKCd8JykgKyAnKSQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5yZXBvc2l0b3J5LnBhcnNlRWxlbWVudENsYXNzZXMoZ2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5laXRoZXIgY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcyBub3IgY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGJlbG9uZyB0byBzdHlsZSBjbGFzc2VzLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjIGluIGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc1JlZ2V4LnRlc3QoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2xhc3Nlc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpLFxuXG4gICAgICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9ICh0aGlzLmRhdGEuYWx0IHx8ICcnKSArICcgJyArIHRoaXMucGF0aE5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuICAgICAgICAgICAgLy8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNoYXNDbGFzc1xuICAgICAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5oYXNDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICBjYXB0aW9uOiAnZmlnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgaW1hZ2U6ICdpbWcnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuICAgICAgICAgICAgLy8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNyZW1vdmVDbGFzc1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXF1aXJlZENvbnRlbnQ6ICdpbWdbc3JjLGFsdF0nLFxuXG4gICAgICAgICAgICBzdHlsZWFibGVFbGVtZW50czogJ2ltZyBmaWd1cmUnLFxuXG4gICAgICAgICAgICAvLyBUZW1wbGF0ZSBvZiB0aGUgd2lkZ2V0OiBwbGFpbiBpbWFnZS5cbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblxuICAgICAgICAgICAgdXBjYXN0OiB1cGNhc3RXaWRnZXRFbGVtZW50KGVkaXRvcilcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBFbmhhbmNlZCBJbWFnZSAoaW1hZ2UyKSBwbHVnaW4gaGVscGVycy5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBzaW5nbGV0b25cbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmltYWdlMiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IGltYWdlIHJhdGlvIG1hdGNoZXMgdGhlIG5hdHVyYWwgb25lXG4gICAgICAgICAqIGJ5IGNvbXBhcmluZyBkaW1lbnNpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrSGFzTmF0dXJhbFJhdGlvOiBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciAkID0gaW1hZ2UuJCxcbiAgICAgICAgICAgICAgICBuYXR1cmFsID0gdGhpcy5nZXROYXR1cmFsKGltYWdlKTtcblxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiBmb3IgdHdvIGFsdGVybmF0aXZlIGNvbXBhcmlzb25zIGlzIHRoYXQgdGhlIHJvdW5kaW5nIGNhbiBjb21lIGZyb21cbiAgICAgICAgICAgIC8vIGJvdGggZGltZW5zaW9ucywgZS5nLiB0aGVyZSBhcmUgdHdvIGNhc2VzOlxuICAgICAgICAgICAgLy8gXHQxLiBoZWlnaHQgaXMgY29tcHV0ZWQgYXMgYSByb3VuZGVkIHJlbGF0aW9uIG9mIHRoZSByZWFsIGhlaWdodCBhbmQgdGhlIHZhbHVlIG9mIHdpZHRoLFxuICAgICAgICAgICAgLy9cdDIuIHdpZHRoIGlzIGNvbXB1dGVkIGFzIGEgcm91bmRlZCByZWxhdGlvbiBvZiB0aGUgcmVhbCB3aWR0aCBhbmQgdGhlIHZhbHVlIG9mIGhlaWdoLlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoJC5jbGllbnRXaWR0aCAvIG5hdHVyYWwud2lkdGggKiBuYXR1cmFsLmhlaWdodCkgPT0gJC5jbGllbnRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCQuY2xpZW50SGVpZ2h0IC8gbmF0dXJhbC5oZWlnaHQgKiBuYXR1cmFsLndpZHRoKSA9PSAkLmNsaWVudFdpZHRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIG5hdHVyYWwgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UuIEZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICogaXQgdXNlcyBuYXR1cmFsKFdpZHRofEhlaWdodCkuIEZvciBvbGQgb25lcyAoSUU4KSBpdCBjcmVhdGVzXG4gICAgICAgICAqIGEgbmV3IGltYWdlIGFuZCByZWFkcyB0aGUgZGltZW5zaW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldE5hdHVyYWw6IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnM7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZS4kLm5hdHVyYWxXaWR0aCkge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW1hZ2UuJC5uYXR1cmFsSGVpZ2gsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZS4kLm5hdHVyYWxXaWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2gsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB3aWRnZXRzIGZyb20gYWxsIDxpbWc+IGFuZFxuICAgIC8vIDxmaWd1cmUgY2xhc3M9XCJ7Y29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzc31cIj4gZWxlbWVudHMuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yXG4gICAgLy8gQHJldHVybnMge0Z1bmN0aW9ufVxuICAgIGZ1bmN0aW9uIHVwY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSB7XG4gICAgICAgIHZhciBpc0NlbnRlcldyYXBwZXIgPSBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpO1xuXG4gICAgICAgIHZhciBjYXB0aW9uZWRDbGFzcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzO1xuXG4gICAgICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbFxuICAgICAgICAvLyBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDFcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBuYW1lID0gZWwubmFtZTtcblxuICAgICAgICAgICAgdmFyIGltYWdlO1xuXG4gICAgICAgICAgICAvLyAjMTExMTAgRG9uJ3QgaW5pdGlhbGl6ZSBvbiBwYXN0ZWQgZmFrZSBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKGVsLmF0dHJpYnV0ZXNbJ2RhdGEtY2tlLXJlYWxlbGVtZW50J10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGEgY2VudGVyIHdyYXBwZXIgaXMgZm91bmQsIHRoZXJlIGFyZSAzIHBvc3NpYmxlIGNhc2VzOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDEuIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxmaWd1cmU+Li4uPC9maWd1cmU+PC9kaXY+LlxuICAgICAgICAgICAgLy8gICAgSW4gdGhpcyBjYXNlIGNlbnRlcmluZyBpcyBkb25lIHdpdGggYSBjbGFzcyBzZXQgb24gd2lkZ2V0LndyYXBwZXIuXG4gICAgICAgICAgICAvLyAgICBTaW1wbHkgcmVwbGFjZSBjZW50ZXJpbmcgd3JhcHBlciB3aXRoIGZpZ3VyZSAoaXQncyBubyBsb25nZXIgbmVjZXNzYXJ5KS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAyLiA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9wPi5cbiAgICAgICAgICAgIC8vICAgIE5vdGhpbmcgdG8gZG8gaGVyZTogPHA+IHJlbWFpbnMgZm9yIHN0eWxpbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMy4gPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9kaXY+LlxuICAgICAgICAgICAgLy8gICAgTm90aGluZyB0byBkbyBoZXJlICgyLikgYnV0IHRoYXQgY2FzZSBpcyBvbmx5IHBvc3NpYmxlIGluIGVudGVyTW9kZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vICAgIHRoYW4gRU5URVJfUC5cbiAgICAgICAgICAgIGlmIChpc0NlbnRlcldyYXBwZXIoZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gJ2RpdicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZ3VyZSA9IGVsLmdldEZpcnN0KCdmaWd1cmUnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYXNlICMxLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlndXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZXBsYWNlV2l0aChmaWd1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBmaWd1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FzZXMgIzIgYW5kICMzIChoYW5kbGVkIHRyYW5zcGFyZW50bHkpXG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2VudGVyaW5nIHdyYXBwZXIsIHNhdmUgaXQgaW4gZGF0YS5cbiAgICAgICAgICAgICAgICBkYXRhLmFsaWduID0gJ2NlbnRlcic7XG5cbiAgICAgICAgICAgICAgICAvLyBJbWFnZSBjYW4gYmUgd3JhcHBlZCBpbiBsaW5rIDxhPjxpbWcvPjwvYT4uXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBlbC5nZXRGaXJzdCgnaW1nJykgfHwgZWwuZ2V0Rmlyc3QoJ2EnKS5nZXRGaXJzdCgnaW1nJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGNlbnRlciB3cmFwcGVyIGhhcyBiZWVuIGZvdW5kLlxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PSAnZmlndXJlJyAmJiBlbC5oYXNDbGFzcyhjYXB0aW9uZWRDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwY2FzdCBsaW5rZWQgaW1hZ2UgbGlrZSA8YT48aW1nLz48L2E+LlxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGVsKSkge1xuICAgICAgICAgICAgICAgIGltYWdlID0gZWwubmFtZSA9PSAnYScgPyBlbC5jaGlsZHJlblswXSA6IGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGltYWdlLCB0aGVuIGNvb2wsIHdlIGdvdCBhIHdpZGdldC5cbiAgICAgICAgICAgIC8vIE5vdyBqdXN0IHJlbW92ZSBkaW1lbnNpb24gYXR0cmlidXRlcyBleHByZXNzZWQgd2l0aCAlLlxuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGltYWdlLmF0dHJpYnV0ZXNbZF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9uICYmIGRpbWVuc2lvbi5tYXRjaChyZWdleFBlcmNlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbWFnZS5hdHRyaWJ1dGVzW2RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0cmFuc2Zvcm1zIHRoZSB3aWRnZXQgdG8gdGhlIGV4dGVybmFsIGZvcm1hdFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG4gICAgZnVuY3Rpb24gZG93bmNhc3RXaWRnZXRFbGVtZW50KGVkaXRvcikge1xuICAgICAgICB2YXIgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzO1xuXG4gICAgICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIDxhPjxpbWcvPjwvYT4sIDxpbWcvPiBpcyB0aGUgZWxlbWVudCB0byBob2xkXG4gICAgICAgICAgICAvLyBpbmxpbmUgc3R5bGVzIG9yIGNsYXNzZXMgKGltYWdlMl9hbGlnbkNsYXNzZXMpLlxuICAgICAgICAgICAgdmFyIGF0dHJzSG9sZGVyID0gZWwubmFtZSA9PSAnYScgPyBlbC5nZXRGaXJzdCgpIDogZWw7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyc0hvbGRlci5hdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZTtcblxuICAgICAgICAgICAgdmFyIGF0dHJzID0gYXR0cnNIb2xkZXIuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgdmFyIGFsaWduID0gdGhpcy5kYXRhLmFsaWduO1xuXG4gICAgICAgICAgICAvLyBEZS13cmFwIHRoZSBpbWFnZSBmcm9tIHJlc2l6ZSBoYW5kbGUgd3JhcHBlci5cbiAgICAgICAgICAgIC8vIE9ubHkgYmxvY2sgd2lkZ2V0cyBoYXZlIG9uZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzaXplV3JhcHBlciA9IGVsLmdldEZpcnN0KCdzcGFuJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzaXplV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICByZXNpemVXcmFwcGVyLnJlcGxhY2VXaXRoKHJlc2l6ZVdyYXBwZXIuZ2V0Rmlyc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZzogMVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxpZ24gJiYgYWxpZ24gIT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IENLRURJVE9SLnRvb2xzLnBhcnNlQ3NzVGV4dChhdHRycy5zdHlsZSB8fCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSB3aWRnZXQgaXMgY2FwdGlvbmVkICg8ZmlndXJlPikgYW5kIGludGVybmFsbHkgY2VudGVyaW5nIGlzIGRvbmVcbiAgICAgICAgICAgICAgICAvLyB3aXRoIHdpZGdldCdzIHdyYXBwZXIgc3R5bGUvY2xhc3MsIGluIHRoZSBleHRlcm5hbCBkYXRhIHJlcHJlc2VudGF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIDxmaWd1cmU+IG11c3QgYmUgd3JhcHBlZCB3aXRoIGFuIGVsZW1lbnQgaG9sZGluZyBhbiBzdHlsZS9jbGFzczpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFx0PGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+XG4gICAgICAgICAgICAgICAgLy8gXHRcdDxmaWd1cmUgY2xhc3M9XCJpbWFnZVwiIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2tcIj4uLi48L2ZpZ3VyZT5cbiAgICAgICAgICAgICAgICAvLyBcdDwvZGl2PlxuICAgICAgICAgICAgICAgIC8vIG9yXG4gICAgICAgICAgICAgICAgLy8gXHQ8ZGl2IGNsYXNzPVwic29tZS1jZW50ZXItY2xhc3NcIj5cbiAgICAgICAgICAgICAgICAvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCI+Li4uPC9maWd1cmU+XG4gICAgICAgICAgICAgICAgLy8gXHQ8L2Rpdj5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChhbGlnbiA9PSAnY2VudGVyJyAmJiBlbC5uYW1lID09ICdmaWd1cmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gZWwud3JhcFdpdGgobmV3IENLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudCgnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduQ2xhc3NlcyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBhbGlnbkNsYXNzZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0LWFsaWduOmNlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBsZWZ0L3JpZ2h0LCBhZGQgZmxvYXQgc3R5bGUgdG8gdGhlIGRvd25jYXN0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGlnbiBpbiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDFcbiAgICAgICAgICAgICAgICAgICAgfSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25DbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc0hvbGRlci5hZGRDbGFzcyhhbGlnbkNsYXNzZXNbYWxpZ25tZW50c09ialthbGlnbl1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1snZmxvYXQnXSA9IGFsaWduO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGVsZW1lbnQgc3R5bGVzLlxuICAgICAgICAgICAgICAgIGlmICghYWxpZ25DbGFzc2VzICYmICFDS0VESVRPUi50b29scy5pc0VtcHR5KHN0eWxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSBDS0VESVRPUi50b29scy53cml0ZUNzc1RleHQoc3R5bGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYW4gZWxlbWVudCBpcyBhIGNlbnRlcmluZyB3cmFwcGVyLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuICAgIC8vIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICBmdW5jdGlvbiBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpIHtcbiAgICAgICAgdmFyIGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3M7XG5cbiAgICAgICAgdmFyIGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuICAgICAgICB2YXIgdmFsaWRDaGlsZHJlbiA9IHtcbiAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICBmaWd1cmU6IDEsXG4gICAgICAgICAgICBpbWc6IDFcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBXcmFwcGVyIG11c3QgYmUgZWl0aGVyIDxkaXY+IG9yIDxwPi5cbiAgICAgICAgICAgIGlmICghKGVsLm5hbWUgaW4ge1xuICAgICAgICAgICAgICAgICAgICBkaXY6IDEsXG4gICAgICAgICAgICAgICAgICAgIHA6IDFcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIC8vIENlbnRlcmluZyB3cmFwcGVyIGNhbiBoYXZlIG9ubHkgb25lIGNoaWxkLlxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIC8vIE9ubHkgPGZpZ3VyZT4gb3IgPGltZyAvPiBjYW4gYmUgZmlyc3QgKG9ubHkpIGNoaWxkIG9mIGNlbnRlcmluZyB3cmFwcGVyLFxuICAgICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiBpdHMgdHlwZS5cbiAgICAgICAgICAgIGlmICghKGNoaWxkLm5hbWUgaW4gdmFsaWRDaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGNlbnRlcmluZyB3cmFwcGVyIGlzIDxwPiwgb25seSA8aW1nIC8+IGNhbiBiZSB0aGUgY2hpbGQuXG4gICAgICAgICAgICAvLyAgIDxwIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nIC8+PC9wPlxuICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2VudGVyaW5nIDxkaXY+IGNhbiBob2xkIDxpbWcvPiBvciA8ZmlndXJlPiwgZGVwZW5kaW5nIG9uIGVudGVyTW9kZS5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgPGZpZ3VyZT4gaXMgdGhlIGZpcnN0IChvbmx5KSBjaGlsZCwgaXQgbXVzdCBoYXZlIGEgY2xhc3MuXG4gICAgICAgICAgICAgICAgLy8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48ZmlndXJlPi4uLjwvZmlndXJlPjxkaXY+XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5hbWUgPT0gJ2ZpZ3VyZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5oYXNDbGFzcyhjYXB0aW9uZWRDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENlbnRlcmluZyA8ZGl2PiBjYW4gaG9sZCA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPiBvbmx5IHdoZW4gZW50ZXJNb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIEVOVEVSXyhCUnxESVYpLlxuICAgICAgICAgICAgICAgICAgICAvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxpbWcgLz48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgLy8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48YT48aW1nIC8+PC9hPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmVudGVyTW9kZSA9PSBDS0VESVRPUi5FTlRFUl9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIGVudGVyTW9kZSwgYSBjaGlsZCB3aGljaCBpcyBub3QgPGZpZ3VyZT4gbXVzdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBlaXRoZXIgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4uXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2VudGVyaW5nIHdyYXBwZXIgZ290IHRvIGJlLi4uIGNlbnRlcmluZy4gSWYgaW1hZ2UyX2FsaWduQ2xhc3NlcyBhcmUgZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjZW50ZXJpbmcgY2xhc3MuIE90aGVyd2lzZSwgY2hlY2sgdGhlIHN0eWxlLlxuICAgICAgICAgICAgaWYgKGFsaWduQ2xhc3NlcyA/IGVsLmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1sxXSkgOlxuICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLnBhcnNlQ3NzVGV4dChlbC5hdHRyaWJ1dGVzLnN0eWxlIHx8ICcnLCB0cnVlKVsndGV4dC1hbGlnbiddID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVja3Mgd2hldGhlciBlbGVtZW50IGlzIDxpbWcvPiBvciA8YT48aW1nLz48L2E+LlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5odG1sUGFyc2VyLmVsZW1lbnR9XG4gICAgZnVuY3Rpb24gaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShlbCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PSAnaW1nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWwubmFtZSA9PSAnYScpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGggPT0gMSAmJiBlbC5nZXRGaXJzdCgnaW1nJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB3aWRnZXQgaW1hZ2UgYWNjb3JkaW5nIHRvIGN1cnJlbnQgd2lkZ2V0IGRhdGEuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fSB3aWRnZXRcbiAgICBmdW5jdGlvbiBzZXREaW1lbnNpb25zKHdpZGdldCkge1xuICAgICAgICB2YXIgZGF0YSA9IHdpZGdldC5kYXRhO1xuXG4gICAgICAgIHZhciBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBkYXRhLndpZHRoXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGltYWdlID0gd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG4gICAgICAgIGZvciAodmFyIGQgaW4gZGltZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnNbZF0pIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoZCwgZGltZW5zaW9uc1tkXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZUF0dHJpYnV0ZShkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmluZXMgYWxsIGZlYXR1cmVzIHJlbGF0ZWQgdG8gZHJhZy1kcml2ZW4gaW1hZ2UgcmVzaXppbmcuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fSB3aWRnZXRcbiAgICBmdW5jdGlvbiBzZXR1cFJlc2l6ZXIod2lkZ2V0KSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB3aWRnZXQuZWRpdG9yO1xuXG4gICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgIHZhciBkb2MgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIHJlc2l6ZXIgaW4gYSB3aWRnZXQgZm9yIHRlc3RpbmcgKCMxMTAwNCkuXG4gICAgICAgIHZhciByZXNpemVyID0gd2lkZ2V0LnJlc2l6ZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgIHJlc2l6ZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyJyk7XG4gICAgICAgIHJlc2l6ZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyXycgKyBjdXJzb3JbZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplXSk7XG4gICAgICAgIHJlc2l6ZXIuYXBwZW5kKG5ldyBDS0VESVRPUi5kb20udGV4dCgnXFx1MjAwYicsIGRvYykpO1xuXG4gICAgICAgIC8vIElubGluZSB3aWRnZXRzIGRvbid0IG5lZWQgYSByZXNpemVyIHdyYXBwZXIgYXMgYW4gaW1hZ2Ugc3BhbnMgdGhlIGVudGlyZSB3aWRnZXQuXG4gICAgICAgIGlmICghd2lkZ2V0LmlubGluZSkge1xuICAgICAgICAgICAgdmFyIGltYWdlT3JMaW5rID0gd2lkZ2V0LnBhcnRzLmxpbmsgfHwgd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG4gICAgICAgICAgICB2YXIgb2xkUmVzaXplV3JhcHBlciA9IGltYWdlT3JMaW5rLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICB2YXIgcmVzaXplV3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cbiAgICAgICAgICAgIHJlc2l6ZVdyYXBwZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3dyYXBwZXInKTtcbiAgICAgICAgICAgIHJlc2l6ZVdyYXBwZXIuYXBwZW5kKGltYWdlT3JMaW5rKTtcbiAgICAgICAgICAgIHJlc2l6ZVdyYXBwZXIuYXBwZW5kKHJlc2l6ZXIpO1xuICAgICAgICAgICAgd2lkZ2V0LmVsZW1lbnQuYXBwZW5kKHJlc2l6ZVdyYXBwZXIsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCB3cmFwcGVyIHdoaWNoIGNvdWxkIGNhbWUgZnJvbSBlLmcuIHBhc3RlZCBIVE1MXG4gICAgICAgICAgICAvLyBhbmQgd2hpY2ggY291bGQgYmUgY29ycnVwdGVkIChlLmcuIHJlc2l6ZXIgc3BhbiBoYXMgYmVlbiBsb3N0KS5cbiAgICAgICAgICAgIGlmIChvbGRSZXNpemVXcmFwcGVyLmlzKCdzcGFuJykpIHtcbiAgICAgICAgICAgICAgICBvbGRSZXNpemVXcmFwcGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkZ2V0LndyYXBwZXIuYXBwZW5kKHJlc2l6ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlcyBvZiBzaXplIHZhcmlhYmxlcyBhbmQgbW91c2Ugb2Zmc2V0cy5cbiAgICAgICAgcmVzaXplci5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgdmFyIGltYWdlID0gd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG4gICAgICAgICAgICAvLyBcImZhY3RvclwiIGNhbiBiZSBlaXRoZXIgMSBvciAtMS4gSS5lLjogRm9yIHJpZ2h0LWFsaWduZWQgaW1hZ2VzLCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBzdWJ0cmFjdCB0aGUgZGlmZmVyZW5jZSB0byBnZXQgcHJvcGVyIHdpZHRoLCBldGMuIFdpdGhvdXQgXCJmYWN0b3JcIixcbiAgICAgICAgICAgIC8vIHJlc2l6ZXIgc3RhcnRzIHdvcmtpbmcgdGhlIG9wcG9zaXRlIHdheS5cbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSB3aWRnZXQuZGF0YS5hbGlnbiA9PSAncmlnaHQnID8gLTEgOiAxO1xuXG4gICAgICAgICAgICAvLyBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBtb3VzZSByZWxhdGl2ZSB0byB0aGUgc2NyZWVuXG4gICAgICAgICAgICAvLyB3aGVuIGJ1dHRvbiBnZXRzIHByZXNzZWQuXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gZXZ0LmRhdGEuJC5zY3JlZW5YO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gZXZ0LmRhdGEuJC5zY3JlZW5ZO1xuXG4gICAgICAgICAgICAvLyBUaGUgaW5pdGlhbCBkaW1lbnNpb25zIGFuZCBhc3BlY3QgcmF0aW8gb2YgdGhlIGltYWdlLlxuICAgICAgICAgICAgdmFyIHN0YXJ0V2lkdGggPSBpbWFnZS4kLmNsaWVudFdpZHRoO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnRIZWlnaHQgPSBpbWFnZS4kLmNsaWVudEhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBBIGNsYXNzIGFwcGxpZWQgdG8gZWRpdGFibGUgZHVyaW5nIHJlc2l6aW5nLlxuICAgICAgICAgICAgdmFyIGN1cnNvckNsYXNzID0gJ2NrZV9pbWFnZV9zJyArICghfmZhY3RvciA/ICd3JyA6ICdlJyk7XG5cbiAgICAgICAgICAgIHZhciBuYXRpdmVFdnQsIG5ld1dpZHRoLCBuZXdIZWlnaHQsIHVwZGF0ZURhdGE7XG5cbiAgICAgICAgICAgIHZhciBtb3ZlRGlmZlgsIG1vdmVEaWZmWSwgbW92ZVJhdGlvO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSB1bmRvIHNuYXBzaG90IGZpcnN0OiBiZWZvcmUgcmVzaXppbmcuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cbiAgICAgICAgICAgIC8vIE1vdXNlbW92ZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgb24gbW91c2V1cC5cbiAgICAgICAgICAgIGF0dGFjaFRvRG9jdW1lbnRzKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgbGlzdGVuZXJzKTtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIG1vdXNlbW92ZSBsaXN0ZW5lci4gVXBkYXRlIHdpZGdldCBkYXRhIGlmIHZhbGlkLlxuICAgICAgICAgICAgYXR0YWNoVG9Eb2N1bWVudHMoJ21vdXNldXAnLCBvbk1vdXNlVXAsIGxpc3RlbmVycyk7XG5cbiAgICAgICAgICAgIC8vIFRoZSBlbnRpcmUgZWRpdGFibGUgd2lsbCBoYXZlIHRoZSBzcGVjaWFsIGN1cnNvciB3aGlsZSByZXNpemluZyBnb2VzIG9uLlxuICAgICAgICAgICAgZWRpdGFibGUuYWRkQ2xhc3MoY3Vyc29yQ2xhc3MpO1xuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRvIGFsd2F5cyBrZWVwIHRoZSByZXNpemVyIGVsZW1lbnQgdmlzaWJsZSB3aGlsZSByZXNpemluZy5cbiAgICAgICAgICAgIHJlc2l6ZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemluZycpO1xuXG4gICAgICAgICAgICAvLyBBdHRhY2hlcyBhbiBldmVudCB0byBhIGdsb2JhbCBkb2N1bWVudCBpZiBpbmxpbmUgZWRpdG9yLlxuICAgICAgICAgICAgLy8gQWRkaXRpb25hbGx5LCBpZiBjbGFzc2ljIChgaWZyYW1lYC1iYXNlZCkgZWRpdG9yLCBhbHNvIGF0dGFjaGVzIHRoZSBzYW1lIGV2ZW50IHRvIGBpZnJhbWVgJ3MgZG9jdW1lbnQuXG4gICAgICAgICAgICBmdW5jdGlvbiBhdHRhY2hUb0RvY3VtZW50cyhuYW1lLCBjYWxsYmFjaywgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxEb2MgPSBDS0VESVRPUi5kb2N1bWVudDtcblxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICghZG9jLmVxdWFscyhnbG9iYWxEb2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGdsb2JhbERvYy5vbihuYW1lLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGRvYy5vbihuYW1lLCBjYWxsYmFjaykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChsaXN0ZW5lcnMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGhvdyB2YXJpYWJsZXMgcmVmZXIgdG8gdGhlIGdlb21ldHJ5LlxuICAgICAgICAgICAgLy8gTm90ZTogeCBjb3JyZXNwb25kcyB0byBtb3ZlT2Zmc2V0LCB0aGlzIGlzIHRoZSBwb3NpdGlvbiBvZiBtb3VzZVxuICAgICAgICAgICAgLy8gTm90ZTogbyBjb3JyZXNwb25kcyB0byBbc3RhcnRYLCBzdGFydFldLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFx0Ky0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgLy8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAvLyBcdHwgICAgICBJICAgICAgIHwgICAgICBJSSAgICAgIHxcbiAgICAgICAgICAgIC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgLy8gXHQrLS0tLS0tLS0tLS0tLSBvIC0tLS0tLS0tLS0tLS0rIF8gXyBfXG4gICAgICAgICAgICAvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICBeXG5cbiAgICAgICAgICAgIC8vIFx0fCAgICAgIFZJICAgICAgfCAgICAgSUlJICAgICAgfCAgICAgIHwgbW92ZURpZmZZXG4gICAgICAgICAgICAvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICB4IF8gXyBfIF8gXyB2XG4gICAgICAgICAgICAvLyBcdCstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS18LS0tLStcbiAgICAgICAgICAgIC8vIFx0ICAgICAgICAgICAgICAgfCAgICAgICAgIHxcbiAgICAgICAgICAgIC8vIFx0ICAgICAgICAgICAgICAgIDwtLS0tLS0tPlxuICAgICAgICAgICAgLy8gXHQgICAgICAgICAgICAgICAgbW92ZURpZmZYXG4gICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTY2FsZVJlc2l6ZSA9IGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZTtcblxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2dCA9IGV2dC5kYXRhLiQ7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGhvdyBmYXIgdGhlIG1vdXNlIGlzIGZyb20gdGhlIHBvaW50IHRoZSBidXR0b24gd2FzIHByZXNzZWQuXG4gICAgICAgICAgICAgICAgbW92ZURpZmZYID0gbmF0aXZlRXZ0LnNjcmVlblggLSBzdGFydFg7XG4gICAgICAgICAgICAgICAgbW92ZURpZmZZID0gc3RhcnRZIC0gbmF0aXZlRXZ0LnNjcmVlblk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIG1vdmUgZGlmZmVyZW5jZS5cbiAgICAgICAgICAgICAgICBtb3ZlUmF0aW8gPSBNYXRoLmFicyhtb3ZlRGlmZlggLyBtb3ZlRGlmZlkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICd3aWR0aCcgfHwgaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ2JvdGgnIHx8IGltYWdlU2NhbGVSZXNpemUgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3V2lkdGggPSBzdGFydFdpZHRoICsgZmFjdG9yICogbW92ZURpZmZYO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnaGVpZ2h0JyB8fCBpbWFnZVNjYWxlUmVzaXplID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gc3RhcnRIZWlnaHQgLSBtb3ZlRGlmZlk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggfHwgc3RhcnRXaWR0aDtcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgfHwgc3RhcnRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCB1cGRhdGUgYXR0cmlidXRlcyBpZiBsZXNzIHRoYW4gMTAuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0byBwcmV2ZW50IGltYWdlcyB0byB2aXN1YWxseSBkaXNhcHBlYXIuXG4gICAgICAgICAgICAgICAgaWYgKG5ld1dpZHRoID49IDE1ICYmIChuZXdIZWlnaHQgPj0gMTUgfHwgbmV3SGVpZ2h0ID09PSAnYXV0bycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLiQuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLiQuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGw7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGwgPSBsaXN0ZW5lcnMucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGwucmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGRlZmF1bHQgY3Vyc29yIGJ5IHJlbW92aW5nIHNwZWNpYWwgY2xhc3MuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUucmVtb3ZlQ2xhc3MoY3Vyc29yQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0byBicmluZyBiYWNrIHRoZSByZWd1bGFyIGJlaGF2aW91ciBvZiB0aGUgcmVzaXplci5cbiAgICAgICAgICAgICAgICByZXNpemVyLnJlbW92ZUNsYXNzKCdja2VfaW1hZ2VfcmVzaXppbmcnKTtcblxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5lbGVtZW50LiQuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5lbGVtZW50LiQuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIGFub3RoZXIgdW5kbyBzbmFwc2hvdDogYWZ0ZXIgcmVzaXppbmcuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCB1cGRhdGUgZGF0YSB0d2ljZSBvciBtb3JlLlxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgd2lkZ2V0IHJlc2l6ZXIgd2hlbiBkYXRhIGNoYW5nZXMuXG4gICAgICAgIHdpZGdldC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc2l6ZXJbd2lkZ2V0LmRhdGEuYWxpZ24gPT0gJ3JpZ2h0JyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnY2tlX2ltYWdlX3Jlc2l6ZXJfbGVmdCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICB3aWRnZXQucGFydHMuaW1hZ2Uub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGdldEVsZW1lbnQgPSBlbGVtZW50LmZpbmRPbmUoJ2ltZycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWRnZXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5sZWZ0IC09IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5kaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25EYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHdpZGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgYWxsb3dlZENvbnRlbnQgcnVsZXMsIGRlcGVuZGluZ1xuICAgIC8vIG9uIGNvbmZpZ3VyYXRpb25zIGxpa2UgY29uZmlnI2ltYWdlMl9hbGlnbkNsYXNzZXMgb3JcbiAgICAvLyBjb25maWcjaW1hZ2UyX2NhcHRpb25lZENsYXNzLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG4gICAgLy8gQHJldHVybnMge09iamVjdH1cbiAgICBmdW5jdGlvbiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0ge1xuICAgICAgICAgICAgZmlnY2FwdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZpZ3VyZToge1xuICAgICAgICAgICAgICAgIGNsYXNzZXM6ICchJyArIGVkaXRvci5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1nOiB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogJyFzcmMsYWx0LHdpZHRoLGhlaWdodCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgZmVhdHVyZSBydWxlcywgZGVwZW5kaW5nXG4gICAgLy8gb24gZWRpdG9yIGNvbmZpZ3VyYXRpb24uIE5vdGUgdGhhdCB0aGUgZm9sbG93aW5nIG1heSBub3QgY292ZXJcbiAgICAvLyBhbGwgdGhlIHBvc3NpYmxlIGNhc2VzIHNpbmNlIHJlcXVpcmVkQ29udGVudCBzdXBwb3J0cyBhIHNpbmdsZVxuICAgIC8vIHRhZyBvbmx5LlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG4gICAgLy8gQHJldHVybnMge09iamVjdH1cbiAgICBmdW5jdGlvbiBnZXRXaWRnZXRGZWF0dXJlcyhlZGl0b3IpIHtcbiAgICAgICAgdmFyIGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuICAgICAgICB2YXIgZmVhdHVyZXMgPSB7XG4gICAgICAgICAgICBhbGlnbjoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGVudDogJ2ltZycgK1xuICAgICAgICAgICAgICAgICAgICAoYWxpZ25DbGFzc2VzID8gJygnICsgYWxpZ25DbGFzc2VzWzBdICsgJyknIDogJ3tmbG9hdH0nKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhcHRpb246IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRlbnQ6ICdmaWdjYXB0aW9uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGVudDogJ2ltZ1t3aWR0aCxoZWlnaHRdJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGVsZW1lbnQgd2hpY2ggaXMgc3R5bGVkLCBjb25zaWRlcmluZyBjdXJyZW50XG4gICAgLy8gc3RhdGUgb2YgdGhlIHdpZGdldC5cbiAgICAvL1xuICAgIC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjYXBwbHlTdHlsZVxuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuICAgIC8vIEByZXR1cm5zIHtDS0VESVRPUi5kb20uZWxlbWVudH1cbiAgICBmdW5jdGlvbiBnZXRTdHlsZWFibGVFbGVtZW50KHdpZGdldCkge1xuICAgICAgICByZXR1cm4gd2lkZ2V0LmRhdGEuaGFzQ2FwdGlvbiA/IHdpZGdldC5lbGVtZW50IDogd2lkZ2V0LnBhcnRzLmltYWdlO1xuICAgIH1cbn0pKCk7XG5cbkNLRURJVE9SLmNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3MgPSAnaW1hZ2UnOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2VtYmVkJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBSRUdFWF9IVFRQID0gL15odHRwcz8vO1xuXG4gICAgdmFyIFJFR0VYX0RFRkFVTFRfTElOSyA9IC88YSBocmVmPS87XG5cbiAgICB2YXIgUFJPVklERVJTID0gWyd5b3V0dWJlJywgJ3R3aXR0ZXInXTtcblxuICAgIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCA9ICdodHRwOi8vYWxsb3kuaWZyYW1lLmx5L2FwaS9vZW1iZWQ/dXJsPXt1cmx9JmNhbGxiYWNrPXtjYWxsYmFja30nO1xuICAgIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTCA9ICc8ZGl2IGRhdGEtYWUtZW1iZWQtdXJsPVwie3VybH1cIj48L2Rpdj4nO1xuICAgIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCA9ICc8YSBocmVmPVwie3VybH1cIj57dXJsfTwvYT4nO1xuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhZGRzIHRoZSBpbmZyYXN0cnVjdHVyZSB0byBlbWJlZCB1cmxzIGFzIG1lZGlhIG9iamVjdHMgdXNpbmcgYW4gb2VtYmVkXG4gICAgICogc2VydmljZS4gQnkgZGVmYXVsdCwgYW5kIGZvciBkZW1vaW5nIHB1cnBvc2VzIG9ubHksIHRoZSBvZW1iZWQgc2VydmljZSBpcyBob3N0ZWQgaW4gaWZyYW1lLmx5XG4gICAgICogYXQgLy9hbGxveS5pZnJhbWUubHkvYXBpL29lbWJlZD91cmw9e3VybH0mY2FsbGJhY2s9e2NhbGxiYWNrfS4gTm90ZSB0aGlzIHNob3VsZCBiZSBjaGFuZ2VkIHRvXG4gICAgICogYSBzZWxmLWhvc3RlZCBvciBwYWlkIHNlcnZpY2UgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMuIEFjY2VzcyB0byB0aGUgYWxsb3kuaWZyYW1lLmx5IGVuZHBvaW50XG4gICAgICogbWF5IGJlIHJlc3RyaWN0ZWQgcGVyIGRvbWFpbiBkdWUgdG8gc2lnbmlmaWNhbnQgdHJhZmZpYy5cbiAgICAgKlxuICAgICAqIFRoaXMgcGx1Z2luIGFkZHMgYW4gYGVtYmVkVXJsYCBjb21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgdG8gZWFzaWx5IGVtYmVkIGEgVVJMIGFuZCB0cmFuc2Zvcm0gaXRcbiAgICAgKiB0byBhbiBlbWJlZGRlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfZW1iZWRcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2VtYmVkJywge1xuICAgICAgICAgICAgcmVxdWlyZXM6ICd3aWRnZXQnLFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIEFFX0VNQkVEX1VSTF9UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoZWRpdG9yLmNvbmZpZy5lbWJlZFVybFRlbXBsYXRlIHx8IENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCk7XG4gICAgICAgICAgICAgICAgdmFyIEFFX0VNQkVEX1dJREdFVF9UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFRwbCB8fCBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1dJREdFVF9UUEwpO1xuICAgICAgICAgICAgICAgIHZhciBBRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKGVkaXRvci5jb25maWcuZW1iZWRMaW5rRGVmYXVsdFRwbCB8fCBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiB0byB1cGNhc3QgRE9NIGVsZW1lbnRzIHRvIGVtYmVkIHdpZGdldHMuXG4gICAgICAgICAgICAgICAgLy8gSXQgbWF0Y2hlcyBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1dJREdFVF9UUExcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm4gPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hbWUgPT09ICdkaXYnICYmIGVsZW1lbnQuYXR0cmlidXRlc1snZGF0YS1hZS1lbWJlZC11cmwnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS51cmwgPSBlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtYWUtZW1iZWQtdXJsJ107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGVtYmVkVXJsIGNvbW1hbmQgdGhhdCBjYW4gYmUgaW52b2tlZCB0byBlYXNpbHkgZW1iZWQgbWVkaWEgVVJMc1xuICAgICAgICAgICAgICAgIGVkaXRvci5hZGRDb21tYW5kKCdlbWJlZFVybCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5zZXJ0SHRtbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBRV9FTUJFRF9XSURHRVRfVFBMLm91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGF0YS51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd2lkZ2V0IHRvIHByb3Blcmx5IGhhbmRsZSBlbWJlZCBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgZWRpdG9yLndpZGdldHMuYWRkKCdhZV9lbWJlZCcsIHtcblxuXG4gICAgICAgICAgICAgICAgICAgIG1hc2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGVudDogJ2RpdltkYXRhLWFlLWVtYmVkLXVybF0nLFxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBMaXN0ZW5lciB0byBiZSBleGVjdXRlZCBldmVyeSB0aW1lIHRoZSB3aWRnZXQncyBkYXRhIGNoYW5nZXMuIEl0IHRha2VzIGNhcmUgb2ZcbiAgICAgICAgICAgICAgICAgICAgICogcmVxdWVzdGluZyB0aGUgZW1iZWQgb2JqZWN0IHRvIHRoZSBjb25maWd1cmVkIG9lbWJlZCBzZXJ2aWNlIGFuZCByZW5kZXIgaXQgaW5cbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgRGF0YSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGV2ZW50LmRhdGEudXJsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0tFRElUT1IudG9vbHMuanNvbnAoQUVfRU1CRURfVVJMX1RQTCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGVuY29kZVVSSUNvbXBvbmVudCh1cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRUdFWF9ERUZBVUxUX0xJTksudGVzdChyZXNwb25zZS5odG1sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5lbGVtZW50LnNldEh0bWwocmVzcG9uc2UuaHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuY3JlYXRlQVRhZyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQVRhZzogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5leGVjQ29tbWFuZCgndW5kbycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYVRhZ0h0bWwgPSBBRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMLm91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5pbnNlcnRIdG1sKGFUYWdIdG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHVwY2FzdCBhbiBlbGVtZW50IHRvIGFlX2VtYmVkIHdpZGdldHMuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2QgdXBjYXN0XG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3aWRnZXRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHVwY2FzdDogZnVuY3Rpb24oZWxlbWVudCwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtYmVkV2lkZ2V0VXBjYXN0Rm4gPSBlZGl0b3IuY29uZmlnLmVtYmVkV2lkZ2V0VXBjYXN0Rm4gfHwgZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbWJlZFdpZGdldFVwY2FzdEZuKGVsZW1lbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBsaXN0ZW5lciB0byBoYW5kbGUgcGFzdGUgZXZlbnRzIGFuZCB0dXJuIGxpbmtzIGludG8gZW1iZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5vbigncGFzdGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmsgPSBldmVudC5kYXRhLmRhdGFWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFR0VYX0hUVFAudGVzdChsaW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3AoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZXZlbnQuZGF0YS5kYXRhVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBsaXN0ZW5lciB0byBoYW5kbGUgc2VsZWN0aW9uIGNoYW5nZSBldmVudHMgYW5kIHByb3Blcmx5IGRldGVjdCBlZGl0b3JcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmFjdGlvbnMgb24gdGhlIHdpZGdldHMgd2l0aG91dCBtZXNzaW5nIHdpdGggd2lkZ2V0IG5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ3NlbGVjdGlvbkNoYW5nZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZ2V0RWxlbWVudCA9IGVsZW1lbnQuZmluZE9uZSgnW2RhdGEtd2lkZ2V0PVwiYWVfZW1iZWRcIl0nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWRnZXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSBlbGVtZW50LmdldENsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5sZWZ0IC09IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi50b3AgKz0gc2Nyb2xsUG9zaXRpb24ueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHdpZGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBmaWx0ZXIgdG8gc2tpcCBmaWx0ZXJpbmcgd2lkZ2V0IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgZWRpdG9yLmZpbHRlci5hZGRFbGVtZW50Q2FsbGJhY2soZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2RhdGEtYWUtZW1iZWQtdXJsJyBpbiBlbGVtZW50LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDS0VESVRPUi5GSUxURVJfU0tJUF9UUkVFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCJpbXBvcnQgU2VsZWN0aW9uVGVzdCBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbi10ZXN0LmpzJztcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfaW1hZ2VhbGlnbm1lbnQnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW51bSBmb3Igc3VwcG9ydGVkIGltYWdlIGFsaWdubWVudHNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBJTUFHRV9BTElHTk1FTlQgPSB7XG4gICAgICAgIENFTlRFUjogJ2NlbnRlcicsXG4gICAgICAgIExFRlQ6ICdsZWZ0JyxcbiAgICAgICAgUklHSFQ6ICdyaWdodCdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW51bSB2YWx1ZXMgZm9yIHN1cHBvcnRlZCBpbWFnZSBhbGlnbm1lbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHZhciBBTElHTl9WQUxVRVMgPSBbXG4gICAgICAgIElNQUdFX0FMSUdOTUVOVC5MRUZULFxuICAgICAgICBJTUFHRV9BTElHTk1FTlQuUklHSFQsXG4gICAgICAgIElNQUdFX0FMSUdOTUVOVC5DRU5URVJcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogTmVjZXNzYXJ5IHN0eWxlcyBmb3IgdGhlIGNlbnRlciBhbGlnbm1lbnRcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICovXG4gICAgdmFyIENFTlRFUkVEX0lNQUdFX1NUWUxFID0gW3tcbiAgICAgICAgbmFtZTogJ2Rpc3BsYXknLFxuICAgICAgICB2YWx1ZTogJ2Jsb2NrJ1xuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ21hcmdpbi1sZWZ0JyxcbiAgICAgICAgdmFsdWU6ICdhdXRvJ1xuICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ21hcmdpbi1yaWdodCcsXG4gICAgICAgIHZhbHVlOiAnYXV0bydcbiAgICB9XTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2UgVGhlIGltYWdlIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhbGlnbm1lbnQgdmFsdWVcbiAgICAgKi9cbiAgICB2YXIgZ2V0SW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgICB2YXIgaW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRTdHlsZSgnZmxvYXQnKTtcblxuICAgICAgICBpZiAoIWltYWdlQWxpZ25tZW50IHx8IGltYWdlQWxpZ25tZW50ID09PSAnaW5oZXJpdCcgfHwgaW1hZ2VBbGlnbm1lbnQgPT09ICdub25lJykge1xuICAgICAgICAgICAgaW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2FsaWduJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWltYWdlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyZWRJbWFnZSA9IENFTlRFUkVEX0lNQUdFX1NUWUxFLmV2ZXJ5KGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlQ2hlY2sgPSBpbWFnZS5nZXRTdHlsZShzdHlsZS5uYW1lKSA9PT0gc3R5bGUudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlQ2hlY2sgJiYgc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDaGVjayA9IHN0eWxlLnZlbmRvclByZWZpeGVzLnNvbWUoZnVuY3Rpb24odmVuZG9yUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2UuZ2V0U3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSkgPT09IHN0eWxlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVDaGVjaztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWltYWdlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlQ29udGFpbmVyID0gaW1hZ2UuJC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9PSBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIENFTlRFUkVEX0lNQUdFX1NUWUxFLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zZXRTdHlsZShzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHZlbmRvclByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zZXRTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXJlZEltYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGltYWdlQWxpZ25tZW50ID0gY2VudGVyZWRJbWFnZSA/IElNQUdFX0FMSUdOTUVOVC5DRU5URVIgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGltYWdlQWxpZ25tZW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gaW1hZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGltYWdlQWxpZ25tZW50IFRoZSBpbWFnZSBhbGlnbm1lbnQgdmFsdWUgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHZhciByZW1vdmVJbWFnZUFsaWdubWVudCA9IGZ1bmN0aW9uKGltYWdlLCBpbWFnZUFsaWdubWVudCkge1xuICAgICAgICBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5MRUZUIHx8IGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuUklHSFQpIHtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IGdldEltYWdlQWxpZ25tZW50KGltYWdlKSkge1xuICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnYWxpZ24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULkNFTlRFUikge1xuICAgICAgICAgICAgQ0VOVEVSRURfSU1BR0VfU1RZTEUuZm9yRWFjaChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZVN0eWxlKHN0eWxlLm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24odmVuZG9yUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBpbWFnZUNvbnRhaW5lciA9IGltYWdlLiQucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYgKGltYWdlQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9PSBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZSBUaGUgaW1hZ2UgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZUFsaWdubWVudCBUaGUgaW1hZ2UgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHNldFxuICAgICAqL1xuICAgIHZhciBzZXRJbWFnZUFsaWdubWVudCA9IGZ1bmN0aW9uKGltYWdlLCBpbWFnZUFsaWdubWVudCkge1xuICAgICAgICByZW1vdmVJbWFnZUFsaWdubWVudChpbWFnZSwgZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpKTtcblxuICAgICAgICBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5MRUZUIHx8IGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuUklHSFQpIHtcbiAgICAgICAgICAgIGltYWdlLnNldFN0eWxlKCdmbG9hdCcsIGltYWdlQWxpZ25tZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULkNFTlRFUikge1xuICAgICAgICAgICAgQ0VOVEVSRURfSU1BR0VfU1RZTEUuZm9yRWFjaChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIGltYWdlLnNldFN0eWxlKHN0eWxlLm5hbWUsIHN0eWxlLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHZlbmRvclByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc2V0U3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSwgc3R5bGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGltYWdlQ29udGFpbmVyID0gaW1hZ2UuJC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICBpbWFnZUNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSO1xuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIG1vZGlmaWVzIHRoZSBqdXN0aWZ5IGNvbW1hbmRzIHRvIHByb3Blcmx5IGFsaWduIGltYWdlcy4gVGhpc1xuICAgICAqIHBsdWdpbiBpcyBhbiBleGNlcnB0IG9mIENLRWRpdG9yJ3Mgb3JpZ2luYWwgaW1hZ2Ugb25lIHRoYXQgY2FuIGJlIGZvdW5kIGF0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yLWRldi9ibG9iL21hc3Rlci9wbHVnaW5zL2ltYWdlL3BsdWdpbi5qc1xuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfaW1hZ2VhbGlnbm1lbnRcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2ltYWdlYWxpZ25tZW50Jywge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ3Bhc3RlJyBldmVudCBvbiB0aGUgZWRpdGluZyBhcmVhLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgYWZ0ZXJJbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZnRlckluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIEFMSUdOX1ZBTFVFUy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoJ2p1c3RpZnknICsgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLm9uKCdleGVjJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGF0YSAmJiBTZWxlY3Rpb25UZXN0LmltYWdlKHtkYXRhOiB7c2VsZWN0aW9uRGF0YTogc2VsZWN0aW9uRGF0YX19KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBzZWxlY3Rpb25EYXRhLmVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlQWxpZ25tZW50ID0gZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUFsaWdubWVudCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUltYWdlQWxpZ25tZW50KGltYWdlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJbWFnZUFsaWdubWVudChpbWFnZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoQ29tbWFuZHMoZWRpdG9yLCBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnRQYXRoKGltYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQub24oJ3JlZnJlc2gnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBldmVudC5kYXRhLnBhdGgubGFzdEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNlbGVjdGlvblRlc3QuaW1hZ2Uoe2RhdGE6IHtzZWxlY3Rpb25EYXRhOiBzZWxlY3Rpb25EYXRhfX0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUFsaWdubWVudCA9IGdldEltYWdlQWxpZ25tZW50KHNlbGVjdGlvbkRhdGEuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShpbWFnZUFsaWdubWVudCA9PT0gdmFsdWUgPyBDS0VESVRPUi5UUklTVEFURV9PTiA6IENLRURJVE9SLlRSSVNUQVRFX09GRik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yY2VzIGEgcmVmcmVzaCBvZiB0aGUgbW9kaWZpZWQganVzdGlmeSBjb21tYW5kcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYXBwbGllZCBjaGFuZ2VzXG4gICAgICAgICAgICAgKiBkbyBub3QgbW9kaWZ5IHRoZSBzZWxlY3Rpb24sIHNvIHRoZSByZWZyZXNoIGlzIG5ldmVyIHRyaWdnZXJlZCBhbmQgdGhlIFVJIGRvZXMgbm90IHVwZGF0ZVxuICAgICAgICAgICAgICogcHJvcGVybHkgdW50aWwgdGhlIG5leHQgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudFBhdGh9IGVsZW1lbnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZWZyZXNoQ29tbWFuZHM6IGZ1bmN0aW9uKGVkaXRvciwgZWxlbWVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICBBTElHTl9WQUxVRVMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKCdqdXN0aWZ5JyArIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5yZWZyZXNoKGVkaXRvciwgZWxlbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCJpbXBvcnQgYWRkaW1hZ2VzIGZyb20gJy4vYWRkaW1hZ2VzJztcbmltcG9ydCBhdXRvbGluayBmcm9tICcuL2F1dG9saW5rJztcbmltcG9ydCBhdXRvbGlzdCBmcm9tICcuL2F1dG9saXN0JztcbmltcG9ydCBkcmFncmVzaXplIGZyb20gJy4vZHJhZ3Jlc2l6ZSc7XG5pbXBvcnQgZHJhZ3Jlc2l6ZWllIGZyb20gJy4vZHJhZ3Jlc2l6ZV9pZSc7XG5pbXBvcnQgZW1iZWQgZnJvbSAnLi9lbWJlZCc7XG5pbXBvcnQgaW1hZ2VhbGlnbm1lbnQgZnJvbSAnLi9pbWFnZWFsaWdubWVudCc7XG5pbXBvcnQgcGFzdGVpbWFnZXMgZnJvbSAnLi9wYXN0ZWltYWdlcyc7XG5pbXBvcnQgcGxhY2Vob2xkZXIgZnJvbSAnLi9wbGFjZWhvbGRlcic7XG5pbXBvcnQgc2VsZWN0aW9ua2V5c3Ryb2tlcyBmcm9tICcuL3NlbGVjdGlvbmtleXN0cm9rZXMnO1xuaW1wb3J0IHRhYmxlcmVzaXplIGZyb20gJy4vdGFibGVyZXNpemUnO1xuaW1wb3J0IHRhYmxldG9vbHMgZnJvbSAnLi90YWJsZXRvb2xzJztcblxuZXhwb3J0IHtcbiAgICBhZGRpbWFnZXMsXG4gICAgYXV0b2xpbmssXG4gICAgYXV0b2xpc3QsXG4gICAgZHJhZ3Jlc2l6ZSxcbiAgICBkcmFncmVzaXplaWUsXG4gICAgZW1iZWQsXG4gICAgaW1hZ2VhbGlnbm1lbnQsXG4gICAgcGFzdGVpbWFnZXMsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgc2VsZWN0aW9ua2V5c3Ryb2tlcyxcbiAgICB0YWJsZXJlc2l6ZSxcbiAgICB0YWJsZXRvb2xzXG59OyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3Bhc3RlaW1hZ2VzJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhbGxvd3MgcGFzdGluZyBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgZWRpdGFibGUgYXJlYS4gVGhlIGltYWdlIHdpbGwgYmUgZW5jb2RlZFxuICAgICAqIGFzIERhdGEgVVJJLiBBbiBldmVudCBgYmVmb3JlSW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgbGlzdCBvZiBwYXN0ZWQgaW1hZ2VzLiBJZiBhbnkgb2YgdGhlIGxpc3RlbmVyc1xuICAgICAqIHJldHVybnMgYGZhbHNlYCBvciBjYW5jZWxzIHRoZSBldmVudCwgdGhlIGltYWdlcyB3b24ndCBiZSBhZGRlZCB0byB0aGUgY29udGVudC4gT3RoZXJ3aXNlLFxuICAgICAqIGFuIGV2ZW50IGBpbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBpbnNlcnRlZCBlbGVtZW50IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9wYXN0ZWltYWdlc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYmVmb3JlIGFkZGluZyBpbWFnZXMgdG8gdGhlIGVkaXRvci5cbiAgICAgKiBAZXZlbnQgYmVmb3JlSW1hZ2VBZGRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZUZpbGVzIEFycmF5IG9mIGltYWdlIGZpbGVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIGFkZGVkIHRvIHRoZSBlZGl0b3Igc3VjY2Vzc2Z1bGx5LlxuICAgICAqXG4gICAgICogQGV2ZW50IGltYWdlQWRkXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1hZ2Ugd2l0aCBzcmMgYXMgRGF0YSBVUklcbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgVGhlIGltYWdlIGZpbGVcbiAgICAgKi9cblxuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfcGFzdGVpbWFnZXMnLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgYSAncGFzdGUnIGV2ZW50IG9uIHRoZSBlZGl0aW5nIGFyZWEuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ3Bhc3RlJywgdGhpcy5fb25QYXN0ZSwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gaW1nIGVsZW1lbnQgd2l0aCBzcmMgdGhlIGltYWdlIGRhdGEgYXMgRGF0YSBVUkkuXG4gICAgICAgICAgICAgKiBUaGVuLCBpdCBmaXJlcyBhbiAnaW1hZ2VBZGQnIGV2ZW50IHZpYSBDS0VkaXRvcidzIGV2ZW50IHN5c3RlbS4gVGhlIHBhc3NlZFxuICAgICAgICAgICAgICogcGFyYW1zIHdpbGwgYmU6XG4gICAgICAgICAgICAgKiAtIGBlbGAgLSB0aGUgY3JlYXRlZCBpbWcgZWxlbWVudFxuICAgICAgICAgICAgICogLSBgZmlsZWAgLSB0aGUgb3JpZ2luYWwgcGFzdGVkIGRhdGFcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9vblBhc3RlXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZXZlbnQgQSBgcGFzdGVgIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vblBhc3RlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFzdGVkRGF0YSA9IGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzdGVkRGF0YS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRmlsZSA9IHBhc3RlZERhdGEuZ2V0QXNGaWxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRmlsZXM6IGltYWdlRmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKCc8aW1nIHNyYz1cIicgKyBldmVudC50YXJnZXQucmVzdWx0ICsgJ1wiPicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogaW1hZ2VGaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2ltYWdlQWRkJywgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VESVRPUiBlbnRlck1vZGUgY29uZmlnIHNldCB0aGUgYmVoYXZpb3Igb2YgcGFyYWdyYXBoc1xuICAgICAqIFdoZW4gdGhlIGNvbnRlbnQgaXMgZW1wdHkgQ0tFRElUT1Iga2VlcHMgdGhlIGVudGVyTW9kZSBzdHJpbmdcbiAgICAgKiBpbnRvIHRoZSBjb250ZW50XG4gICAgICogQHByb3BlcnR5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB2YXIgYnJGaWxsZXIgPSBDS0VESVRPUi5lbnYubmVlZHNCckZpbGxlciA/ICc8YnI+JyA6ICcnO1xuXG4gICAgdmFyIGVudGVyTW9kZUVtcHR5VmFsdWUgPSB7XG4gICAgICAgIDE6IFsnPHA+JyArIGJyRmlsbGVyICsgJzwvcD4nXSxcbiAgICAgICAgMjogWycnLCAnICcsIGJyRmlsbGVyXSxcbiAgICAgICAgMzogWyc8ZGl2PicgKyBickZpbGxlciArICc8L2Rpdj4nXVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWxsb3dzIGFkZGluZyBhIHBsYWNlaG9sZGVyIHRvIHRoZSBlZGl0b3IuIEluIHRoaXMgY2FzZSwgaWYgdGhlcmVcbiAgICAgKiBpcyBubyBjb250ZW50IHRvIHRoZSBlZGl0b3IsIHRoZXJlIHdpbGwgYmUgaGludCB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3BsYWNlaG9sZGVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHBsYWNlaG9sZGVyIGNsYXNzIHdoaWNoIGhhdmUgdG8gYmUgYWRlZCB0byBlZGl0b3Igd2hlbiBlZGl0b3IgaXMgbm90IGZvY3VzZWQuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyQ2xhc3NcbiAgICAgKiBAZGVmYXVsdCBhZV9wbGFjZWhvbGRlclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV9wbGFjZWhvbGRlcicsIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ2JsdXInIGFuZCAnY29udGVudERvbScgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdibHVyJywgdGhpcy5fY2hlY2tFbXB0eURhdGEsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbignY2hhbmdlJywgdGhpcy5fY2hlY2tFbXB0eURhdGEsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbignZm9jdXMnLCB0aGlzLl9yZW1vdmVQbGFjZWhvbGRlckNsYXNzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIHRoaXMuX2NoZWNrRW1wdHlEYXRhLCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbnkgZGF0YSBmcm9tIHRoZSBjb250ZW50IGFuZCBhZGRzIGEgY2xhc3MsXG4gICAgICAgICAgICAgKiBzcGVjaWZpZWQgYnkgdGhlIFwicGxhY2Vob2xkZXJDbGFzc1wiIGNvbmZpZyBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQG1ldGhvZCBfY2hlY2tFbXB0eURhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBlZGl0b3IgZXZlbnQsIGZpcmVkIGZyb20gQ0tFZGl0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2NoZWNrRW1wdHlEYXRhOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGVOb2RlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJIdG1sID0gZWRpdGFibGVOb2RlLiQuaW5uZXJIVE1MLnRyaW0oKTtcblxuICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gZW50ZXJNb2RlRW1wdHlWYWx1ZVtlZGl0b3IuY29uZmlnLmVudGVyTW9kZV0uc29tZShmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckh0bWwgPT09IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZU5vZGUuYWRkQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZU5vZGUucmVtb3ZlQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBwbGFjZWhvbGRlciBjbGFzcyB3aGVuIGlucHV0IGlzIGZvY3VzZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9yZW1vdmVQbGFjZWhvbGRlckNsYXNzXG4gICAgICAgICAgICAgKyBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZWRpdG9yIGV2ZW50LCBmaXJlZCBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9yZW1vdmVQbGFjZWhvbGRlckNsYXNzOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yTm9kZSA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChlZGl0b3IuZWxlbWVudC4kKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvck5vZGUucmVtb3ZlQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3NlbGVjdGlvbmtleXN0cm9rZXMnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHRoYXQgc2ltdWxhdGVzIGVkaXRvciBpbnRlcmFjdGlvbiBldmVudHMgYmFzZWQgb24gbWFudWFsIGtleXN0cm9rZXMuIFRoaXNcbiAgICAgKiBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGRpZmZlcmVudCByZWFjdGlvbnMgaW4gdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbmtleXN0cm9rZXNcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX3NlbGVjdGlvbmtleXN0cm9rZXMnLCB7XG4gICAgICAgICAgICByZXF1aXJlczogJ2FlX3NlbGVjdGlvbnJlZ2lvbicsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGFkZHMgYSBjb21tYW5kIHRvIHRoZSBlZGl0b3IgZm9yIGV2ZXJ5IGRlZmluZWQgc2VsZWN0aW9uS2V5c3Ryb2tlXG4gICAgICAgICAgICAgKiBpbiB0aGUgY29uZmlndXJhdGlvbiBhbmQgbWFwcyBpdCB0byB0aGUgc3BlY2lmaWVkIGtleXN0cm9rZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuY29uZmlnLnNlbGVjdGlvbktleXN0cm9rZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbmZpZy5zZWxlY3Rpb25LZXlzdHJva2VzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IG5ldyBDS0VESVRPUi5jb21tYW5kKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZmlyZSgnZWRpdG9ySW50ZXJhY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW51YWxTZWxlY3Rpb246IHNlbGVjdGlvbktleXN0cm9rZS5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25EYXRhOiBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZE5hbWUgPSAnc2VsZWN0aW9uS2V5c3Ryb2tlJyArIHNlbGVjdGlvbktleXN0cm9rZS5zZWxlY3Rpb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5hZGRDb21tYW5kKGNvbW1hbmROYW1lLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRLZXlzdHJva2Uoc2VsZWN0aW9uS2V5c3Ryb2tlLmtleXMsIGNvbW1hbmROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAxNSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHA6Ly9ja2VkaXRvci5jb20vbGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3RhYmxlcmVzaXplJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBweFVuaXQgPSBDS0VESVRPUi50b29scy5jc3NMZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBnZXRXaWR0aChlbCkge1xuICAgICAgICByZXR1cm4gQ0tFRElUT1IuZW52LmllID8gZWwuJC5jbGllbnRXaWR0aCA6IHBhcnNlSW50KGVsLmdldENvbXB1dGVkU3R5bGUoJ3dpZHRoJyksIDEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3JkZXJXaWR0aChlbGVtZW50LCBzaWRlKSB7XG4gICAgICAgIHZhciBjb21wdXRlZCA9IGVsZW1lbnQuZ2V0Q29tcHV0ZWRTdHlsZSgnYm9yZGVyLScgKyBzaWRlICsgJy13aWR0aCcpLFxuICAgICAgICAgICAgYm9yZGVyTWFwID0ge1xuICAgICAgICAgICAgICAgIHRoaW46ICcwcHgnLFxuICAgICAgICAgICAgICAgIG1lZGl1bTogJzFweCcsXG4gICAgICAgICAgICAgICAgdGhpY2s6ICcycHgnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb21wdXRlZC5pbmRleE9mKCdweCcpIDwgMCkge1xuICAgICAgICAgICAgLy8gbG9vayB1cCBrZXl3b3Jkc1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVkIGluIGJvcmRlck1hcCAmJiBlbGVtZW50LmdldENvbXB1dGVkU3R5bGUoJ2JvcmRlci1zdHlsZScpICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gYm9yZGVyTWFwW2NvbXB1dGVkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gR2V0cyB0aGUgdGFibGUgcm93IHRoYXQgY29udGFpbnMgdGhlIG1vc3QgY29sdW1ucy5cbiAgICBmdW5jdGlvbiBnZXRNYXN0ZXJQaWxsYXJSb3codGFibGUpIHtcbiAgICAgICAgdmFyICRyb3dzID0gdGFibGUuJC5yb3dzLFxuICAgICAgICAgICAgbWF4Q2VsbHMgPSAwLFxuICAgICAgICAgICAgY2VsbHNDb3VudCwgJGVsZWN0ZWQsICR0cjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHJvd3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICR0ciA9ICRyb3dzW2ldO1xuICAgICAgICAgICAgY2VsbHNDb3VudCA9ICR0ci5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChjZWxsc0NvdW50ID4gbWF4Q2VsbHMpIHtcbiAgICAgICAgICAgICAgICBtYXhDZWxscyA9IGNlbGxzQ291bnQ7XG4gICAgICAgICAgICAgICAgJGVsZWN0ZWQgPSAkdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGVsZWN0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRUYWJsZUNvbHVtblBpbGxhcnModGFibGUpIHtcbiAgICAgICAgdmFyIHBpbGxhcnMgPSBbXSxcbiAgICAgICAgICAgIHBpbGxhckluZGV4ID0gLTEsXG4gICAgICAgICAgICBydGwgPSAodGFibGUuZ2V0Q29tcHV0ZWRTdHlsZSgnZGlyZWN0aW9uJykgPT09ICdydGwnKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHJhdyByb3cgZWxlbWVudCB0aGF0IGNvaW50YWlucyB0aGUgbW9zdCBjb2x1bW5zLlxuICAgICAgICB2YXIgJHRyID0gZ2V0TWFzdGVyUGlsbGFyUm93KHRhYmxlKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHRib2R5IGVsZW1lbnQgYW5kIHBvc2l0aW9uLCB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRoZVxuICAgICAgICAvLyB0b3AgYW5kIGJvdHRvbSBib3VuZGFyaWVzLlxuICAgICAgICB2YXIgdGJvZHkgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC50Qm9kaWVzWzBdKSxcbiAgICAgICAgICAgIHRib2R5UG9zaXRpb24gPSB0Ym9keS5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG5cbiAgICAgICAgLy8gTG9vcCB0aG9ydWdoIGFsbCBjZWxscywgYnVpbGRpbmcgcGlsbGFycyBhZnRlciBlYWNoIG9uZSBvZiB0aGVtLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHRyLmNlbGxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHRoZSBjdXJyZW50IGNlbGwgYW5kIHRoZSBzdWNjZXNzaXZlIG9uZSB3aWxsIGJlIHVzZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBwaWxsYXIgc2l6ZSBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgIHZhciB0ZCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCgkdHIuY2VsbHNbaV0pLFxuICAgICAgICAgICAgICAgIG5leHRUZCA9ICR0ci5jZWxsc1tpICsgMV0gJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCR0ci5jZWxsc1tpICsgMV0pO1xuXG4gICAgICAgICAgICBwaWxsYXJJbmRleCArPSB0ZC4kLmNvbFNwYW4gfHwgMTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwaWxsYXIgYm91bmRhcnkgcG9zaXRpb25zLlxuICAgICAgICAgICAgdmFyIHBpbGxhckxlZnQsIHBpbGxhclJpZ2h0LCBwaWxsYXJXaWR0aDtcblxuICAgICAgICAgICAgdmFyIHggPSB0ZC5nZXREb2N1bWVudFBvc2l0aW9uKCkueDtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgY3VycmVudCBjZWxsLlxuICAgICAgICAgICAgcnRsID8gcGlsbGFyUmlnaHQgPSB4ICsgZ2V0Qm9yZGVyV2lkdGgodGQsICdsZWZ0JykgOiBwaWxsYXJMZWZ0ID0geCArIHRkLiQub2Zmc2V0V2lkdGggLSBnZXRCb3JkZXJXaWR0aCh0ZCwgJ3JpZ2h0Jyk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gdGhlIG5leHQgY2VsbCwgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgaWYgKG5leHRUZCkge1xuICAgICAgICAgICAgICAgIHggPSBuZXh0VGQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cbiAgICAgICAgICAgICAgICBydGwgPyBwaWxsYXJMZWZ0ID0geCArIG5leHRUZC4kLm9mZnNldFdpZHRoIC0gZ2V0Qm9yZGVyV2lkdGgobmV4dFRkLCAncmlnaHQnKSA6IHBpbGxhclJpZ2h0ID0geCArIGdldEJvcmRlcldpZHRoKG5leHRUZCwgJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcG9zaXRpb25zIGJhc2VkIG9uIHRoZSB0YWJsZSAoZm9yIGxhc3QgY2VsbCkuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gdGFibGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cbiAgICAgICAgICAgICAgICBydGwgPyBwaWxsYXJMZWZ0ID0geCA6IHBpbGxhclJpZ2h0ID0geCArIHRhYmxlLiQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBpbGxhcldpZHRoID0gTWF0aC5tYXgocGlsbGFyUmlnaHQgLSBwaWxsYXJMZWZ0LCA0KTtcblxuICAgICAgICAgICAgLy8gVGhlIHBpbGxhciBzaG91bGQgcmVmbGVjdHMgZXhhY3RseSB0aGUgc2hhcGUgb2YgdGhlIGhvdmVyZWRcbiAgICAgICAgICAgIC8vIGNvbHVtbiBib3JkZXIgbGluZS5cbiAgICAgICAgICAgIHBpbGxhcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwaWxsYXJJbmRleCxcbiAgICAgICAgICAgICAgICB4OiBwaWxsYXJMZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRib2R5UG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcGlsbGFyV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0Ym9keS4kLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICBydGw6IHJ0bFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGlsbGFycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQaWxsYXJBdFBvc2l0aW9uKHBpbGxhcnMsIHBvc2l0aW9uWCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGlsbGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBpbGxhciA9IHBpbGxhcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvblggPj0gcGlsbGFyLnggJiYgcG9zaXRpb25YIDw9IChwaWxsYXIueCArIHBpbGxhci53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlsbGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuY2VsKGV2dCkge1xuICAgICAgICAoZXZ0LmRhdGEgfHwgZXZ0KS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtblJlc2l6ZXIoZWRpdG9yLCBwaWxsYXIpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50LCByZXNpemVyLCByZXNpemluZywgc3RhcnRPZmZzZXQsIGN1cnJlbnRTaGlmdDtcblxuICAgICAgICB2YXIgbGVmdFNpZGVDZWxscywgcmlnaHRTaWRlQ2VsbHMsIGxlZnRTaGlmdEJvdW5kYXJ5LCByaWdodFNoaWZ0Qm91bmRhcnk7XG5cbiAgICAgICAgZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgICAgICAgcmVzaXplci5yZW1vdmVMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgICAgICByZXNpemVyLnJlbW92ZUxpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICByZXNpemVyLnJlbW92ZUxpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNpemVTdGFydCgpIHtcbiAgICAgICAgICAgIC8vIEJlZm9yZSBzdGFydGluZyB0byByZXNpemUsIGZpZ3VyZSBvdXQgd2hpY2ggY2VsbHMgdG8gY2hhbmdlXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGJvdW5kYXJpZXMgb2YgdGhpcyByZXNpemluZyBzaGlmdC5cblxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gcGlsbGFyLmluZGV4LFxuICAgICAgICAgICAgICAgIG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAocGlsbGFyLnRhYmxlKSxcbiAgICAgICAgICAgICAgICBsZWZ0Q29sdW1uQ2VsbHMgPSBbXSxcbiAgICAgICAgICAgICAgICByaWdodENvbHVtbkNlbGxzID0gW10sXG4gICAgICAgICAgICAgICAgbGVmdE1pblNpemUgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgIHJpZ2h0TWluU2l6ZSA9IGxlZnRNaW5TaXplLFxuICAgICAgICAgICAgICAgIHJ0bCA9IHBpbGxhci5ydGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gbWFwW2ldLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2VsbCA9IHJvd1tjb2x1bW5JbmRleCArIChydGwgPyAxIDogMCldLFxuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwgPSByb3dbY29sdW1uSW5kZXggKyAocnRsID8gMCA6IDEpXTtcblxuICAgICAgICAgICAgICAgIGxlZnRDZWxsID0gbGVmdENlbGwgJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGxlZnRDZWxsKTtcbiAgICAgICAgICAgICAgICByaWdodENlbGwgPSByaWdodENlbGwgJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHJpZ2h0Q2VsbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxlZnRDZWxsIHx8ICFyaWdodENlbGwgfHwgIWxlZnRDZWxsLmVxdWFscyhyaWdodENlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDZWxsICYmIChsZWZ0TWluU2l6ZSA9IE1hdGgubWluKGxlZnRNaW5TaXplLCBnZXRXaWR0aChsZWZ0Q2VsbCkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDZWxsICYmIChyaWdodE1pblNpemUgPSBNYXRoLm1pbihyaWdodE1pblNpemUsIGdldFdpZHRoKHJpZ2h0Q2VsbCkpKTtcblxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29sdW1uQ2VsbHMucHVzaChsZWZ0Q2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q29sdW1uQ2VsbHMucHVzaChyaWdodENlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGxpc3Qgb2YgY2VsbHMgdG8gYmUgcmVzaXplZC5cbiAgICAgICAgICAgIGxlZnRTaWRlQ2VsbHMgPSBsZWZ0Q29sdW1uQ2VsbHM7XG4gICAgICAgICAgICByaWdodFNpZGVDZWxscyA9IHJpZ2h0Q29sdW1uQ2VsbHM7XG5cbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSByZXNpemUgbGltaXQgYm91bmRhcmllcy5cbiAgICAgICAgICAgIGxlZnRTaGlmdEJvdW5kYXJ5ID0gcGlsbGFyLnggLSBsZWZ0TWluU2l6ZTtcbiAgICAgICAgICAgIHJpZ2h0U2hpZnRCb3VuZGFyeSA9IHBpbGxhci54ICsgcmlnaHRNaW5TaXplO1xuXG4gICAgICAgICAgICByZXNpemVyLnNldE9wYWNpdHkoMC41KTtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gcGFyc2VJbnQocmVzaXplci5nZXRTdHlsZSgnbGVmdCcpLCAxMCk7XG4gICAgICAgICAgICBjdXJyZW50U2hpZnQgPSAwO1xuICAgICAgICAgICAgcmVzaXppbmcgPSAxO1xuXG4gICAgICAgICAgICByZXNpemVyLm9uKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgdGhlIG5hdGl2ZSBkcmFnIGJlaGF2aW9yIG90aGVyd2lzZSAnbW91c2Vtb3ZlJyB3b24ndCBmaXJlLlxuICAgICAgICAgICAgZG9jdW1lbnQub24oJ2RyYWdzdGFydCcsIGNhbmNlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNpemVFbmQoKSB7XG4gICAgICAgICAgICByZXNpemluZyA9IDA7XG5cbiAgICAgICAgICAgIHJlc2l6ZXIuc2V0T3BhY2l0eSgwKTtcblxuICAgICAgICAgICAgY3VycmVudFNoaWZ0ICYmIHJlc2l6ZUNvbHVtbigpO1xuXG4gICAgICAgICAgICB2YXIgdGFibGUgPSBwaWxsYXIudGFibGU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRhYmxlLnJlbW92ZUN1c3RvbURhdGEoJ19ja2VfdGFibGVfcGlsbGFycycpO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUxpc3RlbmVyKCdkcmFnc3RhcnQnLCBjYW5jZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzaXplQ29sdW1uKCkge1xuICAgICAgICAgICAgdmFyIHJ0bCA9IHBpbGxhci5ydGwsXG4gICAgICAgICAgICAgICAgY2VsbHNDb3VudCA9IHJ0bCA/IHJpZ2h0U2lkZUNlbGxzLmxlbmd0aCA6IGxlZnRTaWRlQ2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgcmVzaXplIHRvIHRhYmxlIGNlbGxzLCBvbmx5IGZvciB0aG9zZSBieSBzaWRlIG9mIHRoZSBwaWxsYXIuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGxzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q2VsbCA9IGxlZnRTaWRlQ2VsbHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2VsbCA9IHJpZ2h0U2lkZUNlbGxzW2ldLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHBpbGxhci50YWJsZTtcblxuICAgICAgICAgICAgICAgIC8vIERlZmVyIHRoZSByZXNpemluZyB0byBhdm9pZCBhbnkgaW50ZXJmZXJlbmNlIGFtb25nIGNlbGxzLlxuICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLnNldFRpbWVvdXQoZnVuY3Rpb24obGVmdENlbGwsIGxlZnRPbGRXaWR0aCwgcmlnaHRDZWxsLCByaWdodE9sZFdpZHRoLCB0YWJsZVdpZHRoLCBzaXplU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMXB4IGlzIHRoZSBtaW5pbXVtIHZhbGlkIHdpZHRoICgjMTE2MjYpLlxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2VsbCAmJiBsZWZ0Q2VsbC5zZXRTdHlsZSgnd2lkdGgnLCBweFVuaXQoTWF0aC5tYXgobGVmdE9sZFdpZHRoICsgc2l6ZVNoaWZ0LCAxKSkpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwgJiYgcmlnaHRDZWxsLnNldFN0eWxlKCd3aWR0aCcsIHB4VW5pdChNYXRoLm1heChyaWdodE9sZFdpZHRoIC0gc2l6ZVNoaWZ0LCAxKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBsYXN0IGNlbGwsIHdlIG5lZWQgdG8gcmVzaXplIHRoZSB0YWJsZSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5zZXRTdHlsZSgnd2lkdGgnLCBweFVuaXQodGFibGVXaWR0aCArIHNpemVTaGlmdCAqIChydGwgPyAtMSA6IDEpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwLCB0aGlzLCBbXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDZWxsLCBsZWZ0Q2VsbCAmJiBnZXRXaWR0aChsZWZ0Q2VsbCksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2VsbCwgcmlnaHRDZWxsICYmIGdldFdpZHRoKHJpZ2h0Q2VsbCksICghbGVmdENlbGwgfHwgIXJpZ2h0Q2VsbCkgJiYgKGdldFdpZHRoKHRhYmxlKSArIGdldEJvcmRlcldpZHRoKHRhYmxlLCAnbGVmdCcpICsgZ2V0Qm9yZGVyV2lkdGgodGFibGUsICdyaWdodCcpKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNoaWZ0XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihldnQpIHtcbiAgICAgICAgICAgIGNhbmNlbChldnQpO1xuXG4gICAgICAgICAgICByZXNpemVTdGFydCgpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5vbignbW91c2V1cCcsIG9uTW91c2VVcCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVXAoZXZ0KSB7XG4gICAgICAgICAgICBldnQucmVtb3ZlTGlzdGVuZXIoKTtcblxuICAgICAgICAgICAgcmVzaXplRW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldnQpIHtcbiAgICAgICAgICAgIG1vdmUoZXZ0LmRhdGEuZ2V0UGFnZU9mZnNldCgpLngpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cbiAgICAgICAgcmVzaXplciA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKCc8ZGl2IGRhdGEtY2tlLXRlbXA9MSBjb250ZW50ZWRpdGFibGU9ZmFsc2UgdW5zZWxlY3RhYmxlPW9uICcgK1xuICAgICAgICAgICAgJ3N0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7Y3Vyc29yOmNvbC1yZXNpemU7ZmlsdGVyOmFscGhhKG9wYWNpdHk9MCk7b3BhY2l0eTowOycgK1xuICAgICAgICAgICAgJ3BhZGRpbmc6MDtiYWNrZ3JvdW5kLWNvbG9yOiMwMDQ7YmFja2dyb3VuZC1pbWFnZTpub25lO2JvcmRlcjowcHggbm9uZTt6LWluZGV4OjEwXCI+PC9kaXY+JywgZG9jdW1lbnQpO1xuXG4gICAgICAgIC8vIENsZWFuIERPTSB3aGVuIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICAgIGVkaXRvci5vbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGV0YWNoKCk7XG5cblx0XHRcdHJlc2l6ZXIucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFBsYWNlIHRoZSByZXNpemVyIGFmdGVyIGJvZHkgdG8gcHJldmVudCBpdFxuICAgICAgICAvLyBmcm9tIGJlaW5nIGVkaXRhYmxlLlxuICAgICAgICBkb2N1bWVudC5nZXREb2N1bWVudEVsZW1lbnQoKS5hcHBlbmQocmVzaXplcik7XG5cbiAgICAgICAgcmVzaXplci5zZXRTdHlsZXMoe1xuICAgICAgICAgICAgd2lkdGg6IHB4VW5pdChwaWxsYXIud2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBweFVuaXQocGlsbGFyLmhlaWdodCksXG4gICAgICAgICAgICBsZWZ0OiBweFVuaXQocGlsbGFyLngpLFxuICAgICAgICAgICAgdG9wOiBweFVuaXQocGlsbGFyLnkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc2l6ZXIub24oJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCB0aGlzKTtcblxuICAgICAgICBkb2N1bWVudC5nZXRCb2R5KCkuc2V0U3R5bGUoJ2N1cnNvcicsICdjb2wtcmVzaXplJyk7XG5cbiAgICAgICAgLy8gRGlzcGxheSB0aGUgcmVzaXplciB0byByZWNlaXZlIGV2ZW50cyBidXQgZG9uJ3Qgc2hvdyBpdCxcbiAgICAgICAgLy8gb25seSBjaGFuZ2UgdGhlIGN1cnNvciB0byByZXNpemFibGUgc2hhcGUuXG4gICAgICAgIHJlc2l6ZXIuc2hvdygpO1xuXG4gICAgICAgIHZhciBtb3ZlID0gdGhpcy5tb3ZlID0gZnVuY3Rpb24ocG9zWCkge1xuICAgICAgICAgICAgdmFyIHJlc2l6ZXJOZXdQb3NpdGlvbiA9IHBvc1ggLSBNYXRoLnJvdW5kKHJlc2l6ZXIuJC5vZmZzZXRXaWR0aCAvIDIpO1xuXG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVyTmV3UG9zaXRpb24gPT09IGxlZnRTaGlmdEJvdW5kYXJ5IHx8IHJlc2l6ZXJOZXdQb3NpdGlvbiA9PT0gcmlnaHRTaGlmdEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNpemVyTmV3UG9zaXRpb24gPSBNYXRoLm1heChyZXNpemVyTmV3UG9zaXRpb24sIGxlZnRTaGlmdEJvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICByZXNpemVyTmV3UG9zaXRpb24gPSBNYXRoLm1pbihyZXNpemVyTmV3UG9zaXRpb24sIHJpZ2h0U2hpZnRCb3VuZGFyeSk7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50U2hpZnQgPSByZXNpemVyTmV3UG9zaXRpb24gLSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzaXplci5zZXRTdHlsZSgnbGVmdCcsIHB4VW5pdChyZXNpemVyTmV3UG9zaXRpb24pKTtcbiAgICAgICAgfTtcblxuXHRcdHZhciBkZXN0cm95ID0gdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRkZXRhY2goKTtcblxuXHRcdFx0ZG9jdW1lbnQuZ2V0Qm9keSgpLnNldFN0eWxlKCdjdXJzb3InLCAnYXV0bycpO1xuXG5cdFx0XHRyZXNpemVyLnJlbW92ZSgpO1xuXHRcdH07XG5cblx0XHR2YXIgaXNSZXNpemluZyA9IHRoaXMuaXNSZXNpemluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHJlc2l6aW5nO1xuXHRcdH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJQaWxsYXJzQ2FjaGUoZXZ0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldnQuZGF0YS5nZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAoZXZ0Lm5hbWUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgICAgICAgIC8vIEJ5cGFzcyBpbnRlcmFsIG1vdXNlIG1vdmUuXG4gICAgICAgICAgICBpZiAoIXRhcmdldC5pcygndGFibGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlc3QgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZXZ0LmRhdGEuJC5yZWxhdGVkVGFyZ2V0IHx8IGV2dC5kYXRhLiQudG9FbGVtZW50KTtcbiAgICAgICAgICAgIHdoaWxlIChkZXN0ICYmIGRlc3QuJCAmJiAhZGVzdC5lcXVhbHModGFyZ2V0KSAmJiAhZGVzdC5pcygnYm9keScpKSB7XG4gICAgICAgICAgICAgICAgZGVzdCA9IGRlc3QuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc3QgfHwgZGVzdC5lcXVhbHModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5nZXRBc2NlbmRhbnQoJ3RhYmxlJywgMSkucmVtb3ZlQ3VzdG9tRGF0YSgnX2NrZV90YWJsZV9waWxsYXJzJyk7XG4gICAgICAgIGV2dC5yZW1vdmVMaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV90YWJsZXJlc2l6ZScsIHtcbiAgICAgICAgcmVxdWlyZXM6ICdhZV90YWJsZXRvb2xzJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbignY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNpemVyLFxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW4gQ2xhc3NpYyBlZGl0b3IgaXQgaXMgYmV0dGVyIHRvIHVzZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgZWRpdGFibGUgc28gZXZlbnQgd2lsbCB3b3JrIGJlbG93IGJvZHkuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUuaXNJbmxpbmUoKSA/IGVkaXRhYmxlIDogZWRpdG9yLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dCA9IGV2dC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldnQuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRkYgbWF5IHJldHVybiBkb2N1bWVudCBhbmQgSUU4IHNvbWUgVUZPIChvYmplY3Qgd2l0aCBubyBub2RlVHlwZSBwcm9wZXJ0eS4uLilcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBhbiBlbGVtZW50ICgjMTE4MjMpLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnR5cGUgIT09IENLRURJVE9SLk5PREVfRUxFTUVOVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VYID0gZXZ0LmdldFBhZ2VPZmZzZXQoKS54O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgYXR0YWNoZWQgdG8gYSBwaWxsYXIsIHNpbXBseSBtb3ZlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXNpemVyLlxuXHRcdFx0XHRcdGlmIChyZXNpemVyKXtcblx0XHRcdFx0XHRcdGlmIChyZXNpemVyLmlzUmVzaXppbmcoKSkge1xuXHRcdFx0XHRcdFx0XHRyZXNpemVyLm1vdmUocGFnZVgpO1xuXG5cdFx0XHRcdFx0XHRcdGNhbmNlbChldnQpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXNpemVyLmRlc3Ryb3koKTtcblxuXHRcdFx0XHRcdFx0XHRyZXNpemVyID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHQgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgdGFibGUsIHRyLCB0ZCwgdGJvZHkgYnV0IG5vdGhpbmcgZWxzZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlLCBwaWxsYXJzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmlzKCd0YWJsZScpICYmICF0YXJnZXQuZ2V0QXNjZW5kYW50KCd0Ym9keScsIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHRhcmdldC5nZXRBc2NlbmRhbnQoJ3RhYmxlJywgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0YWJsZSB3ZSBmb3VuZCBpcyBpbnNpZGUgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAvLyAoZWcuIHdlIHNob3VsZCBub3QgdXNlIHRhYmxlcyB0aGUgZWRpdG9yIGlzIGVtYmVkZGVkIHdpdGhpbilcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGl0b3IuZWRpdGFibGUoKS5jb250YWlucyh0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBpbGxhcnMgPSB0YWJsZS5nZXRDdXN0b21EYXRhKCdfY2tlX3RhYmxlX3BpbGxhcnMnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRhYmxlIHBpbGxhcnMgY2FsY3VsYXRpb24gcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuc2V0Q3VzdG9tRGF0YSgnX2NrZV90YWJsZV9waWxsYXJzJywgKHBpbGxhcnMgPSBidWlsZFRhYmxlQ29sdW1uUGlsbGFycyh0YWJsZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLm9uKCdtb3VzZW91dCcsIGNsZWFyUGlsbGFyc0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLm9uKCdtb3VzZWRvd24nLCBjbGVhclBpbGxhcnNDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGlsbGFyID0gZ2V0UGlsbGFyQXRQb3NpdGlvbihwaWxsYXJzLCBwYWdlWCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpbGxhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplciA9IG5ldyBjb2x1bW5SZXNpemVyKGVkaXRvciwgcGlsbGFyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSgpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMTUsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwOi8vY2tlZGl0b3IuY29tL2xpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCkge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3RhYmxldG9vbHMnKSl7XG5cdFx0cmV0dXJuO1xuICAgIH1cblxuXHR2YXIgY2VsbE5vZGVSZWdleCA9IC9eKD86dGR8dGgpJC87XG5cblx0ZnVuY3Rpb24gZ2V0U2VsZWN0ZWRDZWxscyggc2VsZWN0aW9uICkge1xuXHRcdHZhciByYW5nZXMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKCk7XG5cdFx0dmFyIHJldHZhbCA9IFtdO1xuXHRcdHZhciBkYXRhYmFzZSA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gbW92ZU91dE9mQ2VsbEd1YXJkKCBub2RlICkge1xuXHRcdFx0Ly8gQXBwbHkgdG8gdGhlIGZpcnN0IGNlbGwgb25seS5cblx0XHRcdGlmICggcmV0dmFsLmxlbmd0aCA+IDAgKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIElmIHdlIGFyZSBleGl0aW5nIGZyb20gdGhlIGZpcnN0IDwvdGQ+LCB0aGVuIHRoZSB0ZCBzaG91bGQgZGVmaW5pdGVseSBiZVxuXHRcdFx0Ly8gaW5jbHVkZWQuXG5cdFx0XHRpZiAoIG5vZGUudHlwZSA9PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiYgY2VsbE5vZGVSZWdleC50ZXN0KCBub2RlLmdldE5hbWUoKSApICYmICFub2RlLmdldEN1c3RvbURhdGEoICdzZWxlY3RlZF9jZWxsJyApICkge1xuXHRcdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoIGRhdGFiYXNlLCBub2RlLCAnc2VsZWN0ZWRfY2VsbCcsIHRydWUgKTtcblx0XHRcdFx0cmV0dmFsLnB1c2goIG5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR2YXIgcmFuZ2UgPSByYW5nZXNbIGkgXTtcblxuXHRcdFx0aWYgKCByYW5nZS5jb2xsYXBzZWQgKSB7XG5cdFx0XHRcdC8vIFdhbGtlciBkb2VzIG5vdCBoYW5kbGUgY29sbGFwc2VkIHJhbmdlcyB5ZXQgLSBmYWxsIGJhY2sgdG8gb2xkIEFQSS5cblx0XHRcdFx0dmFyIHN0YXJ0Tm9kZSA9IHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCk7XG5cdFx0XHRcdHZhciBuZWFyZXN0Q2VsbCA9IHN0YXJ0Tm9kZS5nZXRBc2NlbmRhbnQoICd0ZCcsIHRydWUgKSB8fCBzdGFydE5vZGUuZ2V0QXNjZW5kYW50KCAndGgnLCB0cnVlICk7XG5cdFx0XHRcdGlmICggbmVhcmVzdENlbGwgKVxuXHRcdFx0XHRcdHJldHZhbC5wdXNoKCBuZWFyZXN0Q2VsbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHdhbGtlciA9IG5ldyBDS0VESVRPUi5kb20ud2Fsa2VyKCByYW5nZSApO1xuXHRcdFx0XHR2YXIgbm9kZTtcblx0XHRcdFx0d2Fsa2VyLmd1YXJkID0gbW92ZU91dE9mQ2VsbEd1YXJkO1xuXG5cdFx0XHRcdHdoaWxlICggKCBub2RlID0gd2Fsa2VyLm5leHQoKSApICkge1xuXHRcdFx0XHRcdC8vIElmIG1heSBiZSBwb3NzaWJsZSBmb3IgdXMgdG8gaGF2ZSBhIHJhbmdlIGxpa2UgdGhpczpcblx0XHRcdFx0XHQvLyA8dGQ+XjE8L3RkPjx0ZD5eMjwvdGQ+XG5cdFx0XHRcdFx0Ly8gVGhlIDJuZCB0ZCBzaG91bGRuJ3QgYmUgaW5jbHVkZWQuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBTbyB3ZSBoYXZlIHRvIHRha2UgY2FyZSB0byBpbmNsdWRlIGEgdGQgd2UndmUgZW50ZXJlZCBvbmx5IHdoZW4gd2UndmVcblx0XHRcdFx0XHQvLyB3YWxrZWQgaW50byBpdHMgY2hpbGRyZW4uXG5cblx0XHRcdFx0XHRpZiAoIG5vZGUudHlwZSAhPSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgfHwgIW5vZGUuaXMoIENLRURJVE9SLmR0ZC50YWJsZSApICkge1xuXHRcdFx0XHRcdFx0dmFyIHBhcmVudCA9IG5vZGUuZ2V0QXNjZW5kYW50KCAndGQnLCB0cnVlICkgfHwgbm9kZS5nZXRBc2NlbmRhbnQoICd0aCcsIHRydWUgKTtcblx0XHRcdFx0XHRcdGlmICggcGFyZW50ICYmICFwYXJlbnQuZ2V0Q3VzdG9tRGF0YSggJ3NlbGVjdGVkX2NlbGwnICkgKSB7XG5cdFx0XHRcdFx0XHRcdENLRURJVE9SLmRvbS5lbGVtZW50LnNldE1hcmtlciggZGF0YWJhc2UsIHBhcmVudCwgJ3NlbGVjdGVkX2NlbGwnLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRcdHJldHZhbC5wdXNoKCBwYXJlbnQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5jbGVhckFsbE1hcmtlcnMoIGRhdGFiYXNlICk7XG5cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Rm9jdXNFbGVtZW50QWZ0ZXJEZWxDZWxscyggY2VsbHNUb0RlbGV0ZSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsYXN0ID0gY2VsbHNUb0RlbGV0ZS5sZW5ndGggLSAxLFxuXHRcdFx0ZGF0YWJhc2UgPSB7fSxcblx0XHRcdGNlbGwsIGZvY3VzZWRDZWxsLCB0cjtcblxuXHRcdHdoaWxlICggKCBjZWxsID0gY2VsbHNUb0RlbGV0ZVsgaSsrIF0gKSApXG5cdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoIGRhdGFiYXNlLCBjZWxsLCAnZGVsZXRlX2NlbGwnLCB0cnVlICk7XG5cblx0XHQvLyAxLmZpcnN0IHdlIGNoZWNrIGxlZnQgb3IgcmlnaHQgc2lkZSBmb2N1c2FibGUgY2VsbCByb3cgYnkgcm93O1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjZWxsID0gY2VsbHNUb0RlbGV0ZVsgaSsrIF0gKSApIHtcblx0XHRcdGlmICggKCBmb2N1c2VkQ2VsbCA9IGNlbGwuZ2V0UHJldmlvdXMoKSApICYmICFmb2N1c2VkQ2VsbC5nZXRDdXN0b21EYXRhKCAnZGVsZXRlX2NlbGwnICkgfHwgKCBmb2N1c2VkQ2VsbCA9IGNlbGwuZ2V0TmV4dCgpICkgJiYgIWZvY3VzZWRDZWxsLmdldEN1c3RvbURhdGEoICdkZWxldGVfY2VsbCcgKSApIHtcblx0XHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuY2xlYXJBbGxNYXJrZXJzKCBkYXRhYmFzZSApO1xuXHRcdFx0XHRyZXR1cm4gZm9jdXNlZENlbGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuY2xlYXJBbGxNYXJrZXJzKCBkYXRhYmFzZSApO1xuXG5cdFx0Ly8gMi4gdGhlbiB3ZSBjaGVjayB0aGUgdG9wcGVzdCByb3cgKG91dHNpZGUgdGhlIHNlbGVjdGlvbiBhcmVhIHNxdWFyZSkgZm9jdXNhYmxlIGNlbGxcblx0XHR0ciA9IGNlbGxzVG9EZWxldGVbIDAgXS5nZXRQYXJlbnQoKTtcblx0XHRpZiAoICggdHIgPSB0ci5nZXRQcmV2aW91cygpICkgKVxuXHRcdFx0cmV0dXJuIHRyLmdldExhc3QoKTtcblxuXHRcdC8vIDMuIGxhc3Qgd2UgY2hlY2sgdGhlIGxvd2VyZXN0ICByb3cgZm9jdXNhYmxlIGNlbGxcblx0XHR0ciA9IGNlbGxzVG9EZWxldGVbIGxhc3QgXS5nZXRQYXJlbnQoKTtcblx0XHRpZiAoICggdHIgPSB0ci5nZXROZXh0KCkgKSApXG5cdFx0XHRyZXR1cm4gdHIuZ2V0Q2hpbGQoIDAgKTtcblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Um93KCBzZWxlY3Rpb24sIGluc2VydEJlZm9yZSApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKSxcblx0XHRcdGZpcnN0Q2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHR0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdGRvYyA9IGZpcnN0Q2VsbC5nZXREb2N1bWVudCgpLFxuXHRcdFx0c3RhcnRSb3cgPSBjZWxsc1sgMCBdLmdldFBhcmVudCgpLFxuXHRcdFx0c3RhcnRSb3dJbmRleCA9IHN0YXJ0Um93LiQucm93SW5kZXgsXG5cdFx0XHRsYXN0Q2VsbCA9IGNlbGxzWyBjZWxscy5sZW5ndGggLSAxIF0sXG5cdFx0XHRlbmRSb3dJbmRleCA9IGxhc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXggKyBsYXN0Q2VsbC4kLnJvd1NwYW4gLSAxLFxuXHRcdFx0ZW5kUm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCB0YWJsZS4kLnJvd3NbIGVuZFJvd0luZGV4IF0gKSxcblx0XHRcdHJvd0luZGV4ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRSb3dJbmRleCA6IGVuZFJvd0luZGV4LFxuXHRcdFx0cm93ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRSb3cgOiBlbmRSb3c7XG5cblx0XHR2YXIgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdGNsb25lUm93ID0gbWFwWyByb3dJbmRleCBdLFxuXHRcdFx0bmV4dFJvdyA9IGluc2VydEJlZm9yZSA/IG1hcFsgcm93SW5kZXggLSAxIF0gOiBtYXBbIHJvd0luZGV4ICsgMSBdLFxuXHRcdFx0d2lkdGggPSBtYXBbIDAgXS5sZW5ndGg7XG5cblx0XHR2YXIgbmV3Um93ID0gZG9jLmNyZWF0ZUVsZW1lbnQoICd0cicgKTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGNsb25lUm93WyBpIF0gJiYgaSA8IHdpZHRoOyBpKysgKSB7XG5cdFx0XHR2YXIgY2VsbDtcblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgdGhlcmUncyBhIHNwYW5uaW5nIHJvdyBoZXJlLCBkbyBub3QgYnJlYWsgaXQuXG5cdFx0XHRpZiAoIGNsb25lUm93WyBpIF0ucm93U3BhbiA+IDEgJiYgbmV4dFJvdyAmJiBjbG9uZVJvd1sgaSBdID09IG5leHRSb3dbIGkgXSApIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lUm93WyBpIF07XG5cdFx0XHRcdGNlbGwucm93U3BhbiArPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggY2xvbmVSb3dbIGkgXSApLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCAncm93U3BhbicgKTtcblx0XHRcdFx0Y2VsbC5hcHBlbmRCb2d1cygpO1xuXHRcdFx0XHRuZXdSb3cuYXBwZW5kKCBjZWxsICk7XG5cdFx0XHRcdGNlbGwgPSBjZWxsLiQ7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gY2VsbC5jb2xTcGFuIC0gMTtcblx0XHR9XG5cblx0XHRpbnNlcnRCZWZvcmUgPyBuZXdSb3cuaW5zZXJ0QmVmb3JlKCByb3cgKSA6IG5ld1Jvdy5pbnNlcnRBZnRlciggcm93ICk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWxldGVSb3dzKCBzZWxlY3Rpb25PclJvdyApIHtcblx0XHRpZiAoIHNlbGVjdGlvbk9yUm93IGluc3RhbmNlb2YgQ0tFRElUT1IuZG9tLnNlbGVjdGlvbiApIHtcblx0XHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbk9yUm93ICksXG5cdFx0XHRcdGZpcnN0Q2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0XHRtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKCB0YWJsZSApLFxuXHRcdFx0XHRzdGFydFJvdyA9IGNlbGxzWyAwIF0uZ2V0UGFyZW50KCksXG5cdFx0XHRcdHN0YXJ0Um93SW5kZXggPSBzdGFydFJvdy4kLnJvd0luZGV4LFxuXHRcdFx0XHRsYXN0Q2VsbCA9IGNlbGxzWyBjZWxscy5sZW5ndGggLSAxIF0sXG5cdFx0XHRcdGVuZFJvd0luZGV4ID0gbGFzdENlbGwuZ2V0UGFyZW50KCkuJC5yb3dJbmRleCArIGxhc3RDZWxsLiQucm93U3BhbiAtIDEsXG5cdFx0XHRcdHJvd3NUb0RlbGV0ZSA9IFtdO1xuXG5cdFx0XHQvLyBEZWxldGUgY2VsbCBvciByZWR1Y2UgY2VsbCBzcGFucyBieSBjaGVja2luZyB0aHJvdWdoIHRoZSB0YWJsZSBtYXAuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0Um93SW5kZXg7IGkgPD0gZW5kUm93SW5kZXg7IGkrKyApIHtcblx0XHRcdFx0dmFyIG1hcFJvdyA9IG1hcFsgaSBdLFxuXHRcdFx0XHRcdHJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggdGFibGUuJC5yb3dzWyBpIF0gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtYXBSb3cubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdFx0dmFyIGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIG1hcFJvd1sgaiBdICksXG5cdFx0XHRcdFx0XHRjZWxsUm93SW5kZXggPSBjZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXg7XG5cblx0XHRcdFx0XHRpZiAoIGNlbGwuJC5yb3dTcGFuID09IDEgKVxuXHRcdFx0XHRcdFx0Y2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0XHQvLyBSb3cgc3Bhbm5lZCBjZWxsLlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gU3BhbiByb3cgb2YgdGhlIGNlbGwsIHJlZHVjZSBzcGFubmluZy5cblx0XHRcdFx0XHRcdGNlbGwuJC5yb3dTcGFuIC09IDE7XG5cdFx0XHRcdFx0XHQvLyBSb290IHJvdyBvZiB0aGUgY2VsbCwgcm9vdCBjZWxsIHRvIG5leHQgcm93LlxuXHRcdFx0XHRcdFx0aWYgKCBjZWxsUm93SW5kZXggPT0gaSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5leHRNYXBSb3cgPSBtYXBbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRcdG5leHRNYXBSb3dbIGogLSAxIF0gPyBjZWxsLmluc2VydEFmdGVyKCBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIG5leHRNYXBSb3dbIGogLSAxIF0gKSApIDogbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCB0YWJsZS4kLnJvd3NbIGkgKyAxIF0gKS5hcHBlbmQoIGNlbGwsIDEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqICs9IGNlbGwuJC5jb2xTcGFuIC0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJvd3NUb0RlbGV0ZS5wdXNoKCByb3cgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJvd3MgPSB0YWJsZS4kLnJvd3M7XG5cblx0XHRcdC8vIFdoZXJlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIHJvd3MgYmVlbiBkZWxldGVkP1xuXHRcdFx0Ly8gMS4gSW50byBuZXh0IHNpYmxpbmcgcm93IGlmIGFueTtcblx0XHRcdC8vIDIuIEludG8gcHJldmlvdXMgc2libGluZyByb3cgaWYgYW55O1xuXHRcdFx0Ly8gMy4gSW50byB0YWJsZSdzIHBhcmVudCBlbGVtZW50IGlmIGl0J3MgdGhlIHZlcnkgbGFzdCByb3cuXG5cdFx0XHR2YXIgY3Vyc29yUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHJvd3NbIGVuZFJvd0luZGV4ICsgMSBdIHx8ICggc3RhcnRSb3dJbmRleCA+IDAgPyByb3dzWyBzdGFydFJvd0luZGV4IC0gMSBdIDogbnVsbCApIHx8IHRhYmxlLiQucGFyZW50Tm9kZSApO1xuXG5cdFx0XHRmb3IgKCBpID0gcm93c1RvRGVsZXRlLmxlbmd0aDsgaSA+PSAwOyBpLS0gKVxuXHRcdFx0XHRkZWxldGVSb3dzKCByb3dzVG9EZWxldGVbIGkgXSApO1xuXG5cdFx0XHRyZXR1cm4gY3Vyc29yUG9zaXRpb247XG5cdFx0fSBlbHNlIGlmICggc2VsZWN0aW9uT3JSb3cgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uZWxlbWVudCApIHtcblx0XHRcdHRhYmxlID0gc2VsZWN0aW9uT3JSb3cuZ2V0QXNjZW5kYW50KCAndGFibGUnICk7XG5cblx0XHRcdGlmICggdGFibGUuJC5yb3dzLmxlbmd0aCA9PSAxIClcblx0XHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHNlbGVjdGlvbk9yUm93LnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2VsbENvbEluZGV4KCBjZWxsLCBpc1N0YXJ0ICkge1xuXHRcdHZhciByb3cgPSBjZWxsLmdldFBhcmVudCgpLFxuXHRcdFx0cm93Q2VsbHMgPSByb3cuJC5jZWxscztcblxuXHRcdHZhciBjb2xJbmRleCA9IDA7XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcm93Q2VsbHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR2YXIgbWFwQ2VsbCA9IHJvd0NlbGxzWyBpIF07XG5cdFx0XHRjb2xJbmRleCArPSBpc1N0YXJ0ID8gMSA6IG1hcENlbGwuY29sU3Bhbjtcblx0XHRcdGlmICggbWFwQ2VsbCA9PSBjZWxsLiQgKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sSW5kZXggLSAxO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29sdW1uc0luZGljZXMoIGNlbGxzLCBpc1N0YXJ0ICkge1xuXHRcdHZhciByZXR2YWwgPSBpc1N0YXJ0ID8gSW5maW5pdHkgOiAwO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0dmFyIGNvbEluZGV4ID0gZ2V0Q2VsbENvbEluZGV4KCBjZWxsc1sgaSBdLCBpc1N0YXJ0ICk7XG5cdFx0XHRpZiAoIGlzU3RhcnQgPyBjb2xJbmRleCA8IHJldHZhbCA6IGNvbEluZGV4ID4gcmV0dmFsIClcblx0XHRcdFx0cmV0dmFsID0gY29sSW5kZXg7XG5cdFx0fVxuXHRcdHJldHVybiByZXR2YWw7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRDb2x1bW4oIHNlbGVjdGlvbiwgaW5zZXJ0QmVmb3JlICkge1xuXHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbiApLFxuXHRcdFx0Zmlyc3RDZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0c3RhcnRDb2wgPSBnZXRDb2x1bW5zSW5kaWNlcyggY2VsbHMsIDEgKSxcblx0XHRcdGxhc3RDb2wgPSBnZXRDb2x1bW5zSW5kaWNlcyggY2VsbHMgKSxcblx0XHRcdGNvbEluZGV4ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRDb2wgOiBsYXN0Q29sO1xuXG5cdFx0dmFyIG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAoIHRhYmxlICksXG5cdFx0XHRjbG9uZUNvbCA9IFtdLFxuXHRcdFx0bmV4dENvbCA9IFtdLFxuXHRcdFx0aGVpZ2h0ID0gbWFwLmxlbmd0aDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSsrICkge1xuXHRcdFx0Y2xvbmVDb2wucHVzaCggbWFwWyBpIF1bIGNvbEluZGV4IF0gKTtcblx0XHRcdHZhciBuZXh0Q2VsbCA9IGluc2VydEJlZm9yZSA/IG1hcFsgaSBdWyBjb2xJbmRleCAtIDEgXSA6IG1hcFsgaSBdWyBjb2xJbmRleCArIDEgXTtcblx0XHRcdG5leHRDb2wucHVzaCggbmV4dENlbGwgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGhlaWdodDsgaSsrICkge1xuXHRcdFx0dmFyIGNlbGw7XG5cblx0XHRcdGlmICggIWNsb25lQ29sWyBpIF0gKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciB0aGVyZSdzIGEgc3Bhbm5pbmcgY29sdW1uIGhlcmUsIGRvIG5vdCBicmVhayBpdC5cblx0XHRcdGlmICggY2xvbmVDb2xbIGkgXS5jb2xTcGFuID4gMSAmJiBuZXh0Q29sWyBpIF0gPT0gY2xvbmVDb2xbIGkgXSApIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lQ29sWyBpIF07XG5cdFx0XHRcdGNlbGwuY29sU3BhbiArPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggY2xvbmVDb2xbIGkgXSApLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCAnY29sU3BhbicgKTtcblx0XHRcdFx0Y2VsbC5hcHBlbmRCb2d1cygpO1xuXHRcdFx0XHRjZWxsWyBpbnNlcnRCZWZvcmUgPyAnaW5zZXJ0QmVmb3JlJyA6ICdpbnNlcnRBZnRlcicgXS5jYWxsKCBjZWxsLCBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIGNsb25lQ29sWyBpIF0gKSApO1xuXHRcdFx0XHRjZWxsID0gY2VsbC4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGNlbGwucm93U3BhbiAtIDE7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlQ29sdW1ucyggc2VsZWN0aW9uT3JDZWxsICkge1xuXHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbk9yQ2VsbCApLFxuXHRcdFx0Zmlyc3RDZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdGxhc3RDZWxsID0gY2VsbHNbIGNlbGxzLmxlbmd0aCAtIDEgXSxcblx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0bWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdHN0YXJ0Q29sSW5kZXgsIGVuZENvbEluZGV4LFxuXHRcdFx0cm93c1RvRGVsZXRlID0gW107XG5cblx0XHQvLyBGaWd1cmUgb3V0IHNlbGVjdGVkIGNlbGxzJyBjb2x1bW4gaW5kaWNlcy5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIHJvd3MgPSBtYXAubGVuZ3RoOyBpIDwgcm93czsgaSsrICkge1xuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBjb2xzID0gbWFwWyBpIF0ubGVuZ3RoOyBqIDwgY29sczsgaisrICkge1xuXHRcdFx0XHRpZiAoIG1hcFsgaSBdWyBqIF0gPT0gZmlyc3RDZWxsLiQgKVxuXHRcdFx0XHRcdHN0YXJ0Q29sSW5kZXggPSBqO1xuXHRcdFx0XHRpZiAoIG1hcFsgaSBdWyBqIF0gPT0gbGFzdENlbGwuJCApXG5cdFx0XHRcdFx0ZW5kQ29sSW5kZXggPSBqO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERlbGV0ZSBjZWxsIG9yIHJlZHVjZSBjZWxsIHNwYW5zIGJ5IGNoZWNraW5nIHRocm91Z2ggdGhlIHRhYmxlIG1hcC5cblx0XHRmb3IgKCBpID0gc3RhcnRDb2xJbmRleDsgaSA8PSBlbmRDb2xJbmRleDsgaSsrICkge1xuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdHZhciBtYXBSb3cgPSBtYXBbIGogXSxcblx0XHRcdFx0XHRyb3cgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHRhYmxlLiQucm93c1sgaiBdICksXG5cdFx0XHRcdFx0Y2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggbWFwUm93WyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIGNlbGwuJCApIHtcblx0XHRcdFx0XHRpZiAoIGNlbGwuJC5jb2xTcGFuID09IDEgKVxuXHRcdFx0XHRcdFx0Y2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0XHQvLyBSZWR1Y2UgdGhlIGNvbCBzcGFucy5cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRjZWxsLiQuY29sU3BhbiAtPSAxO1xuXG5cdFx0XHRcdFx0aiArPSBjZWxsLiQucm93U3BhbiAtIDE7XG5cblx0XHRcdFx0XHRpZiAoICFyb3cuJC5jZWxscy5sZW5ndGggKVxuXHRcdFx0XHRcdFx0cm93c1RvRGVsZXRlLnB1c2goIHJvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0Um93Q2VsbHMgPSB0YWJsZS4kLnJvd3NbIDAgXSAmJiB0YWJsZS4kLnJvd3NbIDAgXS5jZWxscztcblxuXHRcdC8vIFdoZXJlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGNvbHVtbnMgYmVlbiBkZWxldGVkP1xuXHRcdC8vIDEuIEludG8gbmV4dCBjZWxsIG9mIHRoZSBmaXJzdCByb3cgaWYgYW55O1xuXHRcdC8vIDIuIEludG8gcHJldmlvdXMgY2VsbCBvZiB0aGUgZmlyc3Qgcm93IGlmIGFueTtcblx0XHQvLyAzLiBJbnRvIHRhYmxlJ3MgcGFyZW50IGVsZW1lbnQ7XG5cdFx0dmFyIGN1cnNvclBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBmaXJzdFJvd0NlbGxzWyBzdGFydENvbEluZGV4IF0gfHwgKCBzdGFydENvbEluZGV4ID8gZmlyc3RSb3dDZWxsc1sgc3RhcnRDb2xJbmRleCAtIDEgXSA6IHRhYmxlLiQucGFyZW50Tm9kZSApICk7XG5cblx0XHQvLyBEZWxldGUgdGFibGUgcm93cyBvbmx5IGlmIGFsbCBjb2x1bW5zIGFyZSBnb25lIChkbyBub3QgcmVtb3ZlIGVtcHR5IHJvdykuXG5cdFx0aWYgKCByb3dzVG9EZWxldGUubGVuZ3RoID09IHJvd3MgKVxuXHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cblx0XHRyZXR1cm4gY3Vyc29yUG9zaXRpb247XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRDZWxsKCBzZWxlY3Rpb24sIGluc2VydEJlZm9yZSApIHtcblx0XHR2YXIgc3RhcnRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpO1xuXHRcdHZhciBjZWxsID0gc3RhcnRFbGVtZW50LmdldEFzY2VuZGFudCggJ3RkJywgMSApIHx8IHN0YXJ0RWxlbWVudC5nZXRBc2NlbmRhbnQoICd0aCcsIDEgKTtcblxuXHRcdGlmICggIWNlbGwgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBuZXcgY2VsbCBlbGVtZW50IHRvIGJlIGFkZGVkLlxuXHRcdHZhciBuZXdDZWxsID0gY2VsbC5jbG9uZSgpO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGlmICggaW5zZXJ0QmVmb3JlIClcblx0XHRcdG5ld0NlbGwuaW5zZXJ0QmVmb3JlKCBjZWxsICk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3Q2VsbC5pbnNlcnRBZnRlciggY2VsbCApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlQ2VsbHMoIHNlbGVjdGlvbk9yQ2VsbCApIHtcblx0XHRpZiAoIHNlbGVjdGlvbk9yQ2VsbCBpbnN0YW5jZW9mIENLRURJVE9SLmRvbS5zZWxlY3Rpb24gKSB7XG5cdFx0XHR2YXIgY2VsbHNUb0RlbGV0ZSA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbk9yQ2VsbCApO1xuXHRcdFx0dmFyIHRhYmxlID0gY2VsbHNUb0RlbGV0ZVsgMCBdICYmIGNlbGxzVG9EZWxldGVbIDAgXS5nZXRBc2NlbmRhbnQoICd0YWJsZScgKTtcblx0XHRcdHZhciBjZWxsVG9Gb2N1cyA9IGdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMoIGNlbGxzVG9EZWxldGUgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSBjZWxsc1RvRGVsZXRlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tIClcblx0XHRcdFx0ZGVsZXRlQ2VsbHMoIGNlbGxzVG9EZWxldGVbIGkgXSApO1xuXG5cdFx0XHRpZiAoIGNlbGxUb0ZvY3VzIClcblx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIGNlbGxUb0ZvY3VzLCB0cnVlICk7XG5cdFx0XHRlbHNlIGlmICggdGFibGUgKVxuXHRcdFx0XHR0YWJsZS5yZW1vdmUoKTtcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rpb25PckNlbGwgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uZWxlbWVudCApIHtcblx0XHRcdHZhciB0ciA9IHNlbGVjdGlvbk9yQ2VsbC5nZXRQYXJlbnQoKTtcblx0XHRcdGlmICggdHIuZ2V0Q2hpbGRDb3VudCgpID09IDEgKVxuXHRcdFx0XHR0ci5yZW1vdmUoKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0c2VsZWN0aW9uT3JDZWxsLnJlbW92ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBmaWxsZXIgYXQgZW5kIGFuZCBlbXB0eSBzcGFjZXMgYXJvdW5kIHRoZSBjZWxsIGNvbnRlbnQuXG5cdGZ1bmN0aW9uIHRyaW1DZWxsKCBjZWxsICkge1xuXHRcdHZhciBib2d1cyA9IGNlbGwuZ2V0Qm9ndXMoKTtcblx0XHRib2d1cyAmJiBib2d1cy5yZW1vdmUoKTtcblx0XHRjZWxsLnRyaW0oKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBsYWNlQ3Vyc29ySW5DZWxsKCBjZWxsLCBwbGFjZUF0RW5kICkge1xuXHRcdHZhciBkb2NJbm5lciA9IGNlbGwuZ2V0RG9jdW1lbnQoKSxcblx0XHRcdGRvY091dGVyID0gQ0tFRElUT1IuZG9jdW1lbnQ7XG5cblx0XHQvLyBGaXhpbmcgXCJVbnNwZWNpZmllZCBlcnJvclwiIHRocm93biBpbiBJRTEwIGJ5IHJlc2V0dGluZ1xuXHRcdC8vIHNlbGVjdGlvbiB0aGUgZGlydHkgYW5kIHNoYW1lZnVsIHdheSAoIzEwMzA4KS5cblx0XHQvLyBXZSBjYW4gbm90IGFwcGx5IHRoaXMgaGFjayB0byBJRTggYmVjYXVzZVxuXHRcdC8vIGl0IGNhdXNlcyBlcnJvciAoIzExMDU4KS5cblx0XHRpZiAoIENLRURJVE9SLmVudi5pZSAmJiBDS0VESVRPUi5lbnYudmVyc2lvbiA9PSAxMCApIHtcblx0XHRcdGRvY091dGVyLmZvY3VzKCk7XG5cdFx0XHRkb2NJbm5lci5mb2N1cygpO1xuXHRcdH1cblxuXHRcdHZhciByYW5nZSA9IG5ldyBDS0VESVRPUi5kb20ucmFuZ2UoIGRvY0lubmVyICk7XG5cdFx0aWYgKCAhcmFuZ2VbICdtb3ZlVG9FbGVtZW50RWRpdCcgKyAoIHBsYWNlQXRFbmQgPyAnRW5kJyA6ICdTdGFydCcgKSBdKCBjZWxsICkgKSB7XG5cdFx0XHRyYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoIGNlbGwgKTtcblx0XHRcdHJhbmdlLmNvbGxhcHNlKCBwbGFjZUF0RW5kID8gZmFsc2UgOiB0cnVlICk7XG5cdFx0fVxuXHRcdHJhbmdlLnNlbGVjdCggdHJ1ZSApO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2VsbEluUm93KCB0YWJsZU1hcCwgcm93SW5kZXgsIGNlbGwgKSB7XG5cdFx0dmFyIG9Sb3cgPSB0YWJsZU1hcFsgcm93SW5kZXggXTtcblx0XHRpZiAoIHR5cGVvZiBjZWxsID09ICd1bmRlZmluZWQnIClcblx0XHRcdHJldHVybiBvUm93O1xuXG5cdFx0Zm9yICggdmFyIGMgPSAwOyBvUm93ICYmIGMgPCBvUm93Lmxlbmd0aDsgYysrICkge1xuXHRcdFx0aWYgKCBjZWxsLmlzICYmIG9Sb3dbIGMgXSA9PSBjZWxsLiQgKVxuXHRcdFx0XHRyZXR1cm4gYztcblx0XHRcdGVsc2UgaWYgKCBjID09IGNlbGwgKVxuXHRcdFx0XHRyZXR1cm4gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBvUm93WyBjIF0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNlbGwuaXMgPyAtMSA6IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjZWxsSW5Db2woIHRhYmxlTWFwLCBjb2xJbmRleCApIHtcblx0XHR2YXIgb0NvbCA9IFtdO1xuXHRcdGZvciAoIHZhciByID0gMDsgciA8IHRhYmxlTWFwLmxlbmd0aDsgcisrICkge1xuXHRcdFx0dmFyIHJvdyA9IHRhYmxlTWFwWyByIF07XG5cdFx0XHRvQ29sLnB1c2goIHJvd1sgY29sSW5kZXggXSApO1xuXG5cdFx0XHQvLyBBdm9pZCBhZGRpbmcgZHVwbGljYXRlIGNlbGxzLlxuXHRcdFx0aWYgKCByb3dbIGNvbEluZGV4IF0ucm93U3BhbiA+IDEgKVxuXHRcdFx0XHRyICs9IHJvd1sgY29sSW5kZXggXS5yb3dTcGFuIC0gMTtcblx0XHR9XG5cdFx0cmV0dXJuIG9Db2w7XG5cdH1cblxuXHRmdW5jdGlvbiBtZXJnZUNlbGxzKCBzZWxlY3Rpb24sIG1lcmdlRGlyZWN0aW9uLCBpc0RldGVjdCApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKTtcblxuXHRcdC8vIEludmFsaWQgbWVyZ2UgcmVxdWVzdCBpZjpcblx0XHQvLyAxLiBJbiBiYXRjaCBtb2RlIGRlc3BpdGUgdGhhdCBsZXNzIHRoYW4gdHdvIHNlbGVjdGVkLlxuXHRcdC8vIDIuIEluIHNvbG8gbW9kZSB3aGlsZSBub3QgZXhhY3RseSBvbmx5IG9uZSBzZWxlY3RlZC5cblx0XHQvLyAzLiBDZWxscyBkaXN0cmlidXRlZCBpbiBkaWZmZXJlbnQgdGFibGUgZ3JvdXBzIChlLmcuIGZyb20gYm90aCB0aGVhZCBhbmQgdGJvZHkpLlxuXHRcdHZhciBjb21tb25BbmNlc3Rvcjtcblx0XHRpZiAoICggbWVyZ2VEaXJlY3Rpb24gPyBjZWxscy5sZW5ndGggIT0gMSA6IGNlbGxzLmxlbmd0aCA8IDIgKSB8fCAoIGNvbW1vbkFuY2VzdG9yID0gc2VsZWN0aW9uLmdldENvbW1vbkFuY2VzdG9yKCkgKSAmJiBjb21tb25BbmNlc3Rvci50eXBlID09IENLRURJVE9SLk5PREVfRUxFTUVOVCAmJiBjb21tb25BbmNlc3Rvci5pcyggJ3RhYmxlJyApIClcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBjZWxsLFxuXHRcdFx0Zmlyc3RDZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0bWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdG1hcEhlaWdodCA9IG1hcC5sZW5ndGgsXG5cdFx0XHRtYXBXaWR0aCA9IG1hcFsgMCBdLmxlbmd0aCxcblx0XHRcdHN0YXJ0Um93ID0gZmlyc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXgsXG5cdFx0XHRzdGFydENvbHVtbiA9IGNlbGxJblJvdyggbWFwLCBzdGFydFJvdywgZmlyc3RDZWxsICk7XG5cblx0XHRpZiAoIG1lcmdlRGlyZWN0aW9uICkge1xuXHRcdFx0dmFyIHRhcmdldENlbGw7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgcm93c3BhbiA9IHBhcnNlSW50KCBmaXJzdENlbGwuZ2V0QXR0cmlidXRlKCAncm93c3BhbicgKSwgMTAgKSB8fCAxO1xuXHRcdFx0XHR2YXIgY29sc3BhbiA9IHBhcnNlSW50KCBmaXJzdENlbGwuZ2V0QXR0cmlidXRlKCAnY29sc3BhbicgKSwgMTAgKSB8fCAxO1xuXG5cdFx0XHRcdHRhcmdldENlbGwgPSBtYXBbIG1lcmdlRGlyZWN0aW9uID09ICd1cCcgPyAoIHN0YXJ0Um93IC0gcm93c3BhbiApIDogbWVyZ2VEaXJlY3Rpb24gPT0gJ2Rvd24nID8gKCBzdGFydFJvdyArIHJvd3NwYW4gKSA6IHN0YXJ0Um93IF1bXG5cdFx0XHRcdFx0bWVyZ2VEaXJlY3Rpb24gPT0gJ2xlZnQnID9cblx0XHRcdFx0XHRcdCggc3RhcnRDb2x1bW4gLSBjb2xzcGFuICkgOlxuXHRcdFx0XHRcdG1lcmdlRGlyZWN0aW9uID09ICdyaWdodCcgPyAoIHN0YXJ0Q29sdW1uICsgY29sc3BhbiApIDogc3RhcnRDb2x1bW4gXTtcblxuXHRcdFx0fSBjYXRjaCAoIGVyICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDEuIE5vIGNlbGwgY291bGQgYmUgbWVyZ2VkLlxuXHRcdFx0Ly8gMi4gU2FtZSBjZWxsIGFjdHVhbGx5LlxuXHRcdFx0aWYgKCAhdGFyZ2V0Q2VsbCB8fCBmaXJzdENlbGwuJCA9PSB0YXJnZXRDZWxsIClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBTb3J0IGluIG1hcCBvcmRlciByZWdhcmRsZXNzIG9mIHRoZSBET00gc2VxdWVuY2UuXG5cdFx0XHRjZWxsc1sgKCBtZXJnZURpcmVjdGlvbiA9PSAndXAnIHx8IG1lcmdlRGlyZWN0aW9uID09ICdsZWZ0JyApID8gJ3Vuc2hpZnQnIDogJ3B1c2gnIF0oIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggdGFyZ2V0Q2VsbCApICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RhcnQgZnJvbSBoZXJlIGFyZSBtZXJnaW5nIHdheSBpZ25vcmFuY2UgKG1lcmdlIHVwL3JpZ2h0LCBiYXRjaCBtZXJnZSkuXG5cdFx0dmFyIGRvYyA9IGZpcnN0Q2VsbC5nZXREb2N1bWVudCgpLFxuXHRcdFx0bGFzdFJvd0luZGV4ID0gc3RhcnRSb3csXG5cdFx0XHR0b3RhbFJvd1NwYW4gPSAwLFxuXHRcdFx0dG90YWxDb2xTcGFuID0gMCxcblx0XHRcdC8vIFVzZSBhIGRvY3VtZW50RnJhZ21lbnQgYXMgYnVmZmVyIHdoZW4gYXBwZW5kaW5nIGNlbGwgY29udGVudHMuXG5cdFx0XHRmcmFnID0gIWlzRGV0ZWN0ICYmIG5ldyBDS0VESVRPUi5kb20uZG9jdW1lbnRGcmFnbWVudCggZG9jICksXG5cdFx0XHRkaW1lbnNpb24gPSAwO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjZWxsID0gY2VsbHNbIGkgXTtcblxuXHRcdFx0dmFyIHRyID0gY2VsbC5nZXRQYXJlbnQoKSxcblx0XHRcdFx0Y2VsbEZpcnN0Q2hpbGQgPSBjZWxsLmdldEZpcnN0KCksXG5cdFx0XHRcdGNvbFNwYW4gPSBjZWxsLiQuY29sU3Bhbixcblx0XHRcdFx0cm93U3BhbiA9IGNlbGwuJC5yb3dTcGFuLFxuXHRcdFx0XHRyb3dJbmRleCA9IHRyLiQucm93SW5kZXgsXG5cdFx0XHRcdGNvbEluZGV4ID0gY2VsbEluUm93KCBtYXAsIHJvd0luZGV4LCBjZWxsICk7XG5cblx0XHRcdC8vIEFjY3VtdWxhdGVkIHRoZSBhY3R1YWwgcGxhY2VzIHRha2VuIGJ5IGFsbCBzZWxlY3RlZCBjZWxscy5cblx0XHRcdGRpbWVuc2lvbiArPSBjb2xTcGFuICogcm93U3Bhbjtcblx0XHRcdC8vIEFjY3VtdWxhdGVkIHRoZSBtYXhpbXVtIHZpcnR1YWwgc3BhbnMgZnJvbSBjb2x1bW4gYW5kIHJvdy5cblx0XHRcdHRvdGFsQ29sU3BhbiA9IE1hdGgubWF4KCB0b3RhbENvbFNwYW4sIGNvbEluZGV4IC0gc3RhcnRDb2x1bW4gKyBjb2xTcGFuICk7XG5cdFx0XHR0b3RhbFJvd1NwYW4gPSBNYXRoLm1heCggdG90YWxSb3dTcGFuLCByb3dJbmRleCAtIHN0YXJ0Um93ICsgcm93U3BhbiApO1xuXG5cdFx0XHRpZiAoICFpc0RldGVjdCApIHtcblx0XHRcdFx0Ly8gVHJpbSBhbGwgY2VsbCBmaWxsZXJzIGFuZCBjaGVjayB0byByZW1vdmUgZW1wdHkgY2VsbHMuXG5cdFx0XHRcdGlmICggdHJpbUNlbGwoIGNlbGwgKSwgY2VsbC5nZXRDaGlsZHJlbigpLmNvdW50KCkgKSB7XG5cdFx0XHRcdFx0Ly8gTWVyZ2UgdmVydGljYWxseSBjZWxscyBhcyB0d28gc2VwYXJhdGVkIHBhcmFncmFwaHMuXG5cdFx0XHRcdFx0aWYgKCByb3dJbmRleCAhPSBsYXN0Um93SW5kZXggJiYgY2VsbEZpcnN0Q2hpbGQgJiYgISggY2VsbEZpcnN0Q2hpbGQuaXNCbG9ja0JvdW5kYXJ5ICYmIGNlbGxGaXJzdENoaWxkLmlzQmxvY2tCb3VuZGFyeSggeyBicjogMSB9ICkgKSApIHtcblx0XHRcdFx0XHRcdHZhciBsYXN0ID0gZnJhZy5nZXRMYXN0KCBDS0VESVRPUi5kb20ud2Fsa2VyLndoaXRlc3BhY2VzKCB0cnVlICkgKTtcblx0XHRcdFx0XHRcdGlmICggbGFzdCAmJiAhKCBsYXN0LmlzICYmIGxhc3QuaXMoICdicicgKSApIClcblx0XHRcdFx0XHRcdFx0ZnJhZy5hcHBlbmQoICdicicgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjZWxsLm1vdmVDaGlsZHJlbiggZnJhZyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPyBjZWxsLnJlbW92ZSgpIDogY2VsbC5zZXRIdG1sKCAnJyApO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFJvd0luZGV4ID0gcm93SW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhaXNEZXRlY3QgKSB7XG5cdFx0XHRmcmFnLm1vdmVDaGlsZHJlbiggZmlyc3RDZWxsICk7XG5cblx0XHRcdGZpcnN0Q2VsbC5hcHBlbmRCb2d1cygpO1xuXG5cdFx0XHRpZiAoIHRvdGFsQ29sU3BhbiA+PSBtYXBXaWR0aCApXG5cdFx0XHRcdGZpcnN0Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoICdyb3dTcGFuJyApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmaXJzdENlbGwuJC5yb3dTcGFuID0gdG90YWxSb3dTcGFuO1xuXG5cdFx0XHRpZiAoIHRvdGFsUm93U3BhbiA+PSBtYXBIZWlnaHQgKVxuXHRcdFx0XHRmaXJzdENlbGwucmVtb3ZlQXR0cmlidXRlKCAnY29sU3BhbicgKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0Zmlyc3RDZWxsLiQuY29sU3BhbiA9IHRvdGFsQ29sU3BhbjtcblxuXHRcdFx0Ly8gU3dpcCBlbXB0eSA8dHI+IGxlZnQgYXQgdGhlIGVuZCBvZiB0YWJsZSBkdWUgdG8gdGhlIG1lcmdpbmcuXG5cdFx0XHR2YXIgdHJzID0gbmV3IENLRURJVE9SLmRvbS5ub2RlTGlzdCggdGFibGUuJC5yb3dzICksXG5cdFx0XHRcdGNvdW50ID0gdHJzLmNvdW50KCk7XG5cblx0XHRcdGZvciAoIGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXHRcdFx0XHR2YXIgdGFpbFRyID0gdHJzLmdldEl0ZW0oIGkgKTtcblx0XHRcdFx0aWYgKCAhdGFpbFRyLiQuY2VsbHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRhaWxUci5yZW1vdmUoKTtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmaXJzdENlbGw7XG5cdFx0fVxuXHRcdC8vIEJlIGFibGUgdG8gbWVyZ2UgY2VsbHMgb25seSBpZiBhY3R1YWwgZGltZW5zaW9uIG9mIHNlbGVjdGVkXG5cdFx0Ly8gY2VsbHMgZXF1YWxzIHRvIHRoZSBjYWN1bGF0ZWQgcmVjdGFuZ2xlLlxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICggdG90YWxSb3dTcGFuICogdG90YWxDb2xTcGFuICkgPT0gZGltZW5zaW9uO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHZlcnRpY2FsU3BsaXRDZWxsKCBzZWxlY3Rpb24sIGlzRGV0ZWN0ICkge1xuXHRcdHZhciBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbiApO1xuXHRcdGlmICggY2VsbHMubGVuZ3RoID4gMSApXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0ZWxzZSBpZiAoIGlzRGV0ZWN0IClcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0dmFyIGNlbGwgPSBjZWxsc1sgMCBdLFxuXHRcdFx0dHIgPSBjZWxsLmdldFBhcmVudCgpLFxuXHRcdFx0dGFibGUgPSB0ci5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAoIHRhYmxlICksXG5cdFx0XHRyb3dJbmRleCA9IHRyLiQucm93SW5kZXgsXG5cdFx0XHRjb2xJbmRleCA9IGNlbGxJblJvdyggbWFwLCByb3dJbmRleCwgY2VsbCApLFxuXHRcdFx0cm93U3BhbiA9IGNlbGwuJC5yb3dTcGFuLFxuXHRcdFx0bmV3Q2VsbCwgbmV3Um93U3BhbiwgbmV3Q2VsbFJvd1NwYW4sIG5ld1Jvd0luZGV4O1xuXG5cdFx0aWYgKCByb3dTcGFuID4gMSApIHtcblx0XHRcdG5ld1Jvd1NwYW4gPSBNYXRoLmNlaWwoIHJvd1NwYW4gLyAyICk7XG5cdFx0XHRuZXdDZWxsUm93U3BhbiA9IE1hdGguZmxvb3IoIHJvd1NwYW4gLyAyICk7XG5cdFx0XHRuZXdSb3dJbmRleCA9IHJvd0luZGV4ICsgbmV3Um93U3Bhbjtcblx0XHRcdHZhciBuZXdDZWxsVHIgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHRhYmxlLiQucm93c1sgbmV3Um93SW5kZXggXSApLFxuXHRcdFx0XHRuZXdDZWxsUm93ID0gY2VsbEluUm93KCBtYXAsIG5ld1Jvd0luZGV4ICksXG5cdFx0XHRcdGNhbmRpZGF0ZUNlbGw7XG5cblx0XHRcdG5ld0NlbGwgPSBjZWxsLmNsb25lKCk7XG5cblx0XHRcdC8vIEZpZ3VyZSBvdXQgd2hlcmUgdG8gaW5zZXJ0IHRoZSBuZXcgY2VsbCBieSBjaGVja2luZyB0aGUgdml0dWFsIHJvdy5cblx0XHRcdGZvciAoIHZhciBjID0gMDsgYyA8IG5ld0NlbGxSb3cubGVuZ3RoOyBjKysgKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZUNlbGwgPSBuZXdDZWxsUm93WyBjIF07XG5cdFx0XHRcdC8vIENhdGNoIGZpcnN0IGNlbGwgYWN0dWFsbHkgZm9sbG93aW5nIHRoZSBjb2x1bW4uXG5cdFx0XHRcdGlmICggY2FuZGlkYXRlQ2VsbC5wYXJlbnROb2RlID09IG5ld0NlbGxUci4kICYmIGMgPiBjb2xJbmRleCApIHtcblx0XHRcdFx0XHRuZXdDZWxsLmluc2VydEJlZm9yZSggbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBjYW5kaWRhdGVDZWxsICkgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYW5kaWRhdGVDZWxsID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZGVzdGluYXRpb24gcm93IGlzIGVtcHR5LCBhcHBlbmQgYXQgd2lsbC5cblx0XHRcdGlmICggIWNhbmRpZGF0ZUNlbGwgKVxuXHRcdFx0XHRuZXdDZWxsVHIuYXBwZW5kKCBuZXdDZWxsICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NlbGxSb3dTcGFuID0gbmV3Um93U3BhbiA9IDE7XG5cblx0XHRcdG5ld0NlbGxUciA9IHRyLmNsb25lKCk7XG5cdFx0XHRuZXdDZWxsVHIuaW5zZXJ0QWZ0ZXIoIHRyICk7XG5cdFx0XHRuZXdDZWxsVHIuYXBwZW5kKCBuZXdDZWxsID0gY2VsbC5jbG9uZSgpICk7XG5cblx0XHRcdHZhciBjZWxsc0luU2FtZVJvdyA9IGNlbGxJblJvdyggbWFwLCByb3dJbmRleCApO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2VsbHNJblNhbWVSb3cubGVuZ3RoOyBpKysgKVxuXHRcdFx0XHRjZWxsc0luU2FtZVJvd1sgaSBdLnJvd1NwYW4rKztcblx0XHR9XG5cblx0XHRuZXdDZWxsLmFwcGVuZEJvZ3VzKCk7XG5cblx0XHRjZWxsLiQucm93U3BhbiA9IG5ld1Jvd1NwYW47XG5cdFx0bmV3Q2VsbC4kLnJvd1NwYW4gPSBuZXdDZWxsUm93U3Bhbjtcblx0XHRpZiAoIG5ld1Jvd1NwYW4gPT0gMSApXG5cdFx0XHRjZWxsLnJlbW92ZUF0dHJpYnV0ZSggJ3Jvd1NwYW4nICk7XG5cdFx0aWYgKCBuZXdDZWxsUm93U3BhbiA9PSAxIClcblx0XHRcdG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCAncm93U3BhbicgKTtcblxuXHRcdHJldHVybiBuZXdDZWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaG9yaXpvbnRhbFNwbGl0Q2VsbCggc2VsZWN0aW9uLCBpc0RldGVjdCApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKTtcblx0XHRpZiAoIGNlbGxzLmxlbmd0aCA+IDEgKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGVsc2UgaWYgKCBpc0RldGVjdCApXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdHZhciBjZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdHRyID0gY2VsbC5nZXRQYXJlbnQoKSxcblx0XHRcdHRhYmxlID0gdHIuZ2V0QXNjZW5kYW50KCAndGFibGUnICksXG5cdFx0XHRtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKCB0YWJsZSApLFxuXHRcdFx0cm93SW5kZXggPSB0ci4kLnJvd0luZGV4LFxuXHRcdFx0Y29sSW5kZXggPSBjZWxsSW5Sb3coIG1hcCwgcm93SW5kZXgsIGNlbGwgKSxcblx0XHRcdGNvbFNwYW4gPSBjZWxsLiQuY29sU3Bhbixcblx0XHRcdG5ld0NlbGwsIG5ld0NvbFNwYW4sIG5ld0NlbGxDb2xTcGFuO1xuXG5cdFx0aWYgKCBjb2xTcGFuID4gMSApIHtcblx0XHRcdG5ld0NvbFNwYW4gPSBNYXRoLmNlaWwoIGNvbFNwYW4gLyAyICk7XG5cdFx0XHRuZXdDZWxsQ29sU3BhbiA9IE1hdGguZmxvb3IoIGNvbFNwYW4gLyAyICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NlbGxDb2xTcGFuID0gbmV3Q29sU3BhbiA9IDE7XG5cdFx0XHR2YXIgY2VsbHNJblNhbWVDb2wgPSBjZWxsSW5Db2woIG1hcCwgY29sSW5kZXggKTtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNlbGxzSW5TYW1lQ29sLmxlbmd0aDsgaSsrIClcblx0XHRcdFx0Y2VsbHNJblNhbWVDb2xbIGkgXS5jb2xTcGFuKys7XG5cdFx0fVxuXHRcdG5ld0NlbGwgPSBjZWxsLmNsb25lKCk7XG5cdFx0bmV3Q2VsbC5pbnNlcnRBZnRlciggY2VsbCApO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGNlbGwuJC5jb2xTcGFuID0gbmV3Q29sU3Bhbjtcblx0XHRuZXdDZWxsLiQuY29sU3BhbiA9IG5ld0NlbGxDb2xTcGFuO1xuXHRcdGlmICggbmV3Q29sU3BhbiA9PSAxIClcblx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCAnY29sU3BhbicgKTtcblx0XHRpZiAoIG5ld0NlbGxDb2xTcGFuID09IDEgKVxuXHRcdFx0bmV3Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoICdjb2xTcGFuJyApO1xuXG5cdFx0cmV0dXJuIG5ld0NlbGw7XG5cdH1cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdGFibGV0b29scycsIHtcblx0XHRpbml0OiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0dmFyIGxhbmcgPSBlZGl0b3IubGFuZy50YWJsZTtcblxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlRGVmKCBkZWYgKSB7XG5cdFx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5leHRlbmQoIGRlZiB8fCB7fSwge1xuXHRcdFx0XHRcdGNvbnRleHRTZW5zaXRpdmU6IDEsXG5cdFx0XHRcdFx0cmVmcmVzaDogZnVuY3Rpb24oIGVkaXRvciwgcGF0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoIHBhdGguY29udGFpbnMoIHsgdGQ6IDEsIHRoOiAxIH0sIDEgKSA/IENLRURJVE9SLlRSSVNUQVRFX09GRiA6IENLRURJVE9SLlRSSVNUQVRFX0RJU0FCTEVEICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBhZGRDbWQoIG5hbWUsIGRlZiApIHtcblx0XHRcdFx0dmFyIGNtZCA9IGVkaXRvci5nZXRDb21tYW5kKG5hbWUpO1xuXG5cdFx0XHRcdGlmIChjbWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjbWQgPSBlZGl0b3IuYWRkQ29tbWFuZChuYW1lLCBkZWYpO1xuXHRcdFx0XHRlZGl0b3IuYWRkRmVhdHVyZShjbWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRhZGRDbWQoICdyb3dEZWxldGUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIGRlbGV0ZVJvd3MoIHNlbGVjdGlvbiApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdyb3dJbnNlcnRCZWZvcmUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0aW5zZXJ0Um93KCBzZWxlY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ3Jvd0luc2VydEFmdGVyJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGluc2VydFJvdyggc2VsZWN0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjb2x1bW5EZWxldGUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSBkZWxldGVDb2x1bW5zKCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0XHRlbGVtZW50ICYmIHBsYWNlQ3Vyc29ySW5DZWxsKCBlbGVtZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjb2x1bW5JbnNlcnRCZWZvcmUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0aW5zZXJ0Q29sdW1uKCBzZWxlY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NvbHVtbkluc2VydEFmdGVyJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGluc2VydENvbHVtbiggc2VsZWN0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsRGVsZXRlJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGRlbGV0ZUNlbGxzKCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxNZXJnZScsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW4scm93c3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuLHJvd3NwYW5dJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbCggbWVyZ2VDZWxscyggZWRpdG9yLmdldFNlbGVjdGlvbigpICksIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxNZXJnZVJpZ2h0JywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuXScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIG1lcmdlQ2VsbHMoIGVkaXRvci5nZXRTZWxlY3Rpb24oKSwgJ3JpZ2h0JyApLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsTWVyZ2VEb3duJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIG1lcmdlQ2VsbHMoIGVkaXRvci5nZXRTZWxlY3Rpb24oKSwgJ2Rvd24nICksIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxWZXJ0aWNhbFNwbGl0JywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIHZlcnRpY2FsU3BsaXRDZWxsKCBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY2VsbEhvcml6b250YWxTcGxpdCcsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKCBob3Jpem9udGFsU3BsaXRDZWxsKCBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY2VsbEluc2VydEJlZm9yZScsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRpbnNlcnRDZWxsKCBzZWxlY3Rpb24sIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxJbnNlcnRBZnRlcicsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRpbnNlcnRDZWxsKCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fSxcblxuXHRcdGdldFNlbGVjdGVkQ2VsbHM6IGdldFNlbGVjdGVkQ2VsbHNcblxuXHR9KTtcbn0gKSgpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHR3by1kaW1lbnNpb24gYXJyYXkgdGhhdCByZWZsZWN0cyB0aGUgYWN0dWFsIGxheW91dCBvZiB0YWJsZSBjZWxscyxcbiAqIHdpdGggY2VsbCBzcGFucywgd2l0aCBtYXBwaW5ncyB0byB0aGUgb3JpZ2luYWwgdGQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGVcbiAqIEBtZW1iZXIgQ0tFRElUT1IudG9vbHNcbiAqL1xuQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCA9IGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0dmFyIGFSb3dzID0gdGFibGUuJC5yb3dzO1xuXG5cdC8vIFJvdyBhbmQgQ29sdW1uIGNvdW50ZXJzLlxuXHR2YXIgciA9IC0xO1xuXG5cdHZhciBhTWFwID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYVJvd3MubGVuZ3RoOyBpKysgKSB7XG5cdFx0cisrO1xuXHRcdCFhTWFwWyByIF0gJiYgKCBhTWFwWyByIF0gPSBbXSApO1xuXG5cdFx0dmFyIGMgPSAtMTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGFSb3dzWyBpIF0uY2VsbHMubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHR2YXIgb0NlbGwgPSBhUm93c1sgaSBdLmNlbGxzWyBqIF07XG5cblx0XHRcdGMrKztcblx0XHRcdHdoaWxlICggYU1hcFsgciBdWyBjIF0gKVxuXHRcdFx0XHRjKys7XG5cblx0XHRcdHZhciBpQ29sU3BhbiA9IGlzTmFOKCBvQ2VsbC5jb2xTcGFuICkgPyAxIDogb0NlbGwuY29sU3Bhbjtcblx0XHRcdHZhciBpUm93U3BhbiA9IGlzTmFOKCBvQ2VsbC5yb3dTcGFuICkgPyAxIDogb0NlbGwucm93U3BhbjtcblxuXHRcdFx0Zm9yICggdmFyIHJzID0gMDsgcnMgPCBpUm93U3BhbjsgcnMrKyApIHtcblx0XHRcdFx0aWYgKCAhYU1hcFsgciArIHJzIF0gKVxuXHRcdFx0XHRcdGFNYXBbIHIgKyBycyBdID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGNzID0gMDsgY3MgPCBpQ29sU3BhbjsgY3MrKyApIHtcblx0XHRcdFx0XHRhTWFwWyByICsgcnMgXVsgYyArIGNzIF0gPSBhUm93c1sgaSBdLmNlbGxzWyBqIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YyArPSBpQ29sU3BhbiAtIDE7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhTWFwO1xufTtcbiIsInZhciB0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnYWUtYXJyb3ctYm94IGFlLWFycm93LWJveC1ib3R0b20nO1xufTtcblxuY29uc3QgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzID0ge1xuICAgIHRhYmxlOiB0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3Nlc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzOyIsImltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vLyBEZWZhdWx0IGd1dHRlciB2YWx1ZSBmb3IgdG9vbGJhciBwb3NpdGlvbmluZ1xudmFyIERFRkFVTFRfR1VUVEVSID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG59O1xuXG4vKipcbiAqIENlbnRlcnMgYSBUb29sYmFyIGFjY29yZGluZyB0byBnaXZlbiByZWN0YW5nbGVcbiAqXG4gKiBAbWV0aG9kIGNlbnRlclRvb2xiYXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b29sYmFyIFRoZSB0b29sYmFyIHRvIGJlIGNlbnRlcmVkXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCBUaGUgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB3aGljaCB0aGUgVG9vbGJhciB3aWxsIGJlIGNlbnRlcmVkXG4gKi9cbnZhciBjZW50ZXJUb29sYmFyID0gZnVuY3Rpb24odG9vbGJhciwgcmVjdCkge1xuICAgICAgICB2YXIgdG9vbGJhck5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0b29sYmFyKTtcblxuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdG9vbGJhci5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIHVpTm9kZSA9IG5hdGl2ZUVkaXRvci5jb25maWcudWlOb2RlIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHZhciB1aU5vZGVTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodWlOb2RlKTtcbiAgICAgICAgdmFyIHVpTm9kZU1hcmdpbkxlZnQgPSBwYXJzZUludCh1aU5vZGVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpLCAxMCk7XG4gICAgICAgIHZhciB1aU5vZGVNYXJnaW5SaWdodCA9IHBhcnNlSW50KHVpTm9kZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1yaWdodCcpLCAxMCk7XG4gICAgICAgIHZhciB0b3RhbFdpZHRoID0gdWlOb2RlTWFyZ2luTGVmdCArIHVpTm9kZS5jbGllbnRXaWR0aCArIHVpTm9kZU1hcmdpblJpZ2h0O1xuXG4gICAgICAgIHZhciBoYWxmTm9kZVdpZHRoID0gdG9vbGJhck5vZGUub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmFyIGd1dHRlciA9IHRvb2xiYXIucHJvcHMuZ3V0dGVyIHx8IERFRkFVTFRfR1VUVEVSO1xuXG4gICAgICAgIHZhciB3aWRnZXRYWSA9IHRvb2xiYXIuZ2V0V2lkZ2V0WFlQb2ludChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiAtIHNjcm9sbFBvc2l0aW9uLngsIHJlY3QudG9wICsgc2Nyb2xsUG9zaXRpb24ueSwgQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1ApO1xuXG4gICAgICAgIHZhciBlbmRQb3NpdGlvbiA9IFtcbiAgICAgICAgICByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiAtIGhhbGZOb2RlV2lkdGggLSBzY3JvbGxQb3NpdGlvbi54LFxuICAgICAgICAgIHJlY3QudG9wIC0gdG9vbGJhck5vZGUub2Zmc2V0SGVpZ2h0ICsgc2Nyb2xsUG9zaXRpb24ueSAtIGd1dHRlci50b3BcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoZW5kUG9zaXRpb25bMF0gPCAwKSB7XG4gICAgICAgICAgICBlbmRQb3NpdGlvblswXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5kUG9zaXRpb25bMF0gPiB0b3RhbFdpZHRoIC0gdG9vbGJhck5vZGUub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgIGVuZFBvc2l0aW9uWzBdID0gdG90YWxXaWR0aCAtIHRvb2xiYXJOb2RlLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9vbGJhci5tb3ZlVG9Qb2ludCh3aWRnZXRYWSwgZW5kUG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIHRvb2xiYXIgYWNjb3JkaW5nIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2VcbiAqXG4gKiBAbWV0aG9kIGltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFBheWxvYWQsIHNob3VsZCBjb250YWluIHRoZSBzZWxlY3Rpb24gZGF0YSBmb3IgcmV0cmlldmluZyB0aGVcbiAqIGNsaWVudCByZWN0YW5nbGUgb2YgdGhlIHNlbGVjdGVkIGltYWdlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlLCBpbiBhbGwgY2FzZXNcbiAqL1xudmFyIGltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb24gPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5zZWxlY3Rpb25EYXRhID8gcGF5bG9hZC5zZWxlY3Rpb25EYXRhIDogcGF5bG9hZC5lZGl0b3JFdmVudCA/XG4gICAgICAgICAgICBwYXlsb2FkLmVkaXRvckV2ZW50LmRhdGEuc2VsZWN0aW9uRGF0YSA6IG51bGw7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbkRhdGEgJiYgc2VsZWN0aW9uRGF0YS5lbGVtZW50KSB7XG4gICAgICAgICAgICBjZW50ZXJUb29sYmFyKHRoaXMsIHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXRDbGllbnRSZWN0KCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIHRvb2xiYXIgYWNjb3JkaW5nIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2VcbiAqXG4gKiBAbWV0aG9kIHRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIE9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIHNlbGVjdGlvbiBkYXRhIGZvciByZXRyaWV2aW5nIHRoZVxuICogY2xpZW50IHJlY3RhbmdsZSBvZiB0aGUgc2VsZWN0ZWQgdGFibGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUsIGluIGFsbCBjYXNlc1xuICovXG52YXIgdGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciB1aU5vZGUgPSBuYXRpdmVFZGl0b3IuY29uZmlnLnVpTm9kZTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdWlOb2RlID8gdWlOb2RlLnNjcm9sbFRvcCA6IDA7XG5cbiAgICAgICAgdmFyIHRhYmxlID0gbmV3IENLRURJVE9SLlRhYmxlKG5hdGl2ZUVkaXRvcikuZ2V0RnJvbVNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgcmVjdCA9IHRhYmxlLmdldENsaWVudFJlY3QoKTtcbiAgICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGNlbnRlclRvb2xiYXIodGhpcywgcmVjdCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25TZXRQb3NpdGlvbiA9IHtcbiAgICBpbWFnZTogaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvbixcbiAgICB0YWJsZTogdGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvblxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uU2V0UG9zaXRpb247IiwidmFyIF9pc1JhbmdlQXRFbGVtZW50RW5kID0gZnVuY3Rpb24ocmFuZ2UsIGVsZW1lbnQpIHtcbiAgICAvLyBGaW5kaW5nIGlmIGEgcmFuZ2UgaXMgYXQgdGhlIGVuZCBvZiBhbiBlbGVtZW50IGlzIHNvbWV3aGF0IHRyaWNreSBkdWUgdG8gaG93IENLRWRpdG9yIGhhbmRsZXNcbiAgICAvLyByYW5nZXMuIEl0IG1pZ2h0IGRlcGVuZCBvbiB3ZXRoZXIgYSBzb3VyY2Ugbm9kZSBpbnNpZGUgdGhlIGVsZW1lbnQgaXMgc2VsZWN0ZWQgb3Igbm90LiBGb3Igbm93LFxuICAgIC8vIHdlIG5lZWQgdG8gY292ZXIgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAvL1xuICAgIC8vIC0gVGhlIHRleHQgbGVuZ3RoIG9mIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIGFzIHRoZSBlbmRPZmZzZXQgb2YgdGhlIHJhbmdlXG4gICAgLy8gLSBCb3RoIHN0YXJ0IGFuZCBlbmQgY29udGFpbmVycyBtYXRjaCB0aGUgZWxlbWVudCBhbmQgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBhcmUgMVxuXG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0VGV4dCgpLmxlbmd0aCA9PT0gcmFuZ2UuZW5kT2Zmc2V0IHx8XG4gICAgICAgIChcbiAgICAgICAgICAgIGVsZW1lbnQuZXF1YWxzKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSAmJlxuICAgICAgICAgICAgZWxlbWVudC5lcXVhbHMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJlxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLmVuZE9mZnNldCAmJlxuICAgICAgICAgICAgcmFuZ2UuZW5kT2Zmc2V0ID09PSAxXG4gICAgICAgICk7XG59O1xuXG52YXIgZW1iZWRTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IHBheWxvYWQuZGF0YS5zZWxlY3Rpb25EYXRhO1xuXG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgICAgIHNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuICAgICAgICAgICAgc2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS13aWRnZXQnKSA9PT0gJ2FlX2VtYmVkJ1xuICAgICAgICApO1xufTtcblxudmFyIGxpbmtTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHZhciBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgIHZhciByYW5nZSA9IG5hdGl2ZUVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuICAgIHZhciBlbGVtZW50O1xuXG4gICAgcmV0dXJuICEhKFxuICAgICAgICBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpICYmXG4gICAgICAgIChlbGVtZW50ID0gKG5ldyBDS0VESVRPUi5MaW5rKG5hdGl2ZUVkaXRvcikpLmdldEZyb21TZWxlY3Rpb24oKSkgJiZcbiAgICAgICAgZWxlbWVudC5nZXRUZXh0KCkubGVuZ3RoICE9PSByYW5nZS5lbmRPZmZzZXQgJiZcbiAgICAgICAgIWVsZW1lbnQuaXNSZWFkT25seSgpICYmXG4gICAgICAgICFfaXNSYW5nZUF0RWxlbWVudEVuZChyYW5nZSwgZWxlbWVudClcbiAgICApO1xufTtcblxudmFyIGltYWdlU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IHBheWxvYWQuZGF0YS5zZWxlY3Rpb25EYXRhO1xuXG4gICAgcmV0dXJuICEhKFxuICAgICAgICBzZWxlY3Rpb25EYXRhLmVsZW1lbnQgJiZcbiAgICAgICAgc2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldE5hbWUoKSA9PT0gJ2ltZycgJiZcbiAgICAgICAgIXNlbGVjdGlvbkRhdGEuZWxlbWVudC5pc1JlYWRPbmx5KClcbiAgICApO1xufTtcblxudmFyIHRleHRTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHZhciBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgdmFyIHNlbGVjdGlvbkVtcHR5ID0gbmF0aXZlRWRpdG9yLmlzU2VsZWN0aW9uRW1wdHkoKTtcblxuICAgIHZhciBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cbiAgICByZXR1cm4gISEoXG4gICAgICAgICFzZWxlY3Rpb25EYXRhLmVsZW1lbnQgJiZcbiAgICAgICAgc2VsZWN0aW9uRGF0YS5yZWdpb24gJiZcbiAgICAgICAgIXNlbGVjdGlvbkVtcHR5ICYmXG4gICAgICAgICFuYXRpdmVFZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0Q29tbW9uQW5jZXN0b3IoKS5pc1JlYWRPbmx5KClcbiAgICApO1xufTtcblxudmFyIHRhYmxlU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICB2YXIgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgIHZhciB0YWJsZSA9IG5ldyBDS0VESVRPUi5UYWJsZShuYXRpdmVFZGl0b3IpO1xuICAgIHZhciBlbGVtZW50ID0gdGFibGUuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgcmV0dXJuICEhKGVsZW1lbnQgJiYgdGFibGUuaXNFZGl0YWJsZShlbGVtZW50KSk7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25UZXN0ID0ge1xuICAgIGVtYmVkOiBlbWJlZFNlbGVjdGlvblRlc3QsXG4gICAgaW1hZ2U6IGltYWdlU2VsZWN0aW9uVGVzdCxcbiAgICBsaW5rOiBsaW5rU2VsZWN0aW9uVGVzdCxcbiAgICB0YWJsZTogdGFibGVTZWxlY3Rpb25UZXN0LFxuICAgIHRleHQ6IHRleHRTZWxlY3Rpb25UZXN0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb25UZXN0OyIsImltcG9ydCBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgZnJvbSAnLi9zZWxlY3Rpb24tYXJyb3dib3guanMnO1xuaW1wb3J0IFNlbGVjdGlvblNldFBvc2l0aW9uIGZyb20gJy4vc2VsZWN0aW9uLXBvc2l0aW9uLmpzJztcbmltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4vc2VsZWN0aW9uLXRlc3QuanMnO1xuXG5jb25zdCBTZWxlY3Rpb25zID0gW3tcbiAgICBuYW1lOiAnZW1iZWQnLFxuICAgIGJ1dHRvbnM6IFsnZW1iZWRSZW1vdmUnLCdlbWJlZEVkaXQnXSxcbiAgICB0ZXN0OiBTZWxlY3Rpb25UZXN0LmVtYmVkXG59LCB7XG4gICAgbmFtZTogJ2xpbmsnLFxuICAgIGJ1dHRvbnM6IFsnbGlua0VkaXQnXSxcbiAgICB0ZXN0OiBTZWxlY3Rpb25UZXN0Lmxpbmtcbn0sIHtcbiAgICBuYW1lOiAnaW1hZ2UnLFxuICAgIGJ1dHRvbnM6IFsnaW1hZ2VMZWZ0JywgJ2ltYWdlQ2VudGVyJywgJ2ltYWdlUmlnaHQnXSxcbiAgICBzZXRQb3NpdGlvbjogU2VsZWN0aW9uU2V0UG9zaXRpb24uaW1hZ2UsXG4gICAgdGVzdDogU2VsZWN0aW9uVGVzdC5pbWFnZVxufSwge1xuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBidXR0b25zOiB7XG4gICAgICAgIGZ1bGw6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnRm9udCcsICdGb250U2l6ZScsICdzZXBhcmF0b3InLCAnYm9sZCcsICdpdGFsaWMnLFxuICAgICAgICAgICAgICAgICd1bmRlcmxpbmUnLCAnc3RyaWtlJywgJ3NlcGFyYXRvcicsICdsaW5rJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAncGFyYWdyYXBoQWxpZ24nLCAnc2VwYXJhdG9yJywgJ3VsJywgJ29sJywgJ3NlcGFyYXRvcicsICdoMScsICdoMicsXG4gICAgICAgICAgICAgICAgJ3NlcGFyYXRvcicsICdpbmRlbnRCbG9jaycsICdvdXRkZW50QmxvY2snLCAnc2VwYXJhdG9yJyxcbiAgICAgICAgICAgICAgICAnVGV4dENvbG9yJywgJ0JHQ29sb3InLCAnc2VwYXJhdG9yJywgJ2NvZGUnLCAncXVvdGUnLCAnc2VwYXJhdG9yJywgJ3JlbW92ZUZvcm1hdCdcbiAgICAgICAgICAgIF1cbiAgICAgICAgXSxcbiAgICAgICAgc2ltcGxlOiBbJ3N0eWxlcycsICdib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnbGluayddXG4gICAgfSxcbiAgICB0ZXN0OiBTZWxlY3Rpb25UZXN0LnRleHRcbn0sIHtcbiAgICBuYW1lOiAndGFibGUnLFxuICAgIGJ1dHRvbnM6IFsndGFibGVIZWFkaW5nJywgJ3RhYmxlUm93JywgJ3RhYmxlQ29sdW1uJywgJ3RhYmxlQ2VsbCcsICd0YWJsZVJlbW92ZSddLFxuICAgIGdldEFycm93Qm94Q2xhc3NlczogU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzLnRhYmxlLFxuICAgIHNldFBvc2l0aW9uOiBTZWxlY3Rpb25TZXRQb3NpdGlvbi50YWJsZSxcbiAgICB0ZXN0OiBTZWxlY3Rpb25UZXN0LnRhYmxlXG59XTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uczsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W3VuZGVmaW5lZF07IH0oKSk7IiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1t1bmRlZmluZWRdOyB9KCkpOyJdLCJzb3VyY2VSb290IjoiIn0=