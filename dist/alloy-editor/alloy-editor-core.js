window["AlloyEditor"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/adapter/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/adapter/core.js":
/*!*****************************!*\
  !*** ./src/adapter/core.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

__webpack_require__(/*! ../core */ "./src/core/index.js");

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

__webpack_require__(/*! ../components/uibridge/uibridge.js */ "./src/components/uibridge/uibridge.js");

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _base = __webpack_require__(/*! ../oop/base */ "./src/oop/base.js");

var _base2 = _interopRequireDefault(_base);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _main = __webpack_require__(/*! ../components/main.jsx */ "./src/components/main.jsx");

var _main2 = _interopRequireDefault(_main);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * AlloyEditor main class. Creates instance of the editor and provides the user configuration
 * to the UI.
 *
 * @class Core
 * @constructor
 */
function Core(config) {
    Core.superclass.constructor.call(this, config);
}

(0, _oop2.default)(Core, _base2.default, {
    /**
     * Initializer lifecycle implementation for the AlloyEditor class. Creates a CKEditor
     * instance, passing it the provided configuration attributes.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method initializer
     * @param config {Object} Configuration object literal for the editor.
     */
    initializer: function initializer(config) {
        var node = this.get('srcNode');

        if (this.get('enableContentEditable')) {
            node.setAttribute('contenteditable', 'true');
        }

        var editor = CKEDITOR.inline(node);

        editor.config.allowedContent = this.get('allowedContent');

        editor.config.toolbars = this.get('toolbars');

        editor.config.removePlugins = this.get('removePlugins');
        editor.config.extraPlugins = this.get('extraPlugins');
        editor.config.placeholderClass = this.get('placeholderClass');

        editor.config.pasteFromWordRemoveStyles = false;
        editor.config.pasteFromWordRemoveFontStyles = false;

        editor.config.selectionKeystrokes = this.get('selectionKeystrokes');

        _lang2.default.mix(editor.config, config);

        if (CKEDITOR.env.ie && !CKEDITOR.env.edge) {
            editor.config.extraPlugins = editor.config.extraPlugins.replace('ae_dragresize', 'ae_dragresize_ie');
            editor.config.removePlugins = editor.config.removePlugins.replace('ae_dragresize', 'ae_dragresize_ie');
        }

        editor.once('contentDom', function () {

            this._addReadOnlyLinkClickListener(editor);

            var editable = editor.editable();

            editable.addClass('ae-editable');
        }.bind(this));

        this._editor = editor;

        AlloyEditor.loadLanguageResources(this._renderUI.bind(this));
    },

    /**
     * Destructor lifecycle implementation for the AlloyEdtor class. Destroys the CKEditor
     * instance and destroys all created toolbars.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method destructor
     */
    destructor: function destructor() {
        this._destroyed = true;

        if (this._editorUIElement) {
            _reactDom2.default.unmountComponentAtNode(this._editorUIElement);
            this._editorUIElement.parentNode.removeChild(this._editorUIElement);
        }

        var nativeEditor = this.get('nativeEditor');

        if (nativeEditor) {
            var editable = nativeEditor.editable();

            if (editable) {
                editable.removeClass('ae-editable');

                if (this.get('enableContentEditable')) {
                    this.get('srcNode').setAttribute('contenteditable', 'false');
                }
            }

            this._clearSelections();

            nativeEditor.destroy();
        }
    },

    /**
     * Clear selections from window object
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _clearSelections
     */
    _clearSelections: function _clearSelections() {
        var nativeEditor = this.get('nativeEditor');
        var isMSSelection = typeof window.getSelection != 'function';

        if (isMSSelection) {
            nativeEditor.document.$.selection.empty();
        } else {
            nativeEditor.document.getWindow().$.getSelection().removeAllRanges();
        }
    },

    /**
     * Method to set default link behavior
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _addReadOnlyLinkClickListener
     * @param {Object} editor
     */
    _addReadOnlyLinkClickListener: function _addReadOnlyLinkClickListener(editor) {
        editor.editable().on('click', this._defaultReadOnlyClickFn, this, {
            editor: editor
        });
    },

    /**
     * Called on `click` event when the editor is in read only mode. Navigates to link's URL or opens
     * the link in a new window.
     *
     * @memberof Core
     * @instance
     * @event readOnlyClick
     * @protected
     * @method _defaultReadOnlyClickFn
     * @param {Object} event The fired `click` event payload
     */
    _defaultReadOnlyClickFn: function _defaultReadOnlyClickFn(event) {
        var mouseEvent = event.data.$;
        var hasCtrlKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
        var shouldOpen = this._editor.config.readOnly || hasCtrlKey;

        mouseEvent.preventDefault();

        if (!shouldOpen) {
            return;
        }

        if (event.listenerData.editor.editable().editor.fire('readOnlyClick', event.data) !== false) {
            var ckElement = new CKEDITOR.dom.elementPath(event.data.getTarget(), this);
            var link = ckElement.lastElement;

            if (link) {
                var href = link.$.attributes.href ? link.$.attributes.href.value : null;
                var target = hasCtrlKey ? '_blank' : link.$.attributes.target ? link.$.attributes.target.value : null;
                this._redirectLink(href, target);
            }
        }
    },

    /**
     * Retrieves the native CKEditor instance. Having this, the developer may use the API of CKEditor OOTB.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _getNativeEditor
     * @return {Object} The current instance of CKEditor.
     */
    _getNativeEditor: function _getNativeEditor() {
        return this._editor;
    },

    /**
     * Redirects the browser to a given link
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _redirectLink
     * @param {string} href The href to take the browser to
     * @param {string=} target Specifies where to display the link
     */
    _redirectLink: function _redirectLink(href, target) {
        if (target && href) {
            window.open(href, target);
        } else if (href) {
            window.location.href = href;
        }
    },

    /**
     * Renders the specified from the user toolbars.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _renderUI
     */
    _renderUI: function _renderUI() {
        if (!this._destroyed) {
            var editorUIElement = document.createElement('div');
            editorUIElement.className = 'ae-ui';

            var uiNode = this.get('uiNode') || document.body;

            uiNode.appendChild(editorUIElement);

            this._mainUI = _reactDom2.default.render(_react2.default.createElement(_main2.default, {
                editor: this,
                eventsDelay: this.get('eventsDelay'),
                toolbars: this.get('toolbars') }), editorUIElement);

            this._editorUIElement = editorUIElement;

            this.get('nativeEditor').fire('uiReady');
        }
    },

    /**
     * The function returns an HTML element from the passed value. If the passed value is a string, it should be
     * the Id of the element which have to be retrieved from the DOM.
     * If an HTML Element is passed, the element itself will be returned.
     *
     * @memberof Core
     * @instance
     * @method _toElement
     * @protected
     * @param {!(String|HTMLElement)} value String, which have to correspond to an HTML element from the DOM,
     * or the HTML element itself. If Id is passed, the HTML element will be retrieved from the DOM.
     * @return {HTMLElement} An HTML element.
     */
    _toElement: function _toElement(value) {
        if (_lang2.default.isString(value)) {
            value = document.getElementById(value);
        }

        return value;
    },

    /**
     * Validates the allowed content attribute. Look
     * [here](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent) for more information about the
     * supported values.
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _validateAllowedContent
     * @param {Any} The value to be checked
     * @return {Boolean} True if the current value is valid configuration, false otherwise
     */
    _validateAllowedContent: function _validateAllowedContent(value) {
        return _lang2.default.isString(value) || _lang2.default.isObject(value) || _lang2.default.isBoolean(value);
    },

    /**
     * Validates the value of toolbars attribute
     *
     * @memberof Core
     * @instance
     * @protected
     * @method _validateToolbars
     * @param {Any} The value to be checked
     * @return {Boolean} True if the current value is valid toolbars configuration, false otherwise
     */
    _validateToolbars: function _validateToolbars(value) {
        return _lang2.default.isObject(value) || _lang2.default.isNull(value);
    }
}, {
    ATTRS: {
        /**
         * Configures the allowed content for the current instance of AlloyEditor.
         * Look on the [official CKEditor API](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent)
         * for more information about the valid values.
         *
         * @memberof Core
         * @instance
         * @property allowedContent
         * @default true
         * @writeOnce
         * @type {Boolean, String, Object}
         */
        allowedContent: {
            validator: '_validateAllowedContent',
            value: true,
            writeOnce: true
        },

        /**
         * Specifies whether AlloyEditor set the contenteditable attribute
         * to "true" on its srcNode.
         *
         * @memberof Core
         * @instance
         * @property enableContentEditable
         * @type Boolean
         * @default true
         * @writeOnce
         */
        enableContentEditable: {
            validator: _lang2.default.isBoolean,
            value: true,
            writeOnce: true
        },

        /**
         * The delay (timeout), in ms, after which events such like key or mouse events will be processed.
         *
         * @memberof Core
         * @instance
         * @property eventsDelay
         * @type {Number}
         */
        eventsDelay: {
            validator: _lang2.default.isNumber,
            value: 100
        },

        /**
         * Specifies the extra plugins which have to be loaded to the current CKEditor instance in order to
         * make AlloyEditor to work properly.
         *
         * @memberof Core
         * @instance
         * @property extraPlugins
         * @default 'uicore,selectionregion,dragresize,addimages,placeholder,tabletools,tableresize,autolink'
         * @writeOnce
         * @type {String}
         */
        extraPlugins: {
            validator: _lang2.default.isString,
            value: 'ae_uicore,ae_selectionregion,ae_selectionkeystrokes,ae_imagealignment,ae_addimages,ae_placeholder,' + 'ae_tabletools,ae_tableresize,ae_autolink,ae_embed,ae_autolist,ae_dragresize,' + 'ae_uibridge',
            //'ae_uibridge,ae_richcombobridge,ae_panelmenubuttonbridge,ae_menubridge,ae_menubuttonbridge,ae_buttonbridge',
            writeOnce: true
        },

        /**
         * Retrieves the native CKEditor instance. Having this, the developer may use the full API of CKEditor.
         *
         * @memberof Core
         * @instance
         * @property nativeEditor
         * @readOnly
         * @type {Object}
         */
        nativeEditor: {
            getter: '_getNativeEditor',
            readOnly: true
        },

        /**
         * Specifies the class, which should be added by Placeholder plugin
         * {{#crossLink "CKEDITOR.plugins.ae_placeholder}}{{/crossLink}}
         * when editor is not focused.
         *
         * @memberof Core
         * @instance
         * @property placeholderClass
         * @default 'ae-placeholder'
         * @writeOnce
         * @type {String}
         */
        placeholderClass: {
            validator: _lang2.default.isString,
            value: 'ae-placeholder',
            writeOnce: true
        },

        /**
         * Specifies the plugins, which come by default with CKEditor, but which are not needed by AlloyEditor.
         * These plugins add the default UI for CKeditor, which is no more needed. Please note that AlloyEdtor
         * comes with its own highly optimized copy of CKEditor (just customized via their official download page).
         * This version does not come with the unneeded plugins, so the value of this property won't be needed.
         * However, if you decide to go with the OOTB version of CKEditor, you will have to remove some of the
         * plugins if you decide to use AlloyEditor. Keep in mind that removing these plugins doesn't remove them
         * entirely from CKEditor. It just removes them from its current instance, in which you will use different
         * UI - those of AlloyEditor. You will be fully able to use both OOTB CKEditor and AlloyEditor on the same
         * page!
         *
         * @memberof Core
         * @instance
         * @property removePlugins
         * @default 'contextmenu,toolbar,elementspath,resize,liststyle,link'
         * @writeOnce
         * @type {String}
         */
        removePlugins: {
            validator: _lang2.default.isString,
            value: 'contextmenu,toolbar,elementspath,resize,liststyle,link',
            writeOnce: true
        },

        /**
         * Array of manual selection triggers. They can be configured to manually show a specific selection toolbar
         * by forcing the selection type. A selectionKeystroke item consists of a keys property with a [CKEditor keystroke
         * definition](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-keystrokes) and a selection property with
         * the selection name to trigger.
         *
         * @memberof Core
         * @instance
         * @property selectionKeystrokes
         * @type {Array}
         */
        selectionKeystrokes: {
            validator: _lang2.default.isArray,
            value: [{
                keys: CKEDITOR.CTRL + 76 /*L*/
                , selection: 'link'
            }, {
                keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /*L*/
                , selection: 'embed'
            }]
        },

        /**
         * The Node ID or HTMl node, which AlloyEditor should use as an editable area.
         *
         * @memberof Core
         * @instance
         * @property srcNode
         * @type String | Node
         * @writeOnce
         */
        srcNode: {
            setter: '_toElement',
            writeOnce: true
        },

        /**
         * The toolbars configuration for this editor instance
         *
         * @memberof Core
         * @instance
         * @property {Object} toolbars
         */
        toolbars: {
            validator: '_validateToolbars',
            value: {
                add: {
                    buttons: ['image', 'embed', 'camera', 'hline', 'table'],
                    tabIndex: 2
                },
                styles: {
                    selections: _selections2.default,
                    tabIndex: 1
                }
            }
        },

        /**
         * The Node ID or HTMl node, where AlloyEditor's UI should be rendered.
         *
         * @memberof Core
         * @instance
         * @property uiNode
         * @type String | Node
         * @writeOnce
         */
        uiNode: {
            setter: '_toElement',
            writeOnce: true
        }
    }
});

CKEDITOR.event.implementOn(Core);

exports.default = Core;

/***/ }),

/***/ "./src/adapter/main.js":
/*!*****************************!*\
  !*** ./src/adapter/main.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Toolbars = exports.SelectionTest = exports.SelectionSetPosition = exports.Selections = exports.SelectionGetArrowBoxClasses = exports.registerBridgeButton = exports.OOP = exports.loadLanguageResources = exports.Lang = exports.implementEventTarget = exports.getUrl = exports.getButtons = exports.getBasePath = exports.editable = exports.Core = exports.Buttons = exports.Attribute = undefined;

var _core = __webpack_require__(/*! ./core.js */ "./src/adapter/core.js");

var _core2 = _interopRequireDefault(_core);

var _lang = __webpack_require__(/*! ../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _buttons = __webpack_require__(/*! ../components/buttons */ "./src/components/buttons/index.js");

var _buttons2 = _interopRequireDefault(_buttons);

var _toolbars = __webpack_require__(/*! ../components/toolbars */ "./src/components/toolbars/index.js");

var _toolbars2 = _interopRequireDefault(_toolbars);

var _selectionArrowbox = __webpack_require__(/*! ../selections/selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _selectionPosition = __webpack_require__(/*! ../selections/selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

var _attribute = __webpack_require__(/*! ../oop/attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// An object containing all currently registered plugins in AlloyEditor.
var BRIDGE_BUTTONS = {};

/**
 * Creates an instance of AlloyEditor.
 *
 * @memberof AlloyEditor
 * @method editable
 * @static
 * @param {String|Node} node The Node ID or HTMl node, which AlloyEditor should use as an editable area.
 * @param {Object} config Configuration attributes for the current instance of AlloyEditor.
 * @return {Object} An instance of {{#crossLink "Core"}}{{/crossLink}}
 */
var editable = function editable(node, config) {
    config = config || {};
    config.srcNode = node;

    AlloyEditor.implementEventTarget();

    return new _core2.default(config);
};

/**
 * The full URL for the AlloyEditor installation directory.
 * It is possible to manually provide the base path by setting a
 * global variable named `ALLOYEDITOR_BASEPATH`. This global variable
 * must be set **before** the editor script loading.
 *
 * @memberof AlloyEditor
 * @method getBasePath
 * @static
 * @return {String} The found base path
 */
var getBasePath = function getBasePath() {
    // Find out the editor directory path, based on its <script> tag.
    var path = window.ALLOYEDITOR_BASEPATH || '';

    if (!path) {
        var scripts = document.getElementsByTagName('script');

        for (var i = 0; i < scripts.length; i++) {
            var match = scripts[i].src.match(AlloyEditor.regexBasePath);

            if (match) {
                path = match[1];
                break;
            }
        }
    }

    // In IE (only) the script.src string is the raw value entered in the
    // HTML source. Other browsers return the full resolved URL instead.
    if (path.indexOf(':/') === -1 && path.slice(0, 2) !== '//') {
        // Absolute path.
        if (path.indexOf('/') === 0) {
            path = location.href.match(/^.*?:\/\/[^\/]*/)[0] + path;
        }
        // Relative path.
        else {
                path = location.href.match(/^[^\?]*\/(?:)/)[0] + path;
            }
    }

    if (!path) {
        throw 'The AlloyEditor installation path could not be automatically detected. Please set the global variable "ALLOYEDITOR_BASEPATH" before creating editor instances.';
    }

    return path;
};

/**
 * Detects and load the corresponding language file if AlloyEditor language strings are not already present.
 * The function fires a {{#crossLink "AlloyEditor/languageResourcesLoaded:event"}}{{/crossLink}} event
 *
 * @memberof AlloyEditor
 * @method loadLanguageResources
 * @static
 * @param {Function} callback Optional callback to be called when AlloyEditor loads the language resource.
 */
var loadLanguageResources = function loadLanguageResources(callback) {
    AlloyEditor.implementEventTarget();

    if (_lang2.default.isFunction(callback)) {
        if (AlloyEditor.Strings) {
            setTimeout(callback, 0);
        } else {
            AlloyEditor.once('languageResourcesLoaded', function () {
                setTimeout(callback, 0);
            });
        }
    }

    if (!AlloyEditor._langResourceRequested) {
        AlloyEditor._langResourceRequested = true;

        var languages = ['af', 'ar', 'bg', 'bn', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fo', 'fr-ca', 'fr', 'gl', 'gu', 'he', 'hi', 'hr', 'hu', 'id', 'is', 'it', 'ja', 'ka', 'km', 'ko', 'ku', 'lt', 'lv', 'mk', 'mn', 'ms', 'nb', 'nl', 'no', 'pl', 'pt-br', 'pt', 'ro', 'ru', 'si', 'sk', 'sl', 'sq', 'sr-latn', 'sr', 'sv', 'th', 'tr', 'tt', 'ug', 'uk', 'vi', 'zh-cn', 'zh'];

        var userLanguage = navigator.language || navigator.userLanguage || 'en';

        var parts = userLanguage.toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/);
        var lang = parts[1];
        var locale = parts[2];

        if (languages.indexOf(lang + '-' + locale) >= 0) {
            lang = lang + '-' + locale;
        } else if (languages.indexOf(lang) === -1) {
            lang = 'en';
        }

        CKEDITOR.scriptLoader.load(AlloyEditor.getUrl('lang/alloy-editor/' + lang + '.js'), function (loaded) {
            if (loaded) {
                AlloyEditor.fire('languageResourcesLoaded');
            }
        }, this);
    }
};

/**
 * Gets the full URL for AlloyEditor resources. By default, URLs
 * returned by this function contain a querystring parameter ("t")
 * set to the {@link CKEDITOR#timestamp} value.
 *
 * @memberof AlloyEditor
 * @method getUrl
 * @static
 * @param {String} resource The resource whose full URL we want to get.
 * It may be a full, absolute, or relative URL.
 * @return {String} The full URL.
 */
var getUrl = function getUrl(resource) {
    var basePath = AlloyEditor.getBasePath();

    // If this is not a full or absolute path.
    if (resource.indexOf(':/') === -1 && resource.indexOf('/') !== 0) {
        resource = basePath + resource;
    }

    // Add the timestamp, except for directories.
    if (CKEDITOR.timestamp && resource.charAt(resource.length - 1) !== '/' && !/[&?]t=/.test(resource)) {
        resource += (resource.indexOf('?') >= 0 ? '&' : '?') + 't=' + CKEDITOR.timestamp;
    }

    return resource;
};

/**
 * Implements event firing and subscribing via CKEDITOR.event.
 *
 * @memberof AlloyEditor
 * @method implementEventTarget
 * @static
 */
var implementEventTarget = function implementEventTarget() {
    if (!AlloyEditor.fire && !AlloyEditor.on) {
        CKEDITOR.event.implementOn(AlloyEditor);
    }
};

/**
 * Regular expression which should match the script which have been used to load AlloyEditor.
 *
 * @memberof AlloyEditor
 * @property regexBasePath
 * @type {RegExp}
 * @static
 */
var regexBasePath = /(^|.*[\\\/])(?:alloy-editor[^/]+|alloy-editor)\.js(?:\?.*|;.*)?$/i;

/**
 * Fired when AlloyEditor detects the browser language and loads the corresponding language file. Once this event
 * is fired, AlloyEditor.Strings will be populated with data.
 *
 * @event languageResourcesLoaded
 */

/**
 * Returns the required plugin names needed for a given plugin
 * if it is already registered or an empty array.
 *
 * @memberof AlloyEditor
 * @method getButtons
 * @param {Array} buttons An array of buttons or plugin names.
 * @return {Function} A function that can be invoked to resolve the requested button names.
 * @static
 */
var getButtons = function getButtons(buttons) {
    return function () {
        return buttons.reduce(function (acc, val) {
            val = BRIDGE_BUTTONS[val] || [val];
            return acc.concat(val);
        }, []);
    };
};

/**
 * Register a button and try to get its required plugins.
 *
 * @memberof AlloyEditor
 * @method registerBridgeButton
 * @param {String} buttonName The name of the button.
 * @param {String} pluginName The name of the plugin that registers the button.
 * @static
 */
var registerBridgeButton = function registerBridgeButton(buttonName, pluginName) {
    if (!BRIDGE_BUTTONS[pluginName]) {
        BRIDGE_BUTTONS[pluginName] = [];
    }

    BRIDGE_BUTTONS[pluginName].push(buttonName);
};

/**
 * @method OOP
 * @memberof AlloyEditor
 */
var OOP = {
    extend: _oop2.default
};

exports.Attribute = _attribute2.default;
exports.Buttons = _buttons2.default;
exports.Core = _core2.default;
exports.editable = editable;
exports.getBasePath = getBasePath;
exports.getButtons = getButtons;
exports.getUrl = getUrl;
exports.implementEventTarget = implementEventTarget;
exports.Lang = _lang2.default;
exports.loadLanguageResources = loadLanguageResources;
exports.OOP = OOP;
exports.registerBridgeButton = registerBridgeButton;
exports.SelectionGetArrowBoxClasses = _selectionArrowbox2.default;
exports.Selections = _selections2.default;
exports.SelectionSetPosition = _selectionPosition2.default;
exports.SelectionTest = _selectionTest2.default;
exports.Toolbars = _toolbars2.default;

/***/ }),

/***/ "./src/components/base/button-action-style.js":
/*!****************************************************!*\
  !*** ./src/components/base/button-action-style.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonActionStyle is a mixin that provides applying style implementation for a
 * button based on the `applyStyle` and `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following methods which can be obtained
 * out of the box using the {{#crossLink "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to return the style that should be applied
 *
 * @class ButtonActionStyle
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'applyStyle',

            /**
             * Removes or applies the component style to the current selection.
             *
             * @instance
             * @memberof ButtonActionStyle
             * @method applyStyle
             */
            value: function applyStyle() {
                if (_lang2.default.isFunction(this.isActive) && _lang2.default.isFunction(this.getStyle)) {
                    var editor = this.props.editor.get('nativeEditor');

                    editor.getSelection().lock();

                    if (this.isActive()) {
                        editor.removeStyle(this.getStyle());
                    } else {
                        editor.applyStyle(this.getStyle());
                    }

                    editor.getSelection().unlock();

                    editor.fire('actionPerformed', this);
                }
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-command-active.js":
/*!******************************************************!*\
  !*** ./src/components/base/button-command-active.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to determine if
 * a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
exports.default = function (WrappedComponent) {
  return function (_WrappedComponent) {
    _inherits(_class, _WrappedComponent);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'isActive',

      /**
       * Checks if the command is active in the current selection.
       *
       * @instance
       * @memberof ButtonCommandActive
       * @method isActive
       * @return {Boolean} True if the command is active, false otherwise.
       */
      value: function isActive() {
        var editor = this.props.editor.get('nativeEditor');

        var command = editor.getCommand(this.props.command);

        return command ? command.state === CKEDITOR.TRISTATE_ON : false;
      }
    }]);

    return _class;
  }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-command.js":
/*!***********************************************!*\
  !*** ./src/components/base/button-command.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'execCommand',

            /**
             * Executes a CKEditor command and fires `actionPerformed` event.
             *
             * @instance
             * @memberof ButtonCommand
             * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
             * @method execCommand
             */
            value: function execCommand(data) {
                var editor = this.props.editor.get('nativeEditor');

                editor.execCommand(this.props.command, data);

                if (this.props.modifiesSelection) {
                    editor.selectionChange(true);
                }

                editor.fire('actionPerformed', this);
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-keystroke.js":
/*!*************************************************!*\
  !*** ./src/components/base/button-keystroke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentWillMount',

            /**
             * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
             *
             * @instance
             * @memberof ButtonKeystroke
             * @method componentWillMount
             */
            value: function componentWillMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this).call(this);
                }

                var nativeEditor = this.props.editor.get('nativeEditor');
                var keystroke = this.props.keystroke;

                var commandName = keystroke.name || (Math.random() * 1e9 >>> 0).toString();

                var command = nativeEditor.getCommand(commandName);

                if (!command) {
                    command = new CKEDITOR.command(nativeEditor, {
                        exec: function (editor) {
                            var keystrokeFn = keystroke.fn;

                            if (_lang2.default.isString(keystrokeFn)) {
                                this[keystrokeFn].call(this, editor);
                            } else if (_lang2.default.isFunction(keystrokeFn)) {
                                keystrokeFn.call(this, editor);
                            }
                        }.bind(this)
                    });

                    nativeEditor.addCommand(commandName, command);
                }

                this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

                nativeEditor.setKeystroke(keystroke.keys, commandName);
            }

            /**
             * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
             *
             * @instance
             * @memberof ButtonKeystroke
             * @method componentWillUnmount
             */

        }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this).call(this);
                }

                this.props.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-props.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-props.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCfgProps is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonCfgProps
 */
exports.default = function (WrappedComponent) {
  return function (_WrappedComponent) {
    _inherits(_class, _WrappedComponent);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'mergeButtonCfgProps',

      /**
       * Merges the properties, passed to the current component with user's configuration
       * via `buttonCfg` property.
       *
       * @instance
       * @memberof ButtonCfgProps
       * @method mergeButtonCfgProps
       * @param {Object} props The properties to be merged with the provided configuration for this
       * button. If not passed, the user configuration will be merged with `this.props`
       * @return {Object} The merged properties
       */
      value: function mergeButtonCfgProps(props) {
        props = props || this.props;

        var nativeEditor = this.props.editor.get('nativeEditor');
        var buttonCfg = nativeEditor.config.buttonCfg || {};
        var result = CKEDITOR.tools.merge(props, buttonCfg['linkEdit']);

        return result;
      }
    }]);

    return _class;
  }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-state-classes.js":
/*!*****************************************************!*\
  !*** ./src/components/base/button-state-classes.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 * - `Function` **isDisabled** to check the disabled state
 *
 * @class ButtonStateClasses
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getStateClasses',

            /**
             * Returns the list of state classes associated to the current element's state, according
             * to the results of the isActive and isDisabled methods.
             *
             * @instance
             * @memberof ButtonStateClasses
             * @method getStateClasses
             * @return {String} A string with the state CSS classes.
             */
            value: function getStateClasses() {
                var stateClasses = '';

                // Check for active state
                if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
                    stateClasses += 'ae-button-pressed';
                }

                // Check for disabled state
                if (_lang2.default.isFunction(this.isDisabled) && this.isDisabled()) {
                    stateClasses += ' ae-button-disabled';
                }

                return stateClasses;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-style.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-style.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonStyle
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentWillMount',

            /**
             * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
             *
             * @instance
             * @memberof ButtonStyle
             * @method componentWillMount
             */
            value: function componentWillMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillMount', this).call(this);
                }

                var style = this.props.style;

                if (_lang2.default.isString(style)) {
                    var parts = style.split('.');
                    var currentMember = this.props.editor.get('nativeEditor').config;
                    var property = parts.shift();

                    while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
                        currentMember = currentMember[property];
                        property = parts.shift();
                    }

                    if (_lang2.default.isObject(currentMember)) {
                        style = currentMember;
                    }
                }

                this._style = new CKEDITOR.style(style);
            }

            /**
             * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
             *
             * @instance
             * @memberof ButtonStyle
             * @method componentWillUnmount
             */

        }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillUnmount', this).call(this);
                }

                this._style = null;
            }

            /**
             * Returns instance of CKEDITOR.style which represents the current button style.
             *
             * @instance
             * @memberof ButtonStyle
             * @method getStyle
             * @return {CKEDITOR.style} The current style representation.
             */

        }, {
            key: 'getStyle',
            value: function getStyle() {
                return this._style;
            }

            /**
             * Checks if style is active in the current selection.
             *
             * @instance
             * @memberof ButtonStyle
             * @method isActive
             * @return {Boolean} True if style is active, false otherwise.
             */

        }, {
            key: 'isActive',
            value: function isActive() {
                var result;

                var editor = this.props.editor.get('nativeEditor');

                var elementPath = editor.elementPath();

                result = this.getStyle().checkActive(elementPath, editor);

                return result;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/toolbar-buttons.js":
/*!************************************************!*\
  !*** ./src/components/base/toolbar-buttons.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ToolbarButtons is a mixin which provides a list of buttons which have to be
 * displayed on the current toolbar depending on user preferences and given state.
 *
 * @class ToolbarButtons
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getToolbarButtons',

            /**
             * Analyzes the current selection and the buttons exclusive mode value to figure out which
             * buttons should be present in a given state.
             *
             * @instance
             * @memberof ToolbarButtons
             * @method getToolbarButtons
             * @param {Array} buttons The buttons could be shown, prior to the state filtering.
             * @param {Object} additionalProps Additional props that should be passed down to the buttons.
             * @return {Array} An Array which contains the buttons that should be rendered.
             */
            value: function getToolbarButtons(buttons, additionalProps) {
                var buttonProps = {};

                var nativeEditor = this.props.editor.get('nativeEditor');
                var buttonCfg = nativeEditor.config.buttonCfg || {};

                if (_lang2.default.isFunction(buttons)) {
                    buttons = buttons.call(this) || [];
                }

                var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
                    return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
                }).map(function (button) {
                    if (_lang2.default.isString(button)) {
                        buttonProps[button] = buttonCfg[button];
                        button = AlloyEditor.Buttons[button];
                    } else if (_lang2.default.isString(button.name)) {
                        buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
                        button = AlloyEditor.Buttons[button.name];
                    }

                    return button;
                })).map(function (button) {
                    var props = this.mergeExclusiveProps({
                        editor: this.props.editor,
                        key: button.key,
                        tabKey: button.key,
                        tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
                        trigger: this.props.trigger
                    }, button.key);

                    props = this.mergeDropdownProps(props, button.key);

                    if (additionalProps) {
                        props = CKEDITOR.tools.merge(props, additionalProps);
                    }

                    props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

                    return _react2.default.createElement(button, props);
                }, this);

                return toolbarButtons;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-arrow-box.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-arrow-box.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for displaying Widget Arrow box on top or on bottom of the widget
 * depending on the point of user interaction with the editor.
 *
 * @class WidgetArrowBox
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'getArrowBoxClasses',

            /**
             * Returns the list of arrow box classes associated to the current element's state. It relies
             * on the getInteractionPoint method to calculate the selection direction.
             *
             * @instance
             * @memberof WidgetArrowBox
             * @method getArrowBoxClasses
             * @return {String} A string with the arrow box CSS classes.
             */
            value: function getArrowBoxClasses() {
                var arrowBoxClasses = 'ae-arrow-box';

                if (_lang2.default.isFunction(this.getInteractionPoint) && this.getInteractionPoint()) {
                    if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
                        arrowBoxClasses += ' ae-arrow-box-top';
                    } else {
                        arrowBoxClasses += ' ae-arrow-box-bottom';
                    }
                }

                return arrowBoxClasses;
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-dropdown.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-dropdown.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class(props) {
            _classCallCheck(this, _class);

            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));

            _this.state = _extends({}, _this.state, {
                dropdownTrigger: null,
                itemDropdown: null
            });
            return _this;
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof WidgetDropdown
         * @method componentWillReceiveProps
         */


        _createClass(_class, [{
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps) {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this).call(this);
                }

                this.setState({
                    dropdownTrigger: null,
                    itemDropdown: null
                });
            }

            /**
             * Merges the provided object with two more properties:
             * - expanded - boolean flag which indicates if an widget should be rendered exclusively.
             * - toggleDropdown - function, which can be used by an widget in order to obtain exclusive state.
             *
             * @instance
             * @memberof WidgetDropdown
             * @method mergeDropdownProps
             * @param {Object} obj The properties container which should be merged with the properties, related
             *    to dropdown state.
             * @param {Object} itemKey They key of an React Widget which contains the dropdown.
             * @return {Object} The merged object.
             */

        }, {
            key: 'mergeDropdownProps',
            value: function mergeDropdownProps(obj, itemKey) {
                return CKEDITOR.tools.merge(obj, {
                    expanded: this.state.itemDropdown === itemKey ? true : false,
                    tabIndex: this.state.dropdownTrigger === itemKey ? 0 : -1,
                    toggleDropdown: this.toggleDropdown.bind(this, itemKey)
                });
            }

            /**
             * Sets the active dropdown of the widget or discards the toggled item from the state.
             *
             * @instance
             * @memberof WidgetDropdown
             * @method toggleDropdown
             * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
             * @param {Number} toggleDirection User movement direction when toggled via keyboard.
             */

        }, {
            key: 'toggleDropdown',
            value: function toggleDropdown(itemDropdown, toggleDirection) {
                this.setState({
                    dropdownTrigger: itemDropdown,
                    itemDropdown: itemDropdown !== this.state.itemDropdown ? itemDropdown : null
                }, function () {
                    if (!this.state.itemDropdown) {
                        if (this.moveFocus) {
                            this.moveFocus(toggleDirection);
                        } else {
                            _reactDom2.default.findDOMNode(this).focus();
                        }
                    }
                });
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-exclusive.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-exclusive.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'cancelExclusive',

            /**
             * Cancels the exclusive state of an widget.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method cancelExclusive
             * @param {Object} itemExclusive The widget which exclusive state should be canceled.
             */
            value: function cancelExclusive(itemExclusive) {
                if (this.state.itemExclusive === itemExclusive) {
                    this.setState({
                        itemExclusive: null
                    });
                }
            }

            /**
             * Lifecycle. Invoked when a component is receiving new props.
             * This method is not called for the initial render.
             * Calling this.setState() within this function will not trigger an additional render.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method componentWillReceiveProps
             * @param {Object} nextProps Object containing the current set of properties.
             */

        }, {
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps) {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentWillReceiveProps', this).call(this);
                }

                // Receiving properties means that the component is being re-rendered.
                // Re-rendering is triggered by editorInteraction, so we have to
                // reset the exclusive state and render the UI according to the new selection.
                this.setState({
                    itemExclusive: null
                });
            }

            /**
             * Filters the items and returns only those with exclusive state.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method filterExclusive
             * @param {Array} items The widgets to be filtered.
             * @return {Array|Object} The item with executive state.
             */

        }, {
            key: 'filterExclusive',
            value: function filterExclusive(items) {
                return items.filter(function (item) {
                    if (this.state.itemExclusive) {
                        if (this.state.itemExclusive === item.key) {
                            return item;
                        }
                    } else {
                        return item;
                    }
                }.bind(this));
            }

            /**
             * Merges the provided object with three more properties:
             * - cancelExclusive - function, which can be used by a widget in order to cancel executive state.
             * - renderExclusive - boolean flag which indicates if an widget should be rendered exclusively.
             * - requestExclusive - function, which can be used by a widget in order to obtain exclusive state.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method mergeExclusiveProps
             * @param {Object} obj The properties container which should be merged with the properties, related
             *    to exclusive state.
             * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
             * @return {Object} The merged object.
             */

        }, {
            key: 'mergeExclusiveProps',
            value: function mergeExclusiveProps(obj, itemKey) {
                return CKEDITOR.tools.merge(obj, {
                    cancelExclusive: this.cancelExclusive.bind(this, itemKey),
                    renderExclusive: this.state.itemExclusive === itemKey,
                    requestExclusive: this.requestExclusive.bind(this, itemKey)
                });
            }

            /**
             * Requests and sets exclusive state of an widget.
             *
             * @instance
             * @memberof WidgetExclusive
             * @method requestExclusive
             * @param {Object} itemExclusive The widget which requests exclusive state.
             */

        }, {
            key: 'requestExclusive',
            value: function requestExclusive(itemExclusive) {
                this.setState({
                    itemExclusive: itemExclusive
                });
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-focus-manager.js":
/*!*****************************************************!*\
  !*** ./src/components/base/widget-focus-manager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DIRECTION_NONE = 0;
var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */

exports.default = function (WrappedComponent) {
    return function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'componentDidMount',

            /**
             * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method componentDidMount
             */
            value: function componentDidMount() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidMount', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidMount', this).call(this);
                }

                this._refresh();
            }

            /**
             * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
             * Refreshes the descendants list.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method componentDidUpdate
             */

        }, {
            key: 'componentDidUpdate',
            value: function componentDidUpdate() {
                if (_lang2.default.isFunction(_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidUpdate', this))) {
                    _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'componentDidUpdate', this).call(this);
                }

                this._refresh();
            }

            /**
             * Focuses the current active descendant.
             *
             * Several Widgets can be nested in a component hierarchy by attaching this focus method to
             * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method focus
             */

        }, {
            key: 'focus',
            value: function focus(event) {
                if (!event || this._isValidTarget(event.target)) {
                    if (this._descendants && this._descendants.length) {
                        var activeDescendantEl = this._descendants[this._activeDescendant];
                        // When user clicks with the mouse, the activeElement is already set and there
                        // is no need to focus it. Focusing of the active descendant (usually some button) is required
                        // in case of keyboard navigation, because the focused element might be not the first button,
                        // but the div element, which contains the button.
                        if (document.activeElement !== activeDescendantEl && !this.props.focusFirstChild) {
                            if (this._descendants.indexOf(document.activeElement) === -1) {
                                activeDescendantEl.focus();
                            }
                        }

                        if (event) {
                            event.stopPropagation();
                            event.preventDefault();
                        }
                    }
                }
            }

            /**
             * Handles the key events on a DOM node to execute the appropriate navigation when needed.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @param {Object} event The Keyboard event that was detected on the widget DOM node.
             * @method handleKey
             */

        }, {
            key: 'handleKey',
            value: function handleKey(event) {
                if (this._isValidTarget(event.target) && this._descendants) {
                    var action = this._getFocusAction(event);

                    if (action.type) {
                        event.stopPropagation();
                        event.preventDefault();

                        if (action.type === ACTION_MOVE_FOCUS) {
                            this._moveFocus(action.direction);
                        }

                        if (action.type === ACTION_DISMISS_FOCUS) {
                            this.props.onDismiss(action.direction);
                        }
                    }
                }
            }

            /**
             * Moves the focus among descendants in the especified direction.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method moveFocus
             * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
             */

        }, {
            key: 'moveFocus',
            value: function moveFocus(direction) {
                direction = _lang2.default.isNumber(direction) ? direction : 0;

                this._moveFocus(direction);
            }

            /**
             * Returns the action, if any, that a keyboard event in the current focus manager state
             * should produce.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusAction
             * @param {object} event The Keyboard event.
             * @protected
             * @return {Object} An action object with type and direction properties.
             */

        }, {
            key: '_getFocusAction',
            value: function _getFocusAction(event) {
                var action = {
                    type: ACTION_NONE
                };

                if (this.props.keys) {
                    var direction = this._getFocusMoveDirection(event);

                    if (direction) {
                        action.direction = direction;
                        action.type = ACTION_MOVE_FOCUS;
                    }

                    var dismissAction = this._getFocusDismissAction(event, direction);

                    if (dismissAction.dismiss) {
                        action.direction = dismissAction.direction;
                        action.type = ACTION_DISMISS_FOCUS;
                    }
                }

                return action;
            }

            /**
             * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
             * will happen in any of these scenarios if a dismiss callback has been specified:
             * - A dismiss key has been pressed
             * - In a non-circular focus manager, when:
             *     - The active descendant is the first one and a prev key has been pressed.
             *     - The active descendant is the last one and a next key has been pressed.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusDismissAction
             * @param {Number} focusMoveDirection The focus movement direction (if any).
             * @param {Object} event The Keyboard event.
             * @protected
             * @return {Object} A dismiss action with dismiss and direction properties.
             */

        }, {
            key: '_getFocusDismissAction',
            value: function _getFocusDismissAction(event, focusMoveDirection) {
                var dismissAction = {
                    direction: focusMoveDirection,
                    dismiss: false
                };

                if (this.props.onDismiss) {
                    if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
                        dismissAction.dismiss = true;
                    }
                    if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
                        dismissAction.dismiss = true;
                        dismissAction.direction = DIRECTION_NEXT;
                    }
                    if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
                        dismissAction.dismiss = true;
                        dismissAction.direction = DIRECTION_PREV;
                    }

                    if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
                        dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
                    }
                }

                return dismissAction;
            }

            /**
             * Returns the direction, if any, in which the focus should be moved. In presence of the
             * shift key modifier, the direction of the movement is inverted.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _getFocusMoveDirection
             * @param {Object} event The Keyboard event.
             * @protected
             * @return {Number} The computed direction of the expected focus movement.
             */

        }, {
            key: '_getFocusMoveDirection',
            value: function _getFocusMoveDirection(event) {
                var direction = DIRECTION_NONE;

                if (this._isValidKey(event.keyCode, this.props.keys.next)) {
                    direction = DIRECTION_NEXT;
                }
                if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
                    direction = DIRECTION_PREV;
                }

                if (event.shifKey) {
                    direction *= -1;
                }

                return direction;
            }

            /**
             * Indicates if a given keyCode is valid for the given set of keys.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _isValidKey
             * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
             * @param {Number} keyCode An event keyCode.
             * @protected
             * @return {Boolean} A boolean value indicating if the key is valid.
             */

        }, {
            key: '_isValidKey',
            value: function _isValidKey(keyCode, keys) {
                return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
            }

            /**
             * Indicates if a given element is valid for focus management. User input elements such as
             * input, select or textarea are excluded.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _isValidKey
             * @param {DOMNode} element A DOM element.
             * @protected
             * @return {Boolean} A boolean value indicating if the element is valid.
             */

        }, {
            key: '_isValidTarget',
            value: function _isValidTarget(element) {
                var tagName = element.tagName.toLowerCase();

                return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
            }

            /**
             * Moves the focus among descendants in the especified direction.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _moveFocus
             * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
             * @protected
             */

        }, {
            key: '_moveFocus',
            value: function _moveFocus(direction) {
                var numDescendants = this._descendants.length;

                var descendant = this._descendants[this._activeDescendant];

                descendant.setAttribute('tabIndex', -1);

                this._activeDescendant += direction;

                if (this.props.circular) {
                    // Calculate proper modulo result since remainder operator doesn't behave in the
                    // same way for negative numbers
                    this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
                } else {
                    this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
                }

                descendant = this._descendants[this._activeDescendant];

                descendant.setAttribute('tabIndex', 0);
                descendant.focus();
            }

            /**
             * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
             *
             * @instance
             * @memberof WidgetFocusManager
             * @method _refresh
             * @protected
             */

        }, {
            key: '_refresh',
            value: function _refresh() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (domNode) {
                    var descendants = domNode.querySelectorAll(this.props.descendants);

                    var priorityDescendants = [];

                    this._descendants = [];

                    Array.prototype.slice.call(descendants).forEach(function (item) {
                        var dataTabIndex = item.getAttribute('data-tabindex');

                        if (dataTabIndex) {
                            priorityDescendants.push(item);
                        } else {
                            this._descendants.push(item);
                        }
                    }.bind(this));

                    priorityDescendants = priorityDescendants.sort(function (a, b) {
                        return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
                    });

                    this._descendants = priorityDescendants.concat(this._descendants);

                    this._activeDescendant = 0;

                    this._descendants.some(function (item, index) {
                        if (item.getAttribute('tabindex') === '0') {
                            this._activeDescendant = index;
                            this.focus();

                            return true;
                        }
                    }.bind(this));
                }
            }
        }]);

        return _class;
    }(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-position.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-position.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Calculates the position where an Widget should be displayed based on the point
 * where user interacted with the editor.
 *
 * @class WidgetPosition
 */
exports.default = function (WrappedComponent) {
    var _class, _temp;

    return _temp = _class = function (_WrappedComponent) {
        _inherits(_class, _WrappedComponent);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: 'cancelAnimation',


            /**
             * Cancels an scheduled animation frame.
             *
             * @instance
             * @memberof WidgetPosition
             * @method cancelAnimation
             */
            value: function cancelAnimation() {
                if (window.cancelAnimationFrame) {
                    window.cancelAnimationFrame(this._animationFrameId);
                }
            }

            /**
             * Returns an object which contains the position of the element in page coordinates,
             * restricted to fit to given viewport.
             *
             * @instance
             * @memberof WidgetPosition
             * @method getConstrainedPosition
             * @param {Object} attrs The following properties, provided as numbers:
             * - height
             * - left
             * - top
             * - width
             * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
             * - width
             * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
             * element.
             */

            /**
             * Lifecycle. Returns the default values of the properties used in the widget.
             *
             * @instance
             * @memberof WidgetPosition
             * @method getDefaultProps
             */

        }, {
            key: 'getConstrainedPosition',
            value: function getConstrainedPosition(attrs, viewPaneSize) {
                viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

                var x = attrs.left;
                var y = attrs.top;

                if (attrs.left + attrs.width > viewPaneSize.width) {
                    x -= attrs.left + attrs.width - viewPaneSize.width;
                }

                if (y < 0) {
                    y = 0;
                }

                return {
                    x: x,
                    y: y
                };
            }

            /**
             * Returns the position, in page coordinates, according to which a widget should appear.
             * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
             *
             * It depends on the props editorEvent to analyze the following user-interaction parameters:
             * - {Object} selectionData The data about the selection in the editor as returned from
             * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
             * This may be the point where the user released the mouse, or just the beginning or the end of
             * the selection.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method getInteractionPoint
             * @return {Object} An Object which contains the following properties:
             * direction, x, y, where x and y are in page coordinates and direction can be one of these:
             * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
             */

        }, {
            key: 'getInteractionPoint',
            value: function getInteractionPoint() {
                var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

                if (!eventPayload) {
                    return;
                }

                var selectionData = eventPayload.selectionData;

                var nativeEvent = eventPayload.nativeEvent;

                var pos = {
                    x: eventPayload.nativeEvent.pageX,
                    y: selectionData.region.top
                };

                var direction = selectionData.region.direction;

                var endRect = selectionData.region.endRect;

                var startRect = selectionData.region.startRect;

                if (endRect && startRect && startRect.top === endRect.top) {
                    direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
                }

                var x;
                var y;

                // If we have the point where user released the mouse, show Toolbar at this point
                // otherwise show it on the middle of the selection.

                if (pos.x && pos.y) {
                    x = this._getXPoint(selectionData, pos.x);

                    if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
                        y = Math.min(pos.y, selectionData.region.top);
                    } else {
                        y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
                    }
                } else {
                    x = selectionData.region.left + selectionData.region.width / 2;

                    if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {

                        y = this._getYPoint(selectionData, nativeEvent);
                    } else {
                        y = selectionData.region.top;
                    }
                }

                return {
                    direction: direction,
                    x: x,
                    y: y
                };
            }

            /**
             * Returns the position of the Widget.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method _getXPoint
             * @param {Object} eventX The X coordinate received from the native event (mouseup).
             * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * @protected
             * @return {Number} The calculated X point in page coordinates.
             */

        }, {
            key: '_getXPoint',
            value: function _getXPoint(selectionData, eventX) {
                var region = selectionData.region;

                var left = region.startRect ? region.startRect.left : region.left;
                var right = region.endRect ? region.endRect.right : region.right;

                var x;

                if (left < eventX && right > eventX) {
                    x = eventX;
                } else {
                    var leftDist = Math.abs(left - eventX);
                    var rightDist = Math.abs(right - eventX);

                    if (leftDist < rightDist) {
                        // user raised the mouse on left on the selection
                        x = left;
                    } else {
                        x = right;
                    }
                }

                return x;
            }

            /**
             * Returns the position of the Widget.
             *
             * @instance
             * @memberof WidgetInteractionPoint
             * @method _getYPoint
             * @param {Object} nativeEvent The data about event is fired
             * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
             * @protected
             * @return {Number} The calculated Y point in page coordinates.
             */

        }, {
            key: '_getYPoint',
            value: function _getYPoint(selectionData, nativeEvent) {
                var y = 0;

                if (selectionData && nativeEvent) {
                    var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

                    if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
                        y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
                    } else {
                        y = selectionData.region.bottom;
                    }
                }

                return y;
            }

            /**
             * Returns the position of the Widget taking in consideration the
             * {{#crossLink "WidgetPosition/gutter:attribute"}}{{/crossLink}} attribute.
             *
             * @instance
             * @memberof WidgetPosition
             * @protected
             * @method  getWidgetXYPoint
             * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
             * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
             * @param {Number} direction The direction of the selection. May be one of the following:
             * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
             * @return {Array} An Array with left and top offsets in page coordinates.
             */

        }, {
            key: 'getWidgetXYPoint',
            value: function getWidgetXYPoint(left, top, direction) {
                var domNode = _reactDom2.default.findDOMNode(this);

                var gutter = this.props.gutter;

                if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
                    left = left - gutter.left - domNode.offsetWidth / 2;

                    top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
                } else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {

                    left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

                    top = top - gutter.top - domNode.offsetHeight / 2;
                }

                if (left < 0) {
                    left = 0;
                }

                if (top < 0) {
                    top = 0;
                }

                return [left, top];
            }

            /**
             * Returns true if the widget is visible, false otherwise
             *
             * @instance
             * @memberof WidgetPosition
             * @method isVisible
             * @return {Boolean} True if the widget is visible, false otherwise
             */

        }, {
            key: 'isVisible',
            value: function isVisible() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (domNode) {
                    var domElement = new CKEDITOR.dom.element(domNode);

                    return domElement.hasClass('alloy-editor-visible');
                }

                return false;
            }

            /**
             * Moves a widget from a starting point to a destination point.
             *
             * @instance
             * @memberof WidgetPosition
             * @method moveToPoint
             * @param  {Object} startPoint The starting point for the movement.
             * @param  {Object} endPoint The destination point for the movement.
             */

        }, {
            key: 'moveToPoint',
            value: function moveToPoint(startPoint, endPoint) {
                var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

                domElement.setStyles({
                    left: startPoint[0] + 'px',
                    top: startPoint[1] + 'px',
                    opacity: 0
                });

                domElement.removeClass('alloy-editor-invisible');

                this._animate(function () {
                    domElement.addClass('ae-toolbar-transition');
                    domElement.addClass('alloy-editor-visible');
                    domElement.setStyles({
                        left: endPoint[0] + 'px',
                        top: endPoint[1] + 'px',
                        opacity: 1
                    });
                });
            }

            /**
             * Shows the widget with the default animation transition.
             *
             * @instance
             * @memberof WidgetPosition
             * @method show
             */

        }, {
            key: 'show',
            value: function show() {
                var domNode = _reactDom2.default.findDOMNode(this);

                if (!this.isVisible() && domNode) {
                    var interactionPoint = this.getInteractionPoint();

                    if (interactionPoint) {
                        var domElement = new CKEDITOR.dom.element(domNode);

                        var finalX, finalY, initialX, initialY;

                        finalX = initialX = parseFloat(domElement.getStyle('left'));
                        finalY = initialY = parseFloat(domElement.getStyle('top'));

                        if (this.props.constrainToViewport) {
                            var res = this.getConstrainedPosition({
                                height: parseFloat(domNode.offsetHeight),
                                left: finalX,
                                top: finalY,
                                width: parseFloat(domNode.offsetWidth)
                            });

                            finalX = res.x;
                            finalY = res.y;
                        }

                        if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
                            initialY = this.props.selectionData.region.bottom;
                        } else {
                            initialY = this.props.selectionData.region.top;
                        }

                        this.moveToPoint([initialX, initialY], [finalX, finalY]);
                    }
                }
            }

            /**
             * Updates the widget position based on the current interaction point.
             *
             * @instance
             * @memberof WidgetPosition
             * @method updatePosition
             */

        }, {
            key: 'updatePosition',
            value: function updatePosition() {
                var interactionPoint = this.getInteractionPoint();

                var domNode = _reactDom2.default.findDOMNode(this);

                if (interactionPoint && domNode) {
                    var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);

                    new CKEDITOR.dom.element(domNode).setStyles({
                        left: xy[0] + 'px',
                        top: xy[1] + 'px'
                    });
                }
            }

            /**
             * Requests an animation frame, if possible, to simulate an animation.
             *
             * @instance
             * @memberof WidgetPosition
             * @method _animate
             * @param {Function} callback The function to be executed on the scheduled frame.
             * @protected
             */

        }, {
            key: '_animate',
            value: function _animate(callback) {
                if (window.requestAnimationFrame) {
                    this._animationFrameId = window.requestAnimationFrame(callback);
                } else {
                    callback();
                }
            }
        }]);

        return _class;
    }(WrappedComponent), _class.defaultProps = _extends({}, WrappedComponent.defaultProps, {
        gutter: {
            left: 0,
            top: 10
        },
        constrainToViewport: true }), _temp;
};

/***/ }),

/***/ "./src/components/buttons/button-bold.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-bold.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonBold class provides functionality for styling an selection with strong (bold) style.
 *
 * @class ButtonBold
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonBold = function (_React$Component) {
    _inherits(ButtonBold, _React$Component);

    function ButtonBold() {
        _classCallCheck(this, ButtonBold);

        return _possibleConstructorReturn(this, (ButtonBold.__proto__ || Object.getPrototypeOf(ButtonBold)).apply(this, arguments));
    }

    _createClass(ButtonBold, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonBold
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.bold, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-bold', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.bold },
                _react2.default.createElement('span', { className: 'ae-icon-bold' })
            );
        }
    }]);

    return ButtonBold;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default bold
 * @memberof ButtonBold
 * @property {String} key
 * @static
 */


ButtonBold.key = 'bold';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonBold
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonBold.defaultProps = {
    command: 'bold',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 66 /*B*/
    },
    style: 'coreStyles_bold'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonBold))));

/***/ }),

/***/ "./src/components/buttons/button-camera-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-camera-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCameraImage class takes photo from camera and inserts it to the content.
 *
 * @class ButtonCameraImage
 */
var ButtonCameraImage = function (_React$Component) {
    _inherits(ButtonCameraImage, _React$Component);

    function ButtonCameraImage() {
        _classCallCheck(this, ButtonCameraImage);

        return _possibleConstructorReturn(this, (ButtonCameraImage.__proto__ || Object.getPrototypeOf(ButtonCameraImage)).apply(this, arguments));
    }

    _createClass(ButtonCameraImage, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses the take photo button.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this.refs.buttonTakePhoto).focus();
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._stream) {
                if (this._stream.stop) {
                    this._stream.stop();
                } else if (this._stream.getVideoTracks) {
                    this._stream.getVideoTracks().forEach(function (track) {
                        track.stop();
                    });
                }
                this._stream = null;
            }
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

            getUserMedia.call(navigator, {
                video: true,
                audio: false
            }, this._handleStreamSuccess.bind(this), this._handleStreamError.bind(this));

            return _react2.default.createElement(
                'div',
                { className: 'ae-camera' },
                _react2.default.createElement(
                    'video',
                    { ref: 'videoContainer' },
                    'Video stream not available.'
                ),
                _react2.default.createElement(
                    'button',
                    { className: 'ae-camera-shoot', onClick: this.takePhoto.bind(this), ref: 'buttonTakePhoto' },
                    'Take photo'
                ),
                _react2.default.createElement('canvas', { className: 'ae-camera-canvas', ref: 'canvasContainer' })
            );
        }

        /**
         * Takes photo from the video stream and inserts in into editor's content.
         *
         * @fires ButtonCameraImage#imageCameraAdd
         * @instance
         * @memberof ButtonCameraImage
         * @method takePhoto
         */

    }, {
        key: 'takePhoto',
        value: function takePhoto() {
            var videoEl = _reactDom2.default.findDOMNode(this.refs.videoContainer);
            var canvasEl = _reactDom2.default.findDOMNode(this.refs.canvasContainer);

            var context = canvasEl.getContext('2d');

            var height = this._videoHeight;
            var width = this.props.videoWidth;

            if (width && height) {
                canvasEl.width = width;
                canvasEl.height = height;

                context.drawImage(videoEl, 0, 0, width, height);

                var imgURL = canvasEl.toDataURL('image/png');

                var el = CKEDITOR.dom.element.createFromHtml('<img src="' + imgURL + '">');

                var editor = this.props.editor.get('nativeEditor');

                editor.insertElement(el);

                this.props.cancelExclusive();

                editor.fire('actionPerformed', this);

                editor.fire('imageCameraAdd', el);
            }
        }

        /**
         * Displays error message in case of video stream capturing failure.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method _handleStreamError
         * @param {Event} error The fired event in case of error.
         * @protected
         */

    }, {
        key: '_handleStreamError',
        value: function _handleStreamError(error) {
            window.alert('An error occurred! ' + error);
        }

        /**
         * Starts streaming video in the video element and sets width/height to the video
         * and canvas elements.
         *
         * @instance
         * @memberof ButtonCameraImage
         * @method _handleStreamSuccess
         * @param {Object} stream The video stream
         * @protected
         */

    }, {
        key: '_handleStreamSuccess',
        value: function _handleStreamSuccess(stream) {
            var videoEl = _reactDom2.default.findDOMNode(this.refs.videoContainer);
            var canvasEl = _reactDom2.default.findDOMNode(this.refs.canvasContainer);

            videoEl.addEventListener('canplay', function (event) {
                var height = videoEl.videoHeight / (videoEl.videoWidth / this.props.videoWidth);

                if (isNaN(height)) {
                    height = this.props.videoWidth / (4 / 3);
                }

                videoEl.setAttribute('width', this.props.videoWidth);
                videoEl.setAttribute('height', height);
                canvasEl.setAttribute('width', this.props.videoWidth);
                canvasEl.setAttribute('height', height);

                this._videoHeight = height;
            }.bind(this), false);

            this._stream = stream;

            if (navigator.mozGetUserMedia) {
                videoEl.mozSrcObject = stream;
            } else {
                videoEl.src = (window.URL || window.webkitURL).createObjectURL(stream);
            }

            videoEl.play();

            _reactDom2.default.findDOMNode(this.refs.buttonTakePhoto).disabled = false;
        }

        /**
         * Fired when an image is being taken from the camera and added as an element to the editor.
         *
         * @event ButtonCameraImage#imageCameraAdd
         * @memberof ButtonCameraImage
         * @param {CKEDITOR.dom.element} el The created img element in editor.
         */

    }]);

    return ButtonCameraImage;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default cameraImage
 * @memberof ButtonCameraImage
 * @property {String} key
 * @static
 */


ButtonCameraImage.key = 'cameraImage';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCameraImage
 * @method getDefaultProps
 */
ButtonCameraImage.defaultProps = {
    videoWidth: 320
};

exports.default = ButtonCameraImage;

/***/ }),

/***/ "./src/components/buttons/button-camera.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-camera.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCamera class renders in two different ways:
 *
 * - Normal: Just a button that allows to switch to the edition mode.
 * - Exclusive: Renders ButtonCameraImage in order to take photo from the camera.
 *
 * @class ButtonCamera
 */
var ButtonCamera = function (_React$Component) {
    _inherits(ButtonCamera, _React$Component);

    function ButtonCamera() {
        _classCallCheck(this, ButtonCamera);

        return _possibleConstructorReturn(this, (ButtonCamera.__proto__ || Object.getPrototypeOf(ButtonCamera)).apply(this, arguments));
    }

    _createClass(ButtonCamera, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCamera
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonCameraImage2.default, this.props);
            } else {
                var disabled = !(navigator.getUserMedia || navigator.webkitGetUserMedia && location.protocol === 'https' || navigator.mozGetUserMedia || navigator.msGetUserMedia);

                var label = disabled ? AlloyEditor.Strings.cameraDisabled : AlloyEditor.Strings.camera;

                return _react2.default.createElement(
                    'button',
                    { 'aria-label': label, className: 'ae-button', 'data-type': 'button-image-camera', disabled: disabled, onClick: this.props.requestExclusive.bind(ButtonCamera.key), tabIndex: this.props.tabIndex, title: label },
                    _react2.default.createElement('span', { className: 'ae-icon-camera' })
                );
            }
        }
    }]);

    return ButtonCamera;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default camera
 * @memberof ButtonCamera
 * @property {String} key
 * @static
 */


ButtonCamera.key = 'camera';

exports.default = ButtonCamera;

/***/ }),

/***/ "./src/components/buttons/button-code.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-code.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCode class provides wraps a selection in `pre` element.
 *
 * @class ButtonCode
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonCode = function (_React$Component) {
    _inherits(ButtonCode, _React$Component);

    function ButtonCode() {
        _classCallCheck(this, ButtonCode);

        return _possibleConstructorReturn(this, (ButtonCode.__proto__ || Object.getPrototypeOf(ButtonCode)).apply(this, arguments));
    }

    _createClass(ButtonCode, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCode
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.code, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-code', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.code },
                _react2.default.createElement('span', { className: 'ae-icon-code' })
            );
        }
    }]);

    return ButtonCode;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default code
 * @memberof ButtonCode
 * @property {String} key
 * @static
 */


ButtonCode.key = 'code';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCode
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonCode.defaultProps = {
    style: {
        element: 'pre'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonCode)));

/***/ }),

/***/ "./src/components/buttons/button-command-list-item.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-command-list-item.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandListItem class is a UI class that renders a ButtonCommand that can be used inside
 * a list as an item, with a string representation of its behaviour.
 *
 * @class ButtonCommandListItem
 * @uses ButtonCommand
 */
var ButtonCommandListItem = function (_React$Component) {
    _inherits(ButtonCommandListItem, _React$Component);

    function ButtonCommandListItem() {
        _classCallCheck(this, ButtonCommandListItem);

        return _possibleConstructorReturn(this, (ButtonCommandListItem.__proto__ || Object.getPrototypeOf(ButtonCommandListItem)).apply(this, arguments));
    }

    _createClass(ButtonCommandListItem, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonCommandListItem
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': this.props.description, className: this._getClassName(), onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex },
                this.props.description
            );
        }

        /**
         * Returns the class name of Widget.
         *
         * @instance
         * @memberof ButtonCommandListItem
         * @method _getClassName
         * @protected
         * @return {String} The class name of the Widget.
         */

    }, {
        key: '_getClassName',
        value: function _getClassName() {
            var className = 'ae-toolbar-element';

            if (this.props.icon) {
                className += ' ae-icon-' + this.props.icon;
            }

            return className;
        }
    }]);

    return ButtonCommandListItem;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonCommandListItem
 * @memberof ButtonCommandListItem
 * @property {String} key
 * @static
 */


ButtonCommandListItem.key = 'buttonCommandListItem';

exports.default = (0, _buttonCommand2.default)(ButtonCommandListItem);

/***/ }),

/***/ "./src/components/buttons/button-commands-list.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-commands-list.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandsList class provides functionality for showing a list of commands that can be
 * executed to the current selection..
 *
 * @class ButtonCommandsList
 * @uses WidgetFocusManager
 */
var ButtonCommandsList = function (_React$Component) {
    _inherits(ButtonCommandsList, _React$Component);

    function ButtonCommandsList() {
        _classCallCheck(this, ButtonCommandsList);

        return _possibleConstructorReturn(this, (ButtonCommandsList.__proto__ || Object.getPrototypeOf(ButtonCommandsList)).apply(this, arguments));
    }

    _createClass(ButtonCommandsList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses on the list node to allow keyboard interaction.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'div',
                { className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left', onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), tabIndex: '0' },
                _react2.default.createElement(
                    'ul',
                    { className: 'ae-listbox', id: this.props.listId, role: 'listbox' },
                    this._renderActions(this.props.commands)
                )
            );
        }

        /**
         * Renders instances of ButtonCommandListItem with the description of the row action that will be executed.
         *
         * @instance
         * @memberof ButtonCommandsList
         * @method _renderActions
         * @protected
         * @return {Array} Rendered instances of ButtonCommandListItem class
         */

    }, {
        key: '_renderActions',
        value: function _renderActions(commands) {
            var editor = this.props.editor;
            var items;

            if (commands && commands.length) {
                items = commands.map(function (item) {
                    return _react2.default.createElement(
                        'li',
                        { key: item.command, role: 'option' },
                        _react2.default.createElement(_buttonCommandListItem2.default, { command: item.command, description: typeof item.label === 'string' ? item.label : item.label(), editor: editor })
                    );
                });
            }

            return items;
        }
    }]);

    return ButtonCommandsList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonCommandsList
 * @memberof ButtonCommandsList
 * @property {String} key
 * @static
 */


ButtonCommandsList.key = 'buttonCommandsList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonCommandsList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonCommandsList.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonCommandsList);

/***/ }),

/***/ "./src/components/buttons/button-dropdown.jsx":
/*!****************************************************!*\
  !*** ./src/components/buttons/button-dropdown.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonDropdown class provides markup and keyboard navigation behaviour to a dropdown
 * opened from a button.
 *
 * @class ButtonDropdown
 */
var ButtonDropdown = function (_React$Component) {
    _inherits(ButtonDropdown, _React$Component);

    function ButtonDropdown() {
        _classCallCheck(this, ButtonDropdown);

        return _possibleConstructorReturn(this, (ButtonDropdown.__proto__ || Object.getPrototypeOf(ButtonDropdown)).apply(this, arguments));
    }

    _createClass(ButtonDropdown, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonDropdown
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'div',
                { className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left', onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), tabIndex: '0' },
                _react2.default.createElement(
                    'ul',
                    { className: 'ae-listbox', role: 'listbox' },
                    this.props.children
                )
            );
        }
    }]);

    return ButtonDropdown;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the dropdown in the configuration.
 *
 * @default dropdown
 * @memberof ButtonDropdown
 * @property {String} key
 * @static
 */


ButtonDropdown.key = 'dropdown';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonDropdown
 * @method getDefaultProps
 */
ButtonDropdown.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonDropdown);

/***/ }),

/***/ "./src/components/buttons/button-embed-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-embed-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedEdit class provides functionality for creating and editing an embed link in a document.
 * Provides UI for creating and editing an embed link.
 *
 * @class ButtonEmbedEdit
 */

var ButtonEmbedEdit = function (_React$Component) {
    _inherits(ButtonEmbedEdit, _React$Component);

    function ButtonEmbedEdit(props) {
        _classCallCheck(this, ButtonEmbedEdit);

        var _this = _possibleConstructorReturn(this, (ButtonEmbedEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedEdit)).call(this, props));

        _this.linkInput = _react2.default.createRef();
        _this.state = _this.getInitialState();
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing. This should only happen if the component
     * is rendered in exclusive mode to prevent aggressive focus stealing.
     *
     * @instance
     * @memberof ButtonEmbedEdit
     * @method componentDidMount
     */


    _createClass(ButtonEmbedEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.renderExclusive || this.props.manualSelection) {
                // We need to wait for the next rendering cycle before focusing to avoid undesired
                // scrolls on the page
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(this._focusLinkInput.bind(this));
                } else {
                    setTimeout(this._focusLinkInput.bind(this), 0);
                }
            }
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method componentWillReceiveProps
         */

    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps() {
            this.setState(this.getInitialState());
        }

        /**
         * Lifecycle. Invoked once before the component is mounted.
         * The return value will be used as the initial value of this.state.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method getInitialState
         */

    }, {
        key: 'getInitialState',
        value: function getInitialState() {
            var editor = this.props.editor.get('nativeEditor');
            var embed;

            var selection = editor.getSelection();

            if (selection) {
                var selectedElement = selection.getSelectedElement();

                if (selectedElement) {
                    embed = selectedElement.findOne('[data-widget="ae_embed"]');
                }
            }

            var href = embed ? embed.getAttribute('data-ae-embed-url') : '';

            return {
                element: embed,
                initialLink: {
                    href: href
                },
                linkHref: href
            };
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var clearLinkStyle = {
                opacity: this.state.linkHref ? 1 : 0
            };

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link' },
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.deleteEmbed, className: 'ae-button', 'data-type': 'button-embed-remove', disabled: !this.state.element, onClick: this._removeEmbed.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.deleteEmbed },
                    _react2.default.createElement('span', { className: 'ae-icon-bin' })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input xxl' },
                    _react2.default.createElement('input', { className: 'ae-input', onChange: this._handleLinkHrefChange.bind(this), onKeyDown: this._handleKeyDown.bind(this), placeholder: AlloyEditor.Strings.editLink, ref: this.linkInput, type: 'text', value: this.state.linkHref }),
                    _react2.default.createElement('button', { 'aria-label': AlloyEditor.Strings.clearInput, className: 'ae-button ae-icon-remove', onClick: this._clearLink.bind(this), style: clearLinkStyle, title: AlloyEditor.Strings.clear })
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.confirm, className: 'ae-button', disabled: !this._isValidState(), onClick: this._embedLink.bind(this), title: AlloyEditor.Strings.confirm },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }

        /**
         * Clears the link input. This only changes the component internal state, but does not
         * affect the link element of the editor. Only the _removeLink and _updateLink methods
         * are translated to the editor element.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _clearLink
         * @protected
         */

    }, {
        key: '_clearLink',
        value: function _clearLink() {
            this.setState({
                linkHref: ''
            });
        }

        /**
         * Triggers the embedUrl command to transform the link into an embed media object
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _embedLink
         * @protected
         */

    }, {
        key: '_embedLink',
        value: function _embedLink() {
            var nativeEditor = this.props.editor.get('nativeEditor');

            nativeEditor.execCommand('embedUrl', {
                url: this.state.linkHref
            });

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();
        }

        /**
         * Focuses the user cursor on the widget's input.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _focusLinkInput
         * @protected
         */

    }, {
        key: '_focusLinkInput',
        value: function _focusLinkInput() {
            this.linkInput.current.focus();
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates/updates the link.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
                event.preventDefault();
            }

            if (event.keyCode === KEY_ENTER) {
                this._embedLink();
            } else if (event.keyCode === KEY_ESC) {
                var editor = this.props.editor.get('nativeEditor');

                // We need to cancelExclusive with the bound parameters in case the button is used
                // inside another in exclusive mode (such is the case of the link button)
                this.props.cancelExclusive();

                editor.fire('actionPerformed', this);
            }
        }

        /**
         * Updates the component state when the link input changes on user interaction.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _handleLinkHrefChange
         * @param {SyntheticEvent} event The change event.
         * @protected
         */

    }, {
        key: '_handleLinkHrefChange',
        value: function _handleLinkHrefChange(event) {
            this.setState({
                linkHref: event.target.value
            });
        }

        /**
         * Verifies that the current link state is valid so the user can save the link. A valid state
         * means that we have a non-empty href that's different from the original one.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _isValidState
         * @protected
         * @return {Boolean} True if the state is valid, false otherwise
         */

    }, {
        key: '_isValidState',
        value: function _isValidState() {
            var validState = this.state.linkHref && this.state.linkHref !== this.state.initialLink.href;

            return validState;
        }

        /**
         * Removes the embed in the editor element.
         *
         * @instance
         * @memberof ButtonEmbedEdit
         * @method _removeEmbed
         * @protected
         */

    }, {
        key: '_removeEmbed',
        value: function _removeEmbed() {
            var editor = this.props.editor.get('nativeEditor');

            var embedWrapper = this.state.element.getAscendant(function (element) {
                return element.hasClass('cke_widget_wrapper');
            });

            embedWrapper.remove();

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonEmbedEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default embedEdit
 * @memberof ButtonEmbedEdit
 * @property {String} key
 * @static
 */


ButtonEmbedEdit.key = 'embedEdit';

exports.default = ButtonEmbedEdit;

/***/ }),

/***/ "./src/components/buttons/button-embed.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-embed.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonEmbed class provides functionality for creating and editing an embed link in a document.
 * ButtonEmbed renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonEmbedEdit UI with all the link edition controls.
 *
 * @class ButtonEmbed
 * @uses ButtonKeystroke
 */
var ButtonEmbed = function (_React$Component) {
    _inherits(ButtonEmbed, _React$Component);

    function ButtonEmbed() {
        _classCallCheck(this, ButtonEmbed);

        return _possibleConstructorReturn(this, (ButtonEmbed.__proto__ || Object.getPrototypeOf(ButtonEmbed)).apply(this, arguments));
    }

    _createClass(ButtonEmbed, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonEmbed
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonEmbedEdit2.default, this.props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.link, className: 'ae-button', 'data-type': 'button-embed', onClick: this._requestExclusive.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.link },
                    _react2.default.createElement('span', { className: 'ae-icon-add' })
                );
            }
        }

        /**
         * Requests the link button to be rendered in exclusive mode to allow the embedding of a link.
         *
         * @instance
         * @memberof ButtonEmbed
         * @method _requestExclusive
         * @protected
         */

    }, {
        key: '_requestExclusive',
        value: function _requestExclusive() {
            this.props.requestExclusive(ButtonEmbed.key);
        }
    }]);

    return ButtonEmbed;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default embed
 * @memberof ButtonEmbed
 * @property {String} key
 * @static
 */


ButtonEmbed.key = 'embed';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonEmbed
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonEmbed.defaultProps = {
    keystroke: {
        fn: '_requestExclusive',
        keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /*L*/
    }
};

exports.default = (0, _buttonKeystroke2.default)(ButtonEmbed);

/***/ }),

/***/ "./src/components/buttons/button-h1.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h1.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH1 class provides wraps a selection in `h1` element.
 *
 * @class ButtonH1
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH1 = function (_React$Component) {
    _inherits(ButtonH1, _React$Component);

    function ButtonH1() {
        _classCallCheck(this, ButtonH1);

        return _possibleConstructorReturn(this, (ButtonH1.__proto__ || Object.getPrototypeOf(ButtonH1)).apply(this, arguments));
    }

    _createClass(ButtonH1, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonH1
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.h1, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-h1', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.h1 },
                _react2.default.createElement('span', { className: 'ae-icon-h1' })
            );
        }
    }]);

    return ButtonH1;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default h1
 * @memberof ButtonH1
 * @property {String} key
 * @static
 */


ButtonH1.key = 'h1';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonH1
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonH1.defaultProps = {
    style: {
        element: 'h1'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH1)));

/***/ }),

/***/ "./src/components/buttons/button-h2.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h2.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH2 class provides wraps a selection in `h2` element.
 *
 * @class ButtonH2
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH2 = function (_React$Component) {
    _inherits(ButtonH2, _React$Component);

    function ButtonH2() {
        _classCallCheck(this, ButtonH2);

        return _possibleConstructorReturn(this, (ButtonH2.__proto__ || Object.getPrototypeOf(ButtonH2)).apply(this, arguments));
    }

    _createClass(ButtonH2, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonH2
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.h2, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-h2', onClick: this.applyStyle.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.h2 },
                _react2.default.createElement('span', { className: 'ae-icon-h2' })
            );
        }
    }]);

    return ButtonH2;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default h2
 * @memberof ButtonH2
 * @property {String} key
 * @static
 */


ButtonH2.key = 'h2';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonH2
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonH2.defaultProps = {
    style: {
        element: 'h2'
    }
};

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH2)));

/***/ }),

/***/ "./src/components/buttons/button-hline.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-hline.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonHline class provides inserts horizontal line.
 *
 * @class ButtonHline
 * @uses ButtonCommand
 * @uses ButtonStyle
 */
var ButtonHline = function (_React$Component) {
    _inherits(ButtonHline, _React$Component);

    function ButtonHline() {
        _classCallCheck(this, ButtonHline);

        return _possibleConstructorReturn(this, (ButtonHline.__proto__ || Object.getPrototypeOf(ButtonHline)).apply(this, arguments));
    }

    _createClass(ButtonHline, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonHline
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.horizontalrule, className: 'ae-button', 'data-type': 'button-hline', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.horizontalrule },
                _react2.default.createElement('span', { className: 'ae-icon-separator' })
            );
        }
    }]);

    return ButtonHline;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default hline
 * @memberof ButtonHline
 * @property {String} key
 * @static
 */


ButtonHline.key = 'hline';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonHline
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonHline.defaultProps = {
    command: 'horizontalrule',
    style: {
        element: 'hr'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStyle2.default)(ButtonHline));

/***/ }),

/***/ "./src/components/buttons/button-image-align-center.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-image-align-center.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignCenter class provides functionality for aligning an image in the center.
 *
 * @class ButtonImageAlignCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignCenter = function (_React$Component) {
    _inherits(ButtonImageAlignCenter, _React$Component);

    function ButtonImageAlignCenter() {
        _classCallCheck(this, ButtonImageAlignCenter);

        return _possibleConstructorReturn(this, (ButtonImageAlignCenter.__proto__ || Object.getPrototypeOf(ButtonImageAlignCenter)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignCenter, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignCenter
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignCenter, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-center', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignCenter },
                _react2.default.createElement('span', { className: 'ae-icon-align-center' })
            );
        }
    }]);

    return ButtonImageAlignCenter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageCenter
 * @memberof ButtonImageAlignCenter
 * @property {String} key
 * @static
 */


ButtonImageAlignCenter.key = 'imageCenter';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignCenter
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignCenter.defaultProps = {
    command: 'justifycenter'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignCenter)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-left.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-image-align-left.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignLeft class provides functionality for aligning an image on left.
 *
 * @class ButtonImageAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignLeft = function (_React$Component) {
    _inherits(ButtonImageAlignLeft, _React$Component);

    function ButtonImageAlignLeft() {
        _classCallCheck(this, ButtonImageAlignLeft);

        return _possibleConstructorReturn(this, (ButtonImageAlignLeft.__proto__ || Object.getPrototypeOf(ButtonImageAlignLeft)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignLeft, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignLeft
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignLeft, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-left', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignLeft },
                _react2.default.createElement('span', { className: 'ae-icon-align-left' })
            );
        }
    }]);

    return ButtonImageAlignLeft;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageLeft
 * @memberof ButtonImageAlignLeft
 * @property {String} key
 * @static
 */


ButtonImageAlignLeft.key = 'imageLeft';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignLeft
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignLeft.defaultProps = {
    command: 'justifyleft'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-right.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-image-align-right.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignRight class provides functionality for aligning an image on right.
 *
 * @class ButtonImageAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignRight = function (_React$Component) {
    _inherits(ButtonImageAlignRight, _React$Component);

    function ButtonImageAlignRight() {
        _classCallCheck(this, ButtonImageAlignRight);

        return _possibleConstructorReturn(this, (ButtonImageAlignRight.__proto__ || Object.getPrototypeOf(ButtonImageAlignRight)).apply(this, arguments));
    }

    _createClass(ButtonImageAlignRight, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonImageAlignRight
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignRight, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-image-align-right', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignRight },
                _react2.default.createElement('span', { className: 'ae-icon-align-right' })
            );
        }
    }]);

    return ButtonImageAlignRight;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default imageRight
 * @memberof ButtonImageAlignRight
 * @property {String} key
 * @static
 */


ButtonImageAlignRight.key = 'imageRight';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonImageAlignRight
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonImageAlignRight.defaultProps = {
    command: 'justifyright'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-image.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-image.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImage class inserts an image to the content.
 *
 * @class ButtonImage
 */
var ButtonImage = function (_React$Component) {
    _inherits(ButtonImage, _React$Component);

    function ButtonImage(props) {
        _classCallCheck(this, ButtonImage);

        var _this = _possibleConstructorReturn(this, (ButtonImage.__proto__ || Object.getPrototypeOf(ButtonImage)).call(this, props));

        _this.fileInput = _react2.default.createRef();
        return _this;
    }

    /**
     * Lifecycle. Renders the UI of the button.
     *
     * @instance
     * @memberof ButtonImage
     * @method render
     * @return {Object} The content which should be rendered.
     */


    _createClass(ButtonImage, [{
        key: 'render',
        value: function render() {
            var inputSyle = { display: 'none' };

            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.image, className: 'ae-button', 'data-type': 'button-image', onClick: this.handleClick.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.image },
                    _react2.default.createElement('span', { className: 'ae-icon-image' })
                ),
                _react2.default.createElement('input', { accept: 'image/*', onChange: this._onInputChange.bind(this), ref: this.fileInput, style: inputSyle, type: 'file' })
            );
        }

        /**
         * Simulates click on the input element. This will open browser's native file open dialog.
         *
         * @instance
         * @memberof ButtonImage
         * @method handleClick
         * @param {SyntheticEvent} event The received click event on the button.
         */

    }, {
        key: 'handleClick',
        value: function handleClick() {
            this.fileInput.current.click();
        }

        /**
         * On input change, reads the chosen file and fires an event `beforeImageAdd` with the image which will be added
         * to the content. The image file will be passed in the `imageFiles` property.
         * If any of the listeners returns `false` or cancels the event, the image won't be added to the content.
         * Otherwise, an event `imageAdd` will be fired with the inserted element into the editable area.
         * The passed params will be:
         * - `el` - the created img element
         * - `file` - the original image file from the input element
         *
         * @fires ButtonImage#beforeImageAdd
         * @fires ButtonImage#imageAdd
         * @instance
         * @memberof ButtonImage
         * @method _onInputChange
         * @protected
         */

    }, {
        key: '_onInputChange',
        value: function _onInputChange() {
            var inputEl = this.fileInput.current;

            // On IE11 the function might be called with an empty array of
            // files. In such a case, no actions will be taken.
            if (!inputEl.files.length) {
                return;
            }

            var reader = new FileReader();
            var file = inputEl.files[0];

            reader.onload = function (event) {
                var editor = this.props.editor.get('nativeEditor');

                var result = editor.fire('beforeImageAdd', {
                    imageFiles: file
                });

                if (!!result) {
                    var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

                    editor.insertElement(el);

                    editor.fire('actionPerformed', this);

                    var imageData = {
                        el: el,
                        file: file
                    };

                    editor.fire('imageAdd', imageData);
                }
            }.bind(this);

            reader.readAsDataURL(file);

            inputEl.value = '';
        }
    }]);

    return ButtonImage;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default image
 * @memberof ButtonImage
 * @property {String} key
 * @static
 */


ButtonImage.key = 'image';

exports.default = ButtonImage;

/***/ }),

/***/ "./src/components/buttons/button-indent-block.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-indent-block.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonIndentBlock class provides functionality for indenting the selected blocks.
 *
 * @class ButtonIndentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonIndentBlock = function (_React$Component) {
    _inherits(ButtonIndentBlock, _React$Component);

    function ButtonIndentBlock() {
        _classCallCheck(this, ButtonIndentBlock);

        return _possibleConstructorReturn(this, (ButtonIndentBlock.__proto__ || Object.getPrototypeOf(ButtonIndentBlock)).apply(this, arguments));
    }

    _createClass(ButtonIndentBlock, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonIndentBlock
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.indent, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-indent-block', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.indent },
                _react2.default.createElement('span', { className: 'ae-icon-indent-block' })
            );
        }
    }]);

    return ButtonIndentBlock;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default indentBlock
 * @memberof ButtonIndentBlock
 * @property {String} key
 * @static
 */


ButtonIndentBlock.key = 'indentBlock';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonIndentBlock
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonIndentBlock.defaultProps = {
    command: 'indent'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonIndentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-italic.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-italic.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonItalic class provides functionality for styling an selection with italic (em) style.
 *
 * @class ButtonItalic
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonItalic = function (_React$Component) {
    _inherits(ButtonItalic, _React$Component);

    function ButtonItalic() {
        _classCallCheck(this, ButtonItalic);

        return _possibleConstructorReturn(this, (ButtonItalic.__proto__ || Object.getPrototypeOf(ButtonItalic)).apply(this, arguments));
    }

    _createClass(ButtonItalic, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonItalic
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.italic, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-italic', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.italic },
                _react2.default.createElement('span', { className: 'ae-icon-italic' })
            );
        }
    }]);

    return ButtonItalic;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default italic
 * @memberof ButtonItalic
 * @property {String} key
 * @static
 */


ButtonItalic.key = 'italic';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonItalic
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonItalic.defaultProps = {
    command: 'italic',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 73 /*I*/
    },
    style: 'coreStyles_italic'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonItalic))));

/***/ }),

/***/ "./src/components/buttons/button-link-autocomplete-list.jsx":
/*!******************************************************************!*\
  !*** ./src/components/buttons/button-link-autocomplete-list.jsx ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkAutocompleteList class provides functionality for showing a list of
 * items that can be selected for the link.
 *
 * @class ButtonLinkAutocompleteList
 * @uses WidgetFocusManager
 */
var ButtonLinkAutocompleteList = function (_React$Component) {
    _inherits(ButtonLinkAutocompleteList, _React$Component);

    function ButtonLinkAutocompleteList(props) {
        _classCallCheck(this, ButtonLinkAutocompleteList);

        var _this = _possibleConstructorReturn(this, (ButtonLinkAutocompleteList.__proto__ || Object.getPrototypeOf(ButtonLinkAutocompleteList)).call(this, props));

        _this.state = {
            items: []
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked when a component is receiving new props.
     * This method is not called for the initial render.
     *
     * @instance
     * @memberof ButtonLinkAutocompleteList
     * @method componentWillReceiveProps
     */


    _createClass(ButtonLinkAutocompleteList, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (!nextProps.term || nextProps.term !== this.props.term) {
                clearTimeout(this._timeout);

                if (nextProps.term) {
                    this._timeout = setTimeout(this._updateItems, this.props.delay);
                } else {
                    this.setState({
                        items: []
                    });
                }
            }

            if (nextProps.autocompleteSelected) {
                setTimeout(this.focus, 0);
                this.props.setAutocompleteState({
                    selected: false
                });
            }
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            clearTimeout(this._timeout);
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            if (!this.props.expanded || !this.state.items.length) {
                return null;
            }

            return _react2.default.createElement(
                _buttonDropdown2.default,
                null,
                this._renderAutocompleteItems(this.state.items)
            );
        }

        /**
         * Lifecycle. Invoked before rendering when new props or state are being received.
         * This method is not called for the initial render or when forceUpdate is used.
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method  shouldComponentUpdate
         * @return {Boolean} Returns false when the transition to the new props and state will not
         * require a component update.
         */

    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps, nextState) {
            return nextProps.expanded !== this.props.expanded || nextProps.term !== this.props.term || nextState.items !== this.state.items;
        }

        /**
         * Renders a set of list items for the provided items
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method _renderAutocompleteItems
         * @param {Array} items List of autocomplete items to render
         * @protected
         * @return {Array} Rendered list item instances
         */

    }, {
        key: '_renderAutocompleteItems',
        value: function _renderAutocompleteItems(items) {
            items = items || [];

            var handleLinkAutocompleteClick = this.props.handleLinkAutocompleteClick;

            return items.map(function (item) {
                var className = this.props.term === item.url ? 'ae-toolbar-element active' : 'ae-toolbar-element';

                return _react2.default.createElement(
                    'li',
                    { key: item.url, role: 'option' },
                    _react2.default.createElement(
                        'button',
                        { className: className, onClick: handleLinkAutocompleteClick, 'data-value': item.url },
                        item.title
                    )
                );
            }.bind(this));
        }

        /**
         * Retrieves the data according to {this.props.term} and calls setState() with the returned data
         *
         * @instance
         * @memberof ButtonLinkAutocompleteList
         * @method _updateItems
         * @protected
         */

    }, {
        key: '_updateItems',
        value: function _updateItems() {
            var instance = this;

            if (!this.props.term) {
                return;
            }

            var promise = Promise.resolve(this.props.data(this.props.term));

            promise.then(function (items) {
                if (items.length) {
                    !instance.props.expanded && instance.props.toggleDropdown();
                }

                instance.setState({
                    items: items
                });
            });
        }
    }]);

    return ButtonLinkAutocompleteList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonLinkAutocompleteList
 * @memberof ButtonLinkAutocompleteList
 * @property {String} key
 * @static
 */


ButtonLinkAutocompleteList.key = 'buttonLinkAutocompleteList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLinkAutocompleteList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLinkAutocompleteList.defaultProps = {
    circular: false,
    data: [],
    delay: 100,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonLinkAutocompleteList);

/***/ }),

/***/ "./src/components/buttons/button-link-edit.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-link-edit.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props.js */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkEdit class provides functionality for creating and editing a link in a document.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEdit
 * @uses ButtonCfgProps
 * @uses WidgetDropdown
 * @uses WidgetFocusManager
 */
var ButtonLinkEdit = function (_React$Component) {
    _inherits(ButtonLinkEdit, _React$Component);

    function ButtonLinkEdit(props) {
        _classCallCheck(this, ButtonLinkEdit);

        var _this = _possibleConstructorReturn(this, (ButtonLinkEdit.__proto__ || Object.getPrototypeOf(ButtonLinkEdit)).call(this, props));

        _this.linkInput = _react2.default.createRef();
        _this.state = _this._getInitialState();
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing. This should only happen if the component
     * is rendered in exclusive mode to prevent aggressive focus stealing.
     *
     * @instance
     * @memberof ButtonLinkEdit
     * @method componentDidMount
     */


    _createClass(ButtonLinkEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.renderExclusive || this.props.manualSelection) {
                // We need to wait for the next rendering cycle before focusing to avoid undesired
                // scrolls on the page
                this._focusLinkInput();
            }
        }

        /**
         * Lifecycle. Invoked when a component is receiving new props.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method componentWillReceiveProps
         */

    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps() {
            this.setState(this._getInitialState());
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var targetSelector = {
                allowedTargets: this.props.allowedTargets,
                editor: this.props.editor,
                handleLinkTargetChange: this._handleLinkTargetChange.bind(this),
                selectedTarget: this.state.linkTarget || AlloyEditor.Strings.linkTargetDefault
            };

            targetSelector = this.mergeDropdownProps(targetSelector, _buttonLinkTargetEdit2.default.key);

            var autocompleteDropdown;

            if (this.props.data) {
                var dataFn = this.props.data;

                if (!_lang2.default.isFunction(dataFn)) {
                    var items = this.props.data;

                    dataFn = function dataFn() {
                        return items;
                    };
                }

                var autocompleteDropdownProps = {
                    autocompleteSelected: this.state.autocompleteSelected,
                    data: dataFn,
                    editor: this.props.editor,
                    handleLinkAutocompleteClick: this._handleLinkAutocompleteClick,
                    onDismiss: this.props.toggleDropdown,
                    setAutocompleteState: this._setAutocompleteState,
                    term: this.state.linkHref
                };

                autocompleteDropdownProps = this.mergeDropdownProps(autocompleteDropdownProps, _buttonLinkAutocompleteList2.default.key);

                autocompleteDropdown = _react2.default.createElement(_buttonLinkAutocompleteList2.default, autocompleteDropdownProps);
            }

            var buttonClearLink;

            if (this.state.linkHref) {
                buttonClearLink = _react2.default.createElement('button', { 'aria-label': AlloyEditor.Strings.clearInput, className: 'ae-button ae-icon-remove', onClick: this._clearLink.bind(this), title: AlloyEditor.Strings.clear });
            }

            var placeholderProp = {};

            if (!CKEDITOR.env.ie && AlloyEditor.Strings) {
                placeholderProp.placeholder = AlloyEditor.Strings.editLink;
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link' },
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.removeLink, className: 'ae-button', disabled: !this.state.element, onClick: this._removeLink.bind(this), title: AlloyEditor.Strings.remove },
                    _react2.default.createElement('span', { className: 'ae-icon-unlink' })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input xxl' },
                    this.props.showTargetSelector && _react2.default.createElement(_buttonLinkTargetEdit2.default, targetSelector),
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container-input' },
                        _react2.default.createElement('input', _extends({ className: 'ae-input', onChange: this._handleLinkHrefChange.bind(this), onKeyDown: this._handleKeyDown.bind(this) }, placeholderProp, { ref: this.linkInput, type: 'text', value: this.state.linkHref })),
                        autocompleteDropdown
                    ),
                    buttonClearLink
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.confirm, className: 'ae-button', disabled: !this._isValidState(), onClick: this._updateLink.bind(this), title: AlloyEditor.Strings.confirm },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }

        /**
         * The return value will be used as the initial value of this.state.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _getInitialState
         * @protected
         * @return {Object}
         */

    }, {
        key: '_getInitialState',
        value: function _getInitialState() {
            var _props = this.props,
                editor = _props.editor,
                defaultLinkTarget = _props.defaultLinkTarget;


            var link = new CKEDITOR.Link(editor.get('nativeEditor')).getFromSelection();
            var href = link ? link.getAttribute('href') : '';
            var target = link ? link.getAttribute('target') : defaultLinkTarget;

            return {
                autocompleteSelected: false,
                element: link,
                initialLink: {
                    href: href,
                    target: target
                },
                linkHref: href,
                linkTarget: target
            };
        }

        /**
         * Clears the link input. This only changes the component internal state, but does not
         * affect the link element of the editor. Only the _removeLink and _updateLink methods
         * are translated to the editor element.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _clearLink
         * @protected
         */

    }, {
        key: '_clearLink',
        value: function _clearLink() {
            this.setState({
                linkHref: ''
            });

            this._focusLinkInput();
        }

        /**
         * Focuses the user cursor on the widget's input.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _focusLinkInput
         * @protected
         */

    }, {
        key: '_focusLinkInput',
        value: function _focusLinkInput() {
            var instance = this;

            var focusLinkEl = function focusLinkEl() {
                instance.linkInput.current.focus();
            };

            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(focusLinkEl);
            } else {
                setTimeout(focusLinkEl, 0);
            }
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates/updates the link.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === 13 || event.keyCode === 27) {
                event.preventDefault();
            }

            if (event.keyCode === 13) {
                this._updateLink();
            } else if (event.keyCode === 40) {
                this.setState({
                    autocompleteSelected: true
                });
            } else if (event.keyCode === 27) {
                var editor = this.props.editor.get('nativeEditor');

                new CKEDITOR.Link(editor).advanceSelection();

                this.props.editor.get('nativeEditor').fire('actionPerformed', this);
            }
        }

        /**
         * Updates the component state when the link input changes on user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkHrefChange
         * @param {SyntheticEvent} event The change event.
         * @protected
         */

    }, {
        key: '_handleLinkHrefChange',
        value: function _handleLinkHrefChange(event) {
            this.setState({
                linkHref: event.target.value
            });

            this._focusLinkInput();
        }

        /**
         * Updates the component state when the link target changes on user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkTargetChange
         * @param {SyntheticEvent} event The click event.
         * @protected
         */

    }, {
        key: '_handleLinkTargetChange',
        value: function _handleLinkTargetChange(event) {
            this.setState({
                itemDropdown: null,
                linkTarget: event.target.getAttribute('data-value')
            });

            this._focusLinkInput();
        }

        /**
         * Updates the component state when an autocomplete link result is selected by user interaction.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _handleLinkAutocompleteClick
         * @param {SyntheticEvent} event The click event.
         * @protected
         */

    }, {
        key: '_handleLinkAutocompleteClick',
        value: function _handleLinkAutocompleteClick(event) {
            this.setState({
                itemDropdown: null,
                linkHref: event.target.getAttribute('data-value')
            });

            this._focusLinkInput();
        }

        /**
         * Verifies that the current link state is valid so the user can save the link. A valid state
         * means that we have a non-empty href and that either that or the link target are different
         * from the original link.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _isValidState
         * @protected
         * @return {Boolean} [description]
         */

    }, {
        key: '_isValidState',
        value: function _isValidState() {
            var validState = this.state.linkHref && (this.state.linkHref !== this.state.initialLink.href || this.state.linkTarget !== this.state.initialLink.target);

            return validState;
        }

        /**
         * Removes the link in the editor element.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _removeLink
         * @protected
         */

    }, {
        key: '_removeLink',
        value: function _removeLink() {
            var editor = this.props.editor.get('nativeEditor');
            var linkUtils = new CKEDITOR.Link(editor);
            var selection = editor.getSelection();
            var bookmarks = selection.createBookmarks();

            linkUtils.remove(this.state.element, { advance: true });

            selection.selectBookmarks(bookmarks);

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();

            editor.fire('actionPerformed', this);
        }

        /**
         * Update autocompleteSelected state to focus and select autocomplete´s dropdown
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _setAutocompleteState
         * @protected
         */

    }, {
        key: '_setAutocompleteState',
        value: function _setAutocompleteState(state) {
            this.setState({
                autocompleteSelected: state.selected
            });
        }

        /**
         * Updates the link in the editor element. If the element didn't exist previously, it will
         * create a new <a> element with the href specified in the link input.
         *
         * @instance
         * @memberof ButtonLinkEdit
         * @method _updateLink
         * @protected
         */

    }, {
        key: '_updateLink',
        value: function _updateLink() {
            var editor = this.props.editor.get('nativeEditor');
            var linkUtils = new CKEDITOR.Link(editor, { appendProtocol: this.props.appendProtocol });
            var linkAttrs = {
                target: this.state.linkTarget
            };
            var modifySelection = { advance: true };

            if (this.state.linkHref) {
                if (this.state.element) {
                    linkAttrs.href = this.state.linkHref;

                    linkUtils.update(linkAttrs, this.state.element, modifySelection);
                } else {
                    linkUtils.create(this.state.linkHref, linkAttrs, modifySelection);
                }

                editor.fire('actionPerformed', this);
            }

            // We need to cancelExclusive with the bound parameters in case the button is used
            // inside another in exclusive mode (such is the case of the link button)
            this.props.cancelExclusive();
        }
    }]);

    return ButtonLinkEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkEdit
 * @memberof ButtonLinkEdit
 * @property {String} key
 * @static
 */


ButtonLinkEdit.key = 'linkEdit';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLinkEdit
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLinkEdit.defaultProps = {
    appendProtocol: true,
    autocompleteUrl: '',
    circular: true,
    customIndexStart: true,
    defaultLinkTarget: '',
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    },
    showTargetSelector: true
};

exports.default = (0, _buttonProps2.default)((0, _widgetDropdown2.default)((0, _widgetFocusManager2.default)(ButtonLinkEdit)));

/***/ }),

/***/ "./src/components/buttons/button-link-target-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-target-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkTargetEdit class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonLinkTargetEdit
 */
var ButtonLinkTargetEdit = function (_React$Component) {
    _inherits(ButtonLinkTargetEdit, _React$Component);

    function ButtonLinkTargetEdit() {
        _classCallCheck(this, ButtonLinkTargetEdit);

        return _possibleConstructorReturn(this, (ButtonLinkTargetEdit.__proto__ || Object.getPrototypeOf(ButtonLinkTargetEdit)).apply(this, arguments));
    }

    _createClass(ButtonLinkTargetEdit, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLinkTargetEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var handleLinkTargetChange = this.props.handleLinkTargetChange;
            var allowedLinkTargets = this.props.allowedTargets;

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-link-target ae-container-dropdown ae-container-dropdown-medium ae-has-dropdown', tabIndex: '0' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': this.props.selectedTarget, className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: this.props.selectedTarget },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            this.props.selectedTarget
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                this.props.expanded && _react2.default.createElement(_buttonTargetList2.default, { editor: this.props.editor, onDismiss: this.props.toggleDropdown, allowedLinkTargets: allowedLinkTargets, handleLinkTargetChange: handleLinkTargetChange, selectedTarget: this.props.selectedTarget })
            );
        }

        /**
         * Lifecycle. Invoked before rendering when new props or state are being received.
         * This method is not called for the initial render or when forceUpdate is used.
         *
         * @instance
         * @memberof ButtonLinkTargetEdit
         * @method  shouldComponentUpdate
         * @return {Boolean} Returns false when the transition to the new props and state will not
         * require a component update.
         */

    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.expanded !== this.props.expanded || nextProps.selectedTarget !== this.props.selectedTarget;
        }
    }]);

    return ButtonLinkTargetEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkTargetEdit
 * @memberof ButtonLinkTargetEdit
 * @property {String} key
 * @static
 */


ButtonLinkTargetEdit.key = 'linkTargetEdit';

exports.default = ButtonLinkTargetEdit;

/***/ }),

/***/ "./src/components/buttons/button-link.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-link.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props.js */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLink class provides functionality for creating and editing a link in a document. ButtonLink
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonLinkEdit UI with all the link edition controls.
 *
 * @class ButtonLink
 * @uses ButtonCfgProps
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 */
var ButtonLink = function (_React$Component) {
    _inherits(ButtonLink, _React$Component);

    function ButtonLink() {
        _classCallCheck(this, ButtonLink);

        return _possibleConstructorReturn(this, (ButtonLink.__proto__ || Object.getPrototypeOf(ButtonLink)).apply(this, arguments));
    }

    _createClass(ButtonLink, [{
        key: 'isActive',

        /**
         * Checks if the current selection is contained within a link.
         *
         * @instance
         * @memberof ButtonLink
         * @method isActive
         * @return {Boolean} True if the selection is inside a link, false otherwise.
         */
        value: function isActive() {
            return new CKEDITOR.Link(this.props.editor.get('nativeEditor')).getFromSelection() !== null;
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonLink
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            if (this.props.renderExclusive) {
                var props = this.mergeButtonCfgProps();

                return _react2.default.createElement(_buttonLinkEdit2.default, props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.link, className: cssClass, 'data-type': 'button-link', onClick: this._requestExclusive.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.link },
                    _react2.default.createElement('span', { className: 'ae-icon-link' })
                );
            }
        }

        /**
         * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
         *
         * @instance
         * @memberof ButtonLink
         * @method _requestExclusive
         * @protected
         */

    }, {
        key: '_requestExclusive',
        value: function _requestExclusive() {
            this.props.requestExclusive(ButtonLink.key);
        }
    }]);

    return ButtonLink;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default link
 * @memberof ButtonLink
 * @property {String} key
 * @static
 */


ButtonLink.key = 'link';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonLink
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonLink.defaultProps = {
    keystroke: {
        fn: '_requestExclusive',
        keys: CKEDITOR.CTRL + 76 /*L*/
    }
};

exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)(ButtonLink)));

/***/ }),

/***/ "./src/components/buttons/button-ol.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ol.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOrderedList class provides functionality for creating ordered lists in an editor.
 *
 * @class ButtonOrderedList
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonOrderedList = function (_React$Component) {
    _inherits(ButtonOrderedList, _React$Component);

    function ButtonOrderedList() {
        _classCallCheck(this, ButtonOrderedList);

        return _possibleConstructorReturn(this, (ButtonOrderedList.__proto__ || Object.getPrototypeOf(ButtonOrderedList)).apply(this, arguments));
    }

    _createClass(ButtonOrderedList, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonOrderedList
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.numberedlist, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-ol', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.numberedlist },
                _react2.default.createElement('span', { className: 'ae-icon-numbered-list' })
            );
        }
    }]);

    return ButtonOrderedList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default ol
 * @memberof ButtonOrderedList
 * @property {String} key
 * @static
 */


ButtonOrderedList.key = 'ol';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonOrderedList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonOrderedList.defaultProps = {
    command: 'numberedlist',
    style: {
        element: 'ol'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonOrderedList)));

/***/ }),

/***/ "./src/components/buttons/button-outdent-block.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-outdent-block.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOutdentBlock class provides functionality for outdenting blocks.
 *
 * @class ButtonOutdentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonOutdentBlock = function (_React$Component) {
    _inherits(ButtonOutdentBlock, _React$Component);

    function ButtonOutdentBlock() {
        _classCallCheck(this, ButtonOutdentBlock);

        return _possibleConstructorReturn(this, (ButtonOutdentBlock.__proto__ || Object.getPrototypeOf(ButtonOutdentBlock)).apply(this, arguments));
    }

    _createClass(ButtonOutdentBlock, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonOutdentBlock
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.outdent, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-outdent-block', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.outdent },
                _react2.default.createElement('span', { className: 'ae-icon-outdent-block' })
            );
        }
    }]);

    return ButtonOutdentBlock;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default indentBlock
 * @memberof ButtonOutdentBlock
 * @property {String} key
 * @static
 */


ButtonOutdentBlock.key = 'outdentBlock';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonOutdentBlock
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonOutdentBlock.defaultProps = {
    command: 'outdent'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonOutdentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-left.jsx":
/*!****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-left.jsx ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignLeft class provides functionality for aligning a paragraph on left.
 *
 * @class ButtonParagraphAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignLeft = function (_React$Component) {
    _inherits(ButtonParagraphAlignLeft, _React$Component);

    function ButtonParagraphAlignLeft() {
        _classCallCheck(this, ButtonParagraphAlignLeft);

        return _possibleConstructorReturn(this, (ButtonParagraphAlignLeft.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignLeft)).apply(this, arguments));
    }

    _createClass(ButtonParagraphAlignLeft, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphAlignLeft
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignLeft, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-align-left', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignLeft },
                _react2.default.createElement('span', { className: 'ae-icon-align-left' })
            );
        }
    }]);

    return ButtonParagraphAlignLeft;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphLeft
 * @memberof ButtonParagraphAlignLeft
 * @property {String} key
 * @static
 */


ButtonParagraphAlignLeft.key = 'paragraphLeft';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphAlignLeft
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphAlignLeft.defaultProps = {
    command: 'justifyleft'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-right.jsx":
/*!*****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-right.jsx ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignRight class provides functionality for aligning a paragraph on right.
 *
 * @class ButtonParagraphAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignRight = function (_React$Component) {
    _inherits(ButtonParagraphAlignRight, _React$Component);

    function ButtonParagraphAlignRight() {
        _classCallCheck(this, ButtonParagraphAlignRight);

        return _possibleConstructorReturn(this, (ButtonParagraphAlignRight.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignRight)).apply(this, arguments));
    }

    _createClass(ButtonParagraphAlignRight, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphAlignRight
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignRight, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-align-right', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignRight },
                _react2.default.createElement('span', { className: 'ae-icon-align-right' })
            );
        }
    }]);

    return ButtonParagraphAlignRight;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphRight
 * @memberof ButtonParagraphAlignRight
 * @property {String} key
 * @static
 */


ButtonParagraphAlignRight.key = 'paragraphRight';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphAlignRight
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphAlignRight.defaultProps = {
    command: 'justifyright'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-center.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-center.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphCenter class provides functionality for centering a paragraph.
 *
 * @class ButtonParagraphCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphCenter = function (_React$Component) {
    _inherits(ButtonParagraphCenter, _React$Component);

    function ButtonParagraphCenter() {
        _classCallCheck(this, ButtonParagraphCenter);

        return _possibleConstructorReturn(this, (ButtonParagraphCenter.__proto__ || Object.getPrototypeOf(ButtonParagraphCenter)).apply(this, arguments));
    }

    _createClass(ButtonParagraphCenter, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphCenter
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignCenter, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-center', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignCenter },
                _react2.default.createElement('span', { className: 'ae-icon-align-center' })
            );
        }
    }]);

    return ButtonParagraphCenter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphCenter
 * @memberof ButtonParagraphCenter
 * @property {String} key
 * @static
 */


ButtonParagraphCenter.key = 'paragraphCenter';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphCenter
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphCenter.defaultProps = {
    command: 'justifycenter'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphCenter)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-justify.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-justify.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active.js */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphJustify class provides functionality for justfying a paragraph.
 *
 * @class ButtonParagraphJustify
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphJustify = function (_React$Component) {
    _inherits(ButtonParagraphJustify, _React$Component);

    function ButtonParagraphJustify() {
        _classCallCheck(this, ButtonParagraphJustify);

        return _possibleConstructorReturn(this, (ButtonParagraphJustify.__proto__ || Object.getPrototypeOf(ButtonParagraphJustify)).apply(this, arguments));
    }

    _createClass(ButtonParagraphJustify, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonParagraphJustify
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.alignJustify, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-paragraph-justify', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.alignJustify },
                _react2.default.createElement('span', { className: 'ae-icon-align-justified' })
            );
        }
    }]);

    return ButtonParagraphJustify;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default paragraphJustify
 * @memberof ButtonParagraphJustify
 * @property {String} key
 * @static
 */


ButtonParagraphJustify.key = 'paragraphJustify';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonParagraphJustify
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonParagraphJustify.defaultProps = {
    command: 'justifyblock'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphJustify)));

/***/ }),

/***/ "./src/components/buttons/button-quote.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-quote.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonQuote class wraps a selection in `blockquote` element.
 *
 * @class ButtonQuote
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonQuote = function (_React$Component) {
    _inherits(ButtonQuote, _React$Component);

    function ButtonQuote() {
        _classCallCheck(this, ButtonQuote);

        return _possibleConstructorReturn(this, (ButtonQuote.__proto__ || Object.getPrototypeOf(ButtonQuote)).apply(this, arguments));
    }

    _createClass(ButtonQuote, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonQuote
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.quote, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-quote', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.quote },
                _react2.default.createElement('span', { className: 'ae-icon-quote' })
            );
        }
    }]);

    return ButtonQuote;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default quote
 * @memberof ButtonQuote
 * @property {String} key
 * @static
 */


ButtonQuote.key = 'quote';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonQuote
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonQuote.defaultProps = {
    command: 'blockquote',
    style: {
        element: 'blockquote'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonQuote)));

/***/ }),

/***/ "./src/components/buttons/button-remove-format.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-remove-format.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonRemoveFormat class removes style formatting.
 *
 * @class ButtonRemoveFormat
 * @uses ButtonCommand
 */
var ButtonRemoveFormat = function (_React$Component) {
    _inherits(ButtonRemoveFormat, _React$Component);

    function ButtonRemoveFormat() {
        _classCallCheck(this, ButtonRemoveFormat);

        return _possibleConstructorReturn(this, (ButtonRemoveFormat.__proto__ || Object.getPrototypeOf(ButtonRemoveFormat)).apply(this, arguments));
    }

    _createClass(ButtonRemoveFormat, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonRemoveFormat
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.removeformat, className: 'ae-button', 'data-type': 'button-removeformat', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.removeformat },
                _react2.default.createElement('span', { className: 'ae-icon-removeformat' })
            );
        }
    }]);

    return ButtonRemoveFormat;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default removeFormat
 * @memberof ButtonRemoveFormat
 * @property {String} key
 * @static
 */


ButtonRemoveFormat.key = 'removeFormat';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonRemoveFormat
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonRemoveFormat.defaultProps = {
    command: 'removeFormat'
};

exports.default = (0, _buttonCommand2.default)(ButtonRemoveFormat);

/***/ }),

/***/ "./src/components/buttons/button-strike.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-strike.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStrike class styles a selection with strike style.
 *
 * @class ButtonStrike
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonStrike = function (_React$Component) {
    _inherits(ButtonStrike, _React$Component);

    function ButtonStrike() {
        _classCallCheck(this, ButtonStrike);

        return _possibleConstructorReturn(this, (ButtonStrike.__proto__ || Object.getPrototypeOf(ButtonStrike)).apply(this, arguments));
    }

    _createClass(ButtonStrike, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         * @instance
         * @memberof ButtonStrike
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.strike, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-strike', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.strike },
                _react2.default.createElement('span', { className: 'ae-icon-strike' })
            );
        }
    }]);

    return ButtonStrike;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default strike
 * @memberof ButtonStrike
 * @property {String} key
 * @static
 */


ButtonStrike.key = 'strike';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStrike
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStrike.defaultProps = {
    command: 'strike',
    style: 'coreStyles_strike'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonStrike)));

/***/ }),

/***/ "./src/components/buttons/button-styles-list-header.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-header.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonsStylesListHeader class provides the header of an list of style items.
 *
 * @class ButtonsStylesListHeader
 */
var ButtonsStylesListHeader = function (_React$Component) {
    _inherits(ButtonsStylesListHeader, _React$Component);

    function ButtonsStylesListHeader() {
        _classCallCheck(this, ButtonsStylesListHeader);

        return _possibleConstructorReturn(this, (ButtonsStylesListHeader.__proto__ || Object.getPrototypeOf(ButtonsStylesListHeader)).apply(this, arguments));
    }

    _createClass(ButtonsStylesListHeader, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonsStylesListHeader
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.styles && this.props.styles.length) {
                return _react2.default.createElement(
                    "span",
                    { className: "ae-list-header" },
                    this.props.name
                );
            } else {
                return null;
            }
        }
    }]);

    return ButtonsStylesListHeader;
}(_react2.default.Component);

exports.default = ButtonsStylesListHeader;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item-remove.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item-remove.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItemRemove class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItemRemove
 */
var ButtonStylesListItemRemove = function (_React$Component) {
    _inherits(ButtonStylesListItemRemove, _React$Component);

    function ButtonStylesListItemRemove() {
        _classCallCheck(this, ButtonStylesListItemRemove);

        return _possibleConstructorReturn(this, (ButtonStylesListItemRemove.__proto__ || Object.getPrototypeOf(ButtonStylesListItemRemove)).apply(this, arguments));
    }

    _createClass(ButtonStylesListItemRemove, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStylesListItemRemove
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                "li",
                { role: "option" },
                _react2.default.createElement(
                    "button",
                    { className: "ae-toolbar-element", onClick: this._removeStyles.bind(this), tabIndex: this.props.tabIndex },
                    AlloyEditor.Strings.normal
                )
            );
        }

        /**
         * Removes all inline styles and configured block elements applied to the current selection.
         *
         * @instance
         * @memberof ButtonStylesListItemRemove
         * @method _removeStyles
         * @protected
         */

    }, {
        key: "_removeStyles",
        value: function _removeStyles() {
            var editor = this.props.editor.get('nativeEditor');

            editor.execCommand('removeFormat');

            this.props.removeBlocks.forEach(function (blockItem) {
                var blockStyle = new CKEDITOR.style({ element: blockItem });

                editor.removeStyle(blockStyle);
            });

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonStylesListItemRemove;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonStylesListItemRemove
 * @memberof ButtonStylesListItemRemove
 * @property {String} key
 * @static
 */


ButtonStylesListItemRemove.key = 'buttonStylesListItemRemove';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStylesListItemRemove
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStylesListItemRemove.defaultProps = {
    removeBlocks: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre']
};

exports.default = ButtonStylesListItemRemove;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style.js */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItem class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItem
 * @uses ButtonActionStyle
 * @uses ButtonStyle
 */
var ButtonStylesListItem = function (_React$Component) {
    _inherits(ButtonStylesListItem, _React$Component);

    function ButtonStylesListItem() {
        _classCallCheck(this, ButtonStylesListItem);

        return _possibleConstructorReturn(this, (ButtonStylesListItem.__proto__ || Object.getPrototypeOf(ButtonStylesListItem)).apply(this, arguments));
    }

    _createClass(ButtonStylesListItem, [{
        key: 'componentWillMount',

        /**
         * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method componentWillMount
         */
        value: function componentWillMount() {
            // Styles with wildcard element (*) generate an empty tag in their preview < class="custom-class" />.
            // We default to element span and remove the margins to obtain a more consistent set of previews.
            var styleCfg = {
                element: 'span',
                styles: {
                    margin: 0
                }
            };

            styleCfg = CKEDITOR.tools.merge(styleCfg, this.props.style);

            this._preview = new CKEDITOR.style(styleCfg).buildPreview(this.props.name);
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            // We need to use dangerouselySetInnterHTML since we're not in control of the style
            // preview that is generated by CKEditor.
            var className = this.props.name === this.props.activeStyle ? 'ae-toolbar-element active' : 'ae-toolbar-element';

            return _react2.default.createElement('button', { className: className, dangerouslySetInnerHTML: { __html: this._preview }, onClick: this._onClick.bind(this), tabIndex: this.props.tabIndex });
        }

        /**
         * Applies the item style to the editor selection.
         *
         * @instance
         * @memberof ButtonStylesListItem
         * @method _onClick
         * @protected
         */

    }, {
        key: '_onClick',
        value: function _onClick() {
            // Typically, we want the style to be the only one applied to the current selection, so
            // we execute the 'removeFormat' command first. Note that block styles won't be cleaned.
            // However, this is consistent with other editors implementations of this feature.
            this.props.editor.get('nativeEditor').execCommand('removeFormat');

            this.applyStyle();
        }
    }]);

    return ButtonStylesListItem;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default buttonStylesListItem
 * @memberof ButtonStylesListItem
 * @property {String} key
 * @static
 */


ButtonStylesListItem.key = 'buttonStylesListItem';

exports.default = (0, _buttonActionStyle2.default)((0, _buttonStyle2.default)(ButtonStylesListItem));

/***/ }),

/***/ "./src/components/buttons/button-styles-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-styles-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesList class provides functionality for showing a list of styles that can be
 * applied to the current selection..
 *
 * @class ButtonStylesList
 * @uses WidgetFocusManager
 */
var ButtonStylesList = function (_React$Component) {
    _inherits(ButtonStylesList, _React$Component);

    function ButtonStylesList() {
        _classCallCheck(this, ButtonStylesList);

        return _possibleConstructorReturn(this, (ButtonStylesList.__proto__ || Object.getPrototypeOf(ButtonStylesList)).apply(this, arguments));
    }

    _createClass(ButtonStylesList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * Focuses on the list node to allow keyboard interaction.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method componentWillMount
         */

    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            var blockStyles = [];
            var inlineStyles = [];
            var objectStyles = [];

            this.props.styles.forEach(function (item) {
                var style = new CKEDITOR.style(item.style);

                if (style.type === CKEDITOR.STYLE_BLOCK) {
                    blockStyles.push(item);
                } else if (style.type === CKEDITOR.STYLE_INLINE) {
                    inlineStyles.push(item);
                } else if (style.type === CKEDITOR.STYLE_OBJECT) {
                    objectStyles.push(item);
                }
            });

            this._blockStyles = blockStyles;
            this._inlineStyles = inlineStyles;
            this._objectStyles = objectStyles;
        }

        /**
         * Lifecycle. Renders the UI of the list.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var removeStylesItem;

            if (this.props.showRemoveStylesItem) {
                removeStylesItem = _react2.default.createElement(_buttonStylesListItemRemove2.default, { editor: this.props.editor, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                _buttonDropdown2.default,
                this.props,
                removeStylesItem,
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.blockStyles, styles: this._blockStyles }),
                this._renderStylesItems(this._blockStyles),
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.inlineStyles, styles: this._inlineStyles }),
                this._renderStylesItems(this._inlineStyles),
                _react2.default.createElement(_buttonStylesListHeader2.default, { name: AlloyEditor.Strings.objectStyles, styles: this._objectStyles }),
                this._renderStylesItems(this._objectStyles)
            );
        }

        /**
         * Renders instances of ButtonStylesListItem with the preview of the correspondent block, inline or object styles.
         *
         * @instance
         * @memberof ButtonStylesList
         * @method _renderStylesItems
         * @param {Array} styles List of styles for which preview should be rendered.
         * @protected
         * @return {Array} Rendered instances of ButtonStylesListItem class
         */

    }, {
        key: '_renderStylesItems',
        value: function _renderStylesItems(styles) {
            var editor = this.props.editor;
            var items;

            if (styles && styles.length) {
                items = styles.map(function (item) {
                    return _react2.default.createElement(
                        'li',
                        { key: item.name, role: 'option' },
                        _react2.default.createElement(_buttonStylesListItem2.default, { activeStyle: this.props.activeStyle, editor: editor, name: item.name, style: item.style })
                    );
                }.bind(this));
            }

            return items;
        }
    }]);

    return ButtonStylesList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @memberof ButtonStylesList
 * @static
 * @property {String} key
 * @default buttonStylesList
 */


ButtonStylesList.key = 'buttonStylesList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonStylesList
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonStylesList.defaultProps = {
    circular: false,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    },
    showRemoveStylesItem: true
};

exports.default = (0, _widgetFocusManager2.default)(ButtonStylesList);

/***/ }),

/***/ "./src/components/buttons/button-styles.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-styles.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

<<<<<<< HEAD
        widget.parts.image.on('click', function () {
            var selection = editor.getSelection();

            if (selection) {
                var element = selection.getStartElement();

                if (element) {
                    var widgetElement = element.findOne('img');

                    if (widgetElement) {
                        var region = element.getClientRect();

                        var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
                        region.left -= scrollPosition.x;
                        region.top += scrollPosition.y;

                        region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

                        editor.fire('editorInteraction', {
                            nativeEvent: event,
                            selectionData: {
                                element: widgetElement,
                                region: region
                            }
                        });
                    }
                }
            }
        });
    }
=======
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
>>>>>>> Build files (auto-generated)

/**
 * The ButtonStyles class provides functionality for styling a selection with a list of
 * configurable and customizable styles. The allowed styles follow CKEDITOR.Style configuration
 * (http://docs.ckeditor.com/#!/api/CKEDITOR.style)
 *
 * @class ButtonStyles
 */
var ButtonStyles = function (_React$Component) {
    _inherits(ButtonStyles, _React$Component);

    function ButtonStyles() {
        _classCallCheck(this, ButtonStyles);

        return _possibleConstructorReturn(this, (ButtonStyles.__proto__ || Object.getPrototypeOf(ButtonStyles)).apply(this, arguments));
    }

    _createClass(ButtonStyles, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonStyles
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var activeStyle = AlloyEditor.Strings.normal;

            var styles = this._getStyles();

            styles.forEach(function (item) {
                if (this._checkActive(item.style)) {
                    activeStyle = item.name;
                }
            }.bind(this));

            var buttonStylesList;

            if (this.props.expanded) {
                buttonStylesList = _react2.default.createElement(_buttonStylesList2.default, { activeStyle: activeStyle, editor: this.props.editor, onDismiss: this.props.toggleDropdown, showRemoveStylesItem: this.props.showRemoveStylesItem, styles: styles });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-dropdown ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.styles + ' ' + activeStyle, className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.styles + ' ' + activeStyle },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            activeStyle
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                buttonStylesList
            );
        }

        /**
         * Checks if the given style definition is applied to the current selection in the editor.
         *
         * @instance
         * @memberof ButtonStyles
         * @method _checkActive
         * @param {Object} styleConfig Style definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
         * @protected
         * @return {Boolean} Returns true if the style is applied to the selection, false otherwise.
         */

    }, {
        key: '_checkActive',
        value: function _checkActive(styleConfig) {
            var nativeEditor = this.props.editor.get('nativeEditor');

            // Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
            // to a 'span' element works for most of those cases with no defined element.
            styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

            var style = new CKEDITOR.style(styleConfig);

            return style.checkActive(nativeEditor.elementPath(), nativeEditor);
        }

        /**
         * Returns an array of styles. Each style consists from two properties:
         * - name - the style name, for example "h1"
         * - style - an object with one property, called `element` which value
         * represents the style which have to be applied to the element.
         *
         * @instance
         * @memberof ButtonStyles
         * @method _getStyles
         * @protected
         * @return {Array<object>} An array of objects containing the styles.
         */

    }, {
        key: '_getStyles',
        value: function _getStyles() {
            return this.props.styles || [{
                name: AlloyEditor.Strings.h1,
                style: {
                    element: 'h1'
                }
            }, {
                name: AlloyEditor.Strings.h2,
                style: {
                    element: 'h2'
                }
            }, {
                name: AlloyEditor.Strings.formatted,
                style: {
                    element: 'pre'
                }
            }, {
                name: AlloyEditor.Strings.cite,
                style: {
                    element: 'cite'
                }
            }, {
                name: AlloyEditor.Strings.code,
                style: {
                    element: 'code'
                }
            }];
        }
    }]);

    return ButtonStyles;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default styles
 * @memberof ButtonStyles
 * @property {String} key
 * @static
 */


ButtonStyles.key = 'styles';

exports.default = ButtonStyles;

/***/ }),

/***/ "./src/components/buttons/button-subscript.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-subscript.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSubscript class provides functionality for applying subscript style to a text selection.
 *
 * @class ButtonSubscript
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSubscript = function (_React$Component) {
    _inherits(ButtonSubscript, _React$Component);

    function ButtonSubscript() {
        _classCallCheck(this, ButtonSubscript);

        return _possibleConstructorReturn(this, (ButtonSubscript.__proto__ || Object.getPrototypeOf(ButtonSubscript)).apply(this, arguments));
    }

    _createClass(ButtonSubscript, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonSubscript
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.subscript, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-subscript', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.subscript },
                _react2.default.createElement('span', { className: 'ae-icon-subscript' })
            );
        }
    }]);

    return ButtonSubscript;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default subscript
 * @memberof ButtonSubscript
 * @property {String} key
 * @static
 */


ButtonSubscript.key = 'subscript';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonSubscript
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonSubscript.defaultProps = {
    command: 'subscript',
    style: 'coreStyles_subscript'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSubscript)));

/***/ }),

/***/ "./src/components/buttons/button-superscript.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-superscript.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSuperscript class provides functionality for applying superscript style to a text selection.
 *
 * @class ButtonSuperscript
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSuperscript = function (_React$Component) {
    _inherits(ButtonSuperscript, _React$Component);

    function ButtonSuperscript() {
        _classCallCheck(this, ButtonSuperscript);

        return _possibleConstructorReturn(this, (ButtonSuperscript.__proto__ || Object.getPrototypeOf(ButtonSuperscript)).apply(this, arguments));
    }

    _createClass(ButtonSuperscript, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonSuperscript
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.superscript, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-superscript', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.superscript },
                _react2.default.createElement('span', { className: 'ae-icon-superscript' })
            );
        }
    }]);

    return ButtonSuperscript;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default superscript
 * @memberof ButtonSuperscript
 * @property {String} key
 * @static
 */


ButtonSuperscript.key = 'superscript';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonSuperscript
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonSuperscript.defaultProps = {
    command: 'superscript',
    style: 'coreStyles_superscript'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSuperscript)));

/***/ }),

/***/ "./src/components/buttons/button-table-cell.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-cell.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableCell class provides functionality to work with table cells.
 *
 * @class ButtonTableCell
 */
var ButtonTableCell = function (_React$Component) {
    _inherits(ButtonTableCell, _React$Component);

    function ButtonTableCell() {
        _classCallCheck(this, ButtonTableCell);

        return _possibleConstructorReturn(this, (ButtonTableCell.__proto__ || Object.getPrototypeOf(ButtonTableCell)).apply(this, arguments));
    }

    _createClass(ButtonTableCell, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableCell
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableCell.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.cell, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.cell },
                    _react2.default.createElement('span', { className: 'ae-icon-cell' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableCell
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'cellInsertBefore',
                label: AlloyEditor.Strings.cellInsertBefore
            }, {
                command: 'cellInsertAfter',
                label: AlloyEditor.Strings.cellInsertAfter
            }, {
                command: 'cellDelete',
                label: AlloyEditor.Strings.cellDelete
            }, {
                command: 'cellMerge',
                label: AlloyEditor.Strings.cellMerge
            }, {
                command: 'cellMergeDown',
                label: AlloyEditor.Strings.cellMergeDown
            }, {
                command: 'cellMergeRight',
                label: AlloyEditor.Strings.cellMergeRight
            }, {
                command: 'cellHorizontalSplit',
                label: AlloyEditor.Strings.cellSplitHorizontal
            }, {
                command: 'cellVerticalSplit',
                label: AlloyEditor.Strings.cellSplitVertical
            }];
        }
    }]);

    return ButtonTableCell;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableCell
 * @memberof ButtonTableCell
 * @property {String} key
 * @static
 */


ButtonTableCell.key = 'tableCell';

exports.default = ButtonTableCell;

/***/ }),

/***/ "./src/components/buttons/button-table-column.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-column.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableColumn class provides functionality to work with table columns.
 *
 * @class ButtonTableColumn
 */
var ButtonTableColumn = function (_React$Component) {
    _inherits(ButtonTableColumn, _React$Component);

    function ButtonTableColumn() {
        _classCallCheck(this, ButtonTableColumn);

        return _possibleConstructorReturn(this, (ButtonTableColumn.__proto__ || Object.getPrototypeOf(ButtonTableColumn)).apply(this, arguments));
    }

    _createClass(ButtonTableColumn, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableColumn
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList, buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableColumn.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.column, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), role: 'listbox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.column },
                    _react2.default.createElement('span', { className: 'ae-icon-column' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableColumn
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'columnInsertBefore',
                label: AlloyEditor.Strings.columnInsertBefore
            }, {
                command: 'columnInsertAfter',
                label: AlloyEditor.Strings.columnInsertAfter
            }, {
                command: 'columnDelete',
                label: AlloyEditor.Strings.columnDelete
            }];
        }
    }]);

    return ButtonTableColumn;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableColumn
 * @memberof ButtonTableColumn
 * @property {String} key
 * @static
 */


ButtonTableColumn.key = 'tableColumn';

exports.default = ButtonTableColumn;

/***/ }),

/***/ "./src/components/buttons/button-table-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonTableEdit class provides functionality for creating and editing a table in a document.
 * Provides UI for creating a table.
 *
 * @class ButtonTableEdit
 */

var ButtonTableEdit = function (_React$Component) {
    _inherits(ButtonTableEdit, _React$Component);

    /**
     * Lifecycle. Invoked once before the component is mounted.
     *
     * @instance
     * @memberof ButtonTableEdit
     * @method getInitialState
     */
    function ButtonTableEdit(props) {
        _classCallCheck(this, ButtonTableEdit);

        var _this = _possibleConstructorReturn(this, (ButtonTableEdit.__proto__ || Object.getPrototypeOf(ButtonTableEdit)).call(this, props));

        _this.rowsRef = _react2.default.createRef();
        _this.colsRef = _react2.default.createRef();
        _this.state = {
            cols: 3,
            rows: 3
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * Focuses on the link input to immediately allow editing.
     *
     * @instance
     * @memberof ButtonTableEdit
     * @method componentDidMount
     */


    _createClass(ButtonTableEdit, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.rowsRef.current.focus();
        }

        /**
         * Creates a table.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _createTable
         * @protected
         */

    }, {
        key: '_createTable',
        value: function _createTable() {
            var editor = this.props.editor.get('nativeEditor');
            var tableUtils = new CKEDITOR.Table(editor);

            tableUtils.create({
                attrs: this.props.tableAttributes,
                cols: this.state.cols,
                rows: this.state.rows
            });

            this.props.cancelExclusive();

            editor.fire('actionPerformed', this);
        }

        /**
         * Handles a change in input value. Sets the provided value from the user back to the input.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _handleChange
         * @param {String} inputName The name of the input which value should be updated.
         * @param {SyntheticEvent} event The provided event.
         * @protected
         */

    }, {
        key: '_handleChange',
        value: function _handleChange(inputName, event) {
            var state = {};
            state[inputName] = event.target.value;

            this.setState(state);
        }

        /**
         * Monitors key interaction inside the input element to respond to the keys:
         * - Enter: Creates the table.
         * - Escape: Discards the changes.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method _handleKeyDown
         * @param {SyntheticEvent} event The keyboard event.
         * @protected
         */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
                event.preventDefault();
            }

            if (event.keyCode === KEY_ENTER) {
                this._createTable();
            } else if (event.keyCode === KEY_ESC) {
                this.props.cancelExclusive();
            }
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableEdit
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var time = Date.now();
            var rowsId = time + 'rows';
            var colsId = time + 'cols';

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-edit-table' },
                _react2.default.createElement(
                    'label',
                    { htmlFor: rowsId },
                    AlloyEditor.Strings.rows
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input small' },
                    _react2.default.createElement('input', { className: 'ae-input', id: rowsId, onChange: this._handleChange.bind(this, 'rows'), min: '1', onKeyDown: this._handleKeyDown.bind(this), placeholder: 'Rows', ref: this.rowsRef, type: 'number', value: this.state.rows })
                ),
                _react2.default.createElement(
                    'label',
                    { htmlFor: colsId },
                    AlloyEditor.Strings.columns
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container-input small' },
                    _react2.default.createElement('input', { className: 'ae-input', id: colsId, onChange: this._handleChange.bind(this, 'cols'), min: '1', onKeyDown: this._handleKeyDown.bind(this), placeholder: 'Colums', ref: this.colsRef, type: 'number', value: this.state.cols })
                ),
                _react2.default.createElement(
                    'button',
                    { 'aria-label': 'Confirm', className: 'ae-button', onClick: this._createTable.bind(this) },
                    _react2.default.createElement('span', { className: 'ae-icon-ok' })
                )
            );
        }
    }]);

    return ButtonTableEdit;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableEdit
 * @memberof ButtonTableEdit
 * @property {String} key
 * @static
 */


ButtonTableEdit.key = 'tableEdit';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonTableEdit
 * @method getDefaultProps
 */
ButtonTableEdit.defaultProps = {
    tableAttributes: {
        border: 1,
        cellPadding: 0,
        cellSpacing: 0,
        style: 'width: 100%'
    }
};

exports.default = ButtonTableEdit;

/***/ }),

/***/ "./src/components/buttons/button-table-heading.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-table-heading.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableHeading class provides functionality to work with table heading.
 *
 * @class ButtonTableHeading
 */
var ButtonTableHeading = function (_React$Component) {
    _inherits(ButtonTableHeading, _React$Component);

    function ButtonTableHeading() {
        _classCallCheck(this, ButtonTableHeading);

        return _possibleConstructorReturn(this, (ButtonTableHeading.__proto__ || Object.getPrototypeOf(ButtonTableHeading)).apply(this, arguments));
    }

    _createClass(ButtonTableHeading, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableHeading
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableHeading.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            var activeHeading = new CKEDITOR.Table(this.props.editor.get('nativeEditor')).getHeading();
            var activeHeadingIntro = AlloyEditor.Strings.headers + ':';
            var activeHeadingLabel = AlloyEditor.Strings['headers' + activeHeading];

            return _react2.default.createElement(
                'div',
                { className: 'ae-container-dropdown-xl ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': '', className: 'ae-toolbar-element', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: '' },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        _react2.default.createElement(
                            'span',
                            { className: 'ae-container-dropdown-selected-item' },
                            activeHeadingIntro,
                            ' ',
                            _react2.default.createElement(
                                'strong',
                                null,
                                activeHeadingLabel
                            )
                        ),
                        _react2.default.createElement('span', { className: 'ae-icon-arrow' })
                    )
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableHeading
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'tableHeadingNone',
                label: AlloyEditor.Strings.headersNone
            }, {
                command: 'tableHeadingRow',
                label: AlloyEditor.Strings.headersRow
            }, {
                command: 'tableHeadingColumn',
                label: AlloyEditor.Strings.headersColumn
            }, {
                command: 'tableHeadingBoth',
                label: AlloyEditor.Strings.headersBoth
            }];
        }
    }]);

    return ButtonTableHeading;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRow
 * @memberof ButtonTableHeading
 * @property {String} key
 * @static
 */


ButtonTableHeading.key = 'tableHeading';

exports.default = ButtonTableHeading;

/***/ }),

/***/ "./src/components/buttons/button-table-remove.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-remove.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRemove class provides functionality for removing a table
 *
 * @class ButtonTableRemove
 */
var ButtonTableRemove = function (_React$Component) {
    _inherits(ButtonTableRemove, _React$Component);

    function ButtonTableRemove() {
        _classCallCheck(this, ButtonTableRemove);

        return _possibleConstructorReturn(this, (ButtonTableRemove.__proto__ || Object.getPrototypeOf(ButtonTableRemove)).apply(this, arguments));
    }

    _createClass(ButtonTableRemove, [{
        key: "render",

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableRemove
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            return _react2.default.createElement(
                "button",
                { "aria-label": AlloyEditor.Strings.deleteTable, className: "ae-button", "data-type": "button-table-remove", onClick: this._removeTable.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.deleteTable },
                _react2.default.createElement("span", { className: "ae-icon-bin" })
            );
        }

        /**
         * Removes the table in the editor element.
         *
         * @instance
         * @memberof ButtonTableRemove
         * @method _removeTable
         * @protected
         */

    }, {
        key: "_removeTable",
        value: function _removeTable() {
            var editor = this.props.editor.get('nativeEditor');
            var tableUtils = new CKEDITOR.Table(editor);

            tableUtils.remove();

            editor.fire('actionPerformed', this);
        }
    }]);

    return ButtonTableRemove;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRemove
 * @memberof ButtonTableRemove
 * @property {String} key
 * @static
 */


ButtonTableRemove.key = 'tableRemove';

exports.default = ButtonTableRemove;

/***/ }),

/***/ "./src/components/buttons/button-table-row.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-table-row.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRow class provides functionality to work with table rows.
 *
 * @class ButtonTableRow
 */
var ButtonTableRow = function (_React$Component) {
    _inherits(ButtonTableRow, _React$Component);

    function ButtonTableRow() {
        _classCallCheck(this, ButtonTableRow);

        return _possibleConstructorReturn(this, (ButtonTableRow.__proto__ || Object.getPrototypeOf(ButtonTableRow)).apply(this, arguments));
    }

    _createClass(ButtonTableRow, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTableRow
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var buttonCommandsList;
            var buttonCommandsListId;

            if (this.props.expanded) {
                buttonCommandsListId = ButtonTableRow.key + 'List';
                buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, { commands: this._getCommands(), editor: this.props.editor, listId: buttonCommandsListId, onDismiss: this.props.toggleDropdown });
            }

            return _react2.default.createElement(
                'div',
                { className: 'ae-container ae-has-dropdown' },
                _react2.default.createElement(
                    'button',
                    { 'aria-expanded': this.props.expanded, 'aria-label': AlloyEditor.Strings.row, 'aria-owns': buttonCommandsListId, className: 'ae-button', onClick: this.props.toggleDropdown.bind(this), role: 'combobox', tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.row },
                    _react2.default.createElement('span', { className: 'ae-icon-row' })
                ),
                buttonCommandsList
            );
        }

        /**
         * Returns a list of commands. If a list of commands was passed
         * as property `commands`, it will take a precedence over the default ones.
         *
         * @instance
         * @memberof ButtonTableRow
         * @method _getCommands
         * @protected
         * @return {Array} The list of available commands.
         */

    }, {
        key: '_getCommands',
        value: function _getCommands() {
            return this.props.commands || [{
                command: 'rowInsertBefore',
                label: AlloyEditor.Strings.rowInsertBefore
            }, {
                command: 'rowInsertAfter',
                label: AlloyEditor.Strings.rowInsertAfter
            }, {
                command: 'rowDelete',
                label: AlloyEditor.Strings.rowDelete
            }];
        }
    }]);

    return ButtonTableRow;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default tableRow
 * @memberof ButtonTableRow
 * @property {String} key
 * @static
 */


ButtonTableRow.key = 'tableRow';

exports.default = ButtonTableRow;

/***/ }),

/***/ "./src/components/buttons/button-table.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-table.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTable class provides functionality for creating and editing a table in a document. ButtonTable
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonTableEdit UI with all the table edition controls.
 *
 * @class ButtonTable
 */
var ButtonTable = function (_React$Component) {
    _inherits(ButtonTable, _React$Component);

    function ButtonTable() {
        _classCallCheck(this, ButtonTable);

        return _possibleConstructorReturn(this, (ButtonTable.__proto__ || Object.getPrototypeOf(ButtonTable)).apply(this, arguments));
    }

    _createClass(ButtonTable, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTable
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            if (this.props.renderExclusive) {
                return _react2.default.createElement(_buttonTableEdit2.default, this.props);
            } else {
                return _react2.default.createElement(
                    'button',
                    { 'aria-label': AlloyEditor.Strings.table, className: 'ae-button', 'data-type': 'button-table', onClick: this.props.requestExclusive, tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.table },
                    _react2.default.createElement('span', { className: 'ae-icon-table' })
                );
            }
        }
    }]);

    return ButtonTable;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default table
 * @memberof ButtonTable
 * @property {String} key
 * @static
 */


ButtonTable.key = 'table';

exports.default = ButtonTable;

/***/ }),

/***/ "./src/components/buttons/button-target-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-target-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTargetList class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonTargetList
 * @uses WidgetFocusManager
 */
var ButtonTargetList = function (_React$Component) {
    _inherits(ButtonTargetList, _React$Component);

    function ButtonTargetList() {
        _classCallCheck(this, ButtonTargetList);

        return _possibleConstructorReturn(this, (ButtonTargetList.__proto__ || Object.getPrototypeOf(ButtonTargetList)).apply(this, arguments));
    }

    _createClass(ButtonTargetList, [{
        key: 'componentDidMount',

        /**
         * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method componentDidMount
         */
        value: function componentDidMount() {
            _reactDom2.default.findDOMNode(this).focus();
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var listTargets = this._renderListTargets();

            return _react2.default.createElement(
                _buttonDropdown2.default,
                this.props,
                listTargets
            );
        }

        /**
         * Returns the the allowed link target items.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method _getAllowedTargetItems
         * @protected
         * @return {Array} The allowed target items.
         */

    }, {
        key: '_getAllowedTargetItems',
        value: function _getAllowedTargetItems() {
            return this.props.allowedLinkTargets || [{
                label: AlloyEditor.Strings.linkTargetDefault,
                value: ''
            }, {
                label: AlloyEditor.Strings.linkTargetSelf,
                value: '_self'
            }, {
                label: AlloyEditor.Strings.linkTargetBlank,
                value: '_blank'
            }, {
                label: AlloyEditor.Strings.linkTargetParent,
                value: '_parent'
            }, {
                label: AlloyEditor.Strings.linkTargetTop,
                value: '_top'
            }];
        }

        /**
         * Renders the allowed link target items.
         *
         * @instance
         * @memberof ButtonTargetList
         * @method _renderListTargets
         * @protected
         * @return {Object} Returns the rendered link items
         */

    }, {
        key: '_renderListTargets',
        value: function _renderListTargets() {
            var targets = this._getAllowedTargetItems();

            var handleLinkTargetChange = this.props.handleLinkTargetChange;

            targets = targets.map(function (target) {
                var className = this.props.selectedTarget === target.value ? 'ae-toolbar-element active' : 'ae-toolbar-element';

                return _react2.default.createElement(
                    'li',
                    { key: target.value, role: 'option' },
                    _react2.default.createElement(
                        'button',
                        { className: className, 'data-value': target.value, onClick: handleLinkTargetChange },
                        target.label
                    )
                );
            }.bind(this));

            return targets;
        }
    }]);

    return ButtonTargetList;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default linkTargetEdit
 * @memberof ButtonTargetList
 * @property {String} key
 * @static
 */


ButtonTargetList.key = 'targetList';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonTargetList
 * @method getDefaultProps
 */
ButtonTargetList.defaultProps = {
    circular: true,
    descendants: '.ae-toolbar-element',
    keys: {
        dismiss: [27],
        dismissNext: [39],
        dismissPrev: [37],
        next: [40],
        prev: [38]
    }
};

exports.default = (0, _widgetFocusManager2.default)(ButtonTargetList);

/***/ }),

/***/ "./src/components/buttons/button-twitter.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-twitter.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTwitter class provides functionality for creating a link which
 * allows people to tweet part of the content in the editor.
 *
 * @class ButtonTwitter
 * @uses ButtonStateClasses
 */
var ButtonTwitter = function (_React$Component) {
    _inherits(ButtonTwitter, _React$Component);

    function ButtonTwitter() {
        _classCallCheck(this, ButtonTwitter);

        return _possibleConstructorReturn(this, (ButtonTwitter.__proto__ || Object.getPrototypeOf(ButtonTwitter)).apply(this, arguments));
    }

    _createClass(ButtonTwitter, [{
        key: 'handleClick',

        /**
         * Creates or removes the twitter link on the selection.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method handleClick
         */
        value: function handleClick() {
            var editor = this.props.editor.get('nativeEditor');

            var linkUtils = new CKEDITOR.Link(editor);

            if (this.isActive()) {
                linkUtils.remove(linkUtils.getFromSelection());
            } else {
                linkUtils.create(this._getHref(), {
                    'class': 'ae-twitter-link',
                    'target': '_blank'
                });
            }

            editor.fire('actionPerformed', this);
        }

        /**
         * Checks if the current selection is contained within a link that points to twitter.com/intent/tweet.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method isActive
         * @return {Boolean} True if the selection is inside a twitter link, false otherwise.
         */

    }, {
        key: 'isActive',
        value: function isActive() {
            var link = new CKEDITOR.Link(this.props.editor.get('nativeEditor')).getFromSelection();

            return link && link.getAttribute('href').indexOf('twitter.com/intent/tweet') !== -1;
        }

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.twitter, className: cssClass, 'data-type': 'button-twitter', onClick: this.handleClick.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.twitter },
                _react2.default.createElement('span', { className: 'ae-icon-twitter' })
            );
        }

        /**
         * Generates the appropriate twitter url based on the selected text and the configuration
         * options received via props.
         *
         * @instance
         * @memberof ButtonTwitter
         * @method _getHref
         * @protected
         * @return {String} A valid twitter url with the selected text and given configuration.
         */

    }, {
        key: '_getHref',
        value: function _getHref() {
            var nativeEditor = this.props.editor.get('nativeEditor');
            var selectedText = nativeEditor.getSelection().getSelectedText();
            var url = this.props.url;
            var via = this.props.via;
            var twitterHref = 'https://twitter.com/intent/tweet?text=' + selectedText;

            if (url) {
                twitterHref += '&url=' + url;
            }

            if (via) {
                twitterHref += '&via=' + via;
            }

            return twitterHref;
        }
    }]);

    return ButtonTwitter;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default twitter
 * @memberof ButtonTwitter
 * @property {String} key
 * @static
 */


ButtonTwitter.key = 'twitter';

exports.default = (0, _buttonStateClasses2.default)(ButtonTwitter);

/***/ }),

/***/ "./src/components/buttons/button-ul.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ul.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnorderedlist class provides functionality for creating unordered lists in an editor.
 *
 * @class ButtonUnorderedlist
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnorderedlist = function (_React$Component) {
    _inherits(ButtonUnorderedlist, _React$Component);

    function ButtonUnorderedlist() {
        _classCallCheck(this, ButtonUnorderedlist);

        return _possibleConstructorReturn(this, (ButtonUnorderedlist.__proto__ || Object.getPrototypeOf(ButtonUnorderedlist)).apply(this, arguments));
    }

    _createClass(ButtonUnorderedlist, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonUnorderedlist
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.bulletedlist, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-ul', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.bulletedlist },
                _react2.default.createElement('span', { className: 'ae-icon-bulleted-list' })
            );
        }
    }]);

    return ButtonUnorderedlist;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default ul
 * @memberof ButtonUnorderedlist
 * @property {String} key
 * @static
 */


ButtonUnorderedlist.key = 'ul';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonUnorderedlist
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonUnorderedlist.defaultProps = {
    command: 'bulletedlist',
    style: {
        element: 'ul'
    }
};

exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnorderedlist)));

/***/ }),

/***/ "./src/components/buttons/button-underline.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-underline.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke.js */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style.js */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnderline class provides functionality for underlying a text selection.
 *
 * @class ButtonUnderline
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnderline = function (_React$Component) {
    _inherits(ButtonUnderline, _React$Component);

    function ButtonUnderline() {
        _classCallCheck(this, ButtonUnderline);

        return _possibleConstructorReturn(this, (ButtonUnderline.__proto__ || Object.getPrototypeOf(ButtonUnderline)).apply(this, arguments));
    }

    _createClass(ButtonUnderline, [{
        key: 'render',

        /**
         * Lifecycle. Renders the UI of the button.
         *
         * @instance
         * @memberof ButtonUnderline
         * @method render
         * @return {Object} The content which should be rendered.
         */
        value: function render() {
            var cssClass = 'ae-button ' + this.getStateClasses();

            return _react2.default.createElement(
                'button',
                { 'aria-label': AlloyEditor.Strings.underline, 'aria-pressed': cssClass.indexOf('pressed') !== -1, className: cssClass, 'data-type': 'button-underline', onClick: this.execCommand.bind(this), tabIndex: this.props.tabIndex, title: AlloyEditor.Strings.underline },
                _react2.default.createElement('span', { className: 'ae-icon-underline' })
            );
        }
    }]);

    return ButtonUnderline;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default underline
 * @memberof ButtonUnderline
 * @property {String} key
 * @static
 */


ButtonUnderline.key = 'underline';

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ButtonUnderline
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ButtonUnderline.defaultProps = {
    command: 'underline',
    keystroke: {
        fn: 'execCommand',
        keys: CKEDITOR.CTRL + 85 /*U*/
    },
    style: 'coreStyles_underline'
};

exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnderline))));

/***/ }),

/***/ "./src/components/buttons/index.js":
/*!*****************************************!*\
  !*** ./src/components/buttons/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ButtonBold$key$Butto;

var _buttonBold = __webpack_require__(/*! ./button-bold.jsx */ "./src/components/buttons/button-bold.jsx");

var _buttonBold2 = _interopRequireDefault(_buttonBold);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonCamera = __webpack_require__(/*! ./button-camera.jsx */ "./src/components/buttons/button-camera.jsx");

var _buttonCamera2 = _interopRequireDefault(_buttonCamera);

var _buttonCode = __webpack_require__(/*! ./button-code.jsx */ "./src/components/buttons/button-code.jsx");

var _buttonCode2 = _interopRequireDefault(_buttonCode);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonEmbed = __webpack_require__(/*! ./button-embed.jsx */ "./src/components/buttons/button-embed.jsx");

var _buttonEmbed2 = _interopRequireDefault(_buttonEmbed);

var _buttonH = __webpack_require__(/*! ./button-h1.jsx */ "./src/components/buttons/button-h1.jsx");

var _buttonH2 = _interopRequireDefault(_buttonH);

var _buttonH3 = __webpack_require__(/*! ./button-h2.jsx */ "./src/components/buttons/button-h2.jsx");

var _buttonH4 = _interopRequireDefault(_buttonH3);

var _buttonHline = __webpack_require__(/*! ./button-hline.jsx */ "./src/components/buttons/button-hline.jsx");

var _buttonHline2 = _interopRequireDefault(_buttonHline);

var _buttonImageAlignCenter = __webpack_require__(/*! ./button-image-align-center.jsx */ "./src/components/buttons/button-image-align-center.jsx");

var _buttonImageAlignCenter2 = _interopRequireDefault(_buttonImageAlignCenter);

var _buttonImageAlignLeft = __webpack_require__(/*! ./button-image-align-left.jsx */ "./src/components/buttons/button-image-align-left.jsx");

var _buttonImageAlignLeft2 = _interopRequireDefault(_buttonImageAlignLeft);

var _buttonImageAlignRight = __webpack_require__(/*! ./button-image-align-right.jsx */ "./src/components/buttons/button-image-align-right.jsx");

var _buttonImageAlignRight2 = _interopRequireDefault(_buttonImageAlignRight);

var _buttonImage = __webpack_require__(/*! ./button-image.jsx */ "./src/components/buttons/button-image.jsx");

var _buttonImage2 = _interopRequireDefault(_buttonImage);

var _buttonIndentBlock = __webpack_require__(/*! ./button-indent-block.jsx */ "./src/components/buttons/button-indent-block.jsx");

var _buttonIndentBlock2 = _interopRequireDefault(_buttonIndentBlock);

var _buttonItalic = __webpack_require__(/*! ./button-italic.jsx */ "./src/components/buttons/button-italic.jsx");

var _buttonItalic2 = _interopRequireDefault(_buttonItalic);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

var _buttonOl = __webpack_require__(/*! ./button-ol.jsx */ "./src/components/buttons/button-ol.jsx");

var _buttonOl2 = _interopRequireDefault(_buttonOl);

var _buttonOutdentBlock = __webpack_require__(/*! ./button-outdent-block.jsx */ "./src/components/buttons/button-outdent-block.jsx");

var _buttonOutdentBlock2 = _interopRequireDefault(_buttonOutdentBlock);

var _buttonParagraphAlignLeft = __webpack_require__(/*! ./button-paragraph-align-left.jsx */ "./src/components/buttons/button-paragraph-align-left.jsx");

var _buttonParagraphAlignLeft2 = _interopRequireDefault(_buttonParagraphAlignLeft);

var _buttonParagraphAlignRight = __webpack_require__(/*! ./button-paragraph-align-right.jsx */ "./src/components/buttons/button-paragraph-align-right.jsx");

var _buttonParagraphAlignRight2 = _interopRequireDefault(_buttonParagraphAlignRight);

var _buttonParagraphCenter = __webpack_require__(/*! ./button-paragraph-center.jsx */ "./src/components/buttons/button-paragraph-center.jsx");

var _buttonParagraphCenter2 = _interopRequireDefault(_buttonParagraphCenter);

var _buttonParagraphJustify = __webpack_require__(/*! ./button-paragraph-justify.jsx */ "./src/components/buttons/button-paragraph-justify.jsx");

var _buttonParagraphJustify2 = _interopRequireDefault(_buttonParagraphJustify);

var _buttonQuote = __webpack_require__(/*! ./button-quote.jsx */ "./src/components/buttons/button-quote.jsx");

var _buttonQuote2 = _interopRequireDefault(_buttonQuote);

var _buttonRemoveFormat = __webpack_require__(/*! ./button-remove-format.jsx */ "./src/components/buttons/button-remove-format.jsx");

var _buttonRemoveFormat2 = _interopRequireDefault(_buttonRemoveFormat);

var _buttonStrike = __webpack_require__(/*! ./button-strike.jsx */ "./src/components/buttons/button-strike.jsx");

var _buttonStrike2 = _interopRequireDefault(_buttonStrike);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _buttonStyles = __webpack_require__(/*! ./button-styles.jsx */ "./src/components/buttons/button-styles.jsx");

var _buttonStyles2 = _interopRequireDefault(_buttonStyles);

var _buttonSubscript = __webpack_require__(/*! ./button-subscript.jsx */ "./src/components/buttons/button-subscript.jsx");

var _buttonSubscript2 = _interopRequireDefault(_buttonSubscript);

var _buttonSuperscript = __webpack_require__(/*! ./button-superscript.jsx */ "./src/components/buttons/button-superscript.jsx");

var _buttonSuperscript2 = _interopRequireDefault(_buttonSuperscript);

var _buttonTableCell = __webpack_require__(/*! ./button-table-cell.jsx */ "./src/components/buttons/button-table-cell.jsx");

var _buttonTableCell2 = _interopRequireDefault(_buttonTableCell);

var _buttonTableColumn = __webpack_require__(/*! ./button-table-column.jsx */ "./src/components/buttons/button-table-column.jsx");

var _buttonTableColumn2 = _interopRequireDefault(_buttonTableColumn);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _buttonTableHeading = __webpack_require__(/*! ./button-table-heading.jsx */ "./src/components/buttons/button-table-heading.jsx");

var _buttonTableHeading2 = _interopRequireDefault(_buttonTableHeading);

var _buttonTableRemove = __webpack_require__(/*! ./button-table-remove.jsx */ "./src/components/buttons/button-table-remove.jsx");

var _buttonTableRemove2 = _interopRequireDefault(_buttonTableRemove);

var _buttonTableRow = __webpack_require__(/*! ./button-table-row.jsx */ "./src/components/buttons/button-table-row.jsx");

var _buttonTableRow2 = _interopRequireDefault(_buttonTableRow);

var _buttonTable = __webpack_require__(/*! ./button-table.jsx */ "./src/components/buttons/button-table.jsx");

var _buttonTable2 = _interopRequireDefault(_buttonTable);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _buttonTwitter = __webpack_require__(/*! ./button-twitter.jsx */ "./src/components/buttons/button-twitter.jsx");

var _buttonTwitter2 = _interopRequireDefault(_buttonTwitter);

var _buttonUl = __webpack_require__(/*! ./button-ul.jsx */ "./src/components/buttons/button-ul.jsx");

var _buttonUl2 = _interopRequireDefault(_buttonUl);

var _buttonUnderline = __webpack_require__(/*! ./button-underline.jsx */ "./src/components/buttons/button-underline.jsx");

var _buttonUnderline2 = _interopRequireDefault(_buttonUnderline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ButtonBold$key$Butto = {}, _defineProperty(_ButtonBold$key$Butto, _buttonBold2.default.key, _buttonBold2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCameraImage2.default.key, _buttonCameraImage2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCamera2.default.key, _buttonCamera2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCode2.default.key, _buttonCode2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCommandListItem2.default.key, _buttonCommandListItem2.default), _defineProperty(_ButtonBold$key$Butto, _buttonCommandsList2.default.key, _buttonCommandsList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonDropdown2.default.key, _buttonDropdown2.default), _defineProperty(_ButtonBold$key$Butto, _buttonEmbedEdit2.default.key, _buttonEmbedEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonEmbed2.default.key, _buttonEmbed2.default), _defineProperty(_ButtonBold$key$Butto, _buttonH2.default.key, _buttonH2.default), _defineProperty(_ButtonBold$key$Butto, _buttonH4.default.key, _buttonH4.default), _defineProperty(_ButtonBold$key$Butto, _buttonHline2.default.key, _buttonHline2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignCenter2.default.key, _buttonImageAlignCenter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignLeft2.default.key, _buttonImageAlignLeft2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImageAlignRight2.default.key, _buttonImageAlignRight2.default), _defineProperty(_ButtonBold$key$Butto, _buttonImage2.default.key, _buttonImage2.default), _defineProperty(_ButtonBold$key$Butto, _buttonIndentBlock2.default.key, _buttonIndentBlock2.default), _defineProperty(_ButtonBold$key$Butto, _buttonItalic2.default.key, _buttonItalic2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkAutocompleteList2.default.key, _buttonLinkAutocompleteList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkEdit2.default.key, _buttonLinkEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLinkTargetEdit2.default.key, _buttonLinkTargetEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonLink2.default.key, _buttonLink2.default), _defineProperty(_ButtonBold$key$Butto, _buttonOl2.default.key, _buttonOl2.default), _defineProperty(_ButtonBold$key$Butto, _buttonOutdentBlock2.default.key, _buttonOutdentBlock2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphAlignLeft2.default.key, _buttonParagraphAlignLeft2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphAlignRight2.default.key, _buttonParagraphAlignRight2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphCenter2.default.key, _buttonParagraphCenter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonParagraphJustify2.default.key, _buttonParagraphJustify2.default), _defineProperty(_ButtonBold$key$Butto, _buttonQuote2.default.key, _buttonQuote2.default), _defineProperty(_ButtonBold$key$Butto, _buttonRemoveFormat2.default.key, _buttonRemoveFormat2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStrike2.default.key, _buttonStrike2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListHeader2.default.key, _buttonStylesListHeader2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListItemRemove2.default.key, _buttonStylesListItemRemove2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesListItem2.default.key, _buttonStylesListItem2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStylesList2.default.key, _buttonStylesList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonStyles2.default.key, _buttonStyles2.default), _defineProperty(_ButtonBold$key$Butto, _buttonSubscript2.default.key, _buttonSubscript2.default), _defineProperty(_ButtonBold$key$Butto, _buttonSuperscript2.default.key, _buttonSuperscript2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableCell2.default.key, _buttonTableCell2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableColumn2.default.key, _buttonTableColumn2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableEdit2.default.key, _buttonTableEdit2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableHeading2.default.key, _buttonTableHeading2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableRemove2.default.key, _buttonTableRemove2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTableRow2.default.key, _buttonTableRow2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTable2.default.key, _buttonTable2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTargetList2.default.key, _buttonTargetList2.default), _defineProperty(_ButtonBold$key$Butto, _buttonTwitter2.default.key, _buttonTwitter2.default), _defineProperty(_ButtonBold$key$Butto, _buttonUl2.default.key, _buttonUl2.default), _defineProperty(_ButtonBold$key$Butto, _buttonUnderline2.default.key, _buttonUnderline2.default), _ButtonBold$key$Butto);

/***/ }),

/***/ "./src/components/main.jsx":
/*!*********************************!*\
  !*** ./src/components/main.jsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetExclusive = __webpack_require__(/*! ./base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ./base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The main editor UI class manages a hierarchy of widgets (toolbars and buttons).
 *
 * @class UI
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var UI = function (_React$Component) {
    _inherits(UI, _React$Component);

    function UI(props) {
        _classCallCheck(this, UI);

        var _this = _possibleConstructorReturn(this, (UI.__proto__ || Object.getPrototypeOf(UI)).call(this, props));

        _this.state = {
            hidden: false
        };
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof UI
     * @method componentDidMount
     */


    _createClass(UI, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var editor = this.props.editor.get('nativeEditor');

            editor.on('editorInteraction', this._onEditorInteraction, this);
            editor.on('actionPerformed', this._onActionPerformed, this);
            editor.on('key', this._onEditorKey, this);

            // Set up events for hiding the UI when user stops interacting with the editor.
            // This may happen when he just clicks outside of the editor. However,
            // this does not include a situation when he clicks on some button, part of
            // editor's UI.

            // It is not easy to debounce _setUIHidden on mousedown, because if we
            // debounce it, when the handler is being invoked, the target might be no more part
            // of the editor's UI - onActionPerformed causes re-render.
            this._mousedownListener = function (event) {
                this._setUIHidden(event.target);
            }.bind(this);

            this._keyDownListener = CKEDITOR.tools.debounce(function (event) {
                this._setUIHidden(document.activeElement);
            }, this.props.eventsDelay, this);

            document.addEventListener('mousedown', this._mousedownListener);
            document.addEventListener('keydown', this._keyDownListener);
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * Fires `ariaUpdate` event passing ARIA related messages.
         * Fires `editorUpdate` event passing the previous and current properties and state.
         *
         * @instance
         * @memberof UI
         * @method componentDidUpdate
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            var domNode = _reactDom2.default.findDOMNode(this);

            var editor = this.props.editor.get('nativeEditor');

            if (domNode) {
                editor.fire('ariaUpdate', {
                    message: this._getAvailableToolbarsMessage(domNode)
                });
            }

            editor.fire('editorUpdate', {
                prevProps: prevProps,
                prevState: prevState,
                props: this.props,
                state: this.state
            });
        }
    }, {
        key: '_getAriaUpdateTemplate',
        value: function _getAriaUpdateTemplate(ariaUpdate) {
            if (!this._ariaUpdateTemplates) {
                this._ariaUpdateTemplates = {};
            }

            if (!this._ariaUpdateTemplates[ariaUpdate]) {
                this._ariaUpdateTemplates[ariaUpdate] = new CKEDITOR.template(this._getAriaUpdates()[ariaUpdate]);
            }

            return this._ariaUpdateTemplates[ariaUpdate];
        }

        /**
         * Returns the templates for ARIA messages.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _getAriaUpdates
         * @return {Object} ARIA relates messages. Default:
         * {
         *      noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
         *      oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
         *      manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
         *  }
         */

    }, {
        key: '_getAriaUpdates',
        value: function _getAriaUpdates() {
            return this.props.ariaUpdates || {
                noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
                oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
                manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
            };
        }

        /**
         * Returns an ARIA message which represents the number of currently available toolbars.
         *
         * @instance
         * @memberof UI
         * @method _getAvailableToolbarsMessage
         * @protected
         * @param {CKEDITOR.dom.element} domNode The DOM node from which the available toolbars will be retrieved.
         * @return {String} The ARIA message for the number of available toolbars
         */

    }, {
        key: '_getAvailableToolbarsMessage',
        value: function _getAvailableToolbarsMessage(domNode) {
            var toolbarsNodeList = domNode.querySelectorAll('[role="toolbar"]');

            if (!toolbarsNodeList.length) {
                return this._getAriaUpdates().noToolbar;
            } else {
                var toolbarNames = Array.prototype.slice.call(toolbarsNodeList).map(function (toolbar) {
                    return toolbar.getAttribute('aria-label');
                });

                var ariaUpdate = toolbarNames.length === 1 ? 'oneToolbar' : 'manyToolbars';

                return this._getAriaUpdateTemplate(ariaUpdate).output({
                    toolbars: toolbarNames.join(',').replace(/,([^,]*)$/, ' and ' + '$1')
                });
            }
        }

        /**
         * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
         *
         * @instance
         * @memberof UI
         * @method componentWillUnmount
         */

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this._mousedownListener) {
                document.removeEventListener('mousedown', this._mousedownListener);
            }

            if (this._keyDownListener) {
                this._keyDownListener.detach();
                document.removeEventListener('keydown', this._keyDownListener);
            }
        }

        /**
         * Lifecycle. Renders the UI of the editor. This may include several toolbars and buttons.
         * The editor's UI also takes care of rendering the items in exclusive mode.
         *
         * @instance
         * @memberof UI
         * @method render
         * @return {Object} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            if (this.state.hidden) {
                return null;
            }

            var toolbars = Object.keys(this.props.toolbars).map(function (toolbar) {
                return AlloyEditor.Toolbars[toolbar] || window[toolbar];
            });

            toolbars = this.filterExclusive(toolbars).map(function (toolbar) {
                var props = this.mergeExclusiveProps({
                    config: this.props.toolbars[toolbar.key],
                    editor: this.props.editor,
                    editorEvent: this.state.editorEvent,
                    key: toolbar.key,
                    onDismiss: this._onDismissToolbarFocus,
                    selectionData: this.state.selectionData
                }, toolbar.key);

                return _react2.default.createElement(toolbar, props);
            }.bind(this));

            return _react2.default.createElement(
                'div',
                { className: 'ae-toolbars', onKeyDown: this.handleKey.bind(this) },
                toolbars
            );
        }

        /**
         * Listener to the editor's `actionPerformed` event. Sets state and redraws the UI of the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onActionPerformed
         * @param {SynteticEvent} event The provided event
         */

    }, {
        key: '_onActionPerformed',
        value: function _onActionPerformed(event) {
            var editor = this.props.editor.get('nativeEditor');

            editor.focus();

            this.setState({
                itemExclusive: null,
                selectionData: editor.getSelectionData()
            });
        }

        /**
         * Executed when a dismiss key is pressed over a toolbar to return the focus to the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onDismissToolbarFocus
         */

    }, {
        key: '_onDismissToolbarFocus',
        value: function _onDismissToolbarFocus() {
            var editor = this.props.editor.get('nativeEditor');

            editor.focus();
        }

        /**
         * Listener to the editor's `userInteraction` event. Retrieves the data about the user selection and
         * provides it via component's state property.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onEditorInteraction
         * @param {SynteticEvent} event The provided event
         */

    }, {
        key: '_onEditorInteraction',
        value: function _onEditorInteraction(event) {
            this.setState({
                editorEvent: event,
                hidden: false,
                itemExclusive: null,
                selectionData: event.data.selectionData
            });
        }

        /**
         * Focuses on the active toolbar when the combination ALT+F10 is pressed inside the editor.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _onEditorKey
         */

    }, {
        key: '_onEditorKey',
        value: function _onEditorKey(event) {
            var nativeEvent = event.data.domEvent.$;

            if (nativeEvent.altKey && nativeEvent.keyCode === 121) {
                this.focus();
            }
        }

        /**
         * Checks if the target with which the user interacted is part of editor's UI or it is
         * the editable area. If none of these, sets the state of editor's UI to be hidden.
         *
         * @instance
         * @memberof UI
         * @protected
         * @method _setUIHidden
         * @param {DOMElement} target The DOM element with which user interacted lastly.
         */

    }, {
        key: '_setUIHidden',
        value: function _setUIHidden(target) {
            var domNode = _reactDom2.default.findDOMNode(this);

            if (domNode) {
                var editable = this.props.editor.get('nativeEditor').editable();
                var targetNode = new CKEDITOR.dom.node(target);

                if (!editable) {
                    this.setState({
                        hidden: true
                    });
                } else {
                    var res = editable.$ === target || editable.contains(targetNode) || new CKEDITOR.dom.element(domNode).contains(targetNode);

                    if (!res) {
                        this.setState({
                            hidden: true
                        });
                    }
                }
            }
        }
    }]);

    return UI;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof UI
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


UI.defaultProps = {
    circular: true,
    descendants: '[class^=ae-toolbar-]',
    eventsDelay: 0,
    keys: {
        next: 9
    }
};

/**
 * Fired when component updates and when it is rendered in the DOM.
 * The payload consists from a `message` property containing the ARIA message.
 *
 * @event ariaUpdate
 */

/**
 * Fired when component updates. The payload consists from an object with the following
 * properties:
 * - prevProps - The previous properties of the component
 * - prevState - The previous state of the component
 * - props - The current properties of the component
 * - state - The current state of the component
 *
 * @event ariaUpdate
 */

exports.default = (0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)(UI));

/***/ }),

/***/ "./src/components/toolbars/index.js":
/*!******************************************!*\
  !*** ./src/components/toolbars/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ToolbarAdd$key$Toolb;

var _toolbarAdd = __webpack_require__(/*! ./toolbar-add.jsx */ "./src/components/toolbars/toolbar-add.jsx");

var _toolbarAdd2 = _interopRequireDefault(_toolbarAdd);

var _toolbarStyles = __webpack_require__(/*! ./toolbar-styles.jsx */ "./src/components/toolbars/toolbar-styles.jsx");

var _toolbarStyles2 = _interopRequireDefault(_toolbarStyles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ToolbarAdd$key$Toolb = {}, _defineProperty(_ToolbarAdd$key$Toolb, _toolbarAdd2.default.key, _toolbarAdd2.default), _defineProperty(_ToolbarAdd$key$Toolb, _toolbarStyles2.default.key, _toolbarStyles2.default), _ToolbarAdd$key$Toolb);

/***/ }),

/***/ "./src/components/toolbars/toolbar-add.jsx":
/*!*************************************************!*\
  !*** ./src/components/toolbars/toolbar-add.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons.js */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box.js */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position.js */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var POSITION_LEFT = 1;
var POSITION_RIGHT = 2;

/**
 * The ToolbarAdd class provides functionality for adding content to the editor.
 *
 * @class ToolbarAdd
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */

var ToolbarAdd = function (_React$Component) {
    _inherits(ToolbarAdd, _React$Component);

    function ToolbarAdd(props) {
        _classCallCheck(this, ToolbarAdd);

        var _this = _possibleConstructorReturn(this, (ToolbarAdd.__proto__ || Object.getPrototypeOf(ToolbarAdd)).call(this, props));

        _this.state = {};
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof ToolbarAdd
     * @method componentDidMount
     */


    _createClass(ToolbarAdd, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._updatePosition();
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method componentDidUpdate
         * @param {Object} prevProps The previous state of the component's properties.
         * @param {Object} prevState Component's previous state.
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this._updatePosition();

            // In case of exclusive rendering, focus the first descendant (button)
            // so the user will be able to start interacting with the buttons immediately.
            if (this.props.renderExclusive) {
                this.focus();
            }
        }

        /**
         * Lifecycle. Renders the buttons for adding content or hides the toolbar
         * if user interacted with a non-editable element.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method render
         * @return {Object|null} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            // Some operations such as `requestExclusive` may force editor to blur which will
            // invalidate the `props.editorEvent` stored value, without causing a `props` change.
            // For example, if the editor is empty, `ae_placeholder` plugin will remove
            // the target from the DOM and will prevent `add` toolbar from rendering.
            //
            // It should be safe to assume that if you have been able to render the toolbar
            // and request the exclusive mode, then rendering might be kept until the exclusive mode is left.
            if (!this.state.itemExclusive && this.props.editorEvent && this.props.editorEvent.data.nativeEvent.target && !this.props.editorEvent.data.nativeEvent.target.isContentEditable) {
                return null;
            }

            var buttons = this._getButtons();
            var className = this._getToolbarClassName();

            return _react2.default.createElement(
                'div',
                { 'aria-label': AlloyEditor.Strings.add, className: className, 'data-tabindex': this.props.config.tabIndex || 0, onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), role: 'toolbar', tabIndex: '-1' },
                _react2.default.createElement(
                    'div',
                    { className: 'ae-container' },
                    buttons
                )
            );
        }

        /**
         * Returns a list of buttons that will eventually render to HTML.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _getButtons
         * @protected
         * @return {Object} The buttons which have to be rendered.
         */

    }, {
        key: '_getButtons',
        value: function _getButtons() {
            var buttons;

            if (this.props.renderExclusive) {
                buttons = this.getToolbarButtons(this.props.config.buttons);
            } else {
                if (this.props.selectionData && this.props.selectionData.region) {
                    buttons = _react2.default.createElement(
                        'button',
                        { 'aria-label': AlloyEditor.Strings.add, className: 'ae-button ae-button-add', onClick: this.props.requestExclusive.bind(this, ToolbarAdd.key), title: AlloyEditor.Strings.add },
                        _react2.default.createElement('span', { className: 'ae-icon-add' })
                    );
                }
            }

            return buttons;
        }

        /**
         * Returns the class name of the toolbar in case of both exclusive and normal mode.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _getToolbarClassName
         * @protected
         * @return {String} The class name which have to be applied to the DOM element.
         */

    }, {
        key: '_getToolbarClassName',
        value: function _getToolbarClassName() {
            var cssClass = 'ae-toolbar-add';

            if (this.props.renderExclusive) {
                cssClass = 'ae-toolbar ' + this.getArrowBoxClasses();
            }

            return cssClass;
        }

        /**
         * Calculates and sets the position of the toolbar in exclusive or normal mode.
         *
         * @instance
         * @memberof ToolbarAdd
         * @method _updatePosition
         * @protected
         */

    }, {
        key: '_updatePosition',
        value: function _updatePosition() {
            var region;

            // If component is not mounted, there is nothing to do
            if (!_reactDom2.default.findDOMNode(this)) {
                return;
            }

            if (this.props.renderExclusive) {
                this.updatePosition();
                this.show();
            } else {
                if (this.props.selectionData) {
                    region = this.props.selectionData.region;
                }

                if (region) {
                    var domNode = _reactDom2.default.findDOMNode(this);

                    var domElement = new CKEDITOR.dom.element(domNode);

                    var startRect = region.startRect || region;

                    var nativeEditor = this.props.editor.get('nativeEditor');

                    var clientRect = nativeEditor.editable().getClientRect();

                    var offsetLeft;

                    var position = this.props.config.position || this.props.position;

                    if (position === POSITION_LEFT) {
                        offsetLeft = clientRect.left - domNode.offsetWidth - this.props.gutterExclusive.left + 'px';
                    } else {
                        offsetLeft = clientRect.right + this.props.gutterExclusive.left + 'px';
                    }

                    domNode.style.left = offsetLeft;

                    domNode.style.top = Math.floor((region.bottom + region.top) / 2) + 'px';

                    if (nativeEditor.element.getStyle('overflow') !== 'auto') {
                        domNode.style.top = Math.floor(region.top - domNode.offsetHeight / 2 + startRect.height / 2) + 'px';
                    } else {
                        domNode.style.top = Math.floor(nativeEditor.element.$.offsetTop + startRect.height / 2 - domNode.offsetHeight / 2) + 'px';
                    }

                    domNode.style.opacity = 1;

                    domElement.removeClass('ae-arrow-box');

                    this.cancelAnimation();
                }
            }
        }
    }]);

    return ToolbarAdd;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default add
 * @memberof ToolbarAdd
 * @property {String} key
 * @static
 */


ToolbarAdd.key = 'add';

/**
 * Defines the constant for positioning the Toolbar on left of the editable area.
 *
 * @default 1
 * @memberof ToolbarAdd
 * @property {String} left
 * @static
 */
ToolbarAdd.left = POSITION_LEFT;

/**
 * Defines the constant for positioning the Toolbar on right of the editable area.
 *
 * @default 2
 * @memberof ToolbarAdd
 * @property {String} right
 * @static
 */
ToolbarAdd.right = POSITION_RIGHT;

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarAdd
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ToolbarAdd.defaultProps = {
    circular: true,
    descendants: '.ae-button',
    gutterExclusive: {
        left: 10,
        top: 0
    },
    keys: {
        dismiss: [27],
        next: [39, 40],
        prev: [37, 38]
    },
    position: POSITION_LEFT
};

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarAdd))))));

/***/ }),

/***/ "./src/components/toolbars/toolbar-styles.jsx":
/*!****************************************************!*\
  !*** ./src/components/toolbars/toolbar-styles.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons.js */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box.js */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown.js */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive.js */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager.js */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position.js */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ToolbarStyles class hosts the buttons for styling a text selection.
 *
 * @class ToolbarStyles
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */
var ToolbarStyles = function (_React$Component) {
    _inherits(ToolbarStyles, _React$Component);

    function ToolbarStyles(props) {
        _classCallCheck(this, ToolbarStyles);

        var _this = _possibleConstructorReturn(this, (ToolbarStyles.__proto__ || Object.getPrototypeOf(ToolbarStyles)).call(this, props));

        _this.state = {};
        return _this;
    }

    /**
     * Lifecycle. Invoked once, only on the client (not on the server),
     * immediately after the initial rendering occurs.
     *
     * @instance
     * @memberof ToolbarStyles
     * @method componentDidMount
     */


    _createClass(ToolbarStyles, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this._updatePosition();
        }

        /**
         * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
         * This method is not called for the initial render.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method componentDidUpdate
         * @param {Object} prevProps The previous state of the component's properties.
         * @param {Object} prevState Component's previous state.
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            this._updatePosition();
        }

        /**
         * Lifecycle. Renders the buttons for adding content or hides the toolbar
         * if user interacted with a non-editable element.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method render
         * @return {Object|null} The content which should be rendered.
         */

    }, {
        key: 'render',
        value: function render() {
            var currentSelection = this._getCurrentSelection();

            if (currentSelection) {
                var getArrowBoxClassesFn = this._getSelectionFunction(currentSelection.getArrowBoxClasses);
                var arrowBoxClasses;

                if (getArrowBoxClassesFn) {
                    arrowBoxClasses = getArrowBoxClassesFn();
                } else {
                    arrowBoxClasses = this.getArrowBoxClasses();
                }

                var cssClasses = 'ae-toolbar-styles ' + arrowBoxClasses;

                var buttons = this.getToolbarButtons(currentSelection.buttons, {
                    manualSelection: this.props.editorEvent ? this.props.editorEvent.data.manualSelection : null,
                    selectionType: currentSelection.name
                });

                return _react2.default.createElement(
                    'div',
                    { 'aria-label': AlloyEditor.Strings.styles, className: cssClasses, 'data-tabindex': this.props.config.tabIndex || 0, onFocus: this.focus.bind(this), onKeyDown: this.handleKey.bind(this), role: 'toolbar', tabIndex: '-1' },
                    _react2.default.createElement(
                        'div',
                        { className: 'ae-container' },
                        buttons
                    )
                );
            }

            return null;
        }

        /**
         * Retrieve a function from String. It converts a fully qualified string into the mapped function.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _getSelectionFunction
         * @param {Function|String} selectionFn A function, or a fully qualified string pointing to the desired one (e.g. 'AlloyEditor.SelectionTest.image').
         * @protected
         * @return {Function} The mapped function.
         */

    }, {
        key: '_getSelectionFunction',
        value: function _getSelectionFunction(selectionFn) {
            var selectionFunction;

            if (_lang2.default.isFunction(selectionFn)) {
                selectionFunction = selectionFn;
            } else if (_lang2.default.isString(selectionFn)) {
                var parts = selectionFn.split('.');
                var currentMember = window;
                var property = parts.shift();

                while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
                    currentMember = currentMember[property];
                    property = parts.shift();
                }

                if (_lang2.default.isFunction(currentMember)) {
                    selectionFunction = currentMember;
                }
            }

            return selectionFunction;
        }

        /**
         * Analyzes the current editor selection and returns the selection configuration that matches.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _getCurrentSelection
         * @protected
         * @return {Object} The matched selection configuration.
         */

    }, {
        key: '_getCurrentSelection',
        value: function _getCurrentSelection() {
            var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;
            var selection;

            if (eventPayload) {
                this.props.config.selections.some(function (item) {
                    var testFn = this._getSelectionFunction(item.test);
                    var result;

                    if (testFn) {
                        result = eventPayload.manualSelection === item.name || testFn({
                            data: eventPayload,
                            editor: this.props.editor
                        });
                    }

                    if (result) {
                        selection = item;
                    }

                    return result;
                }, this);
            }

            return selection;
        }

        /**
         * Calculates and sets the position of the toolbar.
         *
         * @instance
         * @memberof ToolbarStyles
         * @method _updatePosition
         * @protected
         */

    }, {
        key: '_updatePosition',
        value: function _updatePosition() {
            // If component is not mounted, there is nothing to do
            if (!_reactDom2.default.findDOMNode(this)) {
                return;
            }

            var currentSelection = this._getCurrentSelection();
            var result;

            // If current selection has a function called `setPosition`, call it
            // and check the returned value. If false, fallback to the default positioning logic.
            if (currentSelection) {
                var setPositionFn = this._getSelectionFunction(currentSelection.setPosition);

                if (setPositionFn) {
                    result = setPositionFn.call(this, {
                        editor: this.props.editor,
                        editorEvent: this.props.editorEvent,
                        selectionData: this.props.selectionData
                    });
                }
            }

            if (!result) {
                this.updatePosition();
                this.show();
            }
        }
    }]);

    return ToolbarStyles;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarStyles
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


ToolbarStyles.defaultProps = {
    circular: true,
    descendants: '.ae-input, .ae-button:not([disabled]), .ae-toolbar-element',
    keys: {
        dismiss: [27],
        next: [39, 40],
        prev: [37, 38]
    }
};

/**
* The name which will be used as an alias of the button in the configuration.
*
* @default styles
* @memberof ToolbarStyles
* @property {String} key
* @static
*/
ToolbarStyles.key = 'styles';

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarStyles))))));

/***/ }),

/***/ "./src/components/uibridge/uibridge.js":
/*!*********************************************!*\
  !*** ./src/components/uibridge/uibridge.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_uibridge')) {
        return;
    }

    /**
     * CKEditor plugin that extends CKEDITOR.ui.add function so an add handler can be specified
     * on top of the original ones. It bridges the calls to add components via:
     * - editor.ui.add(name, type, definition)
     *
     * @class CKEDITOR.plugins.ae_uibridge
     * @constructor
     */
    CKEDITOR.plugins.add('ae_uibridge', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         *
         * @method beforeInit
         * @param {Object} editor The current editor instance
         */
        beforeInit: function beforeInit(editor) {
            var originalUIAddFn = editor.ui.add;

            editor.ui.add = function (name, type, definition) {
                originalUIAddFn.apply(this, arguments);

                var typeHandler = this._.handlers[type];

                if (typeHandler && typeHandler.add) {
                    typeHandler.add(name, definition, editor);
                    AlloyEditor.registerBridgeButton(name, editor.__processingPlugin__.plugin.name);
                }
            };
        }
    });
})();

/***/ }),

/***/ "./src/core/debounce.js":
/*!******************************!*\
  !*** ./src/core/debounce.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /**
     * Debounce util function. If a function execution is expensive, it might be debounced. This means
     * that it will be executed after some amount of time after its last call. For example, if we attach a
     * a function on scroll event, it might be called hundreds times per second. In this case it may be
     * debounced with, let's say 100ms. The real execution of this function will happen 100ms after last
     * scroll event.
     *
     * @memberof CKEDITOR.tools
     * @method debounce
     * @param {Array} args An array of arguments which the callback will receive.
     * @param {Function} callback The callback which has to be called after given timeout.
     * @param {Number} timeout Timeout in milliseconds after which the callback will be called.
     * @param {Object} context The context in which the callback will be called. This argument is optional.
     * @static
     */

    CKEDITOR.tools.debounce = CKEDITOR.tools.debounce || function (callback, timeout, context, args) {
        var debounceHandle;

        var callFn = function callFn() {
            var callContext = context || this;

            clearTimeout(debounceHandle);

            var result = [];

            for (var len = arguments.length, startIndex = 0; startIndex < len; ++startIndex) {
                result.push(arguments[startIndex]);
            }

            var callArgs = result.concat(args || []);

            debounceHandle = setTimeout(function () {
                callback.apply(callContext, callArgs);
            }, timeout);
        };

        callFn.detach = function () {
            clearTimeout(debounceHandle);
        };

        return callFn;
    };
})();

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uicore = exports.tools = exports.table = exports.selectionRegion = exports.plugins = exports.link = exports.debounce = undefined;

var _debounce = __webpack_require__(/*! ./debounce */ "./src/core/debounce.js");

var _debounce2 = _interopRequireDefault(_debounce);

var _link = __webpack_require__(/*! ./link */ "./src/core/link.js");

var _link2 = _interopRequireDefault(_link);

var _plugins = __webpack_require__(/*! ./plugins */ "./src/core/plugins.js");

var _plugins2 = _interopRequireDefault(_plugins);

var _selectionRegion = __webpack_require__(/*! ./selection-region */ "./src/core/selection-region.js");

var _selectionRegion2 = _interopRequireDefault(_selectionRegion);

var _table = __webpack_require__(/*! ./table */ "./src/core/table.js");

var _table2 = _interopRequireDefault(_table);

var _tools = __webpack_require__(/*! ./tools */ "./src/core/tools.js");

var _tools2 = _interopRequireDefault(_tools);

var _uicore = __webpack_require__(/*! ./uicore */ "./src/core/uicore.js");

var _uicore2 = _interopRequireDefault(_uicore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.debounce = _debounce2.default;
exports.link = _link2.default;
exports.plugins = _plugins2.default;
exports.selectionRegion = _selectionRegion2.default;
exports.table = _table2.default;
exports.tools = _tools2.default;
exports.uicore = _uicore2.default;

/***/ }),

/***/ "./src/core/link.js":
/*!**************************!*\
  !*** ./src/core/link.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
    'use strict';

    var REGEX_BOOKMARK_SCHEME = /^#.*/i;
    var REGEX_EMAIL_SCHEME = /^[a-z0-9\u0430-\u044F\._-]+@/i;
    var REGEX_URI_SCHEME = /^(?:[a-z][a-z0-9+\-.]*)\:|^\//i;

    /**
     * Link class utility. Provides methods for create, delete and update links.
     *
     * @class CKEDITOR.Link
     * @constructor
     * @param {Object} editor The CKEditor instance.
     */
    function Link(editor, config) {
        this._editor = editor;
        this.appendProtocol = config && config.appendProtocol === false ? false : true;
    }

    Link.prototype = {
        constructor: Link,

        /**
         * Advances the editor selection to the next available position after a
         * given link or the one in the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method advanceSelection
         * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
         */
        advanceSelection: function advanceSelection(link) {
            link = link || this.getFromSelection();

            var range = this._editor.getSelection().getRanges()[0];

            if (link) {
                range.moveToElementEditEnd(link);

                var nextNode = range.getNextEditableNode();

                if (nextNode && !this._editor.element.equals(nextNode.getCommonAncestor(link))) {
                    var whitespace = /\s/.exec(nextNode.getText());

                    var offset = whitespace ? whitespace.index + 1 : 0;

                    range.setStart(nextNode, offset);
                    range.setEnd(nextNode, offset);
                }
            }

            this._editor.getSelection().selectRanges([range]);
        },

        /**
         * Create a link with given URI as href.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method create
         * @param {Object} attrs A config object with link attributes. These might be arbitrary DOM attributes.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         * @param {String} URI The URI of the link.
         */
        create: function create(URI, attrs, modifySelection) {
            var selection = this._editor.getSelection();

            var range = selection.getRanges()[0];

            if (range.collapsed) {
                var text = new CKEDITOR.dom.text(URI, this._editor.document);
                range.insertNode(text);
                range.selectNodeContents(text);
            }

            URI = this._getCompleteURI(URI);

            var linkAttrs = CKEDITOR.tools.merge({
                'data-cke-saved-href': URI,
                href: URI
            }, attrs);

            var style = new CKEDITOR.style({
                attributes: linkAttrs,
                element: 'a'
            });

            style.type = CKEDITOR.STYLE_INLINE;
            style.applyToRange(range, this._editor);

            if (modifySelection && modifySelection.advance) {
                this.advanceSelection();
            } else {
                range.select();
            }
        },

        /**
         * Retrieves a link from the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method getFromSelection
         * @return {CKEDITOR.dom.element} The retrieved link or null if not found.
         */
        getFromSelection: function getFromSelection() {
            var selection = this._editor.getSelection();

            var selectedElement = selection.getSelectedElement();

            if (selectedElement && selectedElement.is('a')) {
                return selectedElement;
            }

            var range = selection.getRanges()[0];

            if (range) {
                range.shrink(CKEDITOR.SHRINK_TEXT);

                return this._editor.elementPath(range.getCommonAncestor()).contains('a', 1);
            }

            return null;
        },

        /**
         * Removes a link from the editor.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method remove
         * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         */
        remove: function remove(link, modifySelection) {
            var editor = this._editor;

            if (link) {
                if (modifySelection && modifySelection.advance) {
                    this.advanceSelection();
                }

                link.remove(editor);
            } else {
                var style = new CKEDITOR.style({
                    alwaysRemoveElement: 1,
                    element: 'a',
                    type: CKEDITOR.STYLE_INLINE
                });

                // 'removeStyle()' removes the style from the editor's current selection.
                //  We need to force the selection to be the whole link element
                //  to remove it properly.

                var selection = editor.getSelection();
                selection.selectElement(selection.getStartElement());

                editor.removeStyle(style);
            }
        },

        /**
         * Updates the href of an already existing link.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method update
         * @param {CKEDITOR.dom.element} link The link element which href should be removed.
         * @param {Object|String} attrs The attributes to update or remove. Attributes with null values will be removed.
         * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
         */
        update: function update(attrs, link, modifySelection) {
            var instance = this;

            link = link || this.getFromSelection();

            if (typeof attrs === 'string') {
                var uri = instance._getCompleteURI(attrs);

                link.setAttributes({
                    'data-cke-saved-href': uri,
                    href: uri
                });
            } else if ((typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object') {
                var removeAttrs = [];

                var setAttrs = {};

                Object.keys(attrs).forEach(function (key) {
                    if (attrs[key] === null) {
                        if (key === 'href') {
                            removeAttrs.push('data-cke-saved-href');
                        }

                        removeAttrs.push(key);
                    } else {
                        if (key === 'href') {
                            var uri = instance._getCompleteURI(attrs[key]);

                            setAttrs['data-cke-saved-href'] = uri;
                            setAttrs[key] = uri;
                        } else {
                            setAttrs[key] = attrs[key];
                        }
                    }
                });

                link.removeAttributes(removeAttrs);
                link.setAttributes(setAttrs);
            }

            if (modifySelection && modifySelection.advance) {
                this.advanceSelection(link);
            }
        },

        /**
         * Checks if the URI begins with a '#' symbol to determine if it's an on page bookmark.
         * If it doesn't, it then checks if the URI has an '@' symbol. If it does and the URI
         * looks like an email and doesn't have 'mailto:', 'mailto:' is added to the URI.
         * If it doesn't and the URI doesn't have a scheme, the default 'http' scheme with
         * hierarchical path '//' is added to the URI.
         *
         * @instance
         * @memberof CKEDITOR.Link
         * @method _getCompleteURI
         * @param {String} URI The URI of the link.
         * @protected
         * @return {String} The URI updated with the protocol.
         */
        _getCompleteURI: function _getCompleteURI(URI) {
            if (REGEX_BOOKMARK_SCHEME.test(URI)) {
                return URI;
            } else if (REGEX_EMAIL_SCHEME.test(URI)) {
                URI = 'mailto:' + URI;
            } else if (!REGEX_URI_SCHEME.test(URI)) {
                URI = this.appendProtocol ? 'http://' + URI : URI;
            }

            return URI;
        }
    };

    CKEDITOR.Link = CKEDITOR.Link || Link;
})();

/***/ }),

/***/ "./src/core/plugins.js":
/*!*****************************!*\
  !*** ./src/core/plugins.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    // Wraps each of the plugin lifecycle methods in a closure that will
    // set up the editor.__processingPlugin__ variable so it can be globally
    // accessed exposing the plugin being processed and the lifecycle phase
    // in which it is happening
    //
    // @param {Object} plugin The plugin to wrap lifecycle methods

    var wrapPluginLifecycle = function wrapPluginLifecycle(plugin) {
        var methods = ['beforeInit', 'init', 'afterInit'];

        methods.forEach(function (methodName) {
            if (plugin[methodName]) {
                plugin[methodName] = CKEDITOR.tools.override(plugin[methodName], function (originalPluginMethod) {
                    var payload = {
                        phase: methodName,
                        plugin: plugin
                    };

                    return function (editor) {
                        editor.__processingPlugin__ = payload;

                        originalPluginMethod.call(this, editor);

                        editor.__processingPlugin__ = null;
                    };
                });
            }
        });
    };

    // Filters the requires object to remove unwanted dependencies. At this point
    // only 'toolbar' has been identified, but more can appear. An unwanted plugin
    // dependency is one that prevents a necessary plugin from being removed
    //
    // @param {string|Array<string>} requires The requires object
    // @return {string} The filtered requires object
    var filterUnwantedDependencies = function filterUnwantedDependencies(requires) {
        if (typeof requires === 'string') {
            requires = requires.split(',');
        }

        return requires.filter(function (require) {
            return require !== 'toolbar';
        });
    };

    /**
     * CKEDITOR.plugins class utility which adds additional methods to those of CKEditor.
     *
     * @class CKEDITOR.plugins
     */

    /**
     * Overrides CKEDITOR.plugins.load method so we can extend the lifecycle methods of
     * the loaded plugins to add some metainformation about the plugin being processed
     *
    * @param {String/Array} names The name of the resource to load. It may be a
    * string with a single resource name, or an array with several names.
    * @param {Function} callback A function to be called when all resources
    * are loaded. The callback will receive an array containing all loaded names.
    * @param {Object} [scope] The scope object to be used for the callback call.
     * @memberof CKEDITOR.plugins
     * @method load
     * @static
     */
    CKEDITOR.plugins.load = CKEDITOR.tools.override(CKEDITOR.plugins.load, function (pluginsLoad) {
        // Wrap original load function so we can transform the plugin input parameter
        // before passing it down to the original callback
        return function (names, callback, scope) {
            pluginsLoad.call(this, names, function (plugins) {
                if (callback) {
                    Object.keys(plugins).forEach(function (pluginName) {
                        var plugin = plugins[pluginName];

                        if (plugin.requires) {
                            plugin.requires = filterUnwantedDependencies(plugin.requires);
                        }

                        wrapPluginLifecycle(plugin);
                    });

                    callback.call(scope, plugins);
                }
            });
        };
    });
})();

/***/ }),

/***/ "./src/core/selection-region.js":
/*!**************************************!*\
  !*** ./src/core/selection-region.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_selectionregion')) {
        return;
    }

    CKEDITOR.SELECTION_TOP_TO_BOTTOM = 0;
    CKEDITOR.SELECTION_BOTTOM_TO_TOP = 1;
    CKEDITOR.SELECTION_LEFT_TO_RIGHT = 2;
    CKEDITOR.SELECTION_RIGHT_TO_LEFT = 3;

    /**
     * SelectionRegion utility class which provides metadata about the selection. The metadata may be the start and end
     * rectangles, caret region, etc. **This class is not intended to be used standalone. Its functions will
     * be merged into each editor instance, so the developer may use them directly via the editor, without making
     * an instance of this class**.
     *
     * @class SelectionRegion
     * @constructor
     */
    function SelectionRegion() {}

    SelectionRegion.prototype = {
        constructor: SelectionRegion,

        /**
         * Creates selection from two points in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method createSelectionFromPoint
         * @param {Number} x X point in page coordinates.
         * @param {Number} y Y point in page coordinates.
         */
        createSelectionFromPoint: function createSelectionFromPoint(x, y) {
            this.createSelectionFromRange(x, y, x, y);
        },

        /**
         * Creates selection from range. A range consists from two points in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method createSelectionFromRange
         * @param {Number} startX X coordinate of the first point.
         * @param {Number} startY Y coordinate of the first point.
         * @param {Number} endX X coordinate of the second point.
         * @param {Number} endY Y coordinate of the second point.
         */
        createSelectionFromRange: function createSelectionFromRange(startX, startY, endX, endY) {
            var end;
            var endContainer;
            var endOffset;
            var range;
            var start;
            var startContainer;
            var startOffset;

            if (typeof document.caretPositionFromPoint === 'function') {
                start = document.caretPositionFromPoint(startX, startY);
                end = document.caretPositionFromPoint(endX, endY);

                startContainer = start.offsetNode;
                endContainer = end.offsetNode;

                startOffset = start.offset;
                endOffset = end.offset;

                range = this.createRange();
            } else if (typeof document.caretRangeFromPoint === 'function') {
                start = document.caretRangeFromPoint(startX, startY);
                end = document.caretRangeFromPoint(endX, endY);

                startContainer = start.startContainer;
                endContainer = end.startContainer;

                startOffset = start.startOffset;
                endOffset = end.startOffset;

                range = this.createRange();
            }

            if (range && document.getSelection) {
                range.setStart(new CKEDITOR.dom.node(startContainer), startOffset);
                range.setEnd(new CKEDITOR.dom.node(endContainer), endOffset);

                this.getSelection().selectRanges([range]);
            } else if (typeof document.body.createTextRange === 'function') {
                var selection = this.getSelection();

                selection.unlock();

                range = document.body.createTextRange();
                range.moveToPoint(startX, startY);

                var endRange = range.duplicate();
                endRange.moveToPoint(endX, endY);

                range.setEndPoint('EndToEnd', endRange);
                range.select();

                this.getSelection().lock();
            }
        },

        /**
         * Returns the region of the current position of the caret. The points are in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getCaretRegion
         * @return {Object} Returns object with the following properties:
         * - bottom
         * - left
         * - right
         * - top
         */
        getCaretRegion: function getCaretRegion() {
            var selection = this.getSelection();

            var region = {
                bottom: 0,
                left: 0,
                right: 0,
                top: 0
            };

            var bookmarks = selection.createBookmarks();

            if (!bookmarks.length) {
                return region;
            }

            var bookmarkNodeEl = bookmarks[0].startNode.$;

            bookmarkNodeEl.style.display = 'inline-block';

            region = new CKEDITOR.dom.element(bookmarkNodeEl).getClientRect();

            bookmarkNodeEl.parentNode.removeChild(bookmarkNodeEl);

            var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

            region.bottom = scrollPos.y + region.bottom;
            region.left = scrollPos.x + region.left;
            region.right = scrollPos.x + region.right;
            region.top = scrollPos.y + region.top;

            return region;
        },

        /**
         * Returns data for the current selection.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionData
         * @return {Object|null} Returns an object with the following data:
         * - element - The currently selected element, if any
         * - text - The selected text
         * - region - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionRegion:method"}}{{/crossLink}}
         */
        getSelectionData: function getSelectionData() {
            var selection = this.getSelection();

            if (!selection.getNative()) {
                return null;
            }

            var result = {
                element: selection.getSelectedElement(),
                text: selection.getSelectedText()
            };

            result.region = this.getSelectionRegion(selection);

            return result;
        },

        /**
         * Returns the region of the current selection.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionRegion
         * @return {Object} Returns object which is being returned from
         * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getClientRectsRegion:method"}}{{/crossLink}} with three more properties:
         * - direction - the direction of the selection. Can be one of these:
         *   1. CKEDITOR.SELECTION_TOP_TO_BOTTOM
         *   2. CKEDITOR.SELECTION_BOTTOM_TO_TOP
         * - height - The height of the selection region
         * - width - The width of the selection region
         */
        getSelectionRegion: function getSelectionRegion() {
            var region = this.getClientRectsRegion();

            region.direction = this.getSelectionDirection();

            region.height = region.bottom - region.top;
            region.width = region.right - region.left;

            return region;
        },

        /**
         * Returns true if the current selection is empty, false otherwise.
         *
         * @instance
         * @memberof SelectionRegion
         * @method isSelectionEmpty
         * @return {Boolean} Returns true if the current selection is empty, false otherwise.
         */
        isSelectionEmpty: function isSelectionEmpty() {
            var ranges;

            var selection = this.getSelection();

            return selection.getType() === CKEDITOR.SELECTION_NONE || (ranges = selection.getRanges()) && ranges.length === 1 && ranges[0].collapsed;
        },

        /**
         * Returns object with data about the [client rectangles](https://developer.mozilla.org/en-US/docs/Web/API/Element.getClientRects) of the selection,
         * normalized across browses. All offsets below are in page coordinates.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getClientRectsRegion
         * @return {Object} Returns object with the following data:
         * - bottom - bottom offset of all client rectangles
         * - left - left offset of all client rectangles
         * - right - right offset of all client rectangles
         * - top - top offset of all client rectangles
         * - startRect - An Object, which contains the following information:
         *     + bottom - bottom offset
         *     + height - the height of the rectangle
         *     + left - left offset of the selection
         *     + right - right offset of the selection
         *     + top - top offset of the selection
         *     + width - the width of the rectangle
         * - endRect - An Object, which contains the following information:
         *     + bottom - bottom offset
         *     + height - the height of the rectangle
         *     + left - left offset of the selection
         *     + right - right offset of the selection
         *     + top - top offset of the selection
         *     + width - the width of the rectangle
         *
         * If there is no native selection, the objects will be filled with 0.
         */
        getClientRectsRegion: function getClientRectsRegion() {
            var selection = this.getSelection();
            var nativeSelection = selection.getNative();

            var defaultRect = {
                bottom: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                width: 0
            };

            var region = {
                bottom: 0,
                endRect: defaultRect,
                left: 0,
                right: 0,
                top: 0,
                startRect: defaultRect
            };

            if (!nativeSelection) {
                return region;
            }

            var bottom = 0;
            var clientRects;
            var left = Infinity;
            var rangeCount;
            var right = -Infinity;
            var top = Infinity;

            if (nativeSelection.createRange) {
                clientRects = nativeSelection.createRange().getClientRects();
            } else {
                rangeCount = nativeSelection.rangeCount;
                clientRects = nativeSelection.rangeCount > 0 ? nativeSelection.getRangeAt(0).getClientRects() : [];
            }

            if (clientRects.length === 0) {
                region = this.getCaretRegion();
            } else {
                for (var i = 0, length = clientRects.length; i < length; i++) {
                    var item = clientRects[i];

                    if (item.left < left) {
                        left = item.left;
                    }

                    if (item.right > right) {
                        right = item.right;
                    }

                    if (item.top < top) {
                        top = item.top;
                    }

                    if (item.bottom > bottom) {
                        bottom = item.bottom;
                    }
                }

                var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

                region.bottom = scrollPos.y + bottom;
                region.left = scrollPos.x + left;
                region.right = scrollPos.x + right;
                region.top = scrollPos.y + top;

                if (clientRects.length) {
                    var endRect = clientRects[clientRects.length - 1];
                    var startRect = clientRects[0];

                    region.endRect = {
                        bottom: scrollPos.y + endRect.bottom,
                        height: endRect.height,
                        left: scrollPos.x + endRect.left,
                        right: scrollPos.x + endRect.right,
                        top: scrollPos.y + endRect.top,
                        width: endRect.width
                    };

                    region.startRect = {
                        bottom: scrollPos.y + startRect.bottom,
                        height: startRect.height,
                        left: scrollPos.x + startRect.left,
                        right: scrollPos.x + startRect.right,
                        top: scrollPos.y + startRect.top,
                        width: startRect.width
                    };
                }
            }

            return region;
        },

        /**
         * Retrieves the direction of the selection. The direction is from top to bottom or from bottom to top.
         * For IE < 9 it is not possible, so the direction for these browsers will be always CKEDITOR.SELECTION_TOP_TO_BOTTOM.
         *
         * @instance
         * @memberof SelectionRegion
         * @method getSelectionDirection
         * @return {Number} Returns a number which represents selection direction. It might be one of these:
         * - CKEDITOR.SELECTION_TOP_TO_BOTTOM;
         * - CKEDITOR.SELECTION_BOTTOM_TO_TOP;
         */
        getSelectionDirection: function getSelectionDirection() {
            var direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;
            var selection = this.getSelection();
            var nativeSelection = selection.getNative();

            if (!nativeSelection) {
                return direction;
            }

            var anchorNode;

            if ((anchorNode = nativeSelection.anchorNode) && anchorNode.compareDocumentPosition) {
                var position = anchorNode.compareDocumentPosition(nativeSelection.focusNode);

                if (!position && nativeSelection.anchorOffset > nativeSelection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) {
                    direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
                }
            }

            return direction;
        }
    };

    CKEDITOR.plugins.add('ae_selectionregion', {
        init: function init(editor) {
            var attr, hasOwnProperty;

            hasOwnProperty = Object.prototype.hasOwnProperty;

            for (attr in SelectionRegion.prototype) {
                if (hasOwnProperty.call(SelectionRegion.prototype, attr) && typeof editor[attr] === 'undefined') {
                    editor[attr] = SelectionRegion.prototype[attr];
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/core/table.js":
/*!***************************!*\
  !*** ./src/core/table.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    var IE_NON_DIRECTLY_EDITABLE_ELEMENT = {
        'table': 1,
        'col': 1,
        'colgroup': 1,
        'tbody': 1,
        'td': 1,
        'tfoot': 1,
        'th': 1,
        'thead': 1,
        'tr': 1
    };

    /**
     * Table class utility. Provides methods for create, delete and update tables.
     *
     * @class CKEDITOR.Table
     * @constructor
     * @param {Object} editor The CKEditor instance.
     */

    function Table(editor) {
        this._editor = editor;
    }

    Table.HEADING_BOTH = 'Both';
    Table.HEADING_COL = 'Column';
    Table.HEADING_NONE = 'None';
    Table.HEADING_ROW = 'Row';

    Table.prototype = {
        constructor: Table,

        /**
         * Creates a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method create
         * @param {Object} config Table configuration object
         * @return {Object} The created table
         */
        create: function create(config) {
            var editor = this._editor;
            var table = this._createElement('table');

            config = config || {};

            // Generate the rows and cols.
            var tbody = table.append(this._createElement('tbody'));
            var rows = config.rows || 1;
            var cols = config.cols || 1;

            for (var i = 0; i < rows; i++) {
                var row = tbody.append(this._createElement('tr'));
                for (var j = 0; j < cols; j++) {
                    var cell = row.append(this._createElement('td'));

                    cell.appendBogus();
                }
            }

            this.setAttributes(table, config.attrs);
            this.setHeading(table, config.heading);

            // Insert the table element if we're creating one.
            editor.insertElement(table);

            var firstCell = new CKEDITOR.dom.element(table.$.rows[0].cells[0]);
            var range = editor.createRange();
            range.moveToPosition(firstCell, CKEDITOR.POSITION_AFTER_START);
            range.select();

            return table;
        },

        /**
         * Retrieves a table from the current selection.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method getFromSelection
         * @return {CKEDITOR.dom.element} The retrieved table or null if not found.
         */
        getFromSelection: function getFromSelection() {
            var table;
            var selection = this._editor.getSelection();
            var selected = selection.getSelectedElement();

            if (selected && selected.is('table')) {
                table = selected;
            } else {
                var ranges = selection.getRanges();

                if (ranges.length > 0) {
                    // Webkit could report the following range on cell selection (#4948):
                    // <table><tr><td>[&nbsp;</td></tr></table>]

                    /* istanbul ignore else */
                    if (CKEDITOR.env.webkit) {
                        ranges[0].shrink(CKEDITOR.NODE_ELEMENT);
                    }

                    table = this._editor.elementPath(ranges[0].getCommonAncestor(true)).contains('table', 1);
                }
            }

            return table;
        },

        /**
         * Checks if a given table can be considered as editable. This method
         * workarounds a limitation of IE where for some elements (like table),
         * `isContentEditable` returns always false. This is because IE does not support
         * `contenteditable` on such elements. However, despite such elements
         * cannot be set as content editable directly, a content editable SPAN,
         * or DIV element can be placed inside the individual table cells.
         * See https://msdn.microsoft.com/en-us/library/ms537837%28v=VS.85%29.aspx
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method isEditable
         * @param {CKEDITOR.dom.element} el The table element to test if editable
         * @return {Boolean}
         */
        isEditable: function isEditable(el) {
            if (!CKEDITOR.env.ie || !el.is(IE_NON_DIRECTLY_EDITABLE_ELEMENT)) {
                return !el.isReadOnly();
            }

            if (el.hasAttribute('contenteditable')) {
                return el.getAttribute('contenteditable') !== 'false';
            }

            return this.isEditable(el.getParent());
        },

        /**
         * Returns which heading style is set for the given table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method getHeading
         * @param {CKEDITOR.dom.element} table The table to gather the heading from. If null, it will be retrieved from the current selection.
         * @return {String} The heading of the table. Expected values are `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
         */
        getHeading: function getHeading(table) {
            table = table || this.getFromSelection();

            if (!table) {
                return null;
            }

            var rowHeadingSettings = table.$.tHead !== null;

            var colHeadingSettings = true;

            // Check if all of the first cells in every row are TH
            for (var row = 0; row < table.$.rows.length; row++) {
                // If just one cell isn't a TH then it isn't a header column
                var cell = table.$.rows[row].cells[0];

                if (cell && cell.nodeName.toLowerCase() !== 'th') {
                    colHeadingSettings = false;
                    break;
                }
            }

            var headingSettings = Table.HEADING_NONE;

            if (rowHeadingSettings) {
                headingSettings = Table.HEADING_ROW;
            }

            if (colHeadingSettings) {
                headingSettings = headingSettings === Table.HEADING_ROW ? Table.HEADING_BOTH : Table.HEADING_COL;
            }

            return headingSettings;
        },

        /**
         * Removes a table from the editor.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method remove
         * @param {CKEDITOR.dom.element} table The table element which table style should be removed.
         */
        remove: function remove(table) {
            var editor = this._editor;

            if (table) {
                table.remove();
            } else {
                table = editor.elementPath().contains('table', 1);

                if (table) {
                    // If the table's parent has only one child remove it as well (unless it's a table cell, or the editable element) (#5416, #6289, #12110)
                    var parent = table.getParent();
                    var editable = editor.editable();

                    if (parent.getChildCount() === 1 && !parent.is('td', 'th') && !parent.equals(editable)) {
                        table = parent;
                    }

                    var range = editor.createRange();
                    range.moveToPosition(table, CKEDITOR.POSITION_BEFORE_START);
                    table.remove();
                    range.select();
                }
            }
        },

        /**
         * Assigns provided attributes to a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method setAttributes
         * @param {Object} table The table to which the attributes should be assigned
         * @param {Object} attrs The attributes which have to be assigned to the table
         */
        setAttributes: function setAttributes(table, attrs) {
            if (attrs) {
                Object.keys(attrs).forEach(function (attr) {
                    table.setAttribute(attr, attrs[attr]);
                });
            }
        },

        /**
         * Sets the appropriate table heading style to a table.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @method setHeading
         * @param {CKEDITOR.dom.element} table The table element to which the heading should be set. If null, it will be retrieved from the current selection.
         * @param {String} heading The table heading to be set. Accepted values are: `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
         */
        setHeading: function setHeading(table, heading) {
            table = table || this.getFromSelection();

            var i, newCell;
            var tableHead;
            var tableBody = table.getElementsByTag('tbody').getItem(0);

            var tableHeading = this.getHeading(table);
            var hadColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

            var needColHeading = heading === Table.HEADING_COL || heading === Table.HEADING_BOTH;
            var needRowHeading = heading === Table.HEADING_ROW || heading === Table.HEADING_BOTH;

            // If we need row heading and don't have a <thead> element yet, move the
            // first row of the table to the head and convert the nodes to <th> ones.
            if (!table.$.tHead && needRowHeading) {
                var tableFirstRow = tableBody.getElementsByTag('tr').getItem(0);
                var tableFirstRowChildCount = tableFirstRow.getChildCount();

                // Change TD to TH:
                for (i = 0; i < tableFirstRowChildCount; i++) {
                    var cell = tableFirstRow.getChild(i);

                    // Skip bookmark nodes. (#6155)
                    if (cell.type === CKEDITOR.NODE_ELEMENT && !cell.data('cke-bookmark')) {
                        cell.renameNode('th');
                        cell.setAttribute('scope', 'col');
                    }
                }

                tableHead = this._createElement(table.$.createTHead());
                tableHead.append(tableFirstRow.remove());
            }

            // If we don't need row heading and we have a <thead> element, move the
            // row out of there and into the <tbody> element.
            if (table.$.tHead !== null && !needRowHeading) {
                // Move the row out of the THead and put it in the TBody:
                tableHead = this._createElement(table.$.tHead);

                var previousFirstRow = tableBody.getFirst();

                while (tableHead.getChildCount() > 0) {
                    var newFirstRow = tableHead.getFirst();
                    var newFirstRowChildCount = newFirstRow.getChildCount();

                    for (i = 0; i < newFirstRowChildCount; i++) {
                        newCell = newFirstRow.getChild(i);

                        if (newCell.type === CKEDITOR.NODE_ELEMENT) {
                            newCell.renameNode('td');
                            newCell.removeAttribute('scope');
                        }
                    }

                    newFirstRow.insertBefore(previousFirstRow);
                }

                tableHead.remove();
            }

            tableHeading = this.getHeading(table);
            var hasColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

            // If we need column heading and the table doesn't have it, convert every first cell in
            // every row into a `<th scope="row">` element.
            if (!hasColHeading && needColHeading) {
                for (i = 0; i < table.$.rows.length; i++) {
                    if (table.$.rows[i].cells[0].nodeName.toLowerCase() !== 'th') {
                        newCell = new CKEDITOR.dom.element(table.$.rows[i].cells[0]);
                        newCell.renameNode('th');
                        newCell.setAttribute('scope', 'row');
                    }
                }
            }

            // If we don't need column heading but the table has it, convert every first cell in every
            // row back into a `<td>` element.
            if (hadColHeading && !needColHeading) {
                for (i = 0; i < table.$.rows.length; i++) {
                    var row = new CKEDITOR.dom.element(table.$.rows[i]);

                    if (row.getParent().getName() === 'tbody') {
                        newCell = new CKEDITOR.dom.element(row.$.cells[0]);
                        newCell.renameNode('td');
                        newCell.removeAttribute('scope');
                    }
                }
            }
        },

        /**
         * Creates a new CKEDITOR.dom.element using the passed tag name.
         *
         * @instance
         * @memberof CKEDITOR.Table
         * @protected
         * @method _createElement
         * @param {String} name The tag name from which an element should be created
         * @return {CKEDITOR.dom.element} Instance of CKEDITOR DOM element class
         */
        _createElement: function _createElement(name) {
            return new CKEDITOR.dom.element(name, this._editor.document);
        }
    };

    CKEDITOR.on('instanceReady', function (event) {
        var headingCommands = [Table.HEADING_NONE, Table.HEADING_ROW, Table.HEADING_COL, Table.HEADING_BOTH];

        var tableUtils = new Table(event.editor);

        headingCommands.forEach(function (heading) {
            event.editor.addCommand('tableHeading' + heading, {
                exec: function exec(editor) {
                    tableUtils.setHeading(null, heading);
                }
            });
        });
    });

    CKEDITOR.Table = CKEDITOR.Table || Table;
})();

/***/ }),

/***/ "./src/core/tools.js":
/*!***************************!*\
  !*** ./src/core/tools.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /**
     * CKEDITOR.tools class utility which adds additional methods to those of CKEditor.
     *
     * @class CKEDITOR.tools
     */

    /**
     * Sends a request using the JSONP technique.
     *
     * @memberof CKEDITOR.tools
     * @method jsonp
     * @param {CKEDITOR.template} urlTemplate The template of the URL to be requested. All properties passed in `urlParams` can be used, plus a `{callback}`, which represent a JSONP callback, must be defined.
     * @param {Function} callback A function to be called in case of success.
     * @param {Function} errorCallback A function to be called in case of failure.
     * @param {Object} urlParams Parameters to be passed to the `urlTemplate`.
     * @return {Object} An object with the following properties:
     *  - id: the transaction ID
     *  - a `cancel()` method
     * @static
     */

    CKEDITOR.tools.jsonp = function (urlTemplate, urlParams, callback, errorCallback) {
        var callbackKey = CKEDITOR.tools.getNextNumber();

        urlParams = urlParams || {};
        urlParams.callback = 'CKEDITOR._.jsonpCallbacks[' + callbackKey + ']';

        if (!CKEDITOR._.jsonpCallbacks) {
            CKEDITOR._.jsonpCallbacks = {};
        }

        CKEDITOR._.jsonpCallbacks[callbackKey] = function (response) {
            setTimeout(function () {
                cleanUp();

                callback(response);
            });
        };

        var scriptElement = new CKEDITOR.dom.element('script');
        scriptElement.setAttribute('src', urlTemplate.output(urlParams));
        scriptElement.on('error', function () {
            cleanUp();

            if (errorCallback) {
                errorCallback();
            }
        });

        function cleanUp() {
            if (scriptElement) {
                scriptElement.remove();
                delete CKEDITOR._.jsonpCallbacks[callbackKey];
                scriptElement = null;
            }
        }

        CKEDITOR.document.getBody().append(scriptElement);

        return {
            cancel: cleanUp,
            id: callbackKey
        };
    };

    /**
     * Returns a new object containing all of the properties of all the supplied
     * objects. The properties from later objects will overwrite those in earlier
     * objects.
     *
     * Passing in a single object will create a shallow copy of it.
     *
     * @memberof CKEDITOR.tools
     * @method merge
     * @param {Object} objects* One or more objects to merge.
     * @return {Object} A new merged object.
     * @static
     */
    CKEDITOR.tools.merge = CKEDITOR.tools.merge || function () {
        var result = {};

        for (var i = 0; i < arguments.length; ++i) {
            var obj = arguments[i];

            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    result[key] = obj[key];
                }
            }
        }

        return result;
    };

    /**
     * Simulates event on a DOM element.
     *
     * @memberof CKEDITOR.tools
     * @method simulate
     * @param {DOMElement} element The element on which the event shoud be simualted.
     * @param {String} event The name of the event which have to be simulated.
     * @static
     */
    CKEDITOR.tools.simulate = function (element, event) {
        var eventInstance = document.createEvent('Events');
        eventInstance.initEvent(event, true, false);
        element.dispatchEvent(eventInstance);
    };
})();

/***/ }),

/***/ "./src/core/uicore.js":
/*!****************************!*\
  !*** ./src/core/uicore.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_uicore')) {
        return;
    }

    /**
     * UICore class which will handle user interactions with the editor. These interactions
     * might be triggered via mouse, keyboard or touch devices. The class fill fire an event via
     * CKEditor's event system - "editorInteraction". The UI may listen to this event and
     * execute some actions - for example to show/hide toolbars.
     *
     * By default if user presses the Esc key, 'editorInteraction' event won't be fired. However, this behaviour can be changed
     * by setting {{#crossLink "CKEDITOR.plugins.ae_uicore/allowEsc:attribute"}}{{/crossLink}} config property in editor's configuration to true.
     *
     * @class ae_uicore
     */

    /**
     * Fired when user interacts somehow with the browser. This may be clicking with the mouse, pressing keyboard button,
     * or touching screen. This even will be not fired after each interaction. It will be debounced. By default the timeout
     * is 50ms. This value can be overwritten via {{#crossLink "CKEDITOR.plugins.ae_uicore/timeout:attribute"}}{{/crossLink}}
     * property of editor's configuration, like: editor.config.uicore.timeout = 100
     *
     * @memberof ae_uicore
     * @event ae_uicore#editorInteraction
     * @param {Object} data An object which contains the following properties:
     * - nativeEvent - The event as received from CKEditor.
     * - selectionData - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
     */

    /**
     * Fired by UI elements like Toolbars or Buttons when their state changes. The listener updates the live region with the provided data.
     *
     * @memberof ae_uicore
     * @event ae_uicore#ariaUpdate
     * @param {Object} data An object which contains the following properties:
     * - message - The provided message from the UI element.
     */

    /**
     * If set to true, the editor will still fire {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event,
     * if user presses Esc key.
     *
     * @memberof ae_uicore
     * @attribute allowEsc
     * @default false
     * @type Boolean
     */

    /**
     * Specifies the default timeout after which the {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event
     * will be fired.
     *
     * @memberof ae_uicore
     * @attribute timeout
     * @default 50 (ms)
     * @type Number
     */

    CKEDITOR.plugins.add('ae_uicore', {
        /**
         * Initializer lifecycle implementation for the UICore plugin.
         *
         * @memberof ae_uicore
         * @method init
         * @param {Object} editor The current CKEditor instance.
         * @protected
         */
        init: function init(editor) {
            var ariaState = [];

            var ariaElement = this._createAriaElement(editor.id);

            var uiTasksTimeout = editor.config.uicore ? editor.config.uicore.timeout : 50;

            var handleUI = CKEDITOR.tools.debounce(function (event) {
                ariaState = [];

                if (event.name !== 'keyup' || event.data.$.keyCode !== 27 || editor.config.allowEsc) {
                    var selectionData = editor.getSelectionData();

                    if (selectionData) {
                        editor.fire('editorInteraction', {
                            nativeEvent: event.data.$,
                            selectionData: selectionData
                        });
                    }
                }
            }, uiTasksTimeout);

            var handleAria = CKEDITOR.tools.debounce(function (event) {
                ariaElement.innerHTML = ariaState.join('. ');
            }, uiTasksTimeout);

            var handleMouseLeave = CKEDITOR.tools.debounce(function (event) {
                var aeUINodes = document.querySelectorAll('.ae-ui');

                var found;

                for (var i = 0; i < aeUINodes.length; i++) {
                    if (aeUINodes[i].contains(event.data.$.relatedTarget)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    handleUI(event);
                }
            }, uiTasksTimeout);

            editor.on('ariaUpdate', function (event) {
                // handleAria is debounced function, so if it is being called multiple times, it will
                // be canceled until some time passes.
                // For that reason here we explicitly append the current message to the list of messages
                // and call handleAria. Since it is debounced, when some timeout passes,
                // all the messages will be applied to the live region and not only the last one.

                ariaState.push(event.data.message);

                handleAria();
            });

            editor.once('contentDom', function () {
                var editable = editor.editable();

                var focusHandler = editable.attachListener(editable, 'focus', function (event) {
                    focusHandler.removeListener();

                    editable.attachListener(editable, 'keyup', handleUI);
                    editable.attachListener(editable, 'mouseup', handleUI);
                    editable.attachListener(editable, 'mouseleave', handleMouseLeave);

                    handleUI(event);
                });
            });

            editor.on('destroy', function (event) {
                ariaElement.parentNode.removeChild(ariaElement);

                handleUI.detach();
            });
        },

        /**
         * Creates and applies an HTML element to the body of the document which will contain ARIA messages.
         *
         * @memberof ae_uicore
         * @method _createAriaElement
         * @param {String} id The provided id of the element. It will be used as prefix for the final element Id.
         * @protected
         * @return {HTMLElement} The created and applied to DOM element.
         */
        _createAriaElement: function _createAriaElement(id) {
            var statusElement = document.createElement('div');

            statusElement.className = 'ae-sr-only';

            statusElement.setAttribute('aria-live', 'polite');
            statusElement.setAttribute('role', 'status');
            statusElement.setAttribute('id', id + 'LiveRegion');

            document.body.appendChild(statusElement);

            return statusElement;
        }
    });
})();

/***/ }),

/***/ "./src/oop/attribute.js":
/*!******************************!*\
  !*** ./src/oop/attribute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _lang = __webpack_require__(/*! ./lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attribute implementation.
 *
 * @class Attribute
 * @constructor
*/
function Attribute(config) {
    this.__config__ = config || {};
    this.__ATTRS__ = {};
}

Attribute.prototype = {
    constructor: Attribute,

    /**
     * Retrieves the value of an attribute.
     *
     * @instance
     * @memberof Attribute
     * @method get
     * @param {String} attr The attribute which value should be retrieved.
     * @return {Any} The value of the attribute.
     */
    get: function get(attr) {
        var currentAttr = this.constructor.ATTRS[attr];

        if (!currentAttr) {
            return;
        }

        if (!this._isInitialized(attr)) {
            this._init(attr);
        }

        var curValue = this.__ATTRS__[attr];

        if (currentAttr.getter) {
            curValue = this._callStringOrFunction(currentAttr.getter, curValue);
        }

        return curValue;
    },

    /**
     * Sets the value of an attribute.
     *
     * @instance
     * @memberof Attribute
     * @method set
     * @param {String} attr The attribute which value should be set.
     * @param {Any} value The value which should be set to the attribute.
     */
    set: function set(attr, value) {
        var currentAttr = this.constructor.ATTRS[attr];

        if (!currentAttr) {
            return;
        }

        if (!this._isInitialized(attr)) {
            this._init(attr);
        }

        if (currentAttr.readOnly) {
            return;
        }

        if (currentAttr.writeOnce && this._isInitialized(attr)) {
            return;
        }

        if (currentAttr.validator && !this._callStringOrFunction(currentAttr.validator, value)) {
            return;
        }

        if (currentAttr.setter) {
            value = this._callStringOrFunction(currentAttr.setter, value);
        }

        this.__ATTRS__[attr] = value;
    },

    /**
     * Calls the provided param as function with the supplied arguments.
     * If param provided as string, a corresponding function in this object will
     * be called. If provided param is a function, it will be directly called.
     *
     * @instance
     * @memberof Attribute
     * @method _callStringOrFunction
     * @param  {Any|Array} args The arguments which will be provided to the called function
     * @param  {String|Function} stringOrFunction The function which should be called
     * @protected
     * @return {Any} The returned value from the called function
     */
    _callStringOrFunction: function _callStringOrFunction(stringOrFunction, args) {
        var result = null;

        if (!_lang2.default.isArray(args)) {
            args = [args];
        }

        if (_lang2.default.isString(stringOrFunction) && _lang2.default.isFunction(this[stringOrFunction])) {
            result = this[stringOrFunction].apply(this, args);
        } else if (_lang2.default.isFunction(stringOrFunction)) {
            result = stringOrFunction.apply(this, args);
        }

        return result;
    },

    /**
     * Initializes an attribute. Sets its default value depending on the flags of the
     * attribute and the passed configuration object to the constructor.
     *
     * @instance
     * @memberof Attribute
     * @method _init
     * @param {String} attr The name of the attribute which have to be initialized.
     * @protected
     */
    _init: function _init(attr) {
        var value;

        var currentAttr = this.constructor.ATTRS[attr];

        // Check if there is default value or passed one via configuration object
        var hasDefaultValue = Object.prototype.hasOwnProperty.call(currentAttr, 'value');
        var hasPassedValueViaConfig = Object.prototype.hasOwnProperty.call(this.__config__, attr);

        // If there is valueFn, set the value to be the result of invocation of this function
        if (currentAttr.valueFn) {
            value = this._callStringOrFunction(currentAttr.valueFn, value);

            this.__ATTRS__[attr] = value;
        }
        // else if the attribute has readOnly flag, set the default value from the attribute,
        // regardless if there is value or not
        else if (currentAttr.readOnly) {
                value = currentAttr.value;
            }
            // else if the attribute has writeOnce value, set it from the passed configuration or from the
            // default value, in this order. Otherwise, return miserable.
            else if (currentAttr.writeOnce) {
                    if (hasPassedValueViaConfig) {
                        value = this.__config__[attr];
                    } else if (hasDefaultValue) {
                        value = currentAttr.value;
                    } else {
                        return;
                    }
                }
                // These two cases below are easy - set the value to be from the passed config or
                // from the default value, in this order.
                else if (hasPassedValueViaConfig) {
                        value = this.__config__[attr];
                    } else if (hasDefaultValue) {
                        value = currentAttr.value;
                    }

        // If there is validator, and user passed config object - check the returned value.
        // If it is false, then set as initial value the default one.
        // However, if there is no default value, just return.
        if (currentAttr.validator && hasPassedValueViaConfig && !this._callStringOrFunction(currentAttr.validator, value)) {
            if (hasDefaultValue) {
                value = currentAttr.value;
            } else {
                return;
            }
        }

        // If there is setter and user passed config object - pass the value thought the setter.
        // The value might be one from defaultFn, default value or provided from the config.
        if (currentAttr.setter && hasPassedValueViaConfig) {
            value = this._callStringOrFunction(currentAttr.setter, value);
        }

        // Finally, set the value as initial value to the storage with values.
        this.__ATTRS__[attr] = value;
    },

    /**
     * Checks if an attribute is initialized. An attribute is considered as initialized
     * when there is an own property with this name in the local collection of attribute values
     * for the current instance.
     *
     * @instance
     * @memberof Attribute
     * @method _isInitialized
     * @param {String} attr The attribute which should be checked if it is initialized.
     * @protected
     * @return {Boolean} Returns true if the attribute has been initialized, false otherwise.
     */
    _isInitialized: function _isInitialized(attr) {
        return Object.prototype.hasOwnProperty.call(this.__ATTRS__, attr);
    }
};

exports.default = Attribute;

/***/ }),

/***/ "./src/oop/base.js":
/*!*************************!*\
  !*** ./src/oop/base.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _attribute = __webpack_require__(/*! ./attribute.js */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ./lang.js */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ./oop.js */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Quick and dirty impl of Base class.
 *
 * @class Base
 * @constructor
 */
function Base(config) {
    Base.superclass.constructor.call(this, config);

    this.init(config);
}

(0, _oop2.default)(Base, _attribute2.default, {
    /**
     * Calls the `initializer` method of each class which extends Base starting from the parent to the child.
     * Will pass the configuration object to each initializer method.
     *
     * @instance
     * @memberof Base
     * @method init
     * @param {Object} config Configuration object
     */
    init: function init(config) {
        this._callChain('initializer', config);
    },

    /**
     * Calls the `destructor` method of each class which extends Base starting from the parent to the child.
     *
     * @instance
     * @memberof Base
     * @method destroy
     */
    destroy: function destroy() {
        this._callChain('destructor');
    },

    /**
     * Calls a method of each class, which is being present in the hierarchy starting from parent to the child.
     *
     * @instance
     * @memberof Base
     * @method _callChain
     * @param {Object|Array} args The arguments with which the method should be invoked
     * @param {String} wat  The method, which should be invoked
     * @protected
     */
    _callChain: function _callChain(wat, args) {
        var arr = [];

        var ctor = this.constructor;

        while (ctor) {
            if (_lang2.default.isFunction(ctor.prototype[wat])) {
                arr.push(ctor.prototype[wat]);
            }

            ctor = ctor.superclass ? ctor.superclass.constructor : null;
        }

        arr = arr.reverse();

        args = _lang2.default.isArray(args) ? args : [args];

        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];

            item.apply(this, args);
        }
    }
});

exports.default = Base;

/***/ }),

/***/ "./src/oop/lang.js":
/*!*************************!*\
  !*** ./src/oop/lang.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Provides core language utilities.
 *
 * @class Lang
 */
var Lang = {
    /**
     * Check if the passed value is an array.
     *
     * @memberof Lang
     * @method isArray
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is an array, false otherwise.
     * @static
     */
    isArray: function isArray(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    },

    /**
     * Check if the passed value is boolean.
     *
     * @memberof Lang
     * @method isBoolean
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is boolean, false otherwise.
     * @static
     */
    isBoolean: function isBoolean(value) {
        return typeof value === 'boolean';
    },

    /**
     * Check if the passed value is a function.
     *
     * @memberof Lang
     * @method isFunction
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is a function, false otherwise.
     * @static
     */
    isFunction: function isFunction(value) {
        return typeof value === 'function';
    },

    /**
     * Check if the passed value is NULL.
     *
     * @memberof Lang
     * @method isNull
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is NULL, false otherwise.
     * @static
     */
    isNull: function isNull(value) {
        return value === null;
    },

    /**
     * Check if the passed value is number.
     *
     * @memberof Lang
     * @method isNumber
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is number, false otherwise.
     * @static
     */
    isNumber: function isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    },

    /**
     * Check if the passed value is an object
     *
     * @memberof Lang
     * @method isObject
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is an object, false otherwise.
     * @static
     */
    isObject: function isObject(value) {
        var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        return value && (valueType === 'object' || Lang.isFunction(value));
    },

    /**
     * Check if the passed value is a string.
     *
     * @memberof Lang
     * @method isString
     * @param {Any} value The value which have to be checked.
     * @return {Boolean} True if the passed value is a string, false otherwise.
     * @static
     */
    isString: function isString(value) {
        return typeof value === 'string';
    },

    /**
     * Adds all properties from the supplier to the receiver.
     * The function will add all properties, not only these owned by the supplier.
     *
     * @memberof Lang
     * @method mix
     * @param {Object} receiver The object which will receive properties.
     * @param {Object} supplier The object which provides properties.
     * @return {Object} The modified receiver.
     * @static
     */
    mix: function mix(receiver, supplier) {
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var key in supplier) {
            if (hasOwnProperty.call(supplier, key)) {
                receiver[key] = supplier[key];
            }
        }
    },

    /**
     * Converts value to Integer.
     *
     * @memberof Lang
     * @method toInt
     * @param {Any} value The value which have to be converted to Integer.
     * @return {Integer} The converted value.
     * @static
     */
    toInt: function toInt(value) {
        return parseInt(value, 10);
    }
};

exports.default = Lang;

/***/ }),

/***/ "./src/oop/oop.js":
/*!************************!*\
  !*** ./src/oop/oop.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the prototype, constructor and superclass properties to support an inheritance strategy
 * that can chain constructors and methods. Static members will not be inherited.
 *
 * @memberof OOP
 * @method extend
 * @param {Function} receiver The class which will extend another class.
 * @param {Function} supplier The class which will provide the properties the child class.
 * @param {Object} protoProps Prototype properties to add/override.
 * @param {Object} staticProps Static properties to add/overwrite.
 * @return {Function} The extended class.
 * @static
 */
var extend = function extend(receiver, supplier, protoProps, staticProps) {
    if (!supplier || !receiver) {
        throw 'extend failed, verify dependencies';
    }

    var supplierProto = supplier.prototype,
        receiverProto = Object.create(supplierProto);
    receiver.prototype = receiverProto;

    receiverProto.constructor = receiver;
    receiver.superclass = supplierProto;

    // assign constructor property
    if (supplier !== Object && supplierProto.constructor === Object.prototype.constructor) {
        supplierProto.constructor = supplier;
    }

    // add prototype overrides
    if (protoProps) {
        _lang2.default.mix(receiverProto, protoProps);
    }

    // add object overrides
    if (staticProps) {
        _lang2.default.mix(receiver, staticProps);
    }

    return receiver;
};

exports.default = extend;

/***/ }),

/***/ "./src/plugins/addimages.js":
/*!**********************************!*\
  !*** ./src/plugins/addimages.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    var isIE = CKEDITOR.env.ie;

    if (CKEDITOR.plugins.get('ae_addimages')) {
        return;
    }

    /**
     * CKEditor plugin which allows Drag&Drop of images directly into the editable area. The image will be encoded
     * as Data URI. An event `beforeImageAdd` will be fired with the list of dropped images. If any of the listeners
     * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
     * an event `imageAdd` will be fired with the inserted element into the editable area.
     *
     * @class CKEDITOR.plugins.ae_addimages
     */

    /**
     * Fired before adding images to the editor.
     *
     * @event CKEDITOR.plugins.ae_addimages#beforeImageAdd
     * @instance
     * @memberof CKEDITOR.plugins.ae_addimages
     * @param {Array} imageFiles Array of image files
     */

    /**
     * Fired when an image is being added to the editor successfully.
     *
     * @event CKEDITOR.plugins.ae_addimages#imageAdd
     * @instance
     * @memberof CKEDITOR.plugins.ae_addimages
     * @param {CKEDITOR.dom.element} el The created image with src as Data URI
     * @param {File} file The image file
     */

    CKEDITOR.plugins.add('ae_addimages', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'dragenter', 'dragover', 'drop' and `paste` events on the editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'dragenter', this._onDragEnter, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'dragover', this._onDragOver, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'drop', this._onDragDrop, this, {
                    editor: editor
                });

                editable.attachListener(editable, 'paste', this._onPaste, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Accepts an array of dropped files to the editor. Then, it filters the images and sends them for further
         * processing to {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}}
         *
         * @fires CKEDITOR.plugins.ae_addimages#beforeImageAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _handleFiles
         * @param {Array} files Array of dropped files. Only the images from this list will be processed.
         * @param {Object} editor The current editor instance
         * @protected
         */
        _handleFiles: function _handleFiles(files, editor) {
            var file;
            var i;

            var imageFiles = [];

            for (i = 0; i < files.length; i++) {
                file = files[i];

                if (file.type.indexOf('image') === 0) {
                    imageFiles.push(file);
                }
            }

            var result = editor.fire('beforeImageAdd', {
                imageFiles: imageFiles
            });

            if (!!result) {
                for (i = 0; i < imageFiles.length; i++) {
                    file = imageFiles[i];

                    this._processFile(file, editor);
                }
            }

            return false;
        },

        /**
         * Handles drag drop event. The function will create a selection from the current
         * point and will send a list of files to be processed to
         * {{#crossLink "CKEDITOR.plugins.ae_addimages/_handleFiles:method"}}{{/crossLink}} method.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragDrop
         * @param {CKEDITOR.dom.event} event dragdrop event, as received natively from CKEditor
         * @protected
         */
        _onDragDrop: function _onDragDrop(event) {
            var nativeEvent = event.data.$;

            new CKEDITOR.dom.event(nativeEvent).preventDefault();

            var editor = event.listenerData.editor;

            event.listenerData.editor.createSelectionFromPoint(nativeEvent.clientX, nativeEvent.clientY);

            this._handleFiles(nativeEvent.dataTransfer.files, editor);
        },

        /**
         * Handles drag enter event. In case of IE, this function will prevent the event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragEnter
         * @param {DOM event} event dragenter event, as received natively from CKEditor
         * @protected
         */
        _onDragEnter: function _onDragEnter(event) {
            if (isIE) {
                this._preventEvent(event);
            }
        },

        /**
         * Handles drag over event. In case of IE, this function will prevent the event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onDragOver
         * @param {DOM event} event dragover event, as received natively from CKEditor
         * @protected
         */
        _onDragOver: function _onDragOver(event) {
            if (isIE) {
                this._preventEvent(event);
            }
        },

        /**
         * Checks if the pasted data is image and passes it to
         * {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}} for processing.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _onPaste
         * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
         * @protected
         */
        _onPaste: function _onPaste(event) {
            if (event.data && event.data.$ && event.data.$.clipboardData && event.data.$.clipboardData.items && event.data.$.clipboardData.items.length > 0) {
                var pastedData = event.data.$.clipboardData.items[0];

                if (pastedData.type.indexOf('image') === 0) {
                    var imageFile = pastedData.getAsFile();

                    this._processFile(imageFile, event.listenerData.editor);
                }
            }
        },

        /**
         * Prevents a native event.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _preventEvent
         * @param {DOM event} event The event to be prevented.
         * @protected
         */
        _preventEvent: function _preventEvent(event) {
            event = new CKEDITOR.dom.event(event.data.$);

            event.preventDefault();
            event.stopPropagation();
        },

        /**
         * Processes an image file. The function creates an img element and sets as source
         * a Data URI, then fires an 'imageAdd' event via CKEditor's event system.
         *
         * @fires CKEDITOR.plugins.ae_addimages#imageAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_addimages
         * @method _preventEvent
         * @param {DOM event} event The event to be prevented.
         * @protected
         */
        _processFile: function _processFile(file, editor) {
            var reader = new FileReader();

            reader.addEventListener('loadend', function () {
                var bin = reader.result;

                var el = CKEDITOR.dom.element.createFromHtml('<img src="' + bin + '">');

                editor.insertElement(el);

                var imageData = {
                    el: el,
                    file: file
                };

                editor.fire('imageAdd', imageData);
            });

            reader.readAsDataURL(file);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/autolink.js":
/*!*********************************!*\
  !*** ./src/plugins/autolink.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_autolink')) {
        return;
    }

    // Disables the auto URL detection feature in IE, their lacks functionality:
    // They convert the links only on space. We do on space, comma, semicolon and Enter.
    if (/MSIE ([^;]*)|Trident.*; rv:([0-9.]+)/.test(navigator.userAgent)) {
        document.execCommand('AutoUrlDetect', false, false);
    }

    var KEY_BACK = 8;

    var KEY_COMMA = 188;

    var KEY_ENTER = 13;

    var KEY_SEMICOLON = 186;

    var KEY_SPACE = 32;

    var DELIMITERS = [KEY_COMMA, KEY_ENTER, KEY_SEMICOLON, KEY_SPACE];

    var REGEX_LAST_WORD = /[^\s]+/mg;

    var REGEX_URL = /(https?\:\/\/|www\.)(-\.)?([^(\s/?\.#-)]+\.?)+(\b\/[^\s]*)?$/i;

    /**
     * CKEditor plugin which automatically generates links when user types text which looks like URL.
     *
     * @class CKEDITOR.plugins.ae_autolink
     * @constructor
     */
    CKEDITOR.plugins.add('ae_autolink', {

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers the `keyup` event on the editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'keyup', this._onKeyUp, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Retrieves the last word introduced by the user. Reads from the current
         * caret position backwards until it finds the first white space.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _getLastWord
         * @protected
         * @return {String} The last word introduced by user
         */
        _getLastWord: function _getLastWord(editor) {
            var range = editor.getSelection().getRanges()[0];

            var offset = range.startOffset;

            var previousText = '';

            // The user pressed Enter, so we have to look on the previous node
            if (this._currentKeyCode === KEY_ENTER) {
                var previousNode = range.startContainer.getPrevious();

                var lastChild;

                if (previousNode) {
                    // If previous node is a SPACE, (it does not have 'getLast' method),
                    // ignore it and find the previous text node
                    while (!previousNode.getLast) {
                        previousNode = previousNode.getPrevious();
                    }

                    lastChild = previousNode.getLast();

                    // Depending on the browser, the last child node may be a <BR>
                    // (which does not have 'getText' method),
                    // so ignore it and find the previous text node
                    while (lastChild && !lastChild.getText()) {
                        lastChild = lastChild.getPrevious();
                    }
                }

                // Check if the lastChild is already a link
                if (!(lastChild && lastChild.$.href)) {
                    this._startContainer = lastChild;
                    previousText = lastChild ? lastChild.getText() : '';
                    this._offset = previousText.length;
                }
            } else {
                this._startContainer = range.startContainer;

                // Last character is the delimiter, ignore it
                previousText = this._startContainer.getText().substring(0, offset - 1);

                this._offset = offset - 1;
            }

            var lastWord = '';

            var match = previousText.match(REGEX_LAST_WORD);

            if (match) {
                lastWord = match.pop();
            }

            return lastWord;
        },

        /**
         * Checks if the given link is a valid URL.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method isValidURL
         * @param {String} link The link we want to know if it is a valid URL
         * @protected
         * @return {Boolean} Returns true if the link is a valid URL, false otherwise
         */
        _isValidURL: function _isValidURL(link) {
            return REGEX_URL.test(link);
        },

        /**
         * Listens to the `keydown` event and if the keycode is `Backspace`, removes the previously
         * created link.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _onKeyDown
         * @param {EventFacade} event EventFacade object
         * @protected
         */
        _onKeyDown: function _onKeyDown(event) {
            var nativeEvent = event.data.$;

            var editor = event.listenerData.editor;

            var editable = editor.editable();

            editable.removeListener('keydown', this._onKeyDown);

            if (nativeEvent.keyCode === KEY_BACK) {
                event.cancel();
                event.data.preventDefault();

                this._removeLink(editor);
            }

            this._ckLink = null;
        },

        /**
         * Listens to the `Enter` and `Space` key events in order to check if the last word
         * introduced by the user should be replaced by a link element.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _onKeyUp
         * @param {EventFacade} event EventFacade object
         * @protected
         */
        _onKeyUp: function _onKeyUp(event) {
            var nativeEvent = event.data.$;

            this._currentKeyCode = nativeEvent.keyCode;

            if (DELIMITERS.indexOf(this._currentKeyCode) !== -1) {
                var editor = event.listenerData.editor;

                var lastWord = this._getLastWord(editor);

                if (this._isValidURL(lastWord)) {
                    this._replaceContentByLink(editor, lastWord);
                }
            }
        },

        /**
         * Replaces content by a link element.
         *
         * @fires CKEDITOR.plugins.ae_autolink#autolinkAdd
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _replaceContentByLink
         * @param {String} content The text that has to be replaced by an link element
         * @protected
         */
        _replaceContentByLink: function _replaceContentByLink(editor, content) {
            var range = editor.createRange();
            var node = CKEDITOR.dom.element.get(this._startContainer);
            var offset = this._offset;

            // Select the content, so CKEDITOR.Link can properly replace it
            range.setStart(node, offset - content.length);
            range.setEnd(node, offset);
            range.select();

            var ckLink = new CKEDITOR.Link(editor);
            ckLink.create(content);
            this._ckLink = ckLink;

            var linkNode = ckLink.getFromSelection();
            editor.fire('autolinkAdd', linkNode);

            this._subscribeToKeyEvent(editor);

            // Now range is on the link and it is selected. We have to
            // return focus to the caret position.
            range = editor.getSelection().getRanges()[0];

            // If user pressed `Enter`, get the next editable node at position 0,
            // otherwise set the cursor at the next character of the link (the white space)
            if (this._currentKeyCode === KEY_ENTER) {
                var nextEditableNode = range.getNextEditableNode();

                range.setStart(nextEditableNode, 0);
                range.setEnd(nextEditableNode, 0);
            } else {
                var nextNode = range.getNextNode();

                range.setStart(nextNode, 1);
                range.setEnd(nextNode, 1);
            }

            range.select();
        },

        /**
         * Fired when a URL is detected in text and converted to a link.
         *
         * @event CKEDITOR.plugins.ae_autolink#autolinkAdd
         * @memberof CKEDITOR.plugins.ae_autolink
         * @param {CKEDITOR.dom.element} el Node of the created link.
         */

        /**
         * Removes the created link element, and replaces it by its text.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _removeLink
         * @protected
         */
        _removeLink: function _removeLink(editor) {
            var range = editor.getSelection().getRanges()[0];
            var caretOffset = range.startOffset;

            // Select the link, so CKEDITOR.Link can properly remove it
            var linkNode = this._startContainer.getNext() || this._startContainer;

            var newRange = editor.createRange();
            newRange.setStart(linkNode, 0);
            newRange.setEndAfter(linkNode);
            newRange.select();

            this._ckLink.remove();

            // Return focus to the caret position
            range.setEnd(range.startContainer, caretOffset);
            range.setStart(range.startContainer, caretOffset);

            range.select();
        },

        /**
         * Subscribe to a key event of the editable aria.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolink
         * @method _subscribeToKeyEvent
         * @protected
         */
        _subscribeToKeyEvent: function _subscribeToKeyEvent(editor) {
            var editable = editor.editable();

            // Change the priority of keydown listener - 1 means the highest priority.
            // In Chrome on pressing `Enter` the listener is not being invoked.
            // See http://dev.ckeditor.com/ticket/11861 for more information.
            editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
                editor: editor
            }, 1);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/autolist.js":
/*!*********************************!*\
  !*** ./src/plugins/autolist.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_autolist')) {
        return;
    }

    var KEY_BACK = 8;

    var KEY_SPACE = 32;

    var DEFAULT_CONFIG = [{
        regex: /^\*$/,
        type: 'bulletedlist'
    }, {
        regex: /^1\.$/,
        type: 'numberedlist'
    }];

    /**
        * CKEditor plugin which automatically generates ordered/unordered list when user types text which looks like a list.
        *
        * @class CKEDITOR.plugins.ae_autolist
        * @constructor
        */
    CKEDITOR.plugins.add('ae_autolist', {

        /**
         * Initialization of the plugin, part of CKeditor plugin lifecycle.
         * The function registers the `keydown` event on the content editing area.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * Checks for pressing the `Backspace` key in order to undo the list creation.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method _checkForBackspaceAndUndo
         * @param {Event} event Event object
         * @protected
         */
        _checkForBackspaceAndUndo: function _checkForBackspaceAndUndo(event) {
            var editor = event.listenerData.editor;

            var nativeEvent = event.data.$;

            var editable = editor.editable();

            editable.removeListener('keydown', this._checkForBackspaceAndUndo);

            if (nativeEvent.keyCode === KEY_BACK) {
                editor.execCommand('undo');
                editor.insertHtml(event.listenerData.bullet + '&nbsp;');
                event.data.preventDefault();
            }
        },

        /**
         * Checks current line to find match with MATCHES object to create OL or UL.
         *
         * @instance
         * @memberof CKEDITOR.plugins.ae_autolist
         * @method _checkLine
         * @param {editor} Editor object
         * @protected
         * @return {Object|null} Returns an object which contains the detected list config if any
         */
        _getListConfig: function _getListConfig(editor) {
            var configRegex = editor.config.autolist || DEFAULT_CONFIG;

            var range = editor.getSelection().getRanges()[0];

            var textContainer = range.endContainer.getText();

            var bullet = textContainer.substring(0, range.startOffset);

            var text = textContainer.substring(range.startOffset, textContainer.length);

            var index = 0;

            var regexLen = configRegex.length;

            var autolistCfg = null;

            while (!autolistCfg && regexLen > index) {
                var regexItem = configRegex[index];

                if (regexItem.regex.test(bullet)) {
                    autolistCfg = {
                        bullet: bullet,
                        editor: editor,
                        text: text,
                        type: regexItem.type
                    };

                    break;
                }

                index++;
            }

            return autolistCfg;
        },

        /**
                  * Create list with different types: Bulleted or Numbered list
                  *
                  * @instance
                  * @memberof CKEDITOR.plugins.ae_autolist
                  * @method _createList
                  * @param {Object} listConfig Object that contains bullet, text and type for creating the list
                  * @protected
         */
        _createList: function _createList(listConfig) {
            var editor = listConfig.editor;

            var range = editor.getSelection().getRanges()[0];

            range.endContainer.setText(listConfig.text);
            editor.execCommand(listConfig.type);

            var editable = editor.editable();

            // Subscribe to keydown in order to check if the next key press is `Backspace`.
            // If so, the creation of the list will be discarded.
            editable.attachListener(editable, 'keydown', this._checkForBackspaceAndUndo, this, {
                editor: editor,
                bullet: listConfig.bullet
            }, 1);
        },

        /**
                  * Listens to the `Space` key events to check if the last word
                  * introduced by the user should be replaced by a list (OL or UL)
                  *
                  * @instance
                  * @memberof CKEDITOR.plugins.ae_autolist
                  * @method _onKeyDown
                  * @param {Event} event Event object
                  * @protected
                  */
        _onKeyDown: function _onKeyDown(event) {
            var nativeEvent = event.data.$;

            if (nativeEvent.keyCode === KEY_SPACE) {
                var listConfig = this._getListConfig(event.listenerData.editor);

                if (listConfig) {
                    event.data.preventDefault();
                    this._createList(listConfig);
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/dragresize.js":
/*!***********************************!*\
  !*** ./src/plugins/dragresize.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Dragable image resizing
 * https://github.com/sstur/ck-dragresize
 * - Shows semi-transparent overlay while resizing
 * - Enforces Aspect Ratio (unless holding shift)
 * - Snap to size of other images in editor
 * - Escape while dragging cancels resize
 */
(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_dragresize')) {
        return;
    }

    var IMAGE_HANDLES = {
        both: ['tl', 'tm', 'tr', 'lm', 'rm', 'bl', 'bm', 'br'],
        height: ['tl', 'tm', 'tr', 'bl', 'bm', 'br'],
        scale: ['tl', 'tr', 'bl', 'br'],
        width: ['tl', 'tr', 'lm', 'rm', 'bl', 'br']
    };

    var POSITION_ELEMENT_FN = {
        bl: function bl(handle, left, top, box) {
            positionElement(handle, -3 + left, box.height - 4 + top);
        },
        bm: function bm(handle, left, top, box) {
            positionElement(handle, Math.round(box.width / 2) - 3 + left, box.height - 4 + top);
        },
        br: function br(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, box.height - 4 + top);
        },
        lm: function lm(handle, left, top, box) {
            positionElement(handle, -3 + left, Math.round(box.height / 2) - 3 + top);
        },
        tl: function tl(handle, left, top, box) {
            positionElement(handle, left - 3, top - 3);
        },
        tm: function tm(handle, left, top, box) {
            positionElement(handle, Math.round(box.width / 2) - 3 + left, -3 + top);
        },
        tr: function tr(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, -3 + top);
        },
        rm: function rm(handle, left, top, box) {
            positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
        }
    };

    var IMAGE_SNAP_TO_SIZE = 7;

    var isFirefox = 'MozAppearance' in document.documentElement.style;

    var isWebKit = 'WebkitAppearance' in document.documentElement.style;

    var enablePlugin = isWebKit || isFirefox;

    if (enablePlugin) {
        // CSS is added in a compressed form
        CKEDITOR.addCss('img::selection{color:rgba(0,0,0,0)}img.ckimgrsz{outline:1px dashed #000}#ckimgrsz{position:absolute;width:0;height:0;cursor:default;z-index:10001}#ckimgrsz span{display:none;position:absolute;top:0;left:0;width:0;height:0;background-size:100% 100%;opacity:.65;outline:1px dashed #000}#ckimgrsz i{position:absolute;display:block;width:5px;height:5px;background:#fff;border:1px solid #000}#ckimgrsz i.active,#ckimgrsz i:hover{background:#000}#ckimgrsz i.br,#ckimgrsz i.tl{cursor:nwse-resize}#ckimgrsz i.bm,#ckimgrsz i.tm{cursor:ns-resize}#ckimgrsz i.bl,#ckimgrsz i.tr{cursor:nesw-resize}#ckimgrsz i.lm,#ckimgrsz i.rm{cursor:ew-resize}body.dragging-br,body.dragging-br *,body.dragging-tl,body.dragging-tl *{cursor:nwse-resize!important}body.dragging-bm,body.dragging-bm *,body.dragging-tm,body.dragging-tm *{cursor:ns-resize!important}body.dragging-bl,body.dragging-bl *,body.dragging-tr,body.dragging-tr *{cursor:nesw-resize!important}body.dragging-lm,body.dragging-lm *,body.dragging-rm,body.dragging-rm *{cursor:ew-resize!important}');
    }

    /**
     * Initializes the plugin
     */
    CKEDITOR.plugins.add('ae_dragresize', {
        onLoad: function onLoad() {
            if (!enablePlugin) {
                return;
            }
        },
        init: function init(editor) {
            if (!enablePlugin) {
                return;
            }

            editor.once('contentDom', function (evt) {
                _init(editor);
            });
        }
    });

    function _init(editor) {
        var window = editor.window.$,
            document = editor.document.$;

        if (isFirefox) {
            // Disable the native image resizing
            document.execCommand('enableObjectResizing', false, false);
        }

        var snapToSize = typeof IMAGE_SNAP_TO_SIZE === 'undefined' ? null : IMAGE_SNAP_TO_SIZE;

        editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

        var resizer = new Resizer(editor, {
            imageScaleResize: editor.config.imageScaleResize,
            snapToSize: snapToSize
        });

        var mouseDownListener = function mouseDownListener(e) {
            if (resizer.isHandle(e.target)) {
                resizer.initDrag(e);
            }
        };

        document.addEventListener('mousedown', mouseDownListener, false);

        function selectionChange() {
            var selection = editor.getSelection();

            if (!selection) return;
            // If an element is selected and that element is an IMG
            if (selection.getType() !== CKEDITOR.SELECTION_NONE && selection.getStartElement().is('img')) {
                // And we're not right or middle clicking on the image
                if (!window.event || !window.event.button || window.event.button === 0) {
                    resizer.show(selection.getStartElement().$);
                }
            } else {
                resizer.hide();
            }
        }

        editor.on('selectionChange', selectionChange);

        editor.on('getData', function (e) {
            var html = e.data.dataValue || '';
            html = html.replace(/<div id="ckimgrsz"([\s\S]*?)<\/div>/i, '');
            html = html.replace(/\b(ckimgrsz)\b/g, '');
            e.data.dataValue = html;
        });

        editor.on('beforeUndoImage', function () {
            // Remove the handles before undo images are saved
            resizer.hide();
        });

        editor.on('afterUndoImage', function () {
            // Restore the handles after undo images are saved
            selectionChange();
        });

        editor.on('blur', function () {
            // Remove the handles when editor loses focus
            resizer.hide();
        });

        editor.on('beforeModeUnload', function self() {
            editor.removeListener('beforeModeUnload', self);
            resizer.hide();
        });

        editor.on('destroy', function () {
            var resizeElement = document.getElementById('ckimgrsz');

            if (resizeElement) {
                resizeElement.remove();
            }

            if (isFirefox) {
                document.execCommand('enableObjectResizing', false, true);
            }

            document.removeEventListener('mousedown', mouseDownListener);
        });

        // Update the selection when the browser window is resized
        var resizeTimeout;
        editor.window.on('resize', function () {
            // Cancel any resize waiting to happen
            clearTimeout(resizeTimeout);
            // Delay resize to "debounce"
            resizeTimeout = setTimeout(selectionChange, 50);
        });
    }

    function Resizer(editor, cfg) {
        this.editor = editor;
        this.window = editor.window.$;
        this.document = editor.document.$;
        this.cfg = cfg || {};
        this.init();
    }

    Resizer.prototype = {
        init: function init() {
            var instance = this;

            var container = this.container = this.document.createElement('div');

            container.id = 'ckimgrsz';
            this.preview = this.document.createElement('span');
            container.appendChild(this.preview);

            var handles = this.handles = {};

            IMAGE_HANDLES[this.cfg.imageScaleResize].forEach(function (handleName, index) {
                handles[handleName] = instance.handles[handleName] = instance.createHandle(handleName);
            });

            for (var n in handles) {
                container.appendChild(handles[n]);
            }
        },
        createHandle: function createHandle(name) {
            var el = this.document.createElement('i');
            el.classList.add(name);
            return el;
        },
        isHandle: function isHandle(el) {
            var handles = this.handles;
            for (var n in handles) {
                if (handles[n] === el) {
                    return true;
                }
            }
            return false;
        },
        show: function show(el) {
            this.el = el;
            if (this.cfg.snapToSize) {
                this.otherImages = toArray(this.document.getElementsByTagName('img'));
                this.otherImages.splice(this.otherImages.indexOf(el), 1);
            }
            var box = this.box = getBoundingBox(this.window, el);
            positionElement(this.container, box.left, box.top);
            this.document.body.appendChild(this.container);
            this.el.classList.add('ckimgrsz');
            this.showHandles();
        },
        hide: function hide() {
            // Remove class from all img.ckimgrsz
            var elements = this.document.getElementsByClassName('ckimgrsz');
            for (var i = 0; i < elements.length; ++i) {
                elements[i].classList.remove('ckimgrsz');
            }
            this.hideHandles();
            if (this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
            }
        },
        initDrag: function initDrag(e) {
            if (e.button !== 0) {
                //right-click or middle-click
                return;
            }
            var resizer = this;
            var drag = new DragEvent(this.window, this.document);
            drag.onStart = function () {
                resizer.showPreview();
                resizer.isDragging = true;
                resizer.editor.getSelection().lock();
            };
            drag.onDrag = function () {
                resizer.calculateSize(this);
                resizer.updatePreview();
                var box = resizer.previewBox;
                resizer.updateHandles(box, box.left, box.top);
            };
            drag.onRelease = function () {
                resizer.isDragging = false;
                resizer.hidePreview();
                resizer.hide();
                resizer.editor.getSelection().unlock();
                // Save an undo snapshot before the image is permanently changed
                resizer.editor.fire('saveSnapshot');
            };
            drag.onComplete = function () {
                resizer.resizeComplete();
                // Save another snapshot after the image is changed
                resizer.editor.fire('saveSnapshot');
            };
            drag.start(e);
        },
        updateHandles: function updateHandles(box, left, top) {
            left = left || 0;
            top = top || 0;
            var handles = this.handles;

            for (var handle in handles) {
                POSITION_ELEMENT_FN[handle](handles[handle], left, top, box);
            }
        },
        showHandles: function showHandles() {
            var handles = this.handles;
            this.updateHandles(this.box);
            for (var n in handles) {
                handles[n].style.display = 'block';
            }
        },
        hideHandles: function hideHandles() {
            var handles = this.handles;
            for (var n in handles) {
                handles[n].style.display = 'none';
            }
        },
        showPreview: function showPreview() {
            this.preview.style.backgroundImage = 'url("' + this.el.src + '")';
            this.calculateSize();
            this.updatePreview();
            this.preview.style.display = 'block';
        },
        updatePreview: function updatePreview() {
            var box = this.previewBox;
            positionElement(this.preview, box.left, box.top);
            this.preview.style.width = this.previewBox.width + 'px';
            this.preview.style.height = this.previewBox.height + 'px';
        },
        hidePreview: function hidePreview() {
            var box = getBoundingBox(this.window, this.preview);
            this.result = {
                width: box.width,
                height: box.height
            };
            this.preview.style.display = 'none';
        },
        calculateSize: function calculateSize(data) {
            var box = this.previewBox = {
                top: 0,
                left: 0,
                width: this.box.width,
                height: this.box.height
            };

            if (!data) return;

            var attr = data.target.className;

            if (~attr.indexOf('r')) {
                box.width = Math.max(32, this.box.width + data.delta.x);
            }
            if (~attr.indexOf('b')) {
                box.height = Math.max(32, this.box.height + data.delta.y);
            }
            if (~attr.indexOf('l')) {
                box.width = Math.max(32, this.box.width - data.delta.x);
            }
            if (~attr.indexOf('t')) {
                box.height = Math.max(32, this.box.height - data.delta.y);
            }
            //if dragging corner, enforce aspect ratio (unless shift key is being held)
            if (attr.indexOf('m') < 0 && !data.keys.shift) {
                var ratio = this.box.width / this.box.height;
                if (box.width / box.height > ratio) {
                    box.height = Math.round(box.width / ratio);
                } else {
                    box.width = Math.round(box.height * ratio);
                }
            }

            var snapToSize = this.cfg.snapToSize;

            if (snapToSize) {
                var others = this.otherImages;
                for (var i = 0; i < others.length; i++) {
                    var other = getBoundingBox(this.window, others[i]);
                    if (Math.abs(box.width - other.width) <= snapToSize && Math.abs(box.height - other.height) <= snapToSize) {
                        box.width = other.width;
                        box.height = other.height;
                        break;
                    }
                }
            }

            //recalculate left or top position
            if (~attr.indexOf('l')) {
                box.left = this.box.width - box.width;
            }
            if (~attr.indexOf('t')) {
                box.top = this.box.height - box.height;
            }
        },
        resizeComplete: function resizeComplete() {
            resizeElement.call(this, this.el, this.result.width, this.result.height);
        }
    };

    function DragEvent(window, document) {
        this.window = window;
        this.document = document;
        this.events = {
            mousemove: bind(this.mousemove, this),
            keydown: bind(this.keydown, this),
            mouseup: bind(this.mouseup, this)
        };
    }

    DragEvent.prototype = {
        start: function start(e) {
            e.preventDefault();
            e.stopPropagation();
            this.target = e.target;
            this.attr = e.target.className;
            this.startPos = {
                x: e.clientX,
                y: e.clientY
            };
            this.update(e);
            var events = this.events;
            this.document.addEventListener('mousemove', events.mousemove, false);
            this.document.addEventListener('keydown', events.keydown, false);
            this.document.addEventListener('mouseup', events.mouseup, false);
            this.document.body.classList.add('dragging-' + this.attr);
            this.onStart && this.onStart();
        },
        update: function update(e) {
            this.currentPos = {
                x: e.clientX,
                y: e.clientY
            };
            this.delta = {
                x: e.clientX - this.startPos.x,
                y: e.clientY - this.startPos.y
            };
            this.keys = {
                shift: e.shiftKey,
                ctrl: e.ctrlKey,
                alt: e.altKey
            };
        },
        mousemove: function mousemove(e) {
            this.update(e);
            this.onDrag && this.onDrag();
            if (e.which === 0) {
                //mouse button released outside window; mouseup wasn't fired (Chrome)
                this.mouseup(e);
            }
        },
        keydown: function keydown(e) {
            //escape key cancels dragging
            if (e.keyCode === 27) {
                this.release();
            }
        },
        mouseup: function mouseup(e) {
            this.update(e);
            this.release();
            this.onComplete && this.onComplete();
        },
        release: function release() {
            this.document.body.classList.remove('dragging-' + this.attr);
            var events = this.events;
            this.document.removeEventListener('mousemove', events.mousemove, false);
            this.document.removeEventListener('keydown', events.keydown, false);
            this.document.removeEventListener('mouseup', events.mouseup, false);
            this.onRelease && this.onRelease();
        }
    };

    //helper functions
    function toArray(obj) {
        var len = obj.length,
            arr = new Array(len);
        for (var i = 0; i < len; i++) {
            arr[i] = obj[i];
        }
        return arr;
    }

    function bind(fn, ctx) {
        if (fn.bind) {
            return fn.bind(ctx);
        }
        return function () {
            fn.apply(ctx, arguments);
        };
    }

    function positionElement(el, left, top) {
        el.style.left = String(left) + 'px';
        el.style.top = String(top) + 'px';
    }

    function resizeElement(el, width, height) {
        var imageScaleResize = this.editor.config.imageScaleResize;
        if (imageScaleResize === 'both') {
            el.style.width = String(width) + 'px';
            el.style.height = String(height) + 'px';
        } else if (imageScaleResize === 'width' || imageScaleResize === 'scale') {
            el.style.height = 'auto';
            el.style.width = String(width) + 'px';
        } else if (imageScaleResize === 'height') {
            el.style.height = String(height) + 'px';
            el.style.width = 'auto';
        }
    }

    function getBoundingBox(window, el) {
        var rect = el.getBoundingClientRect();
        return {
            left: rect.left + window.pageXOffset,
            top: rect.top + window.pageYOffset,
            width: rect.width,
            height: rect.height
        };
    }
})();

/***/ }),

/***/ "./src/plugins/dragresize_ie.js":
/*!**************************************!*\
  !*** ./src/plugins/dragresize_ie.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Image2
 * - Show gripper to resize images on IE
 */
(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_dragresize_ie')) {
        return;
    }

    var alignmentsObj = {
        center: 1,
        left: 0,
        right: 2
    };

    /*
     * Set cursor css depend on imageScaleResize config
     **/

    var cursor = {
        both: 'nwse-resize',
        height: 'ns-resize',
        scale: 'nwse-resize',
        width: 'ew-resize'
    };

    var regexPercent = /^\s*(\d+\%)\s*$/i;

    var template = '<img alt="" src="" />';

    CKEDITOR.plugins.add('ae_dragresize_ie', {
        hidpi: true,

        icons: 'image',

        init: function init(editor) {
            var image = widgetDef(editor);

            // Register the widget.
            editor.widgets.add('image', image);
        },

        onLoad: function onLoad() {
            CKEDITOR.addCss('.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ns-resize{' + 'cursor: ns-resize;' + '}' + '.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ew-resize{' + 'cursor: ew-resize;' + '}' + '.cke_image_nocaption{' +
            // This is to remove unwanted space so resize
            // wrapper is displayed property.
            'line-height:0' + '}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'bottom:-5px;' + 'right:-5px;' + 'background:#000;' + 'outline:1px solid #fff;' +
            // Prevent drag handler from being misplaced (#11207).
            'line-height:0;' + 'cursor:nwse-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizer.cke_image_resizing{' + 'display:block' + '}');
        },

        requires: 'widget'
    });

    // Wiget states (forms) depending on alignment and configuration.
    //
    // Non-captioned widget (inline styles)
    // 		┌──────┬───────────────────────────────┬─────────────────────────────┐
    // 		│Align │Internal form                  │Data                         │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│none  │<wrapper>                      │<img />                      │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│left  │<wrapper style=”float:left”>   │<img style=”float:left” />   │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│center│<wrapper>                      │<p style=”text-align:center”>│
    // 		│      │ <p style=”text-align:center”> │  <img />                    │
    // 		│      │   <img />                     │</p>                         │
    // 		│      │ </p>                          │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│right │<wrapper style=”float:right”>  │<img style=”float:right” />  │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		└──────┴───────────────────────────────┴─────────────────────────────┘
    //
    // Non-captioned widget (config.image2_alignClasses defined)
    // 		┌──────┬───────────────────────────────┬─────────────────────────────┐
    // 		│Align │Internal form                  │Data                         │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│none  │<wrapper>                      │<img />                      │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│left  │<wrapper class=”left”>         │<img class=”left” />         │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│center│<wrapper>                      │<p class=”center”>           │
    // 		│      │ <p class=”center”>            │ <img />                     │
    // 		│      │   <img />                     │</p>                         │
    // 		│      │ </p>                          │                             │
    // 		│      │</wrapper>                     │                             │
    // 		├──────┼───────────────────────────────┼─────────────────────────────┤
    // 		│right │<wrapper class=”right”>        │<img class=”right” />        │
    // 		│      │ <img />                       │                             │
    // 		│      │</wrapper>                     │                             │
    // 		└──────┴───────────────────────────────┴─────────────────────────────┘
    //
    // Captioned widget (inline styles)
    // 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
    // 		│Align │Internal form                           │Data                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│none  │<wrapper>                               │<figure />                              │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│left  │<wrapper style=”float:left”>            │<figure style=”float:left” />           │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│center│<wrapper style=”text-align:center”>     │<div style=”text-align:center”>         │
    // 		│      │ <figure style=”display:inline-block” />│ <figure style=”display:inline-block” />│
    // 		│      │</wrapper>                              │</p>                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│right │<wrapper style=”float:right”>           │<figure style=”float:right” />          │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
    //
    // Captioned widget (config.image2_alignClasses defined)
    // 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
    // 		│Align │Internal form                           │Data                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│none  │<wrapper>                               │<figure />                              │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│left  │<wrapper class=”left”>                  │<figure class=”left” />                 │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│center│<wrapper class=”center”>                │<div class=”center”>                    │
    // 		│      │ <figure />                             │ <figure />                             │
    // 		│      │</wrapper>                              │</p>                                    │
    // 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
    // 		│right │<wrapper class=”right”>                 │<figure class=”right” />                │
    // 		│      │ <figure />                             │                                        │
    // 		│      │</wrapper>                              │                                        │
    // 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function widgetDef(editor) {
        editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

        editor.on('imageAdd', function (imageData) {
            editor.widgets.initOn(imageData.data.el, 'image');
        });

        var alignClasses = editor.config.image2_alignClasses;

        var captionedClass = editor.config.image2_captionedClass;

        return {
            init: function init() {
                var helpers = CKEDITOR.plugins.image2;

                var image = this.parts.image;

                var data = {
                    alt: image.getAttribute('alt') || '',
                    hasCaption: !!this.parts.caption,
                    height: image.getAttribute('height') || '',
                    // Lock ratio is on by default (#10833).
                    lock: this.ready ? helpers.checkHasNaturalRatio(image) : true,
                    src: image.getAttribute('src'),
                    width: image.getAttribute('width') || ''
                };

                // If we used 'a' in widget#parts definition, it could happen that
                // selected element is a child of widget.parts#caption. Since there's no clever
                // way to solve it with CSS selectors, it's done like that. (#11783).
                var link = image.getAscendant('a');

                if (link && this.wrapper.contains(link)) {
                    this.parts.link = link;
                }

                // Depending on configuration, read style/class from element and
                // then remove it. Removed style/class will be set on wrapper in #data listener.
                // Note: Center alignment is detected during upcast, so only left/right cases
                // are checked below.
                if (!data.align) {
                    var alignElement = data.hasCaption ? this.element : image;

                    // Read the initial left/right alignment from the class set on element.
                    if (alignClasses) {
                        if (alignElement.hasClass(alignClasses[0])) {
                            data.align = 'left';
                        } else if (alignElement.hasClass(alignClasses[2])) {
                            data.align = 'right';
                        }

                        if (data.align) {
                            alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
                        } else {
                            data.align = 'none';
                        }
                    }
                    // Read initial float style from figure/image and then remove it.
                    else {
                            data.align = alignElement.getStyle('float') || 'none';
                            alignElement.removeStyle('float');
                        }
                }

                // Get rid of extra vertical space when there's no caption.
                // It will improve the look of the resizer.
                this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

                this.setData(data);

                if (editor.config.image2_disableResizer !== true) {
                    setupResizer(this);
                }
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#addClass
            addClass: function addClass(className) {
                getStyleableElement(this).addClass(className);
            },

            allowedContent: getWidgetAllowedContent(editor),

            // This widget converts style-driven dimensions to attributes.
            contentTransformations: [['img[width]: sizeToAttribute']],

            data: function data() {
                var features = this.features;

                // Image can't be captioned when figcaption is disallowed (#11004).
                if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) {
                    this.data.hasCaption = false;
                }

                // Image can't be aligned when floating is disallowed (#11004).
                if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) {
                    this.data.align = 'none';
                }

                // Update widget.parts.link since it will not auto-update unless widget
                // is destroyed and re-inited.
                if (!this.data.link) {
                    if (this.parts.link) {
                        delete this.parts.link;
                    }
                } else {
                    if (!this.parts.link) {
                        this.parts.link = this.parts.image.getParent();
                    }
                }

                this.parts.image.setAttributes({
                    alt: this.data.alt,

                    contenteditable: this.parts.image.getAttribute('contenteditable') ? this.parts.image.getAttribute('contenteditable') : true,

                    // This internal is required by the editor.
                    'data-cke-saved-src': this.data.src,

                    src: this.data.src
                });

                // If shifting non-captioned -> captioned, remove classes
                // related to styles from <img/>.
                if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
                    for (var c in this.data.classes) {
                        this.parts.image.removeClass(c);
                    }
                }

                // Set dimensions of the image according to gathered data.
                // Do it only when the attributes are allowed (#11004).
                if (editor.filter.checkFeature(features.dimension)) {
                    setDimensions(this);
                }

                // Cache current data.
                this.oldData = CKEDITOR.tools.extend({}, this.data);
            },

            downcast: downcastWidgetElement(editor),

            draggable: false,

            // This widget has an editable caption.
            editables: {
                caption: {
                    selector: 'figcaption',
                    allowedContent: 'br em strong sub sup u s; a[!href,target]'
                }
            },

            features: getWidgetFeatures(editor),

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#getClasses
            getClasses: function () {
                var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

                return function () {
                    var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

                    // Neither config.image2_captionedClass nor config.image2_alignClasses
                    // do not belong to style classes.
                    for (var c in classes) {
                        if (classRegex.test(c)) {
                            delete classes[c];
                        }
                    }

                    return classes;
                };
            }(),

            getLabel: function getLabel() {
                var label = (this.data.alt || '') + ' ' + this.pathName;

                return label;
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#hasClass
            hasClass: function hasClass(className) {
                return getStyleableElement(this).hasClass(className);
            },

            parts: {
                caption: 'figcaption',
                image: 'img'
            },

            // Overrides default method to handle internal mutability of Image2.
            // @see CKEDITOR.plugins.widget#removeClass
            removeClass: function removeClass(className) {
                getStyleableElement(this).removeClass(className);
            },

            requiredContent: 'img[src,alt]',

            styleableElements: 'img figure',

            // Template of the widget: plain image.
            template: template,

            upcast: upcastWidgetElement(editor)
        };
    }

    /**
     * A set of Enhanced Image (image2) plugin helpers.
     *
     * @class
     * @singleton
     */
    CKEDITOR.plugins.image2 = {
        /**
         * Checks whether the current image ratio matches the natural one
         * by comparing dimensions.
         *
         * @param {CKEDITOR.dom.element} image
         * @returns {Boolean}
         */
        checkHasNaturalRatio: function checkHasNaturalRatio(image) {
            var $ = image.$,
                natural = this.getNatural(image);

            // The reason for two alternative comparisons is that the rounding can come from
            // both dimensions, e.g. there are two cases:
            // 	1. height is computed as a rounded relation of the real height and the value of width,
            //	2. width is computed as a rounded relation of the real width and the value of heigh.
            return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
        },

        /**
         * Returns natural dimensions of the image. For modern browsers
         * it uses natural(Width|Height). For old ones (IE8) it creates
         * a new image and reads the dimensions.
         *
         * @param {CKEDITOR.dom.element} image
         * @returns {Object}
         */
        getNatural: function getNatural(image) {
            var dimensions;

            if (image.$.naturalWidth) {
                dimensions = {
                    height: image.$.naturalHeigh,
                    width: image.$.naturalWidth
                };
            } else {
                var img = new Image();

                img.src = image.getAttribute('src');

                dimensions = {
                    height: img.heigh,
                    width: img.width
                };
            }

            return dimensions;
        }
    };

    // Returns a function that creates widgets from all <img> and
    // <figure class="{config.image2_captionedClass}"> elements.
    //
    // @param {CKEDITOR.editor} editor
    // @returns {Function}
    function upcastWidgetElement(editor) {
        var isCenterWrapper = centerWrapperChecker(editor);

        var captionedClass = editor.config.image2_captionedClass;

        // @param {CKEDITOR.htmlParser.element} el
        // @param {Object} data
        return function (el, data) {
            var dimensions = {
                height: 1,
                width: 1
            };

            var name = el.name;

            var image;

            // #11110 Don't initialize on pasted fake objects.
            if (el.attributes['data-cke-realelement']) {
                return;
            }

            // If a center wrapper is found, there are 3 possible cases:
            //
            // 1. <div style="text-align:center"><figure>...</figure></div>.
            //    In this case centering is done with a class set on widget.wrapper.
            //    Simply replace centering wrapper with figure (it's no longer necessary).
            //
            // 2. <p style="text-align:center"><img/></p>.
            //    Nothing to do here: <p> remains for styling purposes.
            //
            // 3. <div style="text-align:center"><img/></div>.
            //    Nothing to do here (2.) but that case is only possible in enterMode different
            //    than ENTER_P.
            if (isCenterWrapper(el)) {
                if (name == 'div') {
                    var figure = el.getFirst('figure');

                    // Case #1.
                    if (figure) {
                        el.replaceWith(figure);
                        el = figure;
                    }
                }
                // Cases #2 and #3 (handled transparently)

                // If there's a centering wrapper, save it in data.
                data.align = 'center';

                // Image can be wrapped in link <a><img/></a>.
                image = el.getFirst('img') || el.getFirst('a').getFirst('img');
            }

            // No center wrapper has been found.
            else if (name == 'figure' && el.hasClass(captionedClass)) {
                    image = el.getFirst('img') || el.getFirst('a').getFirst('img');

                    // Upcast linked image like <a><img/></a>.
                } else if (isLinkedOrStandaloneImage(el)) {
                    image = el.name == 'a' ? el.children[0] : el;
                }

            if (!image) {
                return;
            }

            // If there's an image, then cool, we got a widget.
            // Now just remove dimension attributes expressed with %.
            for (var d in dimensions) {
                var dimension = image.attributes[d];

                if (dimension && dimension.match(regexPercent)) {
                    delete image.attributes[d];
                }
            }

            return el;
        };
    }

    // Returns a function which transforms the widget to the external format
    // according to the current configuration.
    //
    // @param {CKEDITOR.editor}
    function downcastWidgetElement(editor) {
        var alignClasses = editor.config.image2_alignClasses;

        // @param {CKEDITOR.htmlParser.element} el
        return function (el) {
            // In case of <a><img/></a>, <img/> is the element to hold
            // inline styles or classes (image2_alignClasses).
            var attrsHolder = el.name == 'a' ? el.getFirst() : el;

            var attrs = attrsHolder.attributes;

            var align = this.data.align;

            // De-wrap the image from resize handle wrapper.
            // Only block widgets have one.
            if (!this.inline) {
                var resizeWrapper = el.getFirst('span');

                if (resizeWrapper) {
                    resizeWrapper.replaceWith(resizeWrapper.getFirst({
                        a: 1,
                        img: 1
                    }));
                }
            }

            if (align && align != 'none') {
                var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

                // When the widget is captioned (<figure>) and internally centering is done
                // with widget's wrapper style/class, in the external data representation,
                // <figure> must be wrapped with an element holding an style/class:
                //
                // 	<div style="text-align:center">
                // 		<figure class="image" style="display:inline-block">...</figure>
                // 	</div>
                // or
                // 	<div class="some-center-class">
                // 		<figure class="image">...</figure>
                // 	</div>
                //
                if (align == 'center' && el.name == 'figure') {
                    el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? {
                        'class': alignClasses[1]
                    } : {
                        style: 'text-align:center'
                    }));
                }

                // If left/right, add float style to the downcasted element.
                else if (align in {
                        left: 1,
                        right: 1
                    }) {
                        if (alignClasses) {
                            attrsHolder.addClass(alignClasses[alignmentsObj[align]]);
                        } else {
                            styles['float'] = align;
                        }
                    }

                // Update element styles.
                if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) {
                    attrs.style = CKEDITOR.tools.writeCssText(styles);
                }
            }

            return el;
        };
    }

    // Returns a function that checks if an element is a centering wrapper.
    //
    // @param {CKEDITOR.editor} editor
    // @returns {Function}
    function centerWrapperChecker(editor) {
        var captionedClass = editor.config.image2_captionedClass;

        var alignClasses = editor.config.image2_alignClasses;

        var validChildren = {
            a: 1,
            figure: 1,
            img: 1
        };

        return function (el) {
            // Wrapper must be either <div> or <p>.
            if (!(el.name in {
                div: 1,
                p: 1
            })) {
                return false;
            }

            var children = el.children;

            // Centering wrapper can have only one child.
            if (children.length !== 1) {
                return false;
            }

            var child = children[0];

            // Only <figure> or <img /> can be first (only) child of centering wrapper,
            // regardless of its type.
            if (!(child.name in validChildren)) {
                return false;
            }

            // If centering wrapper is <p>, only <img /> can be the child.
            //   <p style="text-align:center"><img /></p>
            if (el.name == 'p') {
                if (!isLinkedOrStandaloneImage(child)) {
                    return false;
                }
            }
            // Centering <div> can hold <img/> or <figure>, depending on enterMode.
            else {
                    // If a <figure> is the first (only) child, it must have a class.
                    //   <div style="text-align:center"><figure>...</figure><div>
                    if (child.name == 'figure') {
                        if (!child.hasClass(captionedClass)) {
                            return false;
                        }
                    } else {
                        // Centering <div> can hold <img/> or <a><img/></a> only when enterMode
                        // is ENTER_(BR|DIV).
                        //   <div style="text-align:center"><img /></div>
                        //   <div style="text-align:center"><a><img /></a></div>
                        if (editor.enterMode == CKEDITOR.ENTER_P) {
                            return false;
                        }

                        // Regardless of enterMode, a child which is not <figure> must be
                        // either <img/> or <a><img/></a>.
                        if (!isLinkedOrStandaloneImage(child)) {
                            return false;
                        }
                    }
                }

            // Centering wrapper got to be... centering. If image2_alignClasses are defined,
            // check for centering class. Otherwise, check the style.
            if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') {
                return true;
            }

            return false;
        };
    }

    // Checks whether element is <img/> or <a><img/></a>.
    //
    // @param {CKEDITOR.htmlParser.element}
    function isLinkedOrStandaloneImage(el) {
        if (el.name == 'img') {
            return true;
        } else if (el.name == 'a') {
            return el.children.length == 1 && el.getFirst('img');
        }

        return false;
    }

    // Sets width and height of the widget image according to current widget data.
    //
    // @param {CKEDITOR.plugins.widget} widget
    function setDimensions(widget) {
        var data = widget.data;

        var dimensions = {
            height: data.height,
            width: data.width
        };

        var image = widget.parts.image;

        for (var d in dimensions) {
            if (dimensions[d]) {
                image.setAttribute(d, dimensions[d]);
            } else {
                image.removeAttribute(d);
            }
        }
    }

    // Defines all features related to drag-driven image resizing.
    //
    // @param {CKEDITOR.plugins.widget} widget
    function setupResizer(widget) {
        var editor = widget.editor;

        var editable = editor.editable();

        var doc = editor.document;

        // Store the resizer in a widget for testing (#11004).
        var resizer = widget.resizer = doc.createElement('span');

        resizer.addClass('cke_image_resizer');
        resizer.addClass('cke_image_resizer_' + cursor[editor.config.imageScaleResize]);
        resizer.append(new CKEDITOR.dom.text('\u200B', doc));

        // Inline widgets don't need a resizer wrapper as an image spans the entire widget.
        if (!widget.inline) {
            var imageOrLink = widget.parts.link || widget.parts.image;

            var oldResizeWrapper = imageOrLink.getParent();

            var resizeWrapper = doc.createElement('span');

            resizeWrapper.addClass('cke_image_resizer_wrapper');
            resizeWrapper.append(imageOrLink);
            resizeWrapper.append(resizer);
            widget.element.append(resizeWrapper, true);

            // Remove the old wrapper which could came from e.g. pasted HTML
            // and which could be corrupted (e.g. resizer span has been lost).
            if (oldResizeWrapper.is('span')) {
                oldResizeWrapper.remove();
            }
        } else {
            widget.wrapper.append(resizer);
        }

        // Calculate values of size variables and mouse offsets.
        resizer.on('mousedown', function (evt) {
            var image = widget.parts.image;

            // "factor" can be either 1 or -1. I.e.: For right-aligned images, we need to
            // subtract the difference to get proper width, etc. Without "factor",
            // resizer starts working the opposite way.
            var factor = widget.data.align == 'right' ? -1 : 1;

            // The x-coordinate of the mouse relative to the screen
            // when button gets pressed.
            var startX = evt.data.$.screenX;

            var startY = evt.data.$.screenY;

            // The initial dimensions and aspect ratio of the image.
            var startWidth = image.$.clientWidth;

            var startHeight = image.$.clientHeight;

            var listeners = [];

            // A class applied to editable during resizing.
            var cursorClass = 'cke_image_s' + (!~factor ? 'w' : 'e');

            var nativeEvt, newWidth, newHeight, updateData;

            var moveDiffX, moveDiffY, moveRatio;

            // Save the undo snapshot first: before resizing.
            editor.fire('saveSnapshot');

            // Mousemove listeners are removed on mouseup.
            attachToDocuments('mousemove', onMouseMove, listeners);

            // Clean up the mousemove listener. Update widget data if valid.
            attachToDocuments('mouseup', onMouseUp, listeners);

            // The entire editable will have the special cursor while resizing goes on.
            editable.addClass(cursorClass);

            // This is to always keep the resizer element visible while resizing.
            resizer.addClass('cke_image_resizing');

            // Attaches an event to a global document if inline editor.
            // Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.
            function attachToDocuments(name, callback, collection) {
                var globalDoc = CKEDITOR.document;

                var listeners = [];

                if (!doc.equals(globalDoc)) {
                    listeners.push(globalDoc.on(name, callback));
                }

                listeners.push(doc.on(name, callback));

                if (collection) {
                    for (var i = listeners.length; i--;) {
                        collection.push(listeners.pop());
                    }
                }
            }

            // This is how variables refer to the geometry.
            // Note: x corresponds to moveOffset, this is the position of mouse
            // Note: o corresponds to [startX, startY].
            //
            // 	+--------------+--------------+
            // 	|              |              |
            // 	|      I       |      II      |
            // 	|              |              |
            // 	+------------- o -------------+ _ _ _
            // 	|              |              |      ^

            // 	|      VI      |     III      |      | moveDiffY
            // 	|              |         x _ _ _ _ _ v
            // 	+--------------+---------|----+
            // 	               |         |
            // 	                <------->
            // 	                moveDiffX
            function onMouseMove(evt) {
                var imageScaleResize = editor.config.imageScaleResize;

                nativeEvt = evt.data.$;

                // This is how far the mouse is from the point the button was pressed.
                moveDiffX = nativeEvt.screenX - startX;
                moveDiffY = startY - nativeEvt.screenY;

                // This is the aspect ratio of the move difference.
                moveRatio = Math.abs(moveDiffX / moveDiffY);

                if (imageScaleResize === 'width' || imageScaleResize === 'both' || imageScaleResize === 'scale') {
                    newWidth = startWidth + factor * moveDiffX;
                }

                if (imageScaleResize === 'height' || imageScaleResize === 'both') {
                    newHeight = startHeight - moveDiffY;
                }

                if (imageScaleResize === 'scale') {
                    newHeight = 'auto';
                }

                newWidth = newWidth || startWidth;
                newHeight = newHeight || startHeight;

                // Don't update attributes if less than 10.
                // This is to prevent images to visually disappear.
                if (newWidth >= 15 && (newHeight >= 15 || newHeight === 'auto')) {
                    image.setAttributes({
                        width: newWidth,
                        height: newHeight
                    });
                    updateData = true;
                } else {
                    updateData = false;
                }
            }

            function onMouseUp() {
                var l;

                while (l = listeners.pop()) {
                    l.removeListener();
                }

                // Restore default cursor by removing special class.
                editable.removeClass(cursorClass);

                // This is to bring back the regular behaviour of the resizer.
                resizer.removeClass('cke_image_resizing');

                if (updateData) {
                    widget.setData({
                        height: newHeight,
                        width: newWidth
                    });

                    // Save another undo snapshot: after resizing.
                    editor.fire('saveSnapshot');
                }

                // Don't update data twice or more.
                updateData = false;
            }
        });

        // Change the position of the widget resizer when data changes.
        widget.on('data', function () {
            resizer[widget.data.align == 'right' ? 'addClass' : 'removeClass']('cke_image_resizer_left');
        });

        widget.parts.image.on('click', function () {

            editor._.editable.editor.getSelection().selectElement(this);

            var selectionData = editor._.editable.editor.getSelectionData();
            if (selectionData) {
                editor.fire('editorInteraction', {
                    nativeEvent: event,
                    selectionData: selectionData
                });
            }
        });
    }

    // Returns a set of widget allowedContent rules, depending
    // on configurations like config#image2_alignClasses or
    // config#image2_captionedClass.
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function getWidgetAllowedContent(editor) {
        var rules = {
            figcaption: true,
            figure: {
                classes: '!' + editor.config.image2_captionedClass
            },
            img: {
                attributes: '!src,alt,width,height'
            }
        };

        return rules;
    }

    // Returns a set of widget feature rules, depending
    // on editor configuration. Note that the following may not cover
    // all the possible cases since requiredContent supports a single
    // tag only.
    //
    // @param {CKEDITOR.editor}
    // @returns {Object}
    function getWidgetFeatures(editor) {
        var alignClasses = editor.config.image2_alignClasses;

        var features = {
            align: {
                requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
            },
            caption: {
                requiredContent: 'figcaption'
            },
            dimension: {
                requiredContent: 'img[width,height]'
            }
        };

        return features;
    }

    // Returns element which is styled, considering current
    // state of the widget.
    //
    // @see CKEDITOR.plugins.widget#applyStyle
    // @param {CKEDITOR.plugins.widget} widget
    // @returns {CKEDITOR.dom.element}
    function getStyleableElement(widget) {
        return widget.data.hasCaption ? widget.element : widget.parts.image;
    }
})();

CKEDITOR.config.image2_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/embed.js":
/*!******************************!*\
  !*** ./src/plugins/embed.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    /* istanbul ignore if */

    if (CKEDITOR.plugins.get('ae_embed')) {
        return;
    }

    var REGEX_HTTP = /^https?/;

    var REGEX_DEFAULT_LINK = /<a href=/;

    var PROVIDERS = ['youtube', 'twitter'];

    CKEDITOR.DEFAULT_AE_EMBED_URL_TPL = 'http://alloy.iframe.ly/api/oembed?url={url}&callback={callback}';
    CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL = '<div data-ae-embed-url="{url}"></div>';
    CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL = '<a href="{url}">{url}</a>';
    /**
     * CKEditor plugin which adds the infrastructure to embed urls as media objects using an oembed
     * service. By default, and for demoing purposes only, the oembed service is hosted in iframe.ly
     * at //alloy.iframe.ly/api/oembed?url={url}&callback={callback}. Note this should be changed to
     * a self-hosted or paid service in production environments. Access to the alloy.iframe.ly endpoint
     * may be restricted per domain due to significant traffic.
     *
     * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
     * to an embedded content.
     *
     * @class CKEDITOR.plugins.ae_embed
     */
    CKEDITOR.plugins.add('ae_embed', {
        requires: 'widget',
        init: function init(editor) {
            var AE_EMBED_URL_TPL = new CKEDITOR.template(editor.config.embedUrlTemplate || CKEDITOR.DEFAULT_AE_EMBED_URL_TPL);
            var AE_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL);
            var AE_EMBED_DEFAULT_LINK_TPL = new CKEDITOR.template(editor.config.embedLinkDefaultTpl || CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL);

            // Default function to upcast DOM elements to embed widgets.
            // It matches CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL
            var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
                if (element.name === 'div' && element.attributes['data-ae-embed-url']) {
                    data.url = element.attributes['data-ae-embed-url'];

                    return true;
                }
            };

            // Create a embedUrl command that can be invoked to easily embed media URLs
            editor.addCommand('embedUrl', {
                exec: function exec(editor, data) {
                    editor.insertHtml(AE_EMBED_WIDGET_TPL.output({
                        url: data.url
                    }));
                }
            });

            // Create a widget to properly handle embed operations
            editor.widgets.add('ae_embed', {

                mask: true,
                requiredContent: 'div[data-ae-embed-url]',

                /**
                 * Listener to be executed every time the widget's data changes. It takes care of
                 * requesting the embed object to the configured oembed service and render it in
                 * the editor
                 *
                 * @method data
                 * @param {event} event Data change event
                 */
                data: function data(event) {
                    var widget = this;

                    var url = event.data.url;

                    if (url) {
                        CKEDITOR.tools.jsonp(AE_EMBED_URL_TPL, {
                            url: encodeURIComponent(url)
                        }, function (response) {
                            if (response.html) {
                                if (REGEX_DEFAULT_LINK.test(response.html)) {
                                    widget.createATag(url);
                                } else {
                                    widget.element.setHtml(response.html);
                                }
                            } else {
                                widget.createATag(url);
                            }
                        }, function (msg) {
                            widget.createATag(url);
                        });
                    }
                },

                createATag: function createATag(url) {
                    this.editor.execCommand('undo');

                    var currentSelection = this.editor.getSelection().getSelectedElement();

                    var aTagHtml = AE_EMBED_DEFAULT_LINK_TPL.output({
                        url: url
                    });

                    this.editor.insertHtml(aTagHtml);
                    this.editor.fire('actionPerformed', this);
                },

                /**
                 * Function used to upcast an element to ae_embed widgets.
                 *
                 * @method upcast
                 * @param {CKEDITOR.htmlParser.element} element The element to be checked
                 * @param {Object} data The object that will be passed to the widget
                 */
                upcast: function upcast(element, data) {
                    var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

                    return embedWidgetUpcastFn(element, data);
                }
            });

            // Add a listener to handle paste events and turn links into embed objects
            editor.once('contentDom', function () {
                editor.on('paste', function (event) {
                    var link = event.data.dataValue;

                    if (REGEX_HTTP.test(link)) {
                        event.stop();

                        editor.execCommand('embedUrl', {
                            url: event.data.dataValue
                        });
                    }
                });
            });

            // Add a listener to handle selection change events and properly detect editor
            // interactions on the widgets without messing with widget native selection
            editor.on('selectionChange', function (event) {
                var selection = editor.getSelection();

                if (selection) {
                    var element = selection.getSelectedElement();

                    if (element) {
                        var widgetElement = element.findOne('[data-widget="ae_embed"]');

                        if (widgetElement) {
                            var region = element.getClientRect();

                            var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
                            region.left -= scrollPosition.x;
                            region.top += scrollPosition.y;

                            region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

                            editor.fire('editorInteraction', {
                                nativeEvent: {},
                                selectionData: {
                                    element: widgetElement,
                                    region: region
                                }
                            });
                        }
                    }
                }
            });

            // Add a filter to skip filtering widget elements
            editor.filter.addElementCallback(function (element) {
                if ('data-ae-embed-url' in element.attributes) {
                    return CKEDITOR.FILTER_SKIP_TREE;
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/imagealignment.js":
/*!***************************************!*\
  !*** ./src/plugins/imagealignment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _selectionTest = __webpack_require__(/*! ../selections/selection-test.js */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_imagealignment')) {
        return;
    }

    /**
     * Enum for supported image alignments
     * @type {Object}
     */
    var IMAGE_ALIGNMENT = {
        CENTER: 'center',
        LEFT: 'left',
        RIGHT: 'right'
    };

    /**
     * Enum values for supported image alignments
     * @type {Array}
     */
    var ALIGN_VALUES = [IMAGE_ALIGNMENT.LEFT, IMAGE_ALIGNMENT.RIGHT, IMAGE_ALIGNMENT.CENTER];

    /**
     * Necessary styles for the center alignment
     * @type {Array.<Object>}
     */
    var CENTERED_IMAGE_STYLE = [{
        name: 'display',
        value: 'block'
    }, {
        name: 'margin-left',
        value: 'auto'
    }, {
        name: 'margin-right',
        value: 'auto'
    }];

    /**
     * Retrieves the alignment value of an image.
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @return {String} The alignment value
     */
    var getImageAlignment = function getImageAlignment(image) {
        var imageAlignment = image.getStyle('float');

        if (!imageAlignment || imageAlignment === 'inherit' || imageAlignment === 'none') {
            imageAlignment = image.getAttribute('align');
        }

        if (!imageAlignment) {
            var centeredImage = CENTERED_IMAGE_STYLE.every(function (style) {
                var styleCheck = image.getStyle(style.name) === style.value;

                if (!styleCheck && style.vendorPrefixes) {
                    styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
                        return image.getStyle(vendorPrefix + style.name) === style.value;
                    });
                }

                return styleCheck;
            });

            imageAlignment = centeredImage ? IMAGE_ALIGNMENT.CENTER : null;
        }

        return imageAlignment;
    };

    /**
     * Removes the alignment value of an image
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @param {String} imageAlignment The image alignment value to be removed
     */
    var removeImageAlignment = function removeImageAlignment(image, imageAlignment) {
        if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
            image.removeStyle('float');

            if (imageAlignment === getImageAlignment(image)) {
                image.removeAttribute('align');
            }
        } else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
            CENTERED_IMAGE_STYLE.forEach(function (style) {
                image.removeStyle(style.name);

                if (style.vendorPrefixes) {
                    style.vendorPrefixes.forEach(function (vendorPrefix) {
                        image.removeStyle(vendorPrefix + style.name);
                    });
                }
            });
        }
    };

    /**
     * Sets the alignment value of an image
     *
     * @param {CKEDITOR.dom.element} image The image element
     * @param {String} imageAlignment The image alignment value to be set
     */
    var setImageAlignment = function setImageAlignment(image, imageAlignment) {
        removeImageAlignment(image, getImageAlignment(image));

        if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
            image.setStyle('float', imageAlignment);
        } else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
            CENTERED_IMAGE_STYLE.forEach(function (style) {
                image.setStyle(style.name, style.value);

                if (style.vendorPrefixes) {
                    style.vendorPrefixes.forEach(function (vendorPrefix) {
                        image.setStyle(vendorPrefix + style.name, style.value);
                    });
                }
            });
        }
    };

    /**
     * CKEditor plugin which modifies the justify commands to properly align images. This
     * plugin is an excerpt of CKEditor's original image one that can be found at
     * https://github.com/ckeditor/ckeditor-dev/blob/master/plugins/image/plugin.js
     *
     * @class CKEDITOR.plugins.ae_imagealignment
     */
    CKEDITOR.plugins.add('ae_imagealignment', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'paste' event on the editing area.
         *
         * @method afterInit
         * @param {Object} editor The current editor instance
         */
        afterInit: function afterInit(editor) {
            var self = this;

            ALIGN_VALUES.forEach(function (value) {
                var command = editor.getCommand('justify' + value);

                if (command) {
                    command.on('exec', function (event) {
                        var selectionData = editor.getSelectionData();

                        if (selectionData && _selectionTest2.default.image({ data: { selectionData: selectionData } })) {
                            var image = selectionData.element;

                            var imageAlignment = getImageAlignment(image);

                            if (imageAlignment === value) {
                                removeImageAlignment(image, value);
                            } else {
                                setImageAlignment(image, value);
                            }

                            event.cancel();

                            self.refreshCommands(editor, new CKEDITOR.dom.elementPath(image));
                        }
                    });

                    command.on('refresh', function (event) {
                        var selectionData = {
                            element: event.data.path.lastElement
                        };

                        if (_selectionTest2.default.image({ data: { selectionData: selectionData } })) {
                            var imageAlignment = getImageAlignment(selectionData.element);

                            this.setState(imageAlignment === value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

                            event.cancel();
                        }
                    });
                }
            });
        },

        /**
         * Forces a refresh of the modified justify commands. This is needed because the applied changes
         * do not modify the selection, so the refresh is never triggered and the UI does not update
         * properly until the next selectionChange event.
         *
         * @param {CKEDITOR.editor} editor The editor instance
         * @param {CKEDITOR.dom.elementPath} elementPath The path of the selected image
         */
        refreshCommands: function refreshCommands(editor, elementPath) {
            ALIGN_VALUES.forEach(function (value) {
                var command = editor.getCommand('justify' + value);

                if (command) {
                    command.refresh(editor, elementPath);
                }
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tabletools = exports.tableresize = exports.selectionkeystrokes = exports.placeholder = exports.pasteimages = exports.imagealignment = exports.embed = exports.dragresizeie = exports.dragresize = exports.autolist = exports.autolink = exports.addimages = undefined;

var _addimages = __webpack_require__(/*! ./addimages */ "./src/plugins/addimages.js");

var _addimages2 = _interopRequireDefault(_addimages);

var _autolink = __webpack_require__(/*! ./autolink */ "./src/plugins/autolink.js");

var _autolink2 = _interopRequireDefault(_autolink);

var _autolist = __webpack_require__(/*! ./autolist */ "./src/plugins/autolist.js");

var _autolist2 = _interopRequireDefault(_autolist);

var _dragresize = __webpack_require__(/*! ./dragresize */ "./src/plugins/dragresize.js");

var _dragresize2 = _interopRequireDefault(_dragresize);

var _dragresize_ie = __webpack_require__(/*! ./dragresize_ie */ "./src/plugins/dragresize_ie.js");

var _dragresize_ie2 = _interopRequireDefault(_dragresize_ie);

var _embed = __webpack_require__(/*! ./embed */ "./src/plugins/embed.js");

var _embed2 = _interopRequireDefault(_embed);

var _imagealignment = __webpack_require__(/*! ./imagealignment */ "./src/plugins/imagealignment.js");

var _imagealignment2 = _interopRequireDefault(_imagealignment);

var _pasteimages = __webpack_require__(/*! ./pasteimages */ "./src/plugins/pasteimages.js");

var _pasteimages2 = _interopRequireDefault(_pasteimages);

var _placeholder = __webpack_require__(/*! ./placeholder */ "./src/plugins/placeholder.js");

var _placeholder2 = _interopRequireDefault(_placeholder);

var _selectionkeystrokes = __webpack_require__(/*! ./selectionkeystrokes */ "./src/plugins/selectionkeystrokes.js");

var _selectionkeystrokes2 = _interopRequireDefault(_selectionkeystrokes);

var _tableresize = __webpack_require__(/*! ./tableresize */ "./src/plugins/tableresize.js");

var _tableresize2 = _interopRequireDefault(_tableresize);

var _tabletools = __webpack_require__(/*! ./tabletools */ "./src/plugins/tabletools.js");

var _tabletools2 = _interopRequireDefault(_tabletools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.addimages = _addimages2.default;
exports.autolink = _autolink2.default;
exports.autolist = _autolist2.default;
exports.dragresize = _dragresize2.default;
exports.dragresizeie = _dragresize_ie2.default;
exports.embed = _embed2.default;
exports.imagealignment = _imagealignment2.default;
exports.pasteimages = _pasteimages2.default;
exports.placeholder = _placeholder2.default;
exports.selectionkeystrokes = _selectionkeystrokes2.default;
exports.tableresize = _tableresize2.default;
exports.tabletools = _tabletools2.default;

/***/ }),

/***/ "./src/plugins/pasteimages.js":
/*!************************************!*\
  !*** ./src/plugins/pasteimages.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_pasteimages')) {
        return;
    }

    /**
     * CKEditor plugin which allows pasting images directly into the editable area. The image will be encoded
     * as Data URI. An event `beforeImageAdd` will be fired with the list of pasted images. If any of the listeners
     * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
     * an event `imageAdd` will be fired with the inserted element into the editable area.
     *
     * @class CKEDITOR.plugins.ae_pasteimages
     */

    /**
     * Fired before adding images to the editor.
     * @event beforeImageAdd
     * @param {Array} imageFiles Array of image files
     */

    /**
     * Fired when an image is being added to the editor successfully.
     *
     * @event imageAdd
     * @param {CKEDITOR.dom.element} el The created image with src as Data URI
     * @param {File} file The image file
     */

    CKEDITOR.plugins.add('ae_pasteimages', {
        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'paste' event on the editing area.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.once('contentDom', function () {
                var editable = editor.editable();

                editable.attachListener(editable, 'paste', this._onPaste, this, {
                    editor: editor
                });
            }.bind(this));
        },

        /**
         * The function creates an img element with src the image data as Data URI.
         * Then, it fires an 'imageAdd' event via CKEditor's event system. The passed
         * params will be:
         * - `el` - the created img element
         * - `file` - the original pasted data
         *
         * @method _onPaste
         * @protected
         * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
         */
        _onPaste: function _onPaste(event) {
            if (event.data.$.clipboardData) {
                var pastedData = event.data.$.clipboardData.items[0];
                var editor = event.listenerData.editor;

                if (pastedData.type.indexOf('image') === 0) {
                    var reader = new FileReader();
                    var imageFile = pastedData.getAsFile();

                    reader.onload = function (event) {
                        var result = editor.fire('beforeImageAdd', {
                            imageFiles: imageFile
                        });

                        if (!!result) {
                            var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

                            editor.insertElement(el);

                            var imageData = {
                                el: el,
                                file: imageFile
                            };

                            editor.fire('imageAdd', imageData);
                        }
                    }.bind(this);

                    reader.readAsDataURL(imageFile);
                }
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/placeholder.js":
/*!************************************!*\
  !*** ./src/plugins/placeholder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_placeholder')) {
        return;
    }

    /**
     * CKEDITOR enterMode config set the behavior of paragraphs
     * When the content is empty CKEDITOR keeps the enterMode string
     * into the content
     * @property
     * @type {string}
     */
    var brFiller = CKEDITOR.env.needsBrFiller ? '<br>' : '';

    var enterModeEmptyValue = {
        1: ['<p>' + brFiller + '</p>'],
        2: ['', ' ', brFiller],
        3: ['<div>' + brFiller + '</div>']
    };

    /**
     * CKEditor plugin which allows adding a placeholder to the editor. In this case, if there
     * is no content to the editor, there will be hint to the user.
     *
     * @class CKEDITOR.plugins.ae_placeholder
     */

    /**
     * Specifies the placeholder class which have to be aded to editor when editor is not focused.
     *
     * @attribute placeholderClass
     * @default ae_placeholder
     * @type String
     */

    CKEDITOR.plugins.add('ae_placeholder', {

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function registers a 'blur' and 'contentDom' event listeners.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            editor.on('blur', this._checkEmptyData, this);
            editor.on('change', this._checkEmptyData, this);
            editor.on('focus', this._removePlaceholderClass, this);
            editor.once('contentDom', this._checkEmptyData, this);
        },

        /**
         * Removes any data from the content and adds a class,
         * specified by the "placeholderClass" config attribute.
         *
         * @protected
         * @method _checkEmptyData
         * @param {CKEDITOR.dom.event} editor event, fired from CKEditor
         */
        _checkEmptyData: function _checkEmptyData(event) {
            var editor = event.editor;

            var editableNode = editor.editable();

            var innerHtml = editableNode.$.innerHTML.trim();

            var isEmpty = enterModeEmptyValue[editor.config.enterMode].some(function (element) {
                return innerHtml === element;
            });

            if (isEmpty) {
                editableNode.addClass(editor.config.placeholderClass);
            } else {
                editableNode.removeClass(editor.config.placeholderClass);
            }
        },

        /**
         * Remove placeholder class when input is focused
         *
         * @protected
         * @method _removePlaceholderClass
         + @param {CKEDITOR.dom.event} editor event, fired from CKEditor
         */
        _removePlaceholderClass: function _removePlaceholderClass(event) {
            var editor = event.editor;

            var editorNode = new CKEDITOR.dom.element(editor.element.$);

            editorNode.removeClass(editor.config.placeholderClass);
        }
    });
})();

/***/ }),

/***/ "./src/plugins/selectionkeystrokes.js":
/*!********************************************!*\
  !*** ./src/plugins/selectionkeystrokes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_selectionkeystrokes')) {
        return;
    }

    /**
     * CKEditor plugin that simulates editor interaction events based on manual keystrokes. This
     * can be used to trigger different reactions in the editor.
     *
     * @class CKEDITOR.plugins.ae_selectionkeystrokes
     */
    CKEDITOR.plugins.add('ae_selectionkeystrokes', {
        requires: 'ae_selectionregion',

        /**
         * Initialization of the plugin, part of CKEditor plugin lifecycle.
         * The function adds a command to the editor for every defined selectionKeystroke
         * in the configuration and maps it to the specified keystroke.
         *
         * @method init
         * @param {Object} editor The current editor instance
         */
        init: function init(editor) {
            if (editor.config.selectionKeystrokes) {
                editor.config.selectionKeystrokes.forEach(function (selectionKeystroke) {
                    var command = new CKEDITOR.command(editor, {
                        exec: function exec(editor) {
                            editor.fire('editorInteraction', {
                                manualSelection: selectionKeystroke.selection,
                                nativeEvent: {},
                                selectionData: editor.getSelectionData()
                            });
                        }
                    });

                    var commandName = 'selectionKeystroke' + selectionKeystroke.selection;

                    editor.addCommand(commandName, command);
                    editor.setKeystroke(selectionKeystroke.keys, commandName);
                });
            }
        }
    });
})();

/***/ }),

/***/ "./src/plugins/tableresize.js":
/*!************************************!*\
  !*** ./src/plugins/tableresize.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
    'use strict';

    if (CKEDITOR.plugins.get('ae_tableresize')) {
        return;
    }

    var pxUnit = CKEDITOR.tools.cssLength;

    function getWidth(el) {
        return CKEDITOR.env.ie ? el.$.clientWidth : parseInt(el.getComputedStyle('width'), 10);
    }

    function getBorderWidth(element, side) {
        var computed = element.getComputedStyle('border-' + side + '-width'),
            borderMap = {
            thin: '0px',
            medium: '1px',
            thick: '2px'
        };

        if (computed.indexOf('px') < 0) {
            // look up keywords
            if (computed in borderMap && element.getComputedStyle('border-style') != 'none') {
                computed = borderMap[computed];
            } else {
                computed = 0;
            }
        }

        return parseInt(computed, 10);
    }

    // Gets the table row that contains the most columns.
    function getMasterPillarRow(table) {
        var $rows = table.$.rows,
            maxCells = 0,
            cellsCount,
            $elected,
            $tr;

        for (var i = 0, len = $rows.length; i < len; i++) {
            $tr = $rows[i];
            cellsCount = $tr.cells.length;

            if (cellsCount > maxCells) {
                maxCells = cellsCount;
                $elected = $tr;
            }
        }

        return $elected;
    }

    function buildTableColumnPillars(table) {
        var pillars = [],
            pillarIndex = -1,
            rtl = table.getComputedStyle('direction') === 'rtl';

        // Get the raw row element that cointains the most columns.
        var $tr = getMasterPillarRow(table);

        // Get the tbody element and position, which will be used to set the
        // top and bottom boundaries.
        var tbody = new CKEDITOR.dom.element(table.$.tBodies[0]),
            tbodyPosition = tbody.getDocumentPosition();

        // Loop thorugh all cells, building pillars after each one of them.
        for (var i = 0, len = $tr.cells.length; i < len; i++) {
            // Both the current cell and the successive one will be used in the
            // pillar size calculation.
            var td = new CKEDITOR.dom.element($tr.cells[i]),
                nextTd = $tr.cells[i + 1] && new CKEDITOR.dom.element($tr.cells[i + 1]);

            pillarIndex += td.$.colSpan || 1;

            // Calculate the pillar boundary positions.
            var pillarLeft, pillarRight, pillarWidth;

            var x = td.getDocumentPosition().x;

            // Calculate positions based on the current cell.
            rtl ? pillarRight = x + getBorderWidth(td, 'left') : pillarLeft = x + td.$.offsetWidth - getBorderWidth(td, 'right');

            // Calculate positions based on the next cell, if available.
            if (nextTd) {
                x = nextTd.getDocumentPosition().x;

                rtl ? pillarLeft = x + nextTd.$.offsetWidth - getBorderWidth(nextTd, 'right') : pillarRight = x + getBorderWidth(nextTd, 'left');
            }
            // Otherwise calculate positions based on the table (for last cell).
            else {
                    x = table.getDocumentPosition().x;

                    rtl ? pillarLeft = x : pillarRight = x + table.$.offsetWidth;
                }

            pillarWidth = Math.max(pillarRight - pillarLeft, 4);

            // The pillar should reflects exactly the shape of the hovered
            // column border line.
            pillars.push({
                table: table,
                index: pillarIndex,
                x: pillarLeft,
                y: tbodyPosition.y,
                width: pillarWidth,
                height: tbody.$.offsetHeight,
                rtl: rtl
            });
        }

        return pillars;
    }

    function getPillarAtPosition(pillars, positionX) {
        for (var i = 0, len = pillars.length; i < len; i++) {
            var pillar = pillars[i];

            if (positionX >= pillar.x && positionX <= pillar.x + pillar.width) {
                return pillar;
            }
        }

        return null;
    }

    function cancel(evt) {
        (evt.data || evt).preventDefault();
    }

    function columnResizer(editor) {
        var pillar, document, resizer, isResizing, startOffset, currentShift;

        var leftSideCells, rightSideCells, leftShiftBoundary, rightShiftBoundary;

        function detach() {
            pillar = null;
            currentShift = 0;
            isResizing = 0;

            document.removeListener('mouseup', onMouseUp);
            resizer.removeListener('mousedown', onMouseDown);
            resizer.removeListener('mousemove', onMouseMove);

            document.getBody().setStyle('cursor', 'auto');
        }

        function resizeStart() {
            // Before starting to resize, figure out which cells to change
            // and the boundaries of this resizing shift.

            var columnIndex = pillar.index,
                map = CKEDITOR.tools.buildTableMap(pillar.table),
                leftColumnCells = [],
                rightColumnCells = [],
                leftMinSize = Number.MAX_VALUE,
                rightMinSize = leftMinSize,
                rtl = pillar.rtl;

            for (var i = 0, len = map.length; i < len; i++) {
                var row = map[i],
                    leftCell = row[columnIndex + (rtl ? 1 : 0)],
                    rightCell = row[columnIndex + (rtl ? 0 : 1)];

                leftCell = leftCell && new CKEDITOR.dom.element(leftCell);
                rightCell = rightCell && new CKEDITOR.dom.element(rightCell);

                if (!leftCell || !rightCell || !leftCell.equals(rightCell)) {
                    leftCell && (leftMinSize = Math.min(leftMinSize, getWidth(leftCell)));
                    rightCell && (rightMinSize = Math.min(rightMinSize, getWidth(rightCell)));

                    leftColumnCells.push(leftCell);
                    rightColumnCells.push(rightCell);
                }
            }

            // Cache the list of cells to be resized.
            leftSideCells = leftColumnCells;
            rightSideCells = rightColumnCells;

            // Cache the resize limit boundaries.
            leftShiftBoundary = pillar.x - leftMinSize;
            rightShiftBoundary = pillar.x + rightMinSize;

            resizer.setOpacity(0.5);
            startOffset = parseInt(resizer.getStyle('left'), 10);
            currentShift = 0;
            isResizing = 1;

            resizer.on('mousemove', onMouseMove);

            // Prevent the native drag behavior otherwise 'mousemove' won't fire.
            document.on('dragstart', cancel);
        }

        function resizeEnd() {
            isResizing = 0;

            resizer.setOpacity(0);

            currentShift && resizeColumn();

            var table = pillar.table;
            setTimeout(function () {
                table.removeCustomData('_cke_table_pillars');
            }, 0);

            document.removeListener('dragstart', cancel);
        }

        function resizeColumn() {
            var rtl = pillar.rtl,
                cellsCount = rtl ? rightSideCells.length : leftSideCells.length;

            // Perform the actual resize to table cells, only for those by side of the pillar.
            for (var i = 0; i < cellsCount; i++) {
                var leftCell = leftSideCells[i],
                    rightCell = rightSideCells[i],
                    table = pillar.table;

                // Defer the resizing to avoid any interference among cells.
                CKEDITOR.tools.setTimeout(function (leftCell, leftOldWidth, rightCell, rightOldWidth, tableWidth, sizeShift) {
                    // 1px is the minimum valid width (#11626).
                    leftCell && leftCell.setStyle('width', pxUnit(Math.max(leftOldWidth + sizeShift, 1)));
                    rightCell && rightCell.setStyle('width', pxUnit(Math.max(rightOldWidth - sizeShift, 1)));

                    // If we're in the last cell, we need to resize the table as well
                    if (tableWidth) {
                        table.setStyle('width', pxUnit(tableWidth + sizeShift * (rtl ? -1 : 1)));
                    }
                }, 0, this, [leftCell, leftCell && getWidth(leftCell), rightCell, rightCell && getWidth(rightCell), (!leftCell || !rightCell) && getWidth(table) + getBorderWidth(table, 'left') + getBorderWidth(table, 'right'), currentShift]);
            }
        }

        function onMouseDown(evt) {
            cancel(evt);

            resizeStart();

            document.on('mouseup', onMouseUp, this);
        }

        function onMouseUp(evt) {
            evt.removeListener();

            resizeEnd();
        }

        function onMouseMove(evt) {
            move(evt.data.getPageOffset().x);
        }

        document = editor.document;

        resizer = CKEDITOR.dom.element.createFromHtml('<div data-cke-temp=1 contenteditable=false unselectable=on ' + 'style="position:absolute;cursor:col-resize;filter:alpha(opacity=0);opacity:0;' + 'padding:0;background-color:#004;background-image:none;border:0px none;z-index:10"></div>', document);

        // Clean DOM when editor is destroyed.
        editor.on('destroy', function () {
            resizer.remove();
        });

        // Place the resizer after body to prevent it
        // from being editable.
        document.getDocumentElement().append(resizer);

        this.attachTo = function (targetPillar) {
            // Accept only one pillar at a time.
            if (isResizing) {
                return;
            }

            pillar = targetPillar;

            resizer.setStyles({
                width: pxUnit(targetPillar.width),
                height: pxUnit(targetPillar.height),
                left: pxUnit(targetPillar.x),
                top: pxUnit(targetPillar.y)
            });

            resizer.on('mousedown', onMouseDown, this);

            document.getBody().setStyle('cursor', 'col-resize');

            // Display the resizer to receive events but don't show it,
            // only change the cursor to resizable shape.
            resizer.show();
        };

        var move = this.move = function (posX) {
            if (!pillar) {
                return 0;
            }

            if (!isResizing && (posX < pillar.x || posX > pillar.x + pillar.width)) {
                detach();
                return 0;
            }

            var resizerNewPosition = posX - Math.round(resizer.$.offsetWidth / 2);

            if (isResizing) {
                if (resizerNewPosition === leftShiftBoundary || resizerNewPosition === rightShiftBoundary) {
                    return 1;
                }

                resizerNewPosition = Math.max(resizerNewPosition, leftShiftBoundary);
                resizerNewPosition = Math.min(resizerNewPosition, rightShiftBoundary);

                currentShift = resizerNewPosition - startOffset;
            }

            resizer.setStyle('left', pxUnit(resizerNewPosition));

            return 1;
        };
    }

    function clearPillarsCache(evt) {
        var target = evt.data.getTarget();

        if (evt.name === 'mouseout') {
            // Bypass interal mouse move.
            if (!target.is('table')) {
                return;
            }

            var dest = new CKEDITOR.dom.element(evt.data.$.relatedTarget || evt.data.$.toElement);
            while (dest && dest.$ && !dest.equals(target) && !dest.is('body')) {
                dest = dest.getParent();
            }
            if (!dest || dest.equals(target)) {
                return;
            }
        }

        target.getAscendant('table', 1).removeCustomData('_cke_table_pillars');
        evt.removeListener();
    }

    CKEDITOR.plugins.add('ae_tableresize', {
        requires: 'ae_tabletools',

        init: function init(editor) {
            editor.on('contentDom', function () {
                var resizer,
                    editable = editor.editable();

                // In Classic editor it is better to use document
                // instead of editable so event will work below body.
                editable.attachListener(editable.isInline() ? editable : editor.document, 'mousemove', function (evt) {
                    evt = evt.data;

                    var target = evt.getTarget();

                    // FF may return document and IE8 some UFO (object with no nodeType property...)
                    // instead of an element (#11823).
                    if (target.type !== CKEDITOR.NODE_ELEMENT) {
                        return;
                    }

                    var pageX = evt.getPageOffset().x;

                    // If we're already attached to a pillar, simply move the
                    // resizer.
                    if (resizer && resizer.move(pageX)) {
                        cancel(evt);
                        return;
                    }

                    // Considering table, tr, td, tbody but nothing else.
                    var table, pillars;

                    if (!target.is('table') && !target.getAscendant('tbody', 1)) {
                        return;
                    }

                    table = target.getAscendant('table', 1);

                    // Make sure the table we found is inside the container
                    // (eg. we should not use tables the editor is embedded within)
                    if (!editor.editable().contains(table)) {
                        return;
                    }

                    if (!(pillars = table.getCustomData('_cke_table_pillars'))) {
                        // Cache table pillars calculation result.
                        table.setCustomData('_cke_table_pillars', pillars = buildTableColumnPillars(table));
                        table.on('mouseout', clearPillarsCache);
                        table.on('mousedown', clearPillarsCache);
                    }

                    var pillar = getPillarAtPosition(pillars, pageX);
                    if (pillar) {
                        !resizer && (resizer = new columnResizer(editor));
                        resizer.attachTo(pillar);
                    }
                });
            });
        }
    });
})();

/***/ }),

/***/ "./src/plugins/tabletools.js":
/*!***********************************!*\
  !*** ./src/plugins/tabletools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
	'use strict';

	if (CKEDITOR.plugins.get('ae_tabletools')) {
		return;
	}

	var cellNodeRegex = /^(?:td|th)$/;

	function getSelectedCells(selection) {
		var ranges = selection.getRanges();
		var retval = [];
		var database = {};

		function moveOutOfCellGuard(node) {
			// Apply to the first cell only.
			if (retval.length > 0) return;

			// If we are exiting from the first </td>, then the td should definitely be
			// included.
			if (node.type == CKEDITOR.NODE_ELEMENT && cellNodeRegex.test(node.getName()) && !node.getCustomData('selected_cell')) {
				CKEDITOR.dom.element.setMarker(database, node, 'selected_cell', true);
				retval.push(node);
			}
		}

		for (var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if (range.collapsed) {
				// Walker does not handle collapsed ranges yet - fall back to old API.
				var startNode = range.getCommonAncestor();
				var nearestCell = startNode.getAscendant('td', true) || startNode.getAscendant('th', true);
				if (nearestCell) retval.push(nearestCell);
			} else {
				var walker = new CKEDITOR.dom.walker(range);
				var node;
				walker.guard = moveOutOfCellGuard;

				while (node = walker.next()) {
					// If may be possible for us to have a range like this:
					// <td>^1</td><td>^2</td>
					// The 2nd td shouldn't be included.
					//
					// So we have to take care to include a td we've entered only when we've
					// walked into its children.

					if (node.type != CKEDITOR.NODE_ELEMENT || !node.is(CKEDITOR.dtd.table)) {
						var parent = node.getAscendant('td', true) || node.getAscendant('th', true);
						if (parent && !parent.getCustomData('selected_cell')) {
							CKEDITOR.dom.element.setMarker(database, parent, 'selected_cell', true);
							retval.push(parent);
						}
					}
				}
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		return retval;
	}

	function getFocusElementAfterDelCells(cellsToDelete) {
		var i = 0,
		    last = cellsToDelete.length - 1,
		    database = {},
		    cell,
		    focusedCell,
		    tr;

		while (cell = cellsToDelete[i++]) {
			CKEDITOR.dom.element.setMarker(database, cell, 'delete_cell', true);
		} // 1.first we check left or right side focusable cell row by row;
		i = 0;
		while (cell = cellsToDelete[i++]) {
			if ((focusedCell = cell.getPrevious()) && !focusedCell.getCustomData('delete_cell') || (focusedCell = cell.getNext()) && !focusedCell.getCustomData('delete_cell')) {
				CKEDITOR.dom.element.clearAllMarkers(database);
				return focusedCell;
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		// 2. then we check the toppest row (outside the selection area square) focusable cell
		tr = cellsToDelete[0].getParent();
		if (tr = tr.getPrevious()) return tr.getLast();

		// 3. last we check the lowerest  row focusable cell
		tr = cellsToDelete[last].getParent();
		if (tr = tr.getNext()) return tr.getChild(0);

		return null;
	}

	function insertRow(selection, insertBefore) {
		var cells = getSelectedCells(selection),
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    doc = firstCell.getDocument(),
		    startRow = cells[0].getParent(),
		    startRowIndex = startRow.$.rowIndex,
		    lastCell = cells[cells.length - 1],
		    endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1,
		    endRow = new CKEDITOR.dom.element(table.$.rows[endRowIndex]),
		    rowIndex = insertBefore ? startRowIndex : endRowIndex,
		    row = insertBefore ? startRow : endRow;

		var map = CKEDITOR.tools.buildTableMap(table),
		    cloneRow = map[rowIndex],
		    nextRow = insertBefore ? map[rowIndex - 1] : map[rowIndex + 1],
		    width = map[0].length;

		var newRow = doc.createElement('tr');
		for (var i = 0; cloneRow[i] && i < width; i++) {
			var cell;
			// Check whether there's a spanning row here, do not break it.
			if (cloneRow[i].rowSpan > 1 && nextRow && cloneRow[i] == nextRow[i]) {
				cell = cloneRow[i];
				cell.rowSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneRow[i]).clone();
				cell.removeAttribute('rowSpan');
				cell.appendBogus();
				newRow.append(cell);
				cell = cell.$;
			}

			i += cell.colSpan - 1;
		}

		insertBefore ? newRow.insertBefore(row) : newRow.insertAfter(row);
	}

	function deleteRows(selectionOrRow) {
		if (selectionOrRow instanceof CKEDITOR.dom.selection) {
			var cells = getSelectedCells(selectionOrRow),
			    firstCell = cells[0],
			    table = firstCell.getAscendant('table'),
			    map = CKEDITOR.tools.buildTableMap(table),
			    startRow = cells[0].getParent(),
			    startRowIndex = startRow.$.rowIndex,
			    lastCell = cells[cells.length - 1],
			    endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1,
			    rowsToDelete = [];

			// Delete cell or reduce cell spans by checking through the table map.
			for (var i = startRowIndex; i <= endRowIndex; i++) {
				var mapRow = map[i],
				    row = new CKEDITOR.dom.element(table.$.rows[i]);

				for (var j = 0; j < mapRow.length; j++) {
					var cell = new CKEDITOR.dom.element(mapRow[j]),
					    cellRowIndex = cell.getParent().$.rowIndex;

					if (cell.$.rowSpan == 1) cell.remove();
					// Row spanned cell.
					else {
							// Span row of the cell, reduce spanning.
							cell.$.rowSpan -= 1;
							// Root row of the cell, root cell to next row.
							if (cellRowIndex == i) {
								var nextMapRow = map[i + 1];
								nextMapRow[j - 1] ? cell.insertAfter(new CKEDITOR.dom.element(nextMapRow[j - 1])) : new CKEDITOR.dom.element(table.$.rows[i + 1]).append(cell, 1);
							}
						}

					j += cell.$.colSpan - 1;
				}

				rowsToDelete.push(row);
			}

			var rows = table.$.rows;

			// Where to put the cursor after rows been deleted?
			// 1. Into next sibling row if any;
			// 2. Into previous sibling row if any;
			// 3. Into table's parent element if it's the very last row.
			var cursorPosition = new CKEDITOR.dom.element(rows[endRowIndex + 1] || (startRowIndex > 0 ? rows[startRowIndex - 1] : null) || table.$.parentNode);

			for (i = rowsToDelete.length; i >= 0; i--) {
				deleteRows(rowsToDelete[i]);
			}return cursorPosition;
		} else if (selectionOrRow instanceof CKEDITOR.dom.element) {
			table = selectionOrRow.getAscendant('table');

			if (table.$.rows.length == 1) table.remove();else selectionOrRow.remove();
		}

		return null;
	}

	function getCellColIndex(cell, isStart) {
		var row = cell.getParent(),
		    rowCells = row.$.cells;

		var colIndex = 0;
		for (var i = 0; i < rowCells.length; i++) {
			var mapCell = rowCells[i];
			colIndex += isStart ? 1 : mapCell.colSpan;
			if (mapCell == cell.$) break;
		}

		return colIndex - 1;
	}

	function getColumnsIndices(cells, isStart) {
		var retval = isStart ? Infinity : 0;
		for (var i = 0; i < cells.length; i++) {
			var colIndex = getCellColIndex(cells[i], isStart);
			if (isStart ? colIndex < retval : colIndex > retval) retval = colIndex;
		}
		return retval;
	}

	function insertColumn(selection, insertBefore) {
		var cells = getSelectedCells(selection),
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    startCol = getColumnsIndices(cells, 1),
		    lastCol = getColumnsIndices(cells),
		    colIndex = insertBefore ? startCol : lastCol;

		var map = CKEDITOR.tools.buildTableMap(table),
		    cloneCol = [],
		    nextCol = [],
		    height = map.length;

		for (var i = 0; i < height; i++) {
			cloneCol.push(map[i][colIndex]);
			var nextCell = insertBefore ? map[i][colIndex - 1] : map[i][colIndex + 1];
			nextCol.push(nextCell);
		}

		for (i = 0; i < height; i++) {
			var cell;

			if (!cloneCol[i]) continue;

			// Check whether there's a spanning column here, do not break it.
			if (cloneCol[i].colSpan > 1 && nextCol[i] == cloneCol[i]) {
				cell = cloneCol[i];
				cell.colSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneCol[i]).clone();
				cell.removeAttribute('colSpan');
				cell.appendBogus();
				cell[insertBefore ? 'insertBefore' : 'insertAfter'].call(cell, new CKEDITOR.dom.element(cloneCol[i]));
				cell = cell.$;
			}

			i += cell.rowSpan - 1;
		}
	}

	function deleteColumns(selectionOrCell) {
		var cells = getSelectedCells(selectionOrCell),
		    firstCell = cells[0],
		    lastCell = cells[cells.length - 1],
		    table = firstCell.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    startColIndex,
		    endColIndex,
		    rowsToDelete = [];

		// Figure out selected cells' column indices.
		for (var i = 0, rows = map.length; i < rows; i++) {
			for (var j = 0, cols = map[i].length; j < cols; j++) {
				if (map[i][j] == firstCell.$) startColIndex = j;
				if (map[i][j] == lastCell.$) endColIndex = j;
			}
		}

		// Delete cell or reduce cell spans by checking through the table map.
		for (i = startColIndex; i <= endColIndex; i++) {
			for (j = 0; j < map.length; j++) {
				var mapRow = map[j],
				    row = new CKEDITOR.dom.element(table.$.rows[j]),
				    cell = new CKEDITOR.dom.element(mapRow[i]);

				if (cell.$) {
					if (cell.$.colSpan == 1) cell.remove();
					// Reduce the col spans.
					else cell.$.colSpan -= 1;

					j += cell.$.rowSpan - 1;

					if (!row.$.cells.length) rowsToDelete.push(row);
				}
			}
		}

		var firstRowCells = table.$.rows[0] && table.$.rows[0].cells;

		// Where to put the cursor after columns been deleted?
		// 1. Into next cell of the first row if any;
		// 2. Into previous cell of the first row if any;
		// 3. Into table's parent element;
		var cursorPosition = new CKEDITOR.dom.element(firstRowCells[startColIndex] || (startColIndex ? firstRowCells[startColIndex - 1] : table.$.parentNode));

		// Delete table rows only if all columns are gone (do not remove empty row).
		if (rowsToDelete.length == rows) table.remove();

		return cursorPosition;
	}

	function insertCell(selection, insertBefore) {
		var startElement = selection.getStartElement();
		var cell = startElement.getAscendant('td', 1) || startElement.getAscendant('th', 1);

		if (!cell) return;

		// Create the new cell element to be added.
		var newCell = cell.clone();
		newCell.appendBogus();

		if (insertBefore) newCell.insertBefore(cell);else newCell.insertAfter(cell);
	}

	function deleteCells(selectionOrCell) {
		if (selectionOrCell instanceof CKEDITOR.dom.selection) {
			var cellsToDelete = getSelectedCells(selectionOrCell);
			var table = cellsToDelete[0] && cellsToDelete[0].getAscendant('table');
			var cellToFocus = getFocusElementAfterDelCells(cellsToDelete);

			for (var i = cellsToDelete.length - 1; i >= 0; i--) {
				deleteCells(cellsToDelete[i]);
			}if (cellToFocus) placeCursorInCell(cellToFocus, true);else if (table) table.remove();
		} else if (selectionOrCell instanceof CKEDITOR.dom.element) {
			var tr = selectionOrCell.getParent();
			if (tr.getChildCount() == 1) tr.remove();else selectionOrCell.remove();
		}
	}

	// Remove filler at end and empty spaces around the cell content.
	function trimCell(cell) {
		var bogus = cell.getBogus();
		bogus && bogus.remove();
		cell.trim();
	}

	function placeCursorInCell(cell, placeAtEnd) {
		var docInner = cell.getDocument(),
		    docOuter = CKEDITOR.document;

		// Fixing "Unspecified error" thrown in IE10 by resetting
		// selection the dirty and shameful way (#10308).
		// We can not apply this hack to IE8 because
		// it causes error (#11058).
		if (CKEDITOR.env.ie && CKEDITOR.env.version == 10) {
			docOuter.focus();
			docInner.focus();
		}

		var range = new CKEDITOR.dom.range(docInner);
		if (!range['moveToElementEdit' + (placeAtEnd ? 'End' : 'Start')](cell)) {
			range.selectNodeContents(cell);
			range.collapse(placeAtEnd ? false : true);
		}
		range.select(true);
	}

	function cellInRow(tableMap, rowIndex, cell) {
		var oRow = tableMap[rowIndex];
		if (typeof cell == 'undefined') return oRow;

		for (var c = 0; oRow && c < oRow.length; c++) {
			if (cell.is && oRow[c] == cell.$) return c;else if (c == cell) return new CKEDITOR.dom.element(oRow[c]);
		}
		return cell.is ? -1 : null;
	}

	function cellInCol(tableMap, colIndex) {
		var oCol = [];
		for (var r = 0; r < tableMap.length; r++) {
			var row = tableMap[r];
			oCol.push(row[colIndex]);

			// Avoid adding duplicate cells.
			if (row[colIndex].rowSpan > 1) r += row[colIndex].rowSpan - 1;
		}
		return oCol;
	}

	function mergeCells(selection, mergeDirection, isDetect) {
		var cells = getSelectedCells(selection);

		// Invalid merge request if:
		// 1. In batch mode despite that less than two selected.
		// 2. In solo mode while not exactly only one selected.
		// 3. Cells distributed in different table groups (e.g. from both thead and tbody).
		var commonAncestor;
		if ((mergeDirection ? cells.length != 1 : cells.length < 2) || (commonAncestor = selection.getCommonAncestor()) && commonAncestor.type == CKEDITOR.NODE_ELEMENT && commonAncestor.is('table')) return false;

		var cell,
		    firstCell = cells[0],
		    table = firstCell.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    mapHeight = map.length,
		    mapWidth = map[0].length,
		    startRow = firstCell.getParent().$.rowIndex,
		    startColumn = cellInRow(map, startRow, firstCell);

		if (mergeDirection) {
			var targetCell;
			try {
				var rowspan = parseInt(firstCell.getAttribute('rowspan'), 10) || 1;
				var colspan = parseInt(firstCell.getAttribute('colspan'), 10) || 1;

				targetCell = map[mergeDirection == 'up' ? startRow - rowspan : mergeDirection == 'down' ? startRow + rowspan : startRow][mergeDirection == 'left' ? startColumn - colspan : mergeDirection == 'right' ? startColumn + colspan : startColumn];
			} catch (er) {
				return false;
			}

			// 1. No cell could be merged.
			// 2. Same cell actually.
			if (!targetCell || firstCell.$ == targetCell) return false;

			// Sort in map order regardless of the DOM sequence.
			cells[mergeDirection == 'up' || mergeDirection == 'left' ? 'unshift' : 'push'](new CKEDITOR.dom.element(targetCell));
		}

		// Start from here are merging way ignorance (merge up/right, batch merge).
		var doc = firstCell.getDocument(),
		    lastRowIndex = startRow,
		    totalRowSpan = 0,
		    totalColSpan = 0,

		// Use a documentFragment as buffer when appending cell contents.
		frag = !isDetect && new CKEDITOR.dom.documentFragment(doc),
		    dimension = 0;

		for (var i = 0; i < cells.length; i++) {
			cell = cells[i];

			var tr = cell.getParent(),
			    cellFirstChild = cell.getFirst(),
			    colSpan = cell.$.colSpan,
			    rowSpan = cell.$.rowSpan,
			    rowIndex = tr.$.rowIndex,
			    colIndex = cellInRow(map, rowIndex, cell);

			// Accumulated the actual places taken by all selected cells.
			dimension += colSpan * rowSpan;
			// Accumulated the maximum virtual spans from column and row.
			totalColSpan = Math.max(totalColSpan, colIndex - startColumn + colSpan);
			totalRowSpan = Math.max(totalRowSpan, rowIndex - startRow + rowSpan);

			if (!isDetect) {
				// Trim all cell fillers and check to remove empty cells.
				if (trimCell(cell), cell.getChildren().count()) {
					// Merge vertically cells as two separated paragraphs.
					if (rowIndex != lastRowIndex && cellFirstChild && !(cellFirstChild.isBlockBoundary && cellFirstChild.isBlockBoundary({ br: 1 }))) {
						var last = frag.getLast(CKEDITOR.dom.walker.whitespaces(true));
						if (last && !(last.is && last.is('br'))) frag.append('br');
					}

					cell.moveChildren(frag);
				}
				i ? cell.remove() : cell.setHtml('');
			}
			lastRowIndex = rowIndex;
		}

		if (!isDetect) {
			frag.moveChildren(firstCell);

			firstCell.appendBogus();

			if (totalColSpan >= mapWidth) firstCell.removeAttribute('rowSpan');else firstCell.$.rowSpan = totalRowSpan;

			if (totalRowSpan >= mapHeight) firstCell.removeAttribute('colSpan');else firstCell.$.colSpan = totalColSpan;

			// Swip empty <tr> left at the end of table due to the merging.
			var trs = new CKEDITOR.dom.nodeList(table.$.rows),
			    count = trs.count();

			for (i = count - 1; i >= 0; i--) {
				var tailTr = trs.getItem(i);
				if (!tailTr.$.cells.length) {
					tailTr.remove();
					count++;
					continue;
				}
			}

			return firstCell;
		}
		// Be able to merge cells only if actual dimension of selected
		// cells equals to the caculated rectangle.
		else {
				return totalRowSpan * totalColSpan == dimension;
			}
	}

	function verticalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0],
		    tr = cell.getParent(),
		    table = tr.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    rowIndex = tr.$.rowIndex,
		    colIndex = cellInRow(map, rowIndex, cell),
		    rowSpan = cell.$.rowSpan,
		    newCell,
		    newRowSpan,
		    newCellRowSpan,
		    newRowIndex;

		if (rowSpan > 1) {
			newRowSpan = Math.ceil(rowSpan / 2);
			newCellRowSpan = Math.floor(rowSpan / 2);
			newRowIndex = rowIndex + newRowSpan;
			var newCellTr = new CKEDITOR.dom.element(table.$.rows[newRowIndex]),
			    newCellRow = cellInRow(map, newRowIndex),
			    candidateCell;

			newCell = cell.clone();

			// Figure out where to insert the new cell by checking the vitual row.
			for (var c = 0; c < newCellRow.length; c++) {
				candidateCell = newCellRow[c];
				// Catch first cell actually following the column.
				if (candidateCell.parentNode == newCellTr.$ && c > colIndex) {
					newCell.insertBefore(new CKEDITOR.dom.element(candidateCell));
					break;
				} else {
					candidateCell = null;
				}
			}

			// The destination row is empty, append at will.
			if (!candidateCell) newCellTr.append(newCell);
		} else {
			newCellRowSpan = newRowSpan = 1;

			newCellTr = tr.clone();
			newCellTr.insertAfter(tr);
			newCellTr.append(newCell = cell.clone());

			var cellsInSameRow = cellInRow(map, rowIndex);
			for (var i = 0; i < cellsInSameRow.length; i++) {
				cellsInSameRow[i].rowSpan++;
			}
		}

		newCell.appendBogus();

		cell.$.rowSpan = newRowSpan;
		newCell.$.rowSpan = newCellRowSpan;
		if (newRowSpan == 1) cell.removeAttribute('rowSpan');
		if (newCellRowSpan == 1) newCell.removeAttribute('rowSpan');

		return newCell;
	}

	function horizontalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0],
		    tr = cell.getParent(),
		    table = tr.getAscendant('table'),
		    map = CKEDITOR.tools.buildTableMap(table),
		    rowIndex = tr.$.rowIndex,
		    colIndex = cellInRow(map, rowIndex, cell),
		    colSpan = cell.$.colSpan,
		    newCell,
		    newColSpan,
		    newCellColSpan;

		if (colSpan > 1) {
			newColSpan = Math.ceil(colSpan / 2);
			newCellColSpan = Math.floor(colSpan / 2);
		} else {
			newCellColSpan = newColSpan = 1;
			var cellsInSameCol = cellInCol(map, colIndex);
			for (var i = 0; i < cellsInSameCol.length; i++) {
				cellsInSameCol[i].colSpan++;
			}
		}
		newCell = cell.clone();
		newCell.insertAfter(cell);
		newCell.appendBogus();

		cell.$.colSpan = newColSpan;
		newCell.$.colSpan = newCellColSpan;
		if (newColSpan == 1) cell.removeAttribute('colSpan');
		if (newCellColSpan == 1) newCell.removeAttribute('colSpan');

		return newCell;
	}

	CKEDITOR.plugins.add('ae_tabletools', {
		init: function init(editor) {
			var lang = editor.lang.table;

			function createDef(def) {
				return CKEDITOR.tools.extend(def || {}, {
					contextSensitive: 1,
					refresh: function refresh(editor, path) {
						this.setState(path.contains({ td: 1, th: 1 }, 1) ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
					}
				});
			}
			function addCmd(name, def) {
				var cmd = editor.getCommand(name);

				if (cmd) {
					return;
				}

				cmd = editor.addCommand(name, def);
				editor.addFeature(cmd);
			}

			addCmd('rowDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					placeCursorInCell(deleteRows(selection));
				}
			}));

			addCmd('rowInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection, true);
				}
			}));

			addCmd('rowInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection);
				}
			}));

			addCmd('columnDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					var element = deleteColumns(selection);
					element && placeCursorInCell(element, true);
				}
			}));

			addCmd('columnInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection, true);
				}
			}));

			addCmd('columnInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection);
				}
			}));

			addCmd('cellDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					deleteCells(selection);
				}
			}));

			addCmd('cellMerge', createDef({
				allowedContent: 'td[colspan,rowspan]',
				requiredContent: 'td[colspan,rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection()), true);
				}
			}));

			addCmd('cellMergeRight', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'right'), true);
				}
			}));

			addCmd('cellMergeDown', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'down'), true);
				}
			}));

			addCmd('cellVerticalSplit', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(verticalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellHorizontalSplit', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(horizontalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection, true);
				}
			}));

			addCmd('cellInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection);
				}
			}));
		},

		getSelectedCells: getSelectedCells

	});
})();

/**
 * Create a two-dimension array that reflects the actual layout of table cells,
 * with cell spans, with mappings to the original td elements.
 *
 * @param {CKEDITOR.dom.element} table
 * @member CKEDITOR.tools
 */
CKEDITOR.tools.buildTableMap = function (table) {
	var aRows = table.$.rows;

	// Row and Column counters.
	var r = -1;

	var aMap = [];

	for (var i = 0; i < aRows.length; i++) {
		r++;
		!aMap[r] && (aMap[r] = []);

		var c = -1;

		for (var j = 0; j < aRows[i].cells.length; j++) {
			var oCell = aRows[i].cells[j];

			c++;
			while (aMap[r][c]) {
				c++;
			}var iColSpan = isNaN(oCell.colSpan) ? 1 : oCell.colSpan;
			var iRowSpan = isNaN(oCell.rowSpan) ? 1 : oCell.rowSpan;

			for (var rs = 0; rs < iRowSpan; rs++) {
				if (!aMap[r + rs]) aMap[r + rs] = [];

				for (var cs = 0; cs < iColSpan; cs++) {
					aMap[r + rs][c + cs] = aRows[i].cells[j];
				}
			}

			c += iColSpan - 1;
		}
	}
	return aMap;
};

/***/ }),

/***/ "./src/selections/selection-arrowbox.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-arrowbox.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var tableSelectionGetArrowBoxClasses = function tableSelectionGetArrowBoxClasses() {
    return 'ae-arrow-box ae-arrow-box-bottom';
};

var SelectionGetArrowBoxClasses = {
    table: tableSelectionGetArrowBoxClasses
};

exports.default = SelectionGetArrowBoxClasses;

/***/ }),

/***/ "./src/selections/selection-position.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-position.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default gutter value for toolbar positioning
var DEFAULT_GUTTER = {
    left: 0,
    top: 0
};

/**
 * Centers a Toolbar according to given rectangle
 *
 * @method centerToolbar
 * @param {Object} toolbar The toolbar to be centered
 * @param {Object} rect The rectangle according to which the Toolbar will be centered
 */
var centerToolbar = function centerToolbar(toolbar, rect) {
    var toolbarNode = _reactDom2.default.findDOMNode(toolbar);

    var halfNodeWidth = toolbarNode.offsetWidth / 2;
    var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

    var gutter = toolbar.props.gutter || DEFAULT_GUTTER;

    var widgetXY = toolbar.getWidgetXYPoint(rect.left + rect.width / 2 - scrollPosition.x, rect.top + scrollPosition.y, CKEDITOR.SELECTION_BOTTOM_TO_TOP);

    toolbar.moveToPoint([widgetXY[0], widgetXY[1]], [rect.left + rect.width / 2 - halfNodeWidth - scrollPosition.x, rect.top - toolbarNode.offsetHeight + scrollPosition.y - gutter.top]);
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method imageSelectionSetPosition
 * @param {Object} payload Payload, should contain the selection data for retrieving the
 * client rectangle of the selected image
 * @return {Boolean} True, in all cases
 */
var imageSelectionSetPosition = function imageSelectionSetPosition(payload) {
    centerToolbar(this, payload.selectionData.element.getClientRect());

    return true;
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method tableSelectionSetPosition
 * @param {Object} payload Object, which contains the selection data for retrieving the
 * client rectangle of the selected table
 * @return {Boolean} True, in all cases
 */
var tableSelectionSetPosition = function tableSelectionSetPosition(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var table = new CKEDITOR.Table(nativeEditor).getFromSelection();

    centerToolbar(this, table.getClientRect());

    return true;
};

var SelectionSetPosition = {
    image: imageSelectionSetPosition,
    table: tableSelectionSetPosition
};

exports.default = SelectionSetPosition;

/***/ }),

/***/ "./src/selections/selection-test.js":
/*!******************************************!*\
  !*** ./src/selections/selection-test.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var _isRangeAtElementEnd = function _isRangeAtElementEnd(range, element) {
    // Finding if a range is at the end of an element is somewhat tricky due to how CKEditor handles
    // ranges. It might depend on wether a source node inside the element is selected or not. For now,
    // we need to cover the following cases:
    //
    // - The text length of the element is the same as the endOffset of the range
    // - Both start and end containers match the element and the start and end offsets are 1

    return element.getText().length === range.endOffset || element.equals(range.startContainer) && element.equals(range.endContainer) && range.startOffset === range.endOffset && range.endOffset === 1;
};

var embedSelectionTest = function embedSelectionTest(payload) {
    var selectionData = payload.data.selectionData;

    return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'ae_embed');
};

var linkSelectionTest = function linkSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');
    var range = nativeEditor.getSelection().getRanges()[0];

    var element;

    return !!(nativeEditor.isSelectionEmpty() && (element = new CKEDITOR.Link(nativeEditor).getFromSelection()) && element.getText().length !== range.endOffset && !element.isReadOnly() && !_isRangeAtElementEnd(range, element));
};

var imageSelectionTest = function imageSelectionTest(payload) {
    var selectionData = payload.data.selectionData;

    return !!(selectionData.element && selectionData.element.getName() === 'img' && !selectionData.element.isReadOnly());
};

var textSelectionTest = function textSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var selectionEmpty = nativeEditor.isSelectionEmpty();

    var selectionData = payload.data.selectionData;

    return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly());
};

var tableSelectionTest = function tableSelectionTest(payload) {
    var nativeEditor = payload.editor.get('nativeEditor');

    var table = new CKEDITOR.Table(nativeEditor);
    var element = table.getFromSelection();

    return !!(element && table.isEditable(element));
};

var SelectionTest = {
    embed: embedSelectionTest,
    image: imageSelectionTest,
    link: linkSelectionTest,
    table: tableSelectionTest,
    text: textSelectionTest
};

exports.default = SelectionTest;

/***/ }),

/***/ "./src/selections/selections.js":
/*!**************************************!*\
  !*** ./src/selections/selections.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _selectionArrowbox = __webpack_require__(/*! ./selection-arrowbox.js */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ./selection-position.js */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ./selection-test.js */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Selections = [{
    name: 'embed',
    buttons: ['embedRemove', 'embedEdit'],
    test: _selectionTest2.default.embed
}, {
    name: 'link',
    buttons: ['linkEdit'],
    test: _selectionTest2.default.link
}, {
    name: 'image',
    buttons: ['imageLeft', 'imageCenter', 'imageRight'],
    setPosition: _selectionPosition2.default.image,
    test: _selectionTest2.default.image
}, {
    name: 'text',
    buttons: ['styles', 'bold', 'italic', 'underline', 'link', 'twitter'],
    test: _selectionTest2.default.text
}, {
    name: 'table',
    buttons: ['tableHeading', 'tableRow', 'tableColumn', 'tableCell', 'tableRemove'],
    getArrowBoxClasses: _selectionArrowbox2.default.table,
    setPosition: _selectionPosition2.default.table,
    test: _selectionTest2.default.table
}];

exports.default = Selections;

/***/ }),

/***/ "react":
/*!****************************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"} ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ }),

/***/ "react-dom":
/*!***********************************************************************************************************************!*\
  !*** external {"root":"ReactDOM","commonjs2":"react-dom","commonjs":"react-dom","amd":"react-dom","umd":"react-dom"} ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BbGxveUVkaXRvci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL2NvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvYWRhcHRlci9tYWluLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1jb21tYW5kLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tcHJvcHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL3Rvb2xiYXItYnV0dG9ucy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWFycm93LWJveC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtZXhjbHVzaXZlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LXBvc2l0aW9uLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tYm9sZC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jYW1lcmEtaW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY2FtZXJhLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvZGUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY29tbWFuZHMtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1kcm9wZG93bi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1lbWJlZC1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgxLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWhsaW5lLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWluZGVudC1ibG9jay5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pdGFsaWMuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWVkaXQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay10YXJnZXQtZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLW9sLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLW91dGRlbnQtYmxvY2suanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWFsaWduLXJpZ2h0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXBhcmFncmFwaC1jZW50ZXIuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWp1c3RpZnkuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcXVvdGUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcmVtb3ZlLWZvcm1hdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdHJpa2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN1YnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdXBlcnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1jZWxsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWNvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWhlYWRpbmcuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUtcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLXJvdy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YXJnZXQtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10d2l0dGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVuZGVybGluZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvbWFpbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy90b29sYmFycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItYWRkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL3VpYnJpZGdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9wbHVnaW5zLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvc2VsZWN0aW9uLXJlZ2lvbi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL3RhYmxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvdG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS91aWNvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvYmFzZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvbGFuZy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3Avb29wLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYWRkaW1hZ2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYXV0b2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9hdXRvbGlzdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2RyYWdyZXNpemUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9kcmFncmVzaXplX2llLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9pbWFnZWFsaWdubWVudC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvcGFzdGVpbWFnZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9wbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3NlbGVjdGlvbmtleXN0cm9rZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy90YWJsZXJlc2l6ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3RhYmxldG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tYXJyb3dib3guanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9zZWxlY3Rpb25zL3NlbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwiLFwidW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdERPTVwiLFwiY29tbW9uanMyXCI6XCJyZWFjdC1kb21cIixcImNvbW1vbmpzXCI6XCJyZWFjdC1kb21cIixcImFtZFwiOlwicmVhY3QtZG9tXCIsXCJ1bWRcIjpcInJlYWN0LWRvbVwifSJdLCJuYW1lcyI6WyJDb3JlIiwiY29uZmlnIiwic3VwZXJjbGFzcyIsImNvbnN0cnVjdG9yIiwiY2FsbCIsImluaXRpYWxpemVyIiwibm9kZSIsImdldCIsInNldEF0dHJpYnV0ZSIsImVkaXRvciIsIkNLRURJVE9SIiwiaW5saW5lIiwiYWxsb3dlZENvbnRlbnQiLCJ0b29sYmFycyIsInJlbW92ZVBsdWdpbnMiLCJleHRyYVBsdWdpbnMiLCJwbGFjZWhvbGRlckNsYXNzIiwicGFzdGVGcm9tV29yZFJlbW92ZVN0eWxlcyIsInBhc3RlRnJvbVdvcmRSZW1vdmVGb250U3R5bGVzIiwic2VsZWN0aW9uS2V5c3Ryb2tlcyIsIm1peCIsImVudiIsImllIiwiZWRnZSIsInJlcGxhY2UiLCJvbmNlIiwiX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIiLCJlZGl0YWJsZSIsImFkZENsYXNzIiwiYmluZCIsIl9lZGl0b3IiLCJBbGxveUVkaXRvciIsImxvYWRMYW5ndWFnZVJlc291cmNlcyIsIl9yZW5kZXJVSSIsImRlc3RydWN0b3IiLCJfZGVzdHJveWVkIiwiX2VkaXRvclVJRWxlbWVudCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJuYXRpdmVFZGl0b3IiLCJyZW1vdmVDbGFzcyIsIl9jbGVhclNlbGVjdGlvbnMiLCJkZXN0cm95IiwiaXNNU1NlbGVjdGlvbiIsIndpbmRvdyIsImdldFNlbGVjdGlvbiIsImRvY3VtZW50IiwiJCIsInNlbGVjdGlvbiIsImVtcHR5IiwiZ2V0V2luZG93IiwicmVtb3ZlQWxsUmFuZ2VzIiwib24iLCJfZGVmYXVsdFJlYWRPbmx5Q2xpY2tGbiIsImV2ZW50IiwibW91c2VFdmVudCIsImRhdGEiLCJoYXNDdHJsS2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaG91bGRPcGVuIiwicmVhZE9ubHkiLCJwcmV2ZW50RGVmYXVsdCIsImxpc3RlbmVyRGF0YSIsImZpcmUiLCJja0VsZW1lbnQiLCJkb20iLCJlbGVtZW50UGF0aCIsImdldFRhcmdldCIsImxpbmsiLCJsYXN0RWxlbWVudCIsImhyZWYiLCJhdHRyaWJ1dGVzIiwidmFsdWUiLCJ0YXJnZXQiLCJfcmVkaXJlY3RMaW5rIiwiX2dldE5hdGl2ZUVkaXRvciIsIm9wZW4iLCJsb2NhdGlvbiIsImVkaXRvclVJRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJ1aU5vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJfbWFpblVJIiwicmVuZGVyIiwiX3RvRWxlbWVudCIsImlzU3RyaW5nIiwiZ2V0RWxlbWVudEJ5SWQiLCJfdmFsaWRhdGVBbGxvd2VkQ29udGVudCIsImlzT2JqZWN0IiwiaXNCb29sZWFuIiwiX3ZhbGlkYXRlVG9vbGJhcnMiLCJpc051bGwiLCJBVFRSUyIsInZhbGlkYXRvciIsIndyaXRlT25jZSIsImVuYWJsZUNvbnRlbnRFZGl0YWJsZSIsImV2ZW50c0RlbGF5IiwiaXNOdW1iZXIiLCJnZXR0ZXIiLCJpc0FycmF5Iiwia2V5cyIsIkNUUkwiLCJTSElGVCIsInNyY05vZGUiLCJzZXR0ZXIiLCJhZGQiLCJidXR0b25zIiwidGFiSW5kZXgiLCJzdHlsZXMiLCJzZWxlY3Rpb25zIiwiaW1wbGVtZW50T24iLCJCUklER0VfQlVUVE9OUyIsImltcGxlbWVudEV2ZW50VGFyZ2V0IiwiZ2V0QmFzZVBhdGgiLCJwYXRoIiwiQUxMT1lFRElUT1JfQkFTRVBBVEgiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpIiwibGVuZ3RoIiwibWF0Y2giLCJzcmMiLCJyZWdleEJhc2VQYXRoIiwiaW5kZXhPZiIsInNsaWNlIiwiY2FsbGJhY2siLCJpc0Z1bmN0aW9uIiwiU3RyaW5ncyIsInNldFRpbWVvdXQiLCJfbGFuZ1Jlc291cmNlUmVxdWVzdGVkIiwibGFuZ3VhZ2VzIiwidXNlckxhbmd1YWdlIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJwYXJ0cyIsInRvTG93ZXJDYXNlIiwibGFuZyIsImxvY2FsZSIsInNjcmlwdExvYWRlciIsImxvYWQiLCJnZXRVcmwiLCJsb2FkZWQiLCJyZXNvdXJjZSIsImJhc2VQYXRoIiwidGltZXN0YW1wIiwiY2hhckF0IiwidGVzdCIsImdldEJ1dHRvbnMiLCJyZWR1Y2UiLCJhY2MiLCJ2YWwiLCJjb25jYXQiLCJyZWdpc3RlckJyaWRnZUJ1dHRvbiIsImJ1dHRvbk5hbWUiLCJwbHVnaW5OYW1lIiwicHVzaCIsIk9PUCIsImV4dGVuZCIsIkF0dHJpYnV0ZSIsIkJ1dHRvbnMiLCJMYW5nIiwiU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzIiwiU2VsZWN0aW9ucyIsIlNlbGVjdGlvblNldFBvc2l0aW9uIiwiU2VsZWN0aW9uVGVzdCIsIlRvb2xiYXJzIiwiaXNBY3RpdmUiLCJnZXRTdHlsZSIsInByb3BzIiwibG9jayIsInJlbW92ZVN0eWxlIiwiYXBwbHlTdHlsZSIsInVubG9jayIsIldyYXBwZWRDb21wb25lbnQiLCJjb21tYW5kIiwiZ2V0Q29tbWFuZCIsInN0YXRlIiwiVFJJU1RBVEVfT04iLCJleGVjQ29tbWFuZCIsIm1vZGlmaWVzU2VsZWN0aW9uIiwic2VsZWN0aW9uQ2hhbmdlIiwia2V5c3Ryb2tlIiwiY29tbWFuZE5hbWUiLCJuYW1lIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiZXhlYyIsImtleXN0cm9rZUZuIiwiZm4iLCJhZGRDb21tYW5kIiwiX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kIiwia2V5c3Ryb2tlSGFuZGxlciIsImtleXN0cm9rZXMiLCJzZXRLZXlzdHJva2UiLCJidXR0b25DZmciLCJyZXN1bHQiLCJ0b29scyIsIm1lcmdlIiwic3RhdGVDbGFzc2VzIiwiaXNEaXNhYmxlZCIsInN0eWxlIiwic3BsaXQiLCJjdXJyZW50TWVtYmVyIiwicHJvcGVydHkiLCJzaGlmdCIsIl9zdHlsZSIsImNoZWNrQWN0aXZlIiwiYWRkaXRpb25hbFByb3BzIiwiYnV0dG9uUHJvcHMiLCJ0b29sYmFyQnV0dG9ucyIsImZpbHRlckV4Y2x1c2l2ZSIsImZpbHRlciIsImJ1dHRvbiIsIm1hcCIsImtleSIsImNmZyIsIm1lcmdlRXhjbHVzaXZlUHJvcHMiLCJ0YWJLZXkiLCJ0cmlnZ2VyIiwibWVyZ2VEcm9wZG93blByb3BzIiwiYXJyb3dCb3hDbGFzc2VzIiwiZ2V0SW50ZXJhY3Rpb25Qb2ludCIsImRpcmVjdGlvbiIsIlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NIiwiZHJvcGRvd25UcmlnZ2VyIiwiaXRlbURyb3Bkb3duIiwibmV4dFByb3BzIiwic2V0U3RhdGUiLCJvYmoiLCJpdGVtS2V5IiwiZXhwYW5kZWQiLCJ0b2dnbGVEcm9wZG93biIsInRvZ2dsZURpcmVjdGlvbiIsIm1vdmVGb2N1cyIsImZpbmRET01Ob2RlIiwiZm9jdXMiLCJpdGVtRXhjbHVzaXZlIiwiaXRlbXMiLCJpdGVtIiwiY2FuY2VsRXhjbHVzaXZlIiwicmVuZGVyRXhjbHVzaXZlIiwicmVxdWVzdEV4Y2x1c2l2ZSIsIkRJUkVDVElPTl9OT05FIiwiRElSRUNUSU9OX05FWFQiLCJESVJFQ1RJT05fUFJFViIsIkFDVElPTl9OT05FIiwiQUNUSU9OX01PVkVfRk9DVVMiLCJBQ1RJT05fRElTTUlTU19GT0NVUyIsIl9yZWZyZXNoIiwiX2lzVmFsaWRUYXJnZXQiLCJfZGVzY2VuZGFudHMiLCJhY3RpdmVEZXNjZW5kYW50RWwiLCJfYWN0aXZlRGVzY2VuZGFudCIsImFjdGl2ZUVsZW1lbnQiLCJmb2N1c0ZpcnN0Q2hpbGQiLCJzdG9wUHJvcGFnYXRpb24iLCJhY3Rpb24iLCJfZ2V0Rm9jdXNBY3Rpb24iLCJ0eXBlIiwiX21vdmVGb2N1cyIsIm9uRGlzbWlzcyIsIl9nZXRGb2N1c01vdmVEaXJlY3Rpb24iLCJkaXNtaXNzQWN0aW9uIiwiX2dldEZvY3VzRGlzbWlzc0FjdGlvbiIsImRpc21pc3MiLCJmb2N1c01vdmVEaXJlY3Rpb24iLCJfaXNWYWxpZEtleSIsImtleUNvZGUiLCJkaXNtaXNzTmV4dCIsImRpc21pc3NQcmV2IiwiY2lyY3VsYXIiLCJuZXh0IiwicHJldiIsInNoaWZLZXkiLCJlbGVtZW50IiwidGFnTmFtZSIsIm51bURlc2NlbmRhbnRzIiwiZGVzY2VuZGFudCIsIm1heCIsIm1pbiIsImRvbU5vZGUiLCJkZXNjZW5kYW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJwcmlvcml0eURlc2NlbmRhbnRzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiZGF0YVRhYkluZGV4IiwiZ2V0QXR0cmlidXRlIiwic29ydCIsImEiLCJiIiwidG9JbnQiLCJzb21lIiwiaW5kZXgiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIl9hbmltYXRpb25GcmFtZUlkIiwiYXR0cnMiLCJ2aWV3UGFuZVNpemUiLCJnZXRWaWV3UGFuZVNpemUiLCJ4IiwibGVmdCIsInkiLCJ0b3AiLCJ3aWR0aCIsImV2ZW50UGF5bG9hZCIsImVkaXRvckV2ZW50Iiwic2VsZWN0aW9uRGF0YSIsIm5hdGl2ZUV2ZW50IiwicG9zIiwicGFnZVgiLCJyZWdpb24iLCJlbmRSZWN0Iiwic3RhcnRSZWN0IiwiU0VMRUNUSU9OX0JPVFRPTV9UT19UT1AiLCJfZ2V0WFBvaW50IiwiX2dldFlQb2ludCIsImV2ZW50WCIsInJpZ2h0IiwibGVmdERpc3QiLCJhYnMiLCJyaWdodERpc3QiLCJlbGVtZW50VGFyZ2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0SGVpZ2h0IiwiYm90dG9tIiwiZ3V0dGVyIiwib2Zmc2V0V2lkdGgiLCJTRUxFQ1RJT05fTEVGVF9UT19SSUdIVCIsIlNFTEVDVElPTl9SSUdIVF9UT19MRUZUIiwiZG9tRWxlbWVudCIsImhhc0NsYXNzIiwic3RhcnRQb2ludCIsImVuZFBvaW50Iiwic2V0U3R5bGVzIiwib3BhY2l0eSIsIl9hbmltYXRlIiwiaXNWaXNpYmxlIiwiaW50ZXJhY3Rpb25Qb2ludCIsImZpbmFsWCIsImZpbmFsWSIsImluaXRpYWxYIiwiaW5pdGlhbFkiLCJwYXJzZUZsb2F0IiwiY29uc3RyYWluVG9WaWV3cG9ydCIsInJlcyIsImdldENvbnN0cmFpbmVkUG9zaXRpb24iLCJoZWlnaHQiLCJtb3ZlVG9Qb2ludCIsInh5IiwiZ2V0V2lkZ2V0WFlQb2ludCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRlZmF1bHRQcm9wcyIsIkJ1dHRvbkJvbGQiLCJjc3NDbGFzcyIsImdldFN0YXRlQ2xhc3NlcyIsImJvbGQiLCJDb21wb25lbnQiLCJCdXR0b25DYW1lcmFJbWFnZSIsInJlZnMiLCJidXR0b25UYWtlUGhvdG8iLCJfc3RyZWFtIiwic3RvcCIsImdldFZpZGVvVHJhY2tzIiwidHJhY2siLCJnZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJtb3pHZXRVc2VyTWVkaWEiLCJtc0dldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJfaGFuZGxlU3RyZWFtU3VjY2VzcyIsIl9oYW5kbGVTdHJlYW1FcnJvciIsInRha2VQaG90byIsInZpZGVvRWwiLCJ2aWRlb0NvbnRhaW5lciIsImNhbnZhc0VsIiwiY2FudmFzQ29udGFpbmVyIiwiY29udGV4dCIsImdldENvbnRleHQiLCJfdmlkZW9IZWlnaHQiLCJ2aWRlb1dpZHRoIiwiZHJhd0ltYWdlIiwiaW1nVVJMIiwidG9EYXRhVVJMIiwiZWwiLCJjcmVhdGVGcm9tSHRtbCIsImluc2VydEVsZW1lbnQiLCJlcnJvciIsImFsZXJ0Iiwic3RyZWFtIiwiYWRkRXZlbnRMaXN0ZW5lciIsInZpZGVvSGVpZ2h0IiwiaXNOYU4iLCJtb3pTcmNPYmplY3QiLCJVUkwiLCJ3ZWJraXRVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJwbGF5IiwiZGlzYWJsZWQiLCJCdXR0b25DYW1lcmEiLCJwcm90b2NvbCIsImxhYmVsIiwiY2FtZXJhRGlzYWJsZWQiLCJjYW1lcmEiLCJCdXR0b25Db2RlIiwiY29kZSIsIkJ1dHRvbkNvbW1hbmRMaXN0SXRlbSIsImRlc2NyaXB0aW9uIiwiX2dldENsYXNzTmFtZSIsImljb24iLCJCdXR0b25Db21tYW5kc0xpc3QiLCJoYW5kbGVLZXkiLCJsaXN0SWQiLCJfcmVuZGVyQWN0aW9ucyIsImNvbW1hbmRzIiwiQnV0dG9uRHJvcGRvd24iLCJjaGlsZHJlbiIsIktFWV9FTlRFUiIsIktFWV9FU0MiLCJCdXR0b25FbWJlZEVkaXQiLCJsaW5rSW5wdXQiLCJjcmVhdGVSZWYiLCJnZXRJbml0aWFsU3RhdGUiLCJtYW51YWxTZWxlY3Rpb24iLCJfZm9jdXNMaW5rSW5wdXQiLCJlbWJlZCIsInNlbGVjdGVkRWxlbWVudCIsImdldFNlbGVjdGVkRWxlbWVudCIsImZpbmRPbmUiLCJpbml0aWFsTGluayIsImxpbmtIcmVmIiwiY2xlYXJMaW5rU3R5bGUiLCJkZWxldGVFbWJlZCIsIl9yZW1vdmVFbWJlZCIsIl9oYW5kbGVMaW5rSHJlZkNoYW5nZSIsIl9oYW5kbGVLZXlEb3duIiwiZWRpdExpbmsiLCJjbGVhcklucHV0IiwiX2NsZWFyTGluayIsImNsZWFyIiwiY29uZmlybSIsIl9pc1ZhbGlkU3RhdGUiLCJfZW1iZWRMaW5rIiwidXJsIiwiY3VycmVudCIsInZhbGlkU3RhdGUiLCJlbWJlZFdyYXBwZXIiLCJnZXRBc2NlbmRhbnQiLCJyZW1vdmUiLCJCdXR0b25FbWJlZCIsIl9yZXF1ZXN0RXhjbHVzaXZlIiwiQnV0dG9uSDEiLCJoMSIsIkJ1dHRvbkgyIiwiaDIiLCJCdXR0b25IbGluZSIsImhvcml6b250YWxydWxlIiwiQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciIsImFsaWduQ2VudGVyIiwiQnV0dG9uSW1hZ2VBbGlnbkxlZnQiLCJhbGlnbkxlZnQiLCJCdXR0b25JbWFnZUFsaWduUmlnaHQiLCJhbGlnblJpZ2h0IiwiQnV0dG9uSW1hZ2UiLCJmaWxlSW5wdXQiLCJpbnB1dFN5bGUiLCJkaXNwbGF5IiwiaW1hZ2UiLCJoYW5kbGVDbGljayIsIl9vbklucHV0Q2hhbmdlIiwiY2xpY2siLCJpbnB1dEVsIiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiZmlsZSIsIm9ubG9hZCIsImltYWdlRmlsZXMiLCJpbWFnZURhdGEiLCJyZWFkQXNEYXRhVVJMIiwiQnV0dG9uSW5kZW50QmxvY2siLCJpbmRlbnQiLCJCdXR0b25JdGFsaWMiLCJpdGFsaWMiLCJCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCIsInRlcm0iLCJjbGVhclRpbWVvdXQiLCJfdGltZW91dCIsIl91cGRhdGVJdGVtcyIsImRlbGF5IiwiYXV0b2NvbXBsZXRlU2VsZWN0ZWQiLCJzZXRBdXRvY29tcGxldGVTdGF0ZSIsInNlbGVjdGVkIiwiX3JlbmRlckF1dG9jb21wbGV0ZUl0ZW1zIiwibmV4dFN0YXRlIiwiaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrIiwidGl0bGUiLCJpbnN0YW5jZSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJCdXR0b25MaW5rRWRpdCIsIl9nZXRJbml0aWFsU3RhdGUiLCJ0YXJnZXRTZWxlY3RvciIsImFsbG93ZWRUYXJnZXRzIiwiaGFuZGxlTGlua1RhcmdldENoYW5nZSIsIl9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlIiwic2VsZWN0ZWRUYXJnZXQiLCJsaW5rVGFyZ2V0IiwibGlua1RhcmdldERlZmF1bHQiLCJhdXRvY29tcGxldGVEcm9wZG93biIsImRhdGFGbiIsImF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMiLCJfaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrIiwiX3NldEF1dG9jb21wbGV0ZVN0YXRlIiwiYnV0dG9uQ2xlYXJMaW5rIiwicGxhY2Vob2xkZXJQcm9wIiwicGxhY2Vob2xkZXIiLCJyZW1vdmVMaW5rIiwiX3JlbW92ZUxpbmsiLCJzaG93VGFyZ2V0U2VsZWN0b3IiLCJfdXBkYXRlTGluayIsImRlZmF1bHRMaW5rVGFyZ2V0IiwiTGluayIsImdldEZyb21TZWxlY3Rpb24iLCJmb2N1c0xpbmtFbCIsImFkdmFuY2VTZWxlY3Rpb24iLCJsaW5rVXRpbHMiLCJib29rbWFya3MiLCJjcmVhdGVCb29rbWFya3MiLCJhZHZhbmNlIiwic2VsZWN0Qm9va21hcmtzIiwiYXBwZW5kUHJvdG9jb2wiLCJsaW5rQXR0cnMiLCJtb2RpZnlTZWxlY3Rpb24iLCJ1cGRhdGUiLCJjcmVhdGUiLCJhdXRvY29tcGxldGVVcmwiLCJjdXN0b21JbmRleFN0YXJ0IiwiQnV0dG9uTGlua1RhcmdldEVkaXQiLCJhbGxvd2VkTGlua1RhcmdldHMiLCJCdXR0b25MaW5rIiwibWVyZ2VCdXR0b25DZmdQcm9wcyIsIkJ1dHRvbk9yZGVyZWRMaXN0IiwibnVtYmVyZWRsaXN0IiwiQnV0dG9uT3V0ZGVudEJsb2NrIiwib3V0ZGVudCIsIkJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCIsIkJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQiLCJCdXR0b25QYXJhZ3JhcGhDZW50ZXIiLCJCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5IiwiYWxpZ25KdXN0aWZ5IiwiQnV0dG9uUXVvdGUiLCJxdW90ZSIsIkJ1dHRvblJlbW92ZUZvcm1hdCIsInJlbW92ZWZvcm1hdCIsIkJ1dHRvblN0cmlrZSIsInN0cmlrZSIsIkJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIiwiQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUiLCJfcmVtb3ZlU3R5bGVzIiwibm9ybWFsIiwicmVtb3ZlQmxvY2tzIiwiYmxvY2tJdGVtIiwiYmxvY2tTdHlsZSIsIkJ1dHRvblN0eWxlc0xpc3RJdGVtIiwic3R5bGVDZmciLCJtYXJnaW4iLCJfcHJldmlldyIsImJ1aWxkUHJldmlldyIsImFjdGl2ZVN0eWxlIiwiX19odG1sIiwiX29uQ2xpY2siLCJCdXR0b25TdHlsZXNMaXN0IiwiYmxvY2tTdHlsZXMiLCJpbmxpbmVTdHlsZXMiLCJvYmplY3RTdHlsZXMiLCJTVFlMRV9CTE9DSyIsIlNUWUxFX0lOTElORSIsIlNUWUxFX09CSkVDVCIsIl9ibG9ja1N0eWxlcyIsIl9pbmxpbmVTdHlsZXMiLCJfb2JqZWN0U3R5bGVzIiwicmVtb3ZlU3R5bGVzSXRlbSIsInNob3dSZW1vdmVTdHlsZXNJdGVtIiwiX3JlbmRlclN0eWxlc0l0ZW1zIiwiQnV0dG9uU3R5bGVzIiwiX2dldFN0eWxlcyIsIl9jaGVja0FjdGl2ZSIsImJ1dHRvblN0eWxlc0xpc3QiLCJzdHlsZUNvbmZpZyIsImZvcm1hdHRlZCIsImNpdGUiLCJCdXR0b25TdWJzY3JpcHQiLCJzdWJzY3JpcHQiLCJCdXR0b25TdXBlcnNjcmlwdCIsInN1cGVyc2NyaXB0IiwiQnV0dG9uVGFibGVDZWxsIiwiYnV0dG9uQ29tbWFuZHNMaXN0IiwiYnV0dG9uQ29tbWFuZHNMaXN0SWQiLCJfZ2V0Q29tbWFuZHMiLCJjZWxsIiwiY2VsbEluc2VydEJlZm9yZSIsImNlbGxJbnNlcnRBZnRlciIsImNlbGxEZWxldGUiLCJjZWxsTWVyZ2UiLCJjZWxsTWVyZ2VEb3duIiwiY2VsbE1lcmdlUmlnaHQiLCJjZWxsU3BsaXRIb3Jpem9udGFsIiwiY2VsbFNwbGl0VmVydGljYWwiLCJCdXR0b25UYWJsZUNvbHVtbiIsImNvbHVtbiIsImNvbHVtbkluc2VydEJlZm9yZSIsImNvbHVtbkluc2VydEFmdGVyIiwiY29sdW1uRGVsZXRlIiwiQnV0dG9uVGFibGVFZGl0Iiwicm93c1JlZiIsImNvbHNSZWYiLCJjb2xzIiwicm93cyIsInRhYmxlVXRpbHMiLCJUYWJsZSIsInRhYmxlQXR0cmlidXRlcyIsImlucHV0TmFtZSIsIl9jcmVhdGVUYWJsZSIsInRpbWUiLCJEYXRlIiwibm93Iiwicm93c0lkIiwiY29sc0lkIiwiX2hhbmRsZUNoYW5nZSIsImNvbHVtbnMiLCJib3JkZXIiLCJjZWxsUGFkZGluZyIsImNlbGxTcGFjaW5nIiwiQnV0dG9uVGFibGVIZWFkaW5nIiwiYWN0aXZlSGVhZGluZyIsImdldEhlYWRpbmciLCJhY3RpdmVIZWFkaW5nSW50cm8iLCJoZWFkZXJzIiwiYWN0aXZlSGVhZGluZ0xhYmVsIiwiaGVhZGVyc05vbmUiLCJoZWFkZXJzUm93IiwiaGVhZGVyc0NvbHVtbiIsImhlYWRlcnNCb3RoIiwiQnV0dG9uVGFibGVSZW1vdmUiLCJkZWxldGVUYWJsZSIsIl9yZW1vdmVUYWJsZSIsIkJ1dHRvblRhYmxlUm93Iiwicm93Iiwicm93SW5zZXJ0QmVmb3JlIiwicm93SW5zZXJ0QWZ0ZXIiLCJyb3dEZWxldGUiLCJCdXR0b25UYWJsZSIsInRhYmxlIiwiQnV0dG9uVGFyZ2V0TGlzdCIsImxpc3RUYXJnZXRzIiwiX3JlbmRlckxpc3RUYXJnZXRzIiwibGlua1RhcmdldFNlbGYiLCJsaW5rVGFyZ2V0QmxhbmsiLCJsaW5rVGFyZ2V0UGFyZW50IiwibGlua1RhcmdldFRvcCIsInRhcmdldHMiLCJfZ2V0QWxsb3dlZFRhcmdldEl0ZW1zIiwiQnV0dG9uVHdpdHRlciIsIl9nZXRIcmVmIiwidHdpdHRlciIsInNlbGVjdGVkVGV4dCIsImdldFNlbGVjdGVkVGV4dCIsInZpYSIsInR3aXR0ZXJIcmVmIiwiQnV0dG9uVW5vcmRlcmVkbGlzdCIsImJ1bGxldGVkbGlzdCIsIkJ1dHRvblVuZGVybGluZSIsInVuZGVybGluZSIsIlVJIiwiaGlkZGVuIiwiX29uRWRpdG9ySW50ZXJhY3Rpb24iLCJfb25BY3Rpb25QZXJmb3JtZWQiLCJfb25FZGl0b3JLZXkiLCJfbW91c2Vkb3duTGlzdGVuZXIiLCJfc2V0VUlIaWRkZW4iLCJfa2V5RG93bkxpc3RlbmVyIiwiZGVib3VuY2UiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJtZXNzYWdlIiwiX2dldEF2YWlsYWJsZVRvb2xiYXJzTWVzc2FnZSIsImFyaWFVcGRhdGUiLCJfYXJpYVVwZGF0ZVRlbXBsYXRlcyIsInRlbXBsYXRlIiwiX2dldEFyaWFVcGRhdGVzIiwiYXJpYVVwZGF0ZXMiLCJub1Rvb2xiYXIiLCJhcmlhVXBkYXRlTm9Ub29sYmFyIiwib25lVG9vbGJhciIsImFyaWFVcGRhdGVPbmVUb29sYmFyIiwibWFueVRvb2xiYXJzIiwiYXJpYVVwZGF0ZU1hbnlUb29sYmFycyIsInRvb2xiYXJzTm9kZUxpc3QiLCJ0b29sYmFyTmFtZXMiLCJ0b29sYmFyIiwiX2dldEFyaWFVcGRhdGVUZW1wbGF0ZSIsIm91dHB1dCIsImpvaW4iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoIiwiT2JqZWN0IiwiX29uRGlzbWlzc1Rvb2xiYXJGb2N1cyIsImdldFNlbGVjdGlvbkRhdGEiLCJkb21FdmVudCIsImFsdEtleSIsInRhcmdldE5vZGUiLCJjb250YWlucyIsIlBPU0lUSU9OX0xFRlQiLCJQT1NJVElPTl9SSUdIVCIsIlRvb2xiYXJBZGQiLCJfdXBkYXRlUG9zaXRpb24iLCJpc0NvbnRlbnRFZGl0YWJsZSIsIl9nZXRCdXR0b25zIiwiX2dldFRvb2xiYXJDbGFzc05hbWUiLCJnZXRUb29sYmFyQnV0dG9ucyIsImdldEFycm93Qm94Q2xhc3NlcyIsInVwZGF0ZVBvc2l0aW9uIiwic2hvdyIsImNsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0TGVmdCIsInBvc2l0aW9uIiwiZ3V0dGVyRXhjbHVzaXZlIiwiZmxvb3IiLCJjYW5jZWxBbmltYXRpb24iLCJUb29sYmFyU3R5bGVzIiwiY3VycmVudFNlbGVjdGlvbiIsIl9nZXRDdXJyZW50U2VsZWN0aW9uIiwiZ2V0QXJyb3dCb3hDbGFzc2VzRm4iLCJfZ2V0U2VsZWN0aW9uRnVuY3Rpb24iLCJjc3NDbGFzc2VzIiwic2VsZWN0aW9uVHlwZSIsInNlbGVjdGlvbkZuIiwic2VsZWN0aW9uRnVuY3Rpb24iLCJ0ZXN0Rm4iLCJzZXRQb3NpdGlvbkZuIiwic2V0UG9zaXRpb24iLCJwbHVnaW5zIiwiYmVmb3JlSW5pdCIsIm9yaWdpbmFsVUlBZGRGbiIsInVpIiwiZGVmaW5pdGlvbiIsImFwcGx5IiwiYXJndW1lbnRzIiwidHlwZUhhbmRsZXIiLCJfIiwiaGFuZGxlcnMiLCJfX3Byb2Nlc3NpbmdQbHVnaW5fXyIsInBsdWdpbiIsInRpbWVvdXQiLCJhcmdzIiwiZGVib3VuY2VIYW5kbGUiLCJjYWxsRm4iLCJjYWxsQ29udGV4dCIsImxlbiIsInN0YXJ0SW5kZXgiLCJjYWxsQXJncyIsInNlbGVjdGlvblJlZ2lvbiIsInVpY29yZSIsIlJFR0VYX0JPT0tNQVJLX1NDSEVNRSIsIlJFR0VYX0VNQUlMX1NDSEVNRSIsIlJFR0VYX1VSSV9TQ0hFTUUiLCJyYW5nZSIsImdldFJhbmdlcyIsIm1vdmVUb0VsZW1lbnRFZGl0RW5kIiwibmV4dE5vZGUiLCJnZXROZXh0RWRpdGFibGVOb2RlIiwiZXF1YWxzIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJ3aGl0ZXNwYWNlIiwiZ2V0VGV4dCIsIm9mZnNldCIsInNldFN0YXJ0Iiwic2V0RW5kIiwic2VsZWN0UmFuZ2VzIiwiVVJJIiwiY29sbGFwc2VkIiwidGV4dCIsImluc2VydE5vZGUiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJfZ2V0Q29tcGxldGVVUkkiLCJhcHBseVRvUmFuZ2UiLCJzZWxlY3QiLCJpcyIsInNocmluayIsIlNIUklOS19URVhUIiwiYWx3YXlzUmVtb3ZlRWxlbWVudCIsInNlbGVjdEVsZW1lbnQiLCJnZXRTdGFydEVsZW1lbnQiLCJ1cmkiLCJzZXRBdHRyaWJ1dGVzIiwicmVtb3ZlQXR0cnMiLCJzZXRBdHRycyIsInJlbW92ZUF0dHJpYnV0ZXMiLCJ3cmFwUGx1Z2luTGlmZWN5Y2xlIiwibWV0aG9kcyIsIm1ldGhvZE5hbWUiLCJvdmVycmlkZSIsIm9yaWdpbmFsUGx1Z2luTWV0aG9kIiwicGF5bG9hZCIsInBoYXNlIiwiZmlsdGVyVW53YW50ZWREZXBlbmRlbmNpZXMiLCJyZXF1aXJlcyIsInJlcXVpcmUiLCJwbHVnaW5zTG9hZCIsIm5hbWVzIiwic2NvcGUiLCJTZWxlY3Rpb25SZWdpb24iLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQiLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2UiLCJzdGFydFgiLCJzdGFydFkiLCJlbmRYIiwiZW5kWSIsImVuZCIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsInN0YXJ0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJvZmZzZXROb2RlIiwiY3JlYXRlUmFuZ2UiLCJjYXJldFJhbmdlRnJvbVBvaW50IiwiY3JlYXRlVGV4dFJhbmdlIiwiZW5kUmFuZ2UiLCJkdXBsaWNhdGUiLCJzZXRFbmRQb2ludCIsImdldENhcmV0UmVnaW9uIiwiYm9va21hcmtOb2RlRWwiLCJzdGFydE5vZGUiLCJzY3JvbGxQb3MiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImdldE5hdGl2ZSIsImdldFNlbGVjdGlvblJlZ2lvbiIsImdldENsaWVudFJlY3RzUmVnaW9uIiwiZ2V0U2VsZWN0aW9uRGlyZWN0aW9uIiwiaXNTZWxlY3Rpb25FbXB0eSIsInJhbmdlcyIsImdldFR5cGUiLCJTRUxFQ1RJT05fTk9ORSIsIm5hdGl2ZVNlbGVjdGlvbiIsImRlZmF1bHRSZWN0IiwiY2xpZW50UmVjdHMiLCJJbmZpbml0eSIsInJhbmdlQ291bnQiLCJnZXRDbGllbnRSZWN0cyIsImdldFJhbmdlQXQiLCJhbmNob3JOb2RlIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJmb2N1c05vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJpbml0IiwiYXR0ciIsImhhc093blByb3BlcnR5IiwiSUVfTk9OX0RJUkVDVExZX0VESVRBQkxFX0VMRU1FTlQiLCJIRUFESU5HX0JPVEgiLCJIRUFESU5HX0NPTCIsIkhFQURJTkdfTk9ORSIsIkhFQURJTkdfUk9XIiwiX2NyZWF0ZUVsZW1lbnQiLCJ0Ym9keSIsImFwcGVuZCIsImoiLCJhcHBlbmRCb2d1cyIsInNldEhlYWRpbmciLCJoZWFkaW5nIiwiZmlyc3RDZWxsIiwiY2VsbHMiLCJtb3ZlVG9Qb3NpdGlvbiIsIlBPU0lUSU9OX0FGVEVSX1NUQVJUIiwid2Via2l0IiwiTk9ERV9FTEVNRU5UIiwiaXNFZGl0YWJsZSIsImlzUmVhZE9ubHkiLCJoYXNBdHRyaWJ1dGUiLCJnZXRQYXJlbnQiLCJyb3dIZWFkaW5nU2V0dGluZ3MiLCJ0SGVhZCIsImNvbEhlYWRpbmdTZXR0aW5ncyIsIm5vZGVOYW1lIiwiaGVhZGluZ1NldHRpbmdzIiwicGFyZW50IiwiZ2V0Q2hpbGRDb3VudCIsIlBPU0lUSU9OX0JFRk9SRV9TVEFSVCIsIm5ld0NlbGwiLCJ0YWJsZUhlYWQiLCJ0YWJsZUJvZHkiLCJnZXRFbGVtZW50c0J5VGFnIiwiZ2V0SXRlbSIsInRhYmxlSGVhZGluZyIsImhhZENvbEhlYWRpbmciLCJuZWVkQ29sSGVhZGluZyIsIm5lZWRSb3dIZWFkaW5nIiwidGFibGVGaXJzdFJvdyIsInRhYmxlRmlyc3RSb3dDaGlsZENvdW50IiwiZ2V0Q2hpbGQiLCJyZW5hbWVOb2RlIiwiY3JlYXRlVEhlYWQiLCJwcmV2aW91c0ZpcnN0Um93IiwiZ2V0Rmlyc3QiLCJuZXdGaXJzdFJvdyIsIm5ld0ZpcnN0Um93Q2hpbGRDb3VudCIsInJlbW92ZUF0dHJpYnV0ZSIsImluc2VydEJlZm9yZSIsImhhc0NvbEhlYWRpbmciLCJnZXROYW1lIiwiaGVhZGluZ0NvbW1hbmRzIiwianNvbnAiLCJ1cmxUZW1wbGF0ZSIsInVybFBhcmFtcyIsImVycm9yQ2FsbGJhY2siLCJjYWxsYmFja0tleSIsImdldE5leHROdW1iZXIiLCJqc29ucENhbGxiYWNrcyIsInJlc3BvbnNlIiwiY2xlYW5VcCIsInNjcmlwdEVsZW1lbnQiLCJnZXRCb2R5IiwiY2FuY2VsIiwiaWQiLCJzaW11bGF0ZSIsImV2ZW50SW5zdGFuY2UiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJhcmlhU3RhdGUiLCJhcmlhRWxlbWVudCIsIl9jcmVhdGVBcmlhRWxlbWVudCIsInVpVGFza3NUaW1lb3V0IiwiaGFuZGxlVUkiLCJhbGxvd0VzYyIsImhhbmRsZUFyaWEiLCJpbm5lckhUTUwiLCJoYW5kbGVNb3VzZUxlYXZlIiwiYWVVSU5vZGVzIiwiZm91bmQiLCJyZWxhdGVkVGFyZ2V0IiwiZm9jdXNIYW5kbGVyIiwiYXR0YWNoTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInN0YXR1c0VsZW1lbnQiLCJfX2NvbmZpZ19fIiwiX19BVFRSU19fIiwiY3VycmVudEF0dHIiLCJfaXNJbml0aWFsaXplZCIsIl9pbml0IiwiY3VyVmFsdWUiLCJfY2FsbFN0cmluZ09yRnVuY3Rpb24iLCJzZXQiLCJzdHJpbmdPckZ1bmN0aW9uIiwiaGFzRGVmYXVsdFZhbHVlIiwiaGFzUGFzc2VkVmFsdWVWaWFDb25maWciLCJ2YWx1ZUZuIiwiQmFzZSIsIl9jYWxsQ2hhaW4iLCJ3YXQiLCJhcnIiLCJjdG9yIiwicmV2ZXJzZSIsImlzRmluaXRlIiwidmFsdWVUeXBlIiwicmVjZWl2ZXIiLCJzdXBwbGllciIsInBhcnNlSW50IiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwic3VwcGxpZXJQcm90byIsInJlY2VpdmVyUHJvdG8iLCJpc0lFIiwiX29uRHJhZ0VudGVyIiwiX29uRHJhZ092ZXIiLCJfb25EcmFnRHJvcCIsIl9vblBhc3RlIiwiX2hhbmRsZUZpbGVzIiwiX3Byb2Nlc3NGaWxlIiwiY2xpZW50WCIsImNsaWVudFkiLCJkYXRhVHJhbnNmZXIiLCJfcHJldmVudEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsInBhc3RlZERhdGEiLCJpbWFnZUZpbGUiLCJnZXRBc0ZpbGUiLCJiaW4iLCJ1c2VyQWdlbnQiLCJLRVlfQkFDSyIsIktFWV9DT01NQSIsIktFWV9TRU1JQ09MT04iLCJLRVlfU1BBQ0UiLCJERUxJTUlURVJTIiwiUkVHRVhfTEFTVF9XT1JEIiwiUkVHRVhfVVJMIiwiX29uS2V5VXAiLCJfZ2V0TGFzdFdvcmQiLCJwcmV2aW91c1RleHQiLCJfY3VycmVudEtleUNvZGUiLCJwcmV2aW91c05vZGUiLCJnZXRQcmV2aW91cyIsImxhc3RDaGlsZCIsImdldExhc3QiLCJfc3RhcnRDb250YWluZXIiLCJfb2Zmc2V0Iiwic3Vic3RyaW5nIiwibGFzdFdvcmQiLCJwb3AiLCJfaXNWYWxpZFVSTCIsIl9vbktleURvd24iLCJfY2tMaW5rIiwiX3JlcGxhY2VDb250ZW50QnlMaW5rIiwiY29udGVudCIsImNrTGluayIsImxpbmtOb2RlIiwiX3N1YnNjcmliZVRvS2V5RXZlbnQiLCJuZXh0RWRpdGFibGVOb2RlIiwiZ2V0TmV4dE5vZGUiLCJjYXJldE9mZnNldCIsImdldE5leHQiLCJuZXdSYW5nZSIsInNldEVuZEFmdGVyIiwiREVGQVVMVF9DT05GSUciLCJyZWdleCIsIl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8iLCJpbnNlcnRIdG1sIiwiYnVsbGV0IiwiX2dldExpc3RDb25maWciLCJjb25maWdSZWdleCIsImF1dG9saXN0IiwidGV4dENvbnRhaW5lciIsInJlZ2V4TGVuIiwiYXV0b2xpc3RDZmciLCJyZWdleEl0ZW0iLCJfY3JlYXRlTGlzdCIsImxpc3RDb25maWciLCJzZXRUZXh0IiwiSU1BR0VfSEFORExFUyIsImJvdGgiLCJzY2FsZSIsIlBPU0lUSU9OX0VMRU1FTlRfRk4iLCJibCIsImhhbmRsZSIsImJveCIsInBvc2l0aW9uRWxlbWVudCIsImJtIiwicm91bmQiLCJiciIsImxtIiwidGwiLCJ0bSIsInRyIiwicm0iLCJJTUFHRV9TTkFQX1RPX1NJWkUiLCJpc0ZpcmVmb3giLCJkb2N1bWVudEVsZW1lbnQiLCJpc1dlYktpdCIsImVuYWJsZVBsdWdpbiIsImFkZENzcyIsIm9uTG9hZCIsImV2dCIsInNuYXBUb1NpemUiLCJpbWFnZVNjYWxlUmVzaXplIiwicmVzaXplciIsIlJlc2l6ZXIiLCJtb3VzZURvd25MaXN0ZW5lciIsImUiLCJpc0hhbmRsZSIsImluaXREcmFnIiwiaGlkZSIsImh0bWwiLCJkYXRhVmFsdWUiLCJzZWxmIiwicmVzaXplRWxlbWVudCIsInJlc2l6ZVRpbWVvdXQiLCJjb250YWluZXIiLCJwcmV2aWV3IiwiaGFuZGxlcyIsImhhbmRsZU5hbWUiLCJjcmVhdGVIYW5kbGUiLCJuIiwiY2xhc3NMaXN0Iiwib3RoZXJJbWFnZXMiLCJ0b0FycmF5Iiwic3BsaWNlIiwiZ2V0Qm91bmRpbmdCb3giLCJzaG93SGFuZGxlcyIsImVsZW1lbnRzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImhpZGVIYW5kbGVzIiwiZHJhZyIsIkRyYWdFdmVudCIsIm9uU3RhcnQiLCJzaG93UHJldmlldyIsImlzRHJhZ2dpbmciLCJvbkRyYWciLCJjYWxjdWxhdGVTaXplIiwidXBkYXRlUHJldmlldyIsInByZXZpZXdCb3giLCJ1cGRhdGVIYW5kbGVzIiwib25SZWxlYXNlIiwiaGlkZVByZXZpZXciLCJvbkNvbXBsZXRlIiwicmVzaXplQ29tcGxldGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJkZWx0YSIsInJhdGlvIiwib3RoZXJzIiwib3RoZXIiLCJldmVudHMiLCJtb3VzZW1vdmUiLCJrZXlkb3duIiwibW91c2V1cCIsInN0YXJ0UG9zIiwiY3VycmVudFBvcyIsInNoaWZ0S2V5IiwiY3RybCIsImFsdCIsIndoaWNoIiwicmVsZWFzZSIsImN0eCIsIlN0cmluZyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiYWxpZ25tZW50c09iaiIsImNlbnRlciIsImN1cnNvciIsInJlZ2V4UGVyY2VudCIsImhpZHBpIiwiaWNvbnMiLCJ3aWRnZXREZWYiLCJ3aWRnZXRzIiwiaW5pdE9uIiwiYWxpZ25DbGFzc2VzIiwiaW1hZ2UyX2FsaWduQ2xhc3NlcyIsImNhcHRpb25lZENsYXNzIiwiaW1hZ2UyX2NhcHRpb25lZENsYXNzIiwiaGVscGVycyIsImltYWdlMiIsImhhc0NhcHRpb24iLCJjYXB0aW9uIiwicmVhZHkiLCJjaGVja0hhc05hdHVyYWxSYXRpbyIsIndyYXBwZXIiLCJhbGlnbiIsImFsaWduRWxlbWVudCIsInNldERhdGEiLCJpbWFnZTJfZGlzYWJsZVJlc2l6ZXIiLCJzZXR1cFJlc2l6ZXIiLCJnZXRTdHlsZWFibGVFbGVtZW50IiwiZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQiLCJjb250ZW50VHJhbnNmb3JtYXRpb25zIiwiZmVhdHVyZXMiLCJjaGVja0ZlYXR1cmUiLCJjb250ZW50ZWRpdGFibGUiLCJvbGREYXRhIiwiYyIsImNsYXNzZXMiLCJkaW1lbnNpb24iLCJzZXREaW1lbnNpb25zIiwiZG93bmNhc3QiLCJkb3duY2FzdFdpZGdldEVsZW1lbnQiLCJkcmFnZ2FibGUiLCJlZGl0YWJsZXMiLCJzZWxlY3RvciIsImdldFdpZGdldEZlYXR1cmVzIiwiZ2V0Q2xhc3NlcyIsImNsYXNzUmVnZXgiLCJSZWdFeHAiLCJyZXBvc2l0b3J5IiwicGFyc2VFbGVtZW50Q2xhc3NlcyIsImdldExhYmVsIiwicGF0aE5hbWUiLCJyZXF1aXJlZENvbnRlbnQiLCJzdHlsZWFibGVFbGVtZW50cyIsInVwY2FzdCIsInVwY2FzdFdpZGdldEVsZW1lbnQiLCJuYXR1cmFsIiwiZ2V0TmF0dXJhbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZGltZW5zaW9ucyIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaCIsImltZyIsIkltYWdlIiwiaGVpZ2giLCJpc0NlbnRlcldyYXBwZXIiLCJjZW50ZXJXcmFwcGVyQ2hlY2tlciIsImZpZ3VyZSIsInJlcGxhY2VXaXRoIiwiaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZSIsImQiLCJhdHRyc0hvbGRlciIsInJlc2l6ZVdyYXBwZXIiLCJwYXJzZUNzc1RleHQiLCJ3cmFwV2l0aCIsImh0bWxQYXJzZXIiLCJpc0VtcHR5Iiwid3JpdGVDc3NUZXh0IiwidmFsaWRDaGlsZHJlbiIsImRpdiIsInAiLCJjaGlsZCIsImVudGVyTW9kZSIsIkVOVEVSX1AiLCJ3aWRnZXQiLCJkb2MiLCJpbWFnZU9yTGluayIsIm9sZFJlc2l6ZVdyYXBwZXIiLCJmYWN0b3IiLCJzY3JlZW5YIiwic2NyZWVuWSIsInN0YXJ0V2lkdGgiLCJzdGFydEhlaWdodCIsImxpc3RlbmVycyIsImN1cnNvckNsYXNzIiwibmF0aXZlRXZ0IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJ1cGRhdGVEYXRhIiwibW92ZURpZmZYIiwibW92ZURpZmZZIiwibW92ZVJhdGlvIiwiYXR0YWNoVG9Eb2N1bWVudHMiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsImNvbGxlY3Rpb24iLCJnbG9iYWxEb2MiLCJsIiwicnVsZXMiLCJmaWdjYXB0aW9uIiwiUkVHRVhfSFRUUCIsIlJFR0VYX0RFRkFVTFRfTElOSyIsIlBST1ZJREVSUyIsIkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCIsIkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTCIsIkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCIsIkFFX0VNQkVEX1VSTF9UUEwiLCJlbWJlZFVybFRlbXBsYXRlIiwiQUVfRU1CRURfV0lER0VUX1RQTCIsImVtYmVkV2lkZ2V0VHBsIiwiQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCIsImVtYmVkTGlua0RlZmF1bHRUcGwiLCJkZWZhdWx0RW1iZWRXaWRnZXRVcGNhc3RGbiIsIm1hc2siLCJlbmNvZGVVUklDb21wb25lbnQiLCJjcmVhdGVBVGFnIiwic2V0SHRtbCIsIm1zZyIsImFUYWdIdG1sIiwiZW1iZWRXaWRnZXRVcGNhc3RGbiIsIndpZGdldEVsZW1lbnQiLCJzY3JvbGxQb3NpdGlvbiIsImFkZEVsZW1lbnRDYWxsYmFjayIsIkZJTFRFUl9TS0lQX1RSRUUiLCJJTUFHRV9BTElHTk1FTlQiLCJDRU5URVIiLCJMRUZUIiwiUklHSFQiLCJBTElHTl9WQUxVRVMiLCJDRU5URVJFRF9JTUFHRV9TVFlMRSIsImdldEltYWdlQWxpZ25tZW50IiwiaW1hZ2VBbGlnbm1lbnQiLCJjZW50ZXJlZEltYWdlIiwiZXZlcnkiLCJzdHlsZUNoZWNrIiwidmVuZG9yUHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXgiLCJyZW1vdmVJbWFnZUFsaWdubWVudCIsInNldEltYWdlQWxpZ25tZW50Iiwic2V0U3R5bGUiLCJhZnRlckluaXQiLCJyZWZyZXNoQ29tbWFuZHMiLCJUUklTVEFURV9PRkYiLCJyZWZyZXNoIiwiYWRkaW1hZ2VzIiwiYXV0b2xpbmsiLCJkcmFncmVzaXplIiwiZHJhZ3Jlc2l6ZWllIiwiaW1hZ2VhbGlnbm1lbnQiLCJwYXN0ZWltYWdlcyIsInNlbGVjdGlvbmtleXN0cm9rZXMiLCJ0YWJsZXJlc2l6ZSIsInRhYmxldG9vbHMiLCJickZpbGxlciIsIm5lZWRzQnJGaWxsZXIiLCJlbnRlck1vZGVFbXB0eVZhbHVlIiwiX2NoZWNrRW1wdHlEYXRhIiwiX3JlbW92ZVBsYWNlaG9sZGVyQ2xhc3MiLCJlZGl0YWJsZU5vZGUiLCJpbm5lckh0bWwiLCJ0cmltIiwiZWRpdG9yTm9kZSIsInNlbGVjdGlvbktleXN0cm9rZSIsInB4VW5pdCIsImNzc0xlbmd0aCIsImdldFdpZHRoIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldEJvcmRlcldpZHRoIiwic2lkZSIsImNvbXB1dGVkIiwiYm9yZGVyTWFwIiwidGhpbiIsIm1lZGl1bSIsInRoaWNrIiwiZ2V0TWFzdGVyUGlsbGFyUm93IiwiJHJvd3MiLCJtYXhDZWxscyIsImNlbGxzQ291bnQiLCIkZWxlY3RlZCIsIiR0ciIsImJ1aWxkVGFibGVDb2x1bW5QaWxsYXJzIiwicGlsbGFycyIsInBpbGxhckluZGV4IiwicnRsIiwidEJvZGllcyIsInRib2R5UG9zaXRpb24iLCJnZXREb2N1bWVudFBvc2l0aW9uIiwidGQiLCJuZXh0VGQiLCJjb2xTcGFuIiwicGlsbGFyTGVmdCIsInBpbGxhclJpZ2h0IiwicGlsbGFyV2lkdGgiLCJnZXRQaWxsYXJBdFBvc2l0aW9uIiwicG9zaXRpb25YIiwicGlsbGFyIiwiY29sdW1uUmVzaXplciIsImlzUmVzaXppbmciLCJjdXJyZW50U2hpZnQiLCJsZWZ0U2lkZUNlbGxzIiwicmlnaHRTaWRlQ2VsbHMiLCJsZWZ0U2hpZnRCb3VuZGFyeSIsInJpZ2h0U2hpZnRCb3VuZGFyeSIsIm9uTW91c2VEb3duIiwicmVzaXplU3RhcnQiLCJjb2x1bW5JbmRleCIsImJ1aWxkVGFibGVNYXAiLCJsZWZ0Q29sdW1uQ2VsbHMiLCJyaWdodENvbHVtbkNlbGxzIiwibGVmdE1pblNpemUiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJyaWdodE1pblNpemUiLCJsZWZ0Q2VsbCIsInJpZ2h0Q2VsbCIsInNldE9wYWNpdHkiLCJyZXNpemVFbmQiLCJyZXNpemVDb2x1bW4iLCJyZW1vdmVDdXN0b21EYXRhIiwibGVmdE9sZFdpZHRoIiwicmlnaHRPbGRXaWR0aCIsInRhYmxlV2lkdGgiLCJzaXplU2hpZnQiLCJtb3ZlIiwiZ2V0UGFnZU9mZnNldCIsImdldERvY3VtZW50RWxlbWVudCIsImF0dGFjaFRvIiwidGFyZ2V0UGlsbGFyIiwicG9zWCIsInJlc2l6ZXJOZXdQb3NpdGlvbiIsImNsZWFyUGlsbGFyc0NhY2hlIiwiZGVzdCIsInRvRWxlbWVudCIsImlzSW5saW5lIiwiZ2V0Q3VzdG9tRGF0YSIsInNldEN1c3RvbURhdGEiLCJjZWxsTm9kZVJlZ2V4IiwiZ2V0U2VsZWN0ZWRDZWxscyIsInJldHZhbCIsImRhdGFiYXNlIiwibW92ZU91dE9mQ2VsbEd1YXJkIiwic2V0TWFya2VyIiwibmVhcmVzdENlbGwiLCJ3YWxrZXIiLCJndWFyZCIsImR0ZCIsImNsZWFyQWxsTWFya2VycyIsImdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMiLCJjZWxsc1RvRGVsZXRlIiwibGFzdCIsImZvY3VzZWRDZWxsIiwiaW5zZXJ0Um93IiwiZ2V0RG9jdW1lbnQiLCJzdGFydFJvdyIsInN0YXJ0Um93SW5kZXgiLCJyb3dJbmRleCIsImxhc3RDZWxsIiwiZW5kUm93SW5kZXgiLCJyb3dTcGFuIiwiZW5kUm93IiwiY2xvbmVSb3ciLCJuZXh0Um93IiwibmV3Um93IiwiY2xvbmUiLCJpbnNlcnRBZnRlciIsImRlbGV0ZVJvd3MiLCJzZWxlY3Rpb25PclJvdyIsInJvd3NUb0RlbGV0ZSIsIm1hcFJvdyIsImNlbGxSb3dJbmRleCIsIm5leHRNYXBSb3ciLCJjdXJzb3JQb3NpdGlvbiIsImdldENlbGxDb2xJbmRleCIsImlzU3RhcnQiLCJyb3dDZWxscyIsImNvbEluZGV4IiwibWFwQ2VsbCIsImdldENvbHVtbnNJbmRpY2VzIiwiaW5zZXJ0Q29sdW1uIiwic3RhcnRDb2wiLCJsYXN0Q29sIiwiY2xvbmVDb2wiLCJuZXh0Q29sIiwibmV4dENlbGwiLCJkZWxldGVDb2x1bW5zIiwic2VsZWN0aW9uT3JDZWxsIiwic3RhcnRDb2xJbmRleCIsImVuZENvbEluZGV4IiwiZmlyc3RSb3dDZWxscyIsImluc2VydENlbGwiLCJzdGFydEVsZW1lbnQiLCJkZWxldGVDZWxscyIsImNlbGxUb0ZvY3VzIiwicGxhY2VDdXJzb3JJbkNlbGwiLCJ0cmltQ2VsbCIsImJvZ3VzIiwiZ2V0Qm9ndXMiLCJwbGFjZUF0RW5kIiwiZG9jSW5uZXIiLCJkb2NPdXRlciIsInZlcnNpb24iLCJjb2xsYXBzZSIsImNlbGxJblJvdyIsInRhYmxlTWFwIiwib1JvdyIsImNlbGxJbkNvbCIsIm9Db2wiLCJyIiwibWVyZ2VDZWxscyIsIm1lcmdlRGlyZWN0aW9uIiwiaXNEZXRlY3QiLCJjb21tb25BbmNlc3RvciIsIm1hcEhlaWdodCIsIm1hcFdpZHRoIiwic3RhcnRDb2x1bW4iLCJ0YXJnZXRDZWxsIiwicm93c3BhbiIsImNvbHNwYW4iLCJlciIsImxhc3RSb3dJbmRleCIsInRvdGFsUm93U3BhbiIsInRvdGFsQ29sU3BhbiIsImZyYWciLCJkb2N1bWVudEZyYWdtZW50IiwiY2VsbEZpcnN0Q2hpbGQiLCJnZXRDaGlsZHJlbiIsImNvdW50IiwiaXNCbG9ja0JvdW5kYXJ5Iiwid2hpdGVzcGFjZXMiLCJtb3ZlQ2hpbGRyZW4iLCJ0cnMiLCJub2RlTGlzdCIsInRhaWxUciIsInZlcnRpY2FsU3BsaXRDZWxsIiwibmV3Um93U3BhbiIsIm5ld0NlbGxSb3dTcGFuIiwibmV3Um93SW5kZXgiLCJjZWlsIiwibmV3Q2VsbFRyIiwibmV3Q2VsbFJvdyIsImNhbmRpZGF0ZUNlbGwiLCJjZWxsc0luU2FtZVJvdyIsImhvcml6b250YWxTcGxpdENlbGwiLCJuZXdDb2xTcGFuIiwibmV3Q2VsbENvbFNwYW4iLCJjZWxsc0luU2FtZUNvbCIsImNyZWF0ZURlZiIsImRlZiIsImNvbnRleHRTZW5zaXRpdmUiLCJ0aCIsIlRSSVNUQVRFX0RJU0FCTEVEIiwiYWRkQ21kIiwiY21kIiwiYWRkRmVhdHVyZSIsImFSb3dzIiwiYU1hcCIsIm9DZWxsIiwiaUNvbFNwYW4iLCJpUm93U3BhbiIsInJzIiwiY3MiLCJ0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyIsIkRFRkFVTFRfR1VUVEVSIiwiY2VudGVyVG9vbGJhciIsInRvb2xiYXJOb2RlIiwiaGFsZk5vZGVXaWR0aCIsIndpZGdldFhZIiwiaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvbiIsInRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb24iLCJfaXNSYW5nZUF0RWxlbWVudEVuZCIsImVtYmVkU2VsZWN0aW9uVGVzdCIsImxpbmtTZWxlY3Rpb25UZXN0IiwiaW1hZ2VTZWxlY3Rpb25UZXN0IiwidGV4dFNlbGVjdGlvblRlc3QiLCJzZWxlY3Rpb25FbXB0eSIsInRhYmxlU2VsZWN0aW9uVGVzdCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBOztBQUNBOztBQUVB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U0FBbEQsQ0FGVjtBQUdDd0MsVUFBTSx3QkFBY2lvQjtBQUhyQixDQWJnQixFQWlCaEI7QUFDQzVsQixVQUFNLE9BRFA7QUFFQzdFLGFBQVMsQ0FBQyxjQUFELEVBQWlCLFVBQWpCLEVBQTZCLGFBQTdCLEVBQTRDLFdBQTVDLEVBQXlELGFBQXpELENBRlY7QUFHQzJtQix3QkFBb0IsNEJBQTRCcEUsS0FIakQ7QUFJQ3lGLGlCQUFhLDRCQUFxQnpGLEtBSm5DO0FBS0MvZixVQUFNLHdCQUFjK2Y7QUFMckIsQ0FqQmdCLENBQW5COztrQkF5QmUvZSxVOzs7Ozs7Ozs7OztBQzdCZixhQUFhLG9DQUFvQyxFQUFFLEk7Ozs7Ozs7Ozs7O0FDQW5ELGFBQWEsb0NBQW9DLEVBQUUsSSIsImZpbGUiOiJhbGxveS1lZGl0b3ItY29yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9hZGFwdGVyL21haW4uanNcIik7XG4iLCJpbXBvcnQgJy4uL2NvcmUnO1xuaW1wb3J0ICcuLi9wbHVnaW5zJztcblxuaW1wb3J0ICcuLi9jb21wb25lbnRzL3VpYnJpZGdlL3VpYnJpZGdlLmpzJztcblxuaW1wb3J0IGV4dGVuZCBmcm9tICcuLi9vb3Avb29wJztcbmltcG9ydCBMYW5nIGZyb20gJy4uL29vcC9sYW5nJztcbmltcG9ydCBCYXNlIGZyb20gJy4uL29vcC9iYXNlJztcbmltcG9ydCBTZWxlY3Rpb25zIGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9ucyc7XG5pbXBvcnQgVUkgZnJvbSAnLi4vY29tcG9uZW50cy9tYWluLmpzeCc7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuLyoqXG4gKiBBbGxveUVkaXRvciBtYWluIGNsYXNzLiBDcmVhdGVzIGluc3RhbmNlIG9mIHRoZSBlZGl0b3IgYW5kIHByb3ZpZGVzIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAqIHRvIHRoZSBVSS5cbiAqXG4gKiBAY2xhc3MgQ29yZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvcmUoY29uZmlnKSB7XG4gICAgQ29yZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY29uZmlnKTtcbn1cblxuZXh0ZW5kKENvcmUsIEJhc2UsIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBBbGxveUVkaXRvciBjbGFzcy4gQ3JlYXRlcyBhIENLRWRpdG9yXG4gICAgICogaW5zdGFuY2UsIHBhc3NpbmcgaXQgdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZXJcbiAgICAgKiBAcGFyYW0gY29uZmlnIHtPYmplY3R9IENvbmZpZ3VyYXRpb24gb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZXI6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0KCdzcmNOb2RlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdlbmFibGVDb250ZW50RWRpdGFibGUnKSkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICd0cnVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRpdG9yID0gQ0tFRElUT1IuaW5saW5lKG5vZGUpO1xuXG4gICAgICAgIGVkaXRvci5jb25maWcuYWxsb3dlZENvbnRlbnQgPSB0aGlzLmdldCgnYWxsb3dlZENvbnRlbnQnKTtcblxuICAgICAgICBlZGl0b3IuY29uZmlnLnRvb2xiYXJzID0gdGhpcy5nZXQoJ3Rvb2xiYXJzJyk7XG5cbiAgICAgICAgZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zID0gdGhpcy5nZXQoJ3JlbW92ZVBsdWdpbnMnKTtcbiAgICAgICAgZWRpdG9yLmNvbmZpZy5leHRyYVBsdWdpbnMgPSB0aGlzLmdldCgnZXh0cmFQbHVnaW5zJyk7XG4gICAgICAgIGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyA9IHRoaXMuZ2V0KCdwbGFjZWhvbGRlckNsYXNzJyk7XG5cbiAgICAgICAgZWRpdG9yLmNvbmZpZy5wYXN0ZUZyb21Xb3JkUmVtb3ZlU3R5bGVzID0gZmFsc2U7XG4gICAgICAgIGVkaXRvci5jb25maWcucGFzdGVGcm9tV29yZFJlbW92ZUZvbnRTdHlsZXMgPSBmYWxzZTtcblxuICAgICAgICBlZGl0b3IuY29uZmlnLnNlbGVjdGlvbktleXN0cm9rZXMgPSB0aGlzLmdldCgnc2VsZWN0aW9uS2V5c3Ryb2tlcycpO1xuXG4gICAgICAgIExhbmcubWl4KGVkaXRvci5jb25maWcsIGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKENLRURJVE9SLmVudi5pZSAmJiAhQ0tFRElUT1IuZW52LmVkZ2UpIHtcbiAgICAgICAgICAgIGVkaXRvci5jb25maWcuZXh0cmFQbHVnaW5zID0gZWRpdG9yLmNvbmZpZy5leHRyYVBsdWdpbnMucmVwbGFjZSgnYWVfZHJhZ3Jlc2l6ZScsICdhZV9kcmFncmVzaXplX2llJyk7XG4gICAgICAgICAgICBlZGl0b3IuY29uZmlnLnJlbW92ZVBsdWdpbnMgPSBlZGl0b3IuY29uZmlnLnJlbW92ZVBsdWdpbnMucmVwbGFjZSgnYWVfZHJhZ3Jlc2l6ZScsICdhZV9kcmFncmVzaXplX2llJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB0aGlzLl9hZGRSZWFkT25seUxpbmtDbGlja0xpc3RlbmVyKGVkaXRvcik7XG5cbiAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICBlZGl0YWJsZS5hZGRDbGFzcygnYWUtZWRpdGFibGUnKTtcblxuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICBBbGxveUVkaXRvci5sb2FkTGFuZ3VhZ2VSZXNvdXJjZXModGhpcy5fcmVuZGVyVUkuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IgbGlmZWN5Y2xlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgQWxsb3lFZHRvciBjbGFzcy4gRGVzdHJveXMgdGhlIENLRWRpdG9yXG4gICAgICogaW5zdGFuY2UgYW5kIGRlc3Ryb3lzIGFsbCBjcmVhdGVkIHRvb2xiYXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBkZXN0cnVjdG9yXG4gICAgICovXG4gICAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VkaXRvclVJRWxlbWVudCkge1xuICAgICAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLl9lZGl0b3JVSUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fZWRpdG9yVUlFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWRpdG9yVUlFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgaWYgKG5hdGl2ZUVkaXRvcikge1xuICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gbmF0aXZlRWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgIGlmIChlZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlLnJlbW92ZUNsYXNzKCdhZS1lZGl0YWJsZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KCdlbmFibGVDb250ZW50RWRpdGFibGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldCgnc3JjTm9kZScpLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGVjdGlvbnMoKTtcblxuICAgICAgICAgICAgbmF0aXZlRWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHNlbGVjdGlvbnMgZnJvbSB3aW5kb3cgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9jbGVhclNlbGVjdGlvbnNcbiAgICAgKi9cbiAgICBfY2xlYXJTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUVkaXRvciA9IHRoaXMuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIGlzTVNTZWxlY3Rpb24gPSB0eXBlb2Ygd2luZG93LmdldFNlbGVjdGlvbiAhPSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIGlmIChpc01TU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBuYXRpdmVFZGl0b3IuZG9jdW1lbnQuJC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hdGl2ZUVkaXRvci5kb2N1bWVudC5nZXRXaW5kb3coKS4kLmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBzZXQgZGVmYXVsdCBsaW5rIGJlaGF2aW9yXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9hZGRSZWFkT25seUxpbmtDbGlja0xpc3RlbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvclxuICAgICAqL1xuICAgIF9hZGRSZWFkT25seUxpbmtDbGlja0xpc3RlbmVyOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgZWRpdG9yLmVkaXRhYmxlKCkub24oJ2NsaWNrJywgdGhpcy5fZGVmYXVsdFJlYWRPbmx5Q2xpY2tGbiwgdGhpcywge1xuICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBgY2xpY2tgIGV2ZW50IHdoZW4gdGhlIGVkaXRvciBpcyBpbiByZWFkIG9ubHkgbW9kZS4gTmF2aWdhdGVzIHRvIGxpbmsncyBVUkwgb3Igb3BlbnNcbiAgICAgKiB0aGUgbGluayBpbiBhIG5ldyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBldmVudCByZWFkT25seUNsaWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX2RlZmF1bHRSZWFkT25seUNsaWNrRm5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGZpcmVkIGBjbGlja2AgZXZlbnQgcGF5bG9hZFxuICAgICAqL1xuICAgIF9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgbW91c2VFdmVudCA9IGV2ZW50LmRhdGEuJDtcbiAgICAgICAgdmFyIGhhc0N0cmxLZXkgPSBtb3VzZUV2ZW50LmN0cmxLZXkgfHwgbW91c2VFdmVudC5tZXRhS2V5O1xuICAgICAgICB2YXIgc2hvdWxkT3BlbiA9IHRoaXMuX2VkaXRvci5jb25maWcucmVhZE9ubHkgfHwgaGFzQ3RybEtleTtcblxuICAgICAgICBtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFzaG91bGRPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvci5lZGl0YWJsZSgpLmVkaXRvci5maXJlKCdyZWFkT25seUNsaWNrJywgZXZlbnQuZGF0YSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgY2tFbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50UGF0aChldmVudC5kYXRhLmdldFRhcmdldCgpLCB0aGlzKTtcbiAgICAgICAgICAgIHZhciBsaW5rID0gY2tFbGVtZW50Lmxhc3RFbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gbGluay4kLmF0dHJpYnV0ZXMuaHJlZiA/IGxpbmsuJC5hdHRyaWJ1dGVzLmhyZWYudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBoYXNDdHJsS2V5ID8gJ19ibGFuaycgOiBsaW5rLiQuYXR0cmlidXRlcy50YXJnZXQgPyBsaW5rLiQuYXR0cmlidXRlcy50YXJnZXQudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZGlyZWN0TGluayhocmVmLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbmF0aXZlIENLRWRpdG9yIGluc3RhbmNlLiBIYXZpbmcgdGhpcywgdGhlIGRldmVsb3BlciBtYXkgdXNlIHRoZSBBUEkgb2YgQ0tFZGl0b3IgT09UQi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX2dldE5hdGl2ZUVkaXRvclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgQ0tFZGl0b3IuXG4gICAgICovXG4gICAgX2dldE5hdGl2ZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZGl0b3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZGlyZWN0cyB0aGUgYnJvd3NlciB0byBhIGdpdmVuIGxpbmtcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX3JlZGlyZWN0TGlua1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFRoZSBocmVmIHRvIHRha2UgdGhlIGJyb3dzZXIgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRhcmdldCBTcGVjaWZpZXMgd2hlcmUgdG8gZGlzcGxheSB0aGUgbGlua1xuICAgICAqL1xuICAgIF9yZWRpcmVjdExpbms6IGZ1bmN0aW9uKGhyZWYsIHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ICYmIGhyZWYpIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHJlZikge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNwZWNpZmllZCBmcm9tIHRoZSB1c2VyIHRvb2xiYXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfcmVuZGVyVUlcbiAgICAgKi9cbiAgICBfcmVuZGVyVUk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgdmFyIGVkaXRvclVJRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZWRpdG9yVUlFbGVtZW50LmNsYXNzTmFtZSA9ICdhZS11aSc7XG5cbiAgICAgICAgICAgIHZhciB1aU5vZGUgPSB0aGlzLmdldCgndWlOb2RlJykgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgICAgICAgICAgdWlOb2RlLmFwcGVuZENoaWxkKGVkaXRvclVJRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuX21haW5VSSA9IFJlYWN0RE9NLnJlbmRlcig8VUlcbiAgICAgICAgICAgICAgICBlZGl0b3I9e3RoaXN9XG4gICAgICAgICAgICAgICAgZXZlbnRzRGVsYXk9e3RoaXMuZ2V0KCdldmVudHNEZWxheScpfVxuICAgICAgICAgICAgICAgIHRvb2xiYXJzPXt0aGlzLmdldCgndG9vbGJhcnMnKX0gLz4sIGVkaXRvclVJRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2VkaXRvclVJRWxlbWVudCA9IGVkaXRvclVJRWxlbWVudDtcblxuICAgICAgICAgICAgdGhpcy5nZXQoJ25hdGl2ZUVkaXRvcicpLmZpcmUoJ3VpUmVhZHknKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhbiBIVE1MIGVsZW1lbnQgZnJvbSB0aGUgcGFzc2VkIHZhbHVlLiBJZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBzaG91bGQgYmVcbiAgICAgKiB0aGUgSWQgb2YgdGhlIGVsZW1lbnQgd2hpY2ggaGF2ZSB0byBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAqIElmIGFuIEhUTUwgRWxlbWVudCBpcyBwYXNzZWQsIHRoZSBlbGVtZW50IGl0c2VsZiB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIF90b0VsZW1lbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHshKFN0cmluZ3xIVE1MRWxlbWVudCl9IHZhbHVlIFN0cmluZywgd2hpY2ggaGF2ZSB0byBjb3JyZXNwb25kIHRvIGFuIEhUTUwgZWxlbWVudCBmcm9tIHRoZSBET00sXG4gICAgICogb3IgdGhlIEhUTUwgZWxlbWVudCBpdHNlbGYuIElmIElkIGlzIHBhc3NlZCwgdGhlIEhUTUwgZWxlbWVudCB3aWxsIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBET00uXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEFuIEhUTUwgZWxlbWVudC5cbiAgICAgKi9cbiAgICBfdG9FbGVtZW50OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoTGFuZy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGFsbG93ZWQgY29udGVudCBhdHRyaWJ1dGUuIExvb2tcbiAgICAgKiBbaGVyZV0oaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5jb25maWctY2ZnLWFsbG93ZWRDb250ZW50KSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgICAgKiBzdXBwb3J0ZWQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfdmFsaWRhdGVBbGxvd2VkQ29udGVudFxuICAgICAqIEBwYXJhbSB7QW55fSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgdmFsaWQgY29uZmlndXJhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlQWxsb3dlZENvbnRlbnQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBMYW5nLmlzU3RyaW5nKHZhbHVlKSB8fCBMYW5nLmlzT2JqZWN0KHZhbHVlKSB8fCBMYW5nLmlzQm9vbGVhbih2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgdmFsdWUgb2YgdG9vbGJhcnMgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF92YWxpZGF0ZVRvb2xiYXJzXG4gICAgICogQHBhcmFtIHtBbnl9IFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyB2YWxpZCB0b29sYmFycyBjb25maWd1cmF0aW9uLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBfdmFsaWRhdGVUb29sYmFyczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIExhbmcuaXNPYmplY3QodmFsdWUpIHx8IExhbmcuaXNOdWxsKHZhbHVlKTtcbiAgICB9XG59LCB7XG4gICAgQVRUUlM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhlIGFsbG93ZWQgY29udGVudCBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgQWxsb3lFZGl0b3IuXG4gICAgICAgICAqIExvb2sgb24gdGhlIFtvZmZpY2lhbCBDS0VkaXRvciBBUEldKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1IuY29uZmlnLWNmZy1hbGxvd2VkQ29udGVudClcbiAgICAgICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZhbGlkIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhbGxvd2VkQ29udGVudFxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW4sIFN0cmluZywgT2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgYWxsb3dlZENvbnRlbnQ6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJ192YWxpZGF0ZUFsbG93ZWRDb250ZW50JyxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIEFsbG95RWRpdG9yIHNldCB0aGUgY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZVxuICAgICAgICAgKiB0byBcInRydWVcIiBvbiBpdHMgc3JjTm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlbmFibGVDb250ZW50RWRpdGFibGVcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZUNvbnRlbnRFZGl0YWJsZToge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBMYW5nLmlzQm9vbGVhbixcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxheSAodGltZW91dCksIGluIG1zLCBhZnRlciB3aGljaCBldmVudHMgc3VjaCBsaWtlIGtleSBvciBtb3VzZSBldmVudHMgd2lsbCBiZSBwcm9jZXNzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgZXZlbnRzRGVsYXlcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50c0RlbGF5OiB7XG4gICAgICAgICAgICB2YWxpZGF0b3I6IExhbmcuaXNOdW1iZXIsXG4gICAgICAgICAgICB2YWx1ZTogMTAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZXh0cmEgcGx1Z2lucyB3aGljaCBoYXZlIHRvIGJlIGxvYWRlZCB0byB0aGUgY3VycmVudCBDS0VkaXRvciBpbnN0YW5jZSBpbiBvcmRlciB0b1xuICAgICAgICAgKiBtYWtlIEFsbG95RWRpdG9yIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgZXh0cmFQbHVnaW5zXG4gICAgICAgICAqIEBkZWZhdWx0ICd1aWNvcmUsc2VsZWN0aW9ucmVnaW9uLGRyYWdyZXNpemUsYWRkaW1hZ2VzLHBsYWNlaG9sZGVyLHRhYmxldG9vbHMsdGFibGVyZXNpemUsYXV0b2xpbmsnXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGV4dHJhUGx1Z2luczoge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6ICdhZV91aWNvcmUsYWVfc2VsZWN0aW9ucmVnaW9uLGFlX3NlbGVjdGlvbmtleXN0cm9rZXMsYWVfaW1hZ2VhbGlnbm1lbnQsYWVfYWRkaW1hZ2VzLGFlX3BsYWNlaG9sZGVyLCcgK1xuICAgICAgICAgICAgICAgICdhZV90YWJsZXRvb2xzLGFlX3RhYmxlcmVzaXplLGFlX2F1dG9saW5rLGFlX2VtYmVkLGFlX2F1dG9saXN0LGFlX2RyYWdyZXNpemUsJyArXG4gICAgICAgICAgICAgICAgJ2FlX3VpYnJpZGdlJyxcbiAgICAgICAgICAgICAgICAvLydhZV91aWJyaWRnZSxhZV9yaWNoY29tYm9icmlkZ2UsYWVfcGFuZWxtZW51YnV0dG9uYnJpZGdlLGFlX21lbnVicmlkZ2UsYWVfbWVudWJ1dHRvbmJyaWRnZSxhZV9idXR0b25icmlkZ2UnLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgbmF0aXZlIENLRWRpdG9yIGluc3RhbmNlLiBIYXZpbmcgdGhpcywgdGhlIGRldmVsb3BlciBtYXkgdXNlIHRoZSBmdWxsIEFQSSBvZiBDS0VkaXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBuYXRpdmVFZGl0b3JcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBuYXRpdmVFZGl0b3I6IHtcbiAgICAgICAgICAgIGdldHRlcjogJ19nZXROYXRpdmVFZGl0b3InLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBjbGFzcywgd2hpY2ggc2hvdWxkIGJlIGFkZGVkIGJ5IFBsYWNlaG9sZGVyIHBsdWdpblxuICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3BsYWNlaG9sZGVyfX17ey9jcm9zc0xpbmt9fVxuICAgICAgICAgKiB3aGVuIGVkaXRvciBpcyBub3QgZm9jdXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBwbGFjZWhvbGRlckNsYXNzXG4gICAgICAgICAqIEBkZWZhdWx0ICdhZS1wbGFjZWhvbGRlcidcbiAgICAgICAgICogQHdyaXRlT25jZVxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgcGxhY2Vob2xkZXJDbGFzczoge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6ICdhZS1wbGFjZWhvbGRlcicsXG4gICAgICAgICAgICB3cml0ZU9uY2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBwbHVnaW5zLCB3aGljaCBjb21lIGJ5IGRlZmF1bHQgd2l0aCBDS0VkaXRvciwgYnV0IHdoaWNoIGFyZSBub3QgbmVlZGVkIGJ5IEFsbG95RWRpdG9yLlxuICAgICAgICAgKiBUaGVzZSBwbHVnaW5zIGFkZCB0aGUgZGVmYXVsdCBVSSBmb3IgQ0tlZGl0b3IsIHdoaWNoIGlzIG5vIG1vcmUgbmVlZGVkLiBQbGVhc2Ugbm90ZSB0aGF0IEFsbG95RWR0b3JcbiAgICAgICAgICogY29tZXMgd2l0aCBpdHMgb3duIGhpZ2hseSBvcHRpbWl6ZWQgY29weSBvZiBDS0VkaXRvciAoanVzdCBjdXN0b21pemVkIHZpYSB0aGVpciBvZmZpY2lhbCBkb3dubG9hZCBwYWdlKS5cbiAgICAgICAgICogVGhpcyB2ZXJzaW9uIGRvZXMgbm90IGNvbWUgd2l0aCB0aGUgdW5uZWVkZWQgcGx1Z2lucywgc28gdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgd29uJ3QgYmUgbmVlZGVkLlxuICAgICAgICAgKiBIb3dldmVyLCBpZiB5b3UgZGVjaWRlIHRvIGdvIHdpdGggdGhlIE9PVEIgdmVyc2lvbiBvZiBDS0VkaXRvciwgeW91IHdpbGwgaGF2ZSB0byByZW1vdmUgc29tZSBvZiB0aGVcbiAgICAgICAgICogcGx1Z2lucyBpZiB5b3UgZGVjaWRlIHRvIHVzZSBBbGxveUVkaXRvci4gS2VlcCBpbiBtaW5kIHRoYXQgcmVtb3ZpbmcgdGhlc2UgcGx1Z2lucyBkb2Vzbid0IHJlbW92ZSB0aGVtXG4gICAgICAgICAqIGVudGlyZWx5IGZyb20gQ0tFZGl0b3IuIEl0IGp1c3QgcmVtb3ZlcyB0aGVtIGZyb20gaXRzIGN1cnJlbnQgaW5zdGFuY2UsIGluIHdoaWNoIHlvdSB3aWxsIHVzZSBkaWZmZXJlbnRcbiAgICAgICAgICogVUkgLSB0aG9zZSBvZiBBbGxveUVkaXRvci4gWW91IHdpbGwgYmUgZnVsbHkgYWJsZSB0byB1c2UgYm90aCBPT1RCIENLRWRpdG9yIGFuZCBBbGxveUVkaXRvciBvbiB0aGUgc2FtZVxuICAgICAgICAgKiBwYWdlIVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IHJlbW92ZVBsdWdpbnNcbiAgICAgICAgICogQGRlZmF1bHQgJ2NvbnRleHRtZW51LHRvb2xiYXIsZWxlbWVudHNwYXRoLHJlc2l6ZSxsaXN0c3R5bGUsbGluaydcbiAgICAgICAgICogQHdyaXRlT25jZVxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlUGx1Z2luczoge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6ICdjb250ZXh0bWVudSx0b29sYmFyLGVsZW1lbnRzcGF0aCxyZXNpemUsbGlzdHN0eWxlLGxpbmsnLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IG9mIG1hbnVhbCBzZWxlY3Rpb24gdHJpZ2dlcnMuIFRoZXkgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gbWFudWFsbHkgc2hvdyBhIHNwZWNpZmljIHNlbGVjdGlvbiB0b29sYmFyXG4gICAgICAgICAqIGJ5IGZvcmNpbmcgdGhlIHNlbGVjdGlvbiB0eXBlLiBBIHNlbGVjdGlvbktleXN0cm9rZSBpdGVtIGNvbnNpc3RzIG9mIGEga2V5cyBwcm9wZXJ0eSB3aXRoIGEgW0NLRWRpdG9yIGtleXN0cm9rZVxuICAgICAgICAgKiBkZWZpbml0aW9uXShodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLmNvbmZpZy1jZmcta2V5c3Ryb2tlcykgYW5kIGEgc2VsZWN0aW9uIHByb3BlcnR5IHdpdGhcbiAgICAgICAgICogdGhlIHNlbGVjdGlvbiBuYW1lIHRvIHRyaWdnZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgc2VsZWN0aW9uS2V5c3Ryb2tlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25LZXlzdHJva2VzOiB7XG4gICAgICAgICAgICB2YWxpZGF0b3I6IExhbmcuaXNBcnJheSxcbiAgICAgICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA3NiAvKkwqLyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246ICdsaW5rJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyBDS0VESVRPUi5TSElGVCArIDc2IC8qTCovLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogJ2VtYmVkJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIE5vZGUgSUQgb3IgSFRNbCBub2RlLCB3aGljaCBBbGxveUVkaXRvciBzaG91bGQgdXNlIGFzIGFuIGVkaXRhYmxlIGFyZWEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcHJvcGVydHkgc3JjTm9kZVxuICAgICAgICAgKiBAdHlwZSBTdHJpbmcgfCBOb2RlXG4gICAgICAgICAqIEB3cml0ZU9uY2VcbiAgICAgICAgICovXG4gICAgICAgIHNyY05vZGU6IHtcbiAgICAgICAgICAgIHNldHRlcjogJ190b0VsZW1lbnQnLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b29sYmFycyBjb25maWd1cmF0aW9uIGZvciB0aGlzIGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IHRvb2xiYXJzXG4gICAgICAgICAqL1xuICAgICAgICB0b29sYmFyczoge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiAnX3ZhbGlkYXRlVG9vbGJhcnMnLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBhZGQ6IHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogWydpbWFnZScsICdlbWJlZCcsICdjYW1lcmEnLCAnaGxpbmUnLCAndGFibGUnXSxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IDJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiBTZWxlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIE5vZGUgSUQgb3IgSFRNbCBub2RlLCB3aGVyZSBBbGxveUVkaXRvcidzIFVJIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB1aU5vZGVcbiAgICAgICAgICogQHR5cGUgU3RyaW5nIHwgTm9kZVxuICAgICAgICAgKiBAd3JpdGVPbmNlXG4gICAgICAgICAqL1xuICAgICAgICB1aU5vZGU6IHtcbiAgICAgICAgICAgIHNldHRlcjogJ190b0VsZW1lbnQnLFxuICAgICAgICAgICAgd3JpdGVPbmNlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuQ0tFRElUT1IuZXZlbnQuaW1wbGVtZW50T24oQ29yZSk7XG5cbmV4cG9ydCBkZWZhdWx0IENvcmU7XG4iLCJpbXBvcnQgQ29yZSBmcm9tICcuL2NvcmUuanMnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vb29wL2xhbmcuanMnO1xuXG5pbXBvcnQgQnV0dG9ucyBmcm9tICcuLi9jb21wb25lbnRzL2J1dHRvbnMnO1xuaW1wb3J0IFRvb2xiYXJzIGZyb20gJy4uL2NvbXBvbmVudHMvdG9vbGJhcnMnO1xuXG5pbXBvcnQgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzIGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9uLWFycm93Ym94JztcbmltcG9ydCBTZWxlY3Rpb25zIGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9ucyc7XG5pbXBvcnQgU2VsZWN0aW9uU2V0UG9zaXRpb24gZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tcG9zaXRpb24nO1xuaW1wb3J0IFNlbGVjdGlvblRlc3QgZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdCc7XG5cbmltcG9ydCBBdHRyaWJ1dGUgZnJvbSAnLi4vb29wL2F0dHJpYnV0ZSc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4uL29vcC9vb3AnO1xuXG4vLyBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgY3VycmVudGx5IHJlZ2lzdGVyZWQgcGx1Z2lucyBpbiBBbGxveUVkaXRvci5cbnZhciBCUklER0VfQlVUVE9OUyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQWxsb3lFZGl0b3IuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGVkaXRhYmxlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBub2RlIFRoZSBOb2RlIElEIG9yIEhUTWwgbm9kZSwgd2hpY2ggQWxsb3lFZGl0b3Igc2hvdWxkIHVzZSBhcyBhbiBlZGl0YWJsZSBhcmVhLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIEFsbG95RWRpdG9yLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJDb3JlXCJ9fXt7L2Nyb3NzTGlua319XG4gKi9cbmNvbnN0IGVkaXRhYmxlID0gZnVuY3Rpb24obm9kZSwgY29uZmlnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbmZpZy5zcmNOb2RlID0gbm9kZTtcblxuICAgIEFsbG95RWRpdG9yLmltcGxlbWVudEV2ZW50VGFyZ2V0KCk7XG5cbiAgICByZXR1cm4gbmV3IENvcmUoY29uZmlnKTtcbn07XG5cbi8qKlxuICogVGhlIGZ1bGwgVVJMIGZvciB0aGUgQWxsb3lFZGl0b3IgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeS5cbiAqIEl0IGlzIHBvc3NpYmxlIHRvIG1hbnVhbGx5IHByb3ZpZGUgdGhlIGJhc2UgcGF0aCBieSBzZXR0aW5nIGFcbiAqIGdsb2JhbCB2YXJpYWJsZSBuYW1lZCBgQUxMT1lFRElUT1JfQkFTRVBBVEhgLiBUaGlzIGdsb2JhbCB2YXJpYWJsZVxuICogbXVzdCBiZSBzZXQgKipiZWZvcmUqKiB0aGUgZWRpdG9yIHNjcmlwdCBsb2FkaW5nLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBnZXRCYXNlUGF0aFxuICogQHN0YXRpY1xuICogQHJldHVybiB7U3RyaW5nfSBUaGUgZm91bmQgYmFzZSBwYXRoXG4gKi9cbmNvbnN0IGdldEJhc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gRmluZCBvdXQgdGhlIGVkaXRvciBkaXJlY3RvcnkgcGF0aCwgYmFzZWQgb24gaXRzIDxzY3JpcHQ+IHRhZy5cbiAgICB2YXIgcGF0aCA9IHdpbmRvdy5BTExPWUVESVRPUl9CQVNFUEFUSCB8fCAnJztcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHNjcmlwdHNbIGkgXS5zcmMubWF0Y2goQWxsb3lFZGl0b3IucmVnZXhCYXNlUGF0aCk7XG5cblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW4gSUUgKG9ubHkpIHRoZSBzY3JpcHQuc3JjIHN0cmluZyBpcyB0aGUgcmF3IHZhbHVlIGVudGVyZWQgaW4gdGhlXG4gICAgLy8gSFRNTCBzb3VyY2UuIE90aGVyIGJyb3dzZXJzIHJldHVybiB0aGUgZnVsbCByZXNvbHZlZCBVUkwgaW5zdGVhZC5cbiAgICBpZiAocGF0aC5pbmRleE9mKCc6LycpID09PSAtMSAmJiBwYXRoLnNsaWNlKDAsIDIpICE9PSAnLy8nICkge1xuICAgICAgICAvLyBBYnNvbHV0ZSBwYXRoLlxuICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgICAgIHBhdGggPSBsb2NhdGlvbi5ocmVmLm1hdGNoKC9eLio/OlxcL1xcL1teXFwvXSovKVswXSArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsYXRpdmUgcGF0aC5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gbG9jYXRpb24uaHJlZi5tYXRjaCgvXlteXFw/XSpcXC8oPzopLylbMF0gKyBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoKXtcbiAgICAgICAgdGhyb3cgJ1RoZSBBbGxveUVkaXRvciBpbnN0YWxsYXRpb24gcGF0aCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBkZXRlY3RlZC4gUGxlYXNlIHNldCB0aGUgZ2xvYmFsIHZhcmlhYmxlIFwiQUxMT1lFRElUT1JfQkFTRVBBVEhcIiBiZWZvcmUgY3JlYXRpbmcgZWRpdG9yIGluc3RhbmNlcy4nO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBEZXRlY3RzIGFuZCBsb2FkIHRoZSBjb3JyZXNwb25kaW5nIGxhbmd1YWdlIGZpbGUgaWYgQWxsb3lFZGl0b3IgbGFuZ3VhZ2Ugc3RyaW5ncyBhcmUgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqIFRoZSBmdW5jdGlvbiBmaXJlcyBhIHt7I2Nyb3NzTGluayBcIkFsbG95RWRpdG9yL2xhbmd1YWdlUmVzb3VyY2VzTG9hZGVkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50XG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGxvYWRMYW5ndWFnZVJlc291cmNlc1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gQWxsb3lFZGl0b3IgbG9hZHMgdGhlIGxhbmd1YWdlIHJlc291cmNlLlxuICovXG5jb25zdCBsb2FkTGFuZ3VhZ2VSZXNvdXJjZXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIEFsbG95RWRpdG9yLmltcGxlbWVudEV2ZW50VGFyZ2V0KCk7XG5cbiAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICBpZiAoQWxsb3lFZGl0b3IuU3RyaW5ncykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBbGxveUVkaXRvci5vbmNlKCdsYW5ndWFnZVJlc291cmNlc0xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIUFsbG95RWRpdG9yLl9sYW5nUmVzb3VyY2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgQWxsb3lFZGl0b3IuX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlcyA9IFsnYWYnLCAnYXInLCAnYmcnLCAnYm4nLCAnYnMnLCAnY2EnLCAnY3MnLCAnY3knLCAnZGEnLCAnZGUnLCAnZWwnLCAnZW4tYXUnLCAnZW4tY2EnLCAnZW4tZ2InLCAnZW4nLCAnZW8nLCAnZXMnLCAnZXQnLCAnZXUnLCAnZmEnLCAnZmknLCAnZm8nLCAnZnItY2EnLCAnZnInLCAnZ2wnLCAnZ3UnLCAnaGUnLCAnaGknLCAnaHInLCAnaHUnLCAnaWQnLCAnaXMnLCAnaXQnLCAnamEnLCAna2EnLCAna20nLCAna28nLCAna3UnLCAnbHQnLCAnbHYnLCAnbWsnLCAnbW4nLCAnbXMnLCAnbmInLCAnbmwnLCAnbm8nLCAncGwnLCAncHQtYnInLCAncHQnLCAncm8nLCAncnUnLCAnc2knLCAnc2snLCAnc2wnLCAnc3EnLCAnc3ItbGF0bicsICdzcicsICdzdicsICd0aCcsICd0cicsICd0dCcsICd1ZycsICd1aycsICd2aScsICd6aC1jbicsICd6aCddO1xuXG4gICAgICAgIHZhciB1c2VyTGFuZ3VhZ2UgPSBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fCAnZW4nO1xuXG4gICAgICAgIHZhciBwYXJ0cyA9IHVzZXJMYW5ndWFnZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oW2Etel0rKSg/Oi0oW2Etel0rKSk/Lyk7XG4gICAgICAgIHZhciBsYW5nID0gcGFydHNbMV07XG4gICAgICAgIHZhciBsb2NhbGUgPSBwYXJ0c1syXTtcblxuICAgICAgICBpZiAobGFuZ3VhZ2VzLmluZGV4T2YobGFuZyArICctJyArIGxvY2FsZSkgPj0gMCkge1xuICAgICAgICAgICAgbGFuZyA9IGxhbmcgKyAnLScgKyBsb2NhbGU7XG4gICAgICAgIH0gZWxzZSBpZiAobGFuZ3VhZ2VzLmluZGV4T2YobGFuZykgPT09IC0xKSB7XG4gICAgICAgICAgICBsYW5nID0gJ2VuJztcbiAgICAgICAgfVxuXG4gICAgICAgIENLRURJVE9SLnNjcmlwdExvYWRlci5sb2FkKEFsbG95RWRpdG9yLmdldFVybCgnbGFuZy9hbGxveS1lZGl0b3IvJyArIGxhbmcgKyAnLmpzJyksIGZ1bmN0aW9uKGxvYWRlZCkge1xuICAgICAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgICAgICAgIEFsbG95RWRpdG9yLmZpcmUoJ2xhbmd1YWdlUmVzb3VyY2VzTG9hZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZnVsbCBVUkwgZm9yIEFsbG95RWRpdG9yIHJlc291cmNlcy4gQnkgZGVmYXVsdCwgVVJMc1xuICogcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBjb250YWluIGEgcXVlcnlzdHJpbmcgcGFyYW1ldGVyIChcInRcIilcbiAqIHNldCB0byB0aGUge0BsaW5rIENLRURJVE9SI3RpbWVzdGFtcH0gdmFsdWUuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGdldFVybFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlIFRoZSByZXNvdXJjZSB3aG9zZSBmdWxsIFVSTCB3ZSB3YW50IHRvIGdldC5cbiAqIEl0IG1heSBiZSBhIGZ1bGwsIGFic29sdXRlLCBvciByZWxhdGl2ZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmdWxsIFVSTC5cbiAqL1xuY29uc3QgZ2V0VXJsID0gZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICB2YXIgYmFzZVBhdGggPSBBbGxveUVkaXRvci5nZXRCYXNlUGF0aCgpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBub3QgYSBmdWxsIG9yIGFic29sdXRlIHBhdGguXG4gICAgaWYgKHJlc291cmNlLmluZGV4T2YoJzovJykgPT09IC0xICYmIHJlc291cmNlLmluZGV4T2YoJy8nKSAhPT0gMCkge1xuICAgICAgICByZXNvdXJjZSA9IGJhc2VQYXRoICsgcmVzb3VyY2U7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSB0aW1lc3RhbXAsIGV4Y2VwdCBmb3IgZGlyZWN0b3JpZXMuXG4gICAgaWYgKENLRURJVE9SLnRpbWVzdGFtcCAmJiByZXNvdXJjZS5jaGFyQXQoIHJlc291cmNlLmxlbmd0aCAtIDEgKSAhPT0gJy8nICYmICEoL1smP110PS8pLnRlc3QocmVzb3VyY2UpKSB7XG4gICAgICAgIHJlc291cmNlICs9IChyZXNvdXJjZS5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyAndD0nICsgQ0tFRElUT1IudGltZXN0YW1wO1xuICAgIH1cblxuICAgIHJldHVybiByZXNvdXJjZTtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBldmVudCBmaXJpbmcgYW5kIHN1YnNjcmliaW5nIHZpYSBDS0VESVRPUi5ldmVudC5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgaW1wbGVtZW50RXZlbnRUYXJnZXRcbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgaW1wbGVtZW50RXZlbnRUYXJnZXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIUFsbG95RWRpdG9yLmZpcmUgJiYgIUFsbG95RWRpdG9yLm9uKSB7XG4gICAgICAgIENLRURJVE9SLmV2ZW50LmltcGxlbWVudE9uKEFsbG95RWRpdG9yKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB3aGljaCBzaG91bGQgbWF0Y2ggdGhlIHNjcmlwdCB3aGljaCBoYXZlIGJlZW4gdXNlZCB0byBsb2FkIEFsbG95RWRpdG9yLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQHByb3BlcnR5IHJlZ2V4QmFzZVBhdGhcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IHJlZ2V4QmFzZVBhdGggPSAvKF58LipbXFxcXFxcL10pKD86YWxsb3ktZWRpdG9yW14vXSt8YWxsb3ktZWRpdG9yKVxcLmpzKD86XFw/Lip8Oy4qKT8kL2k7XG5cbi8qKlxuICogRmlyZWQgd2hlbiBBbGxveUVkaXRvciBkZXRlY3RzIHRoZSBicm93c2VyIGxhbmd1YWdlIGFuZCBsb2FkcyB0aGUgY29ycmVzcG9uZGluZyBsYW5ndWFnZSBmaWxlLiBPbmNlIHRoaXMgZXZlbnRcbiAqIGlzIGZpcmVkLCBBbGxveUVkaXRvci5TdHJpbmdzIHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAZXZlbnQgbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWRcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlcXVpcmVkIHBsdWdpbiBuYW1lcyBuZWVkZWQgZm9yIGEgZ2l2ZW4gcGx1Z2luXG4gKiBpZiBpdCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgb3IgYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGdldEJ1dHRvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1dHRvbnMgQW4gYXJyYXkgb2YgYnV0dG9ucyBvciBwbHVnaW4gbmFtZXMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBpbnZva2VkIHRvIHJlc29sdmUgdGhlIHJlcXVlc3RlZCBidXR0b24gbmFtZXMuXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IGdldEJ1dHRvbnMgPSBmdW5jdGlvbihidXR0b25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYnV0dG9ucy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB2YWwpIHtcbiAgICAgICAgICAgIHZhbCA9IEJSSURHRV9CVVRUT05TW3ZhbF0gfHwgW3ZhbF07XG4gICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdCh2YWwpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBidXR0b24gYW5kIHRyeSB0byBnZXQgaXRzIHJlcXVpcmVkIHBsdWdpbnMuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIHJlZ2lzdGVyQnJpZGdlQnV0dG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gYnV0dG9uTmFtZSBUaGUgbmFtZSBvZiB0aGUgYnV0dG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsdWdpbk5hbWUgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiB0aGF0IHJlZ2lzdGVycyB0aGUgYnV0dG9uLlxuICogQHN0YXRpY1xuICovXG5jb25zdCByZWdpc3RlckJyaWRnZUJ1dHRvbiA9IGZ1bmN0aW9uKGJ1dHRvbk5hbWUsIHBsdWdpbk5hbWUpIHtcbiAgICBpZiAoIUJSSURHRV9CVVRUT05TW3BsdWdpbk5hbWVdKSB7XG4gICAgICAgIEJSSURHRV9CVVRUT05TW3BsdWdpbk5hbWVdID0gW107XG4gICAgfVxuXG4gICAgQlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0ucHVzaChidXR0b25OYW1lKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBPT1BcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICovXG5jb25zdCBPT1AgPSB7XG4gICAgZXh0ZW5kXG59O1xuXG5leHBvcnQge1xuICAgIEF0dHJpYnV0ZSxcbiAgICBCdXR0b25zLFxuICAgIENvcmUsXG4gICAgZWRpdGFibGUsXG4gICAgZ2V0QmFzZVBhdGgsXG4gICAgZ2V0QnV0dG9ucyxcbiAgICBnZXRVcmwsXG4gICAgaW1wbGVtZW50RXZlbnRUYXJnZXQsXG4gICAgTGFuZyxcbiAgICBsb2FkTGFuZ3VhZ2VSZXNvdXJjZXMsXG4gICAgT09QLFxuICAgIHJlZ2lzdGVyQnJpZGdlQnV0dG9uLFxuICAgIFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyxcbiAgICBTZWxlY3Rpb25zLFxuICAgIFNlbGVjdGlvblNldFBvc2l0aW9uLFxuICAgIFNlbGVjdGlvblRlc3QsXG4gICAgVG9vbGJhcnNcbn07XG4iLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5cbi8qKlxuICogQnV0dG9uQWN0aW9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGFwcGx5aW5nIHN0eWxlIGltcGxlbWVudGF0aW9uIGZvciBhXG4gKiBidXR0b24gYmFzZWQgb24gdGhlIGBhcHBseVN0eWxlYCBhbmQgYHJlbW92ZVN0eWxlYCBBUEkgb2YgQ0tFRElUT1IuXG4gKlxuICogVG8gZXhlY3V0ZSBwcm9wZXJseSwgdGhlIGNvbXBvbmVudCBoYXMgdG8gZXhwb3NlIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyB3aGljaCBjYW4gYmUgb2J0YWluZWRcbiAqIG91dCBvZiB0aGUgYm94IHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJCdXR0b25TdHlsZVwifX17ey9jcm9zc0xpbmt9fSBtaXhpbjpcbiAqIC0gYEZ1bmN0aW9uYCB7eyNjcm9zc0xpbmsgXCJCdXR0b25TdHlsZS9pc0FjdGl2ZVwifX17ey9jcm9zc0xpbmt9fSB0byBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKiAtIGBGdW5jdGlvbmAge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGUvZ2V0U3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG8gcmV0dXJuIHRoZSBzdHlsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkXG4gKlxuICogQGNsYXNzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9yIGFwcGxpZXMgdGhlIGNvbXBvbmVudCBzdHlsZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQWN0aW9uU3R5bGVcbiAgICAgKiBAbWV0aG9kIGFwcGx5U3R5bGVcbiAgICAgKi9cbiAgICBhcHBseVN0eWxlKCkge1xuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHRoaXMuaXNBY3RpdmUpICYmIExhbmcuaXNGdW5jdGlvbih0aGlzLmdldFN0eWxlKSkge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIGVkaXRvci5nZXRTZWxlY3Rpb24oKS5sb2NrKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVtb3ZlU3R5bGUodGhpcy5nZXRTdHlsZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5U3R5bGUodGhpcy5nZXRTdHlsZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsIi8qKlxuICogQnV0dG9uQ29tbWFuZEFjdGl2ZSBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgYW4gYGlzQWN0aXZlYCBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmXG4gKiBhIGNvbnRleHQtYXdhcmUgY29tbWFuZCBpcyBjdXJyZW50bHkgaW4gYW4gYWN0aXZlIHN0YXRlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbW1hbmQgaXMgYWN0aXZlIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kQWN0aXZlXG4gICAgICogQG1ldGhvZCBpc0FjdGl2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbW1hbmQgaXMgYWN0aXZlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIHZhciBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQodGhpcy5wcm9wcy5jb21tYW5kKTtcblxuICAgICAgICByZXR1cm4gY29tbWFuZCA/IGNvbW1hbmQuc3RhdGUgPT09IENLRURJVE9SLlRSSVNUQVRFX09OIDogZmFsc2U7XG4gICAgfVxufTsiLCIvKipcbiAqIEJ1dHRvbkNvbW1hbmQgaXMgYSBtaXhpbiB0aGF0IGV4ZWN1dGVzIGEgY29tbWFuZCB2aWEgQ0tFRElUT1IncyBBUEkuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgQ0tFZGl0b3IgY29tbWFuZCBhbmQgZmlyZXMgYGFjdGlvblBlcmZvcm1lZGAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZGF0YSBPcHRpb25hbCBkYXRhIHRvIGJlIHBhc3NlZCB0byBDS0VESVRPUidzIGBleGVjQ29tbWFuZGAgbWV0aG9kLlxuICAgICAqIEBtZXRob2QgZXhlY0NvbW1hbmRcbiAgICAgKi9cbiAgICBleGVjQ29tbWFuZChkYXRhKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCh0aGlzLnByb3BzLmNvbW1hbmQsIGRhdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1vZGlmaWVzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uQ2hhbmdlKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgIH1cbn07IiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcuanMnO1xuXG4vKipcbiAqIEJ1dHRvbktleXN0cm9rZSBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgYSBga2V5c3Ryb2tlYCBwcm9wIHRoYXQgYWxsb3dzIGNvbmZpZ3VyaW5nXG4gKiBhIGZ1bmN0aW9uIG9mIHRoZSBpbnN0YW5jZSB0byBiZSBpbnZva2VkIHVwb24gdGhlIGtleXN0cm9rZSBhY3RpdmF0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25LZXlzdHJva2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uS2V5c3Ryb2tlXG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIGtleXN0cm9rZSA9IHRoaXMucHJvcHMua2V5c3Ryb2tlO1xuXG4gICAgICAgIHZhciBjb21tYW5kTmFtZSA9IGtleXN0cm9rZS5uYW1lIHx8ICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIGNvbW1hbmQgPSBuYXRpdmVFZGl0b3IuZ2V0Q29tbWFuZChjb21tYW5kTmFtZSk7XG5cbiAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgICBjb21tYW5kID0gbmV3IENLRURJVE9SLmNvbW1hbmQobmF0aXZlRWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5c3Ryb2tlRm4gPSBrZXlzdHJva2UuZm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMYW5nLmlzU3RyaW5nKGtleXN0cm9rZUZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c3Ryb2tlRm5dLmNhbGwodGhpcywgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTGFuZy5pc0Z1bmN0aW9uKGtleXN0cm9rZUZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXN0cm9rZUZuLmNhbGwodGhpcywgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbmF0aXZlRWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGNvbW1hbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVmYXVsdEtleXN0cm9rZUNvbW1hbmQgPSBuYXRpdmVFZGl0b3Iua2V5c3Ryb2tlSGFuZGxlci5rZXlzdHJva2VzW2tleXN0cm9rZS5rZXlzXTtcblxuICAgICAgICBuYXRpdmVFZGl0b3Iuc2V0S2V5c3Ryb2tlKGtleXN0cm9rZS5rZXlzLCBjb21tYW5kTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbktleXN0cm9rZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCkpIHtcbiAgICAgICAgICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpLnNldEtleXN0cm9rZSh0aGlzLnByb3BzLmtleXN0cm9rZS5rZXlzLCB0aGlzLl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZCk7XG4gICAgfVxufTsiLCIvKipcbiAqIEJ1dHRvbkNmZ1Byb3BzIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIHN0eWxlIHByb3AgYW5kIHNvbWUgbWV0aG9kcyB0byBhcHBseSB0aGUgcmVzdWx0aW5nXG4gKiBzdHlsZSBhbmQgY2hlY2tpbmcgaWYgaXQgaXMgcHJlc2VudCBpbiBhIGdpdmVuIHBhdGggb3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25DZmdQcm9wc1xuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzLCBwYXNzZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHdpdGggdXNlcidzIGNvbmZpZ3VyYXRpb25cbiAgICAgKiB2aWEgYGJ1dHRvbkNmZ2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ2ZnUHJvcHNcbiAgICAgKiBAbWV0aG9kIG1lcmdlQnV0dG9uQ2ZnUHJvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gYmUgbWVyZ2VkIHdpdGggdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXNcbiAgICAgKiBidXR0b24uIElmIG5vdCBwYXNzZWQsIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBtZXJnZWQgd2l0aCBgdGhpcy5wcm9wc2BcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIG1lcmdlQnV0dG9uQ2ZnUHJvcHMocHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuXG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgYnV0dG9uQ2ZnID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5idXR0b25DZmcgfHwge307XG4gICAgICAgIHZhciByZXN1bHQgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYnV0dG9uQ2ZnWydsaW5rRWRpdCddKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07IiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIEJ1dHRvblN0YXRlQ2xhc3NlcyBpcyBhIG1peGluIHRoYXQgZGVjb3JhdGVzIHRoZSBkb21FbGVtZW50IG9mIGEgY29tcG9uZW50XG4gKiB3aXRoIGRpZmZlcmVudCBDU1MgY2xhc3NlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBUbyBjaGVjayBmb3Igc3RhdGUsIHRoZSBjb21wb25lbnQgY2FuIGV4cG9zZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gKiAtIGBGdW5jdGlvbmAgKippc0FjdGl2ZSoqIHRvIGNoZWNrIHRoZSBhY3RpdmUgc3RhdGVcbiAqIC0gYEZ1bmN0aW9uYCAqKmlzRGlzYWJsZWQqKiB0byBjaGVjayB0aGUgZGlzYWJsZWQgc3RhdGVcbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHN0YXRlIGNsYXNzZXMgYXNzb2NpYXRlZCB0byB0aGUgY3VycmVudCBlbGVtZW50J3Mgc3RhdGUsIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSByZXN1bHRzIG9mIHRoZSBpc0FjdGl2ZSBhbmQgaXNEaXNhYmxlZCBtZXRob2RzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICAgICAqIEBtZXRob2QgZ2V0U3RhdGVDbGFzc2VzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB3aXRoIHRoZSBzdGF0ZSBDU1MgY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBnZXRTdGF0ZUNsYXNzZXMoKSB7XG4gICAgICAgIHZhciBzdGF0ZUNsYXNzZXMgPSAnJztcblxuICAgICAgICAvLyBDaGVjayBmb3IgYWN0aXZlIHN0YXRlXG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5pc0FjdGl2ZSkgJiYgdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICBzdGF0ZUNsYXNzZXMgKz0gJ2FlLWJ1dHRvbi1wcmVzc2VkJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBkaXNhYmxlZCBzdGF0ZVxuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHRoaXMuaXNEaXNhYmxlZCkgJiYgdGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgICAgIHN0YXRlQ2xhc3NlcyArPSAnIGFlLWJ1dHRvbi1kaXNhYmxlZCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGVDbGFzc2VzO1xuICAgIH1cbn07IiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcuanMnXG5cbi8qKlxuICogQnV0dG9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgc3R5bGUgcHJvcCBhbmQgc29tZSBtZXRob2RzIHRvIGFwcGx5IHRoZSByZXN1bHRpbmdcbiAqIHN0eWxlIGFuZCBjaGVja2luZyBpZiBpdCBpcyBwcmVzZW50IGluIGEgZ2l2ZW4gcGF0aCBvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT4gY2xhc3MgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnByb3BzLnN0eWxlO1xuXG4gICAgICAgIGlmIChMYW5nLmlzU3RyaW5nKHN0eWxlKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gc3R5bGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWVtYmVyID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5jb25maWc7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICB3aGlsZSAocHJvcGVydHkgJiYgTGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyKSAmJiBMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXJbcHJvcGVydHldKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNZW1iZXIgPSBjdXJyZW50TWVtYmVyW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBjdXJyZW50TWVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCkpIHtcbiAgICAgICAgICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiBDS0VESVRPUi5zdHlsZSB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IGJ1dHRvbiBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuICAgICAqIEBtZXRob2QgZ2V0U3R5bGVcbiAgICAgKiBAcmV0dXJuIHtDS0VESVRPUi5zdHlsZX0gVGhlIGN1cnJlbnQgc3R5bGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0U3R5bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3R5bGUgaXMgYWN0aXZlIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuICAgICAqIEBtZXRob2QgaXNBY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHN0eWxlIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIHZhciBlbGVtZW50UGF0aCA9IGVkaXRvci5lbGVtZW50UGF0aCgpO1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0U3R5bGUoKS5jaGVja0FjdGl2ZShlbGVtZW50UGF0aCwgZWRpdG9yKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07IiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUb29sYmFyQnV0dG9ucyBpcyBhIG1peGluIHdoaWNoIHByb3ZpZGVzIGEgbGlzdCBvZiBidXR0b25zIHdoaWNoIGhhdmUgdG8gYmVcbiAqIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCB0b29sYmFyIGRlcGVuZGluZyBvbiB1c2VyIHByZWZlcmVuY2VzIGFuZCBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckJ1dHRvbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEFuYWx5emVzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmQgdGhlIGJ1dHRvbnMgZXhjbHVzaXZlIG1vZGUgdmFsdWUgdG8gZmlndXJlIG91dCB3aGljaFxuICAgICAqIGJ1dHRvbnMgc2hvdWxkIGJlIHByZXNlbnQgaW4gYSBnaXZlbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuICAgICAqIEBtZXRob2QgZ2V0VG9vbGJhckJ1dHRvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBidXR0b25zIFRoZSBidXR0b25zIGNvdWxkIGJlIHNob3duLCBwcmlvciB0byB0aGUgc3RhdGUgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhZGRpdGlvbmFsUHJvcHMgQWRkaXRpb25hbCBwcm9wcyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgZG93biB0byB0aGUgYnV0dG9ucy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIGJ1dHRvbnMgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0VG9vbGJhckJ1dHRvbnMoYnV0dG9ucywgYWRkaXRpb25hbFByb3BzKSB7XG4gICAgICAgIHZhciBidXR0b25Qcm9wcyA9IHt9O1xuXG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgYnV0dG9uQ2ZnID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5idXR0b25DZmcgfHwge307XG5cbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihidXR0b25zKSkge1xuICAgICAgICAgICAgYnV0dG9ucyA9IGJ1dHRvbnMuY2FsbCh0aGlzKSB8fCBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b29sYmFyQnV0dG9ucyA9IHRoaXMuZmlsdGVyRXhjbHVzaXZlKFxuICAgICAgICAgICAgICAgIGJ1dHRvbnMuZmlsdGVyKGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uICYmIChBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbl0gfHwgQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuaXNTdHJpbmcoYnV0dG9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uUHJvcHNbYnV0dG9uXSA9IGJ1dHRvbkNmZ1tidXR0b25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b25dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKExhbmcuaXNTdHJpbmcoYnV0dG9uLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Qcm9wc1tBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbi5uYW1lXS5rZXldID0gQ0tFRElUT1IudG9vbHMubWVyZ2UoYnV0dG9uQ2ZnW2J1dHRvbl0sIGJ1dHRvbi5jZmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMubWVyZ2VFeGNsdXNpdmVQcm9wcyh7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5wcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIGtleTogYnV0dG9uLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdGFiS2V5OiBidXR0b24ua2V5LFxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogKHRoaXMucHJvcHMudHJpZ2dlciAmJiB0aGlzLnByb3BzLnRyaWdnZXIucHJvcHMudGFiS2V5ID09PSBidXR0b24ua2V5KSA/IDAgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogdGhpcy5wcm9wcy50cmlnZ2VyXG4gICAgICAgICAgICAgICAgfSwgYnV0dG9uLmtleSk7XG5cbiAgICAgICAgICAgICAgICBwcm9wcyA9IHRoaXMubWVyZ2VEcm9wZG93blByb3BzKHByb3BzLCBidXR0b24ua2V5KTtcblxuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYWRkaXRpb25hbFByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9wcyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHByb3BzLCBidXR0b25Qcm9wc1tidXR0b24ua2V5XSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChidXR0b24sIHByb3BzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0b29sYmFyQnV0dG9ucztcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBkaXNwbGF5aW5nIFdpZGdldCBBcnJvdyBib3ggb24gdG9wIG9yIG9uIGJvdHRvbSBvZiB0aGUgd2lkZ2V0XG4gKiBkZXBlbmRpbmcgb24gdGhlIHBvaW50IG9mIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRBcnJvd0JveFxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBhcnJvdyBib3ggY2xhc3NlcyBhc3NvY2lhdGVkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQncyBzdGF0ZS4gSXQgcmVsaWVzXG4gICAgICogb24gdGhlIGdldEludGVyYWN0aW9uUG9pbnQgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgc2VsZWN0aW9uIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRBcnJvd0JveFxuICAgICAqIEBtZXRob2QgZ2V0QXJyb3dCb3hDbGFzc2VzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB3aXRoIHRoZSBhcnJvdyBib3ggQ1NTIGNsYXNzZXMuXG4gICAgICovXG4gICAgZ2V0QXJyb3dCb3hDbGFzc2VzKCkge1xuICAgICAgICB2YXIgYXJyb3dCb3hDbGFzc2VzID0gJ2FlLWFycm93LWJveCc7XG5cbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmdldEludGVyYWN0aW9uUG9pbnQpICYmIHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KCkuZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSkge1xuICAgICAgICAgICAgICAgIGFycm93Qm94Q2xhc3NlcyArPSAnIGFlLWFycm93LWJveC10b3AnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJvd0JveENsYXNzZXMgKz0gJyBhZS1hcnJvdy1ib3gtYm90dG9tJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJvd0JveENsYXNzZXM7XG4gICAgfVxufTsiLCJpbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtYW5hZ2luZyBkaWZmZXJlbnQgZHJvcGRvd25zIGluc2lkZSBhIHdpZGdldC5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0RHJvcGRvd25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGRyb3Bkb3duVHJpZ2dlcjogbnVsbCxcbiAgICAgICAgICAgIGl0ZW1Ecm9wZG93bjogbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RHJvcGRvd25cbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRyb3Bkb3duVHJpZ2dlcjogbnVsbCxcbiAgICAgICAgICAgIGl0ZW1Ecm9wZG93bjogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHR3byBtb3JlIHByb3BlcnRpZXM6XG4gICAgICogLSBleHBhbmRlZCAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cbiAgICAgKiAtIHRvZ2dsZURyb3Bkb3duIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIHdpZGdldCBpbiBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG4gICAgICogQG1ldGhvZCBtZXJnZURyb3Bkb3duUHJvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcbiAgICAgKiAgICB0byBkcm9wZG93biBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggY29udGFpbnMgdGhlIGRyb3Bkb3duLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG4gICAgICovXG4gICAgbWVyZ2VEcm9wZG93blByb3BzKG9iaiwgaXRlbUtleSkge1xuICAgICAgICByZXR1cm4gQ0tFRElUT1IudG9vbHMubWVyZ2Uob2JqLCB7XG4gICAgICAgICAgICBleHBhbmRlZDogdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPT09IGl0ZW1LZXkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICB0YWJJbmRleDogdGhpcy5zdGF0ZS5kcm9wZG93blRyaWdnZXIgPT09IGl0ZW1LZXkgPyAwIDogLTEsXG4gICAgICAgICAgICB0b2dnbGVEcm9wZG93bjogdGhpcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMsIGl0ZW1LZXkpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBkcm9wZG93biBvZiB0aGUgd2lkZ2V0IG9yIGRpc2NhcmRzIHRoZSB0b2dnbGVkIGl0ZW0gZnJvbSB0aGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RHJvcGRvd25cbiAgICAgKiBAbWV0aG9kIHRvZ2dsZURyb3Bkb3duXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1Ecm9wZG93biBUaGUgd2lkZ2V0IHdoaWNoIHJlcXVlc3RzIHRvIHRvZ2dsZSBpdHMgZHJvcGRvd24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvZ2dsZURpcmVjdGlvbiBVc2VyIG1vdmVtZW50IGRpcmVjdGlvbiB3aGVuIHRvZ2dsZWQgdmlhIGtleWJvYXJkLlxuICAgICAqL1xuICAgIHRvZ2dsZURyb3Bkb3duKGl0ZW1Ecm9wZG93biwgdG9nZ2xlRGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZHJvcGRvd25UcmlnZ2VyOiBpdGVtRHJvcGRvd24sXG4gICAgICAgICAgICBpdGVtRHJvcGRvd246IGl0ZW1Ecm9wZG93biAhPT0gdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPyBpdGVtRHJvcGRvd24gOiBudWxsXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLml0ZW1Ecm9wZG93bikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdmVGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVGb2N1cyh0b2dnbGVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59OyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtYW5hZ2luZyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuICogVGhlIGV4Y2x1c2l2ZSBzdGF0ZSBtZWFucyB0aGF0IGEgYnV0dG9uIG1heSByZXF1ZXN0IHRvIGJlIHRoZSBvbmx5IHJlbmRlcmVkXG4gKiB3aWRnZXQgaW4gaXRzIHBhcmVudCBjb250YWluZXIuIFdpZGdldEV4Y2x1c2l2ZSB3aWxsIG1hbmFnZSB0aGlzIHN0YXRlIGJ5XG4gKiBmaWx0ZXJpbmcgYW5kIHN1cHByZXNzaW5nIHRoZSBvdGhlciBzaWJsaW5nIHdpZGdldHMgZnJvbSBkaXNwbGF5aW5nLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRFeGNsdXNpdmVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENhbmNlbHMgdGhlIGV4Y2x1c2l2ZSBzdGF0ZSBvZiBhbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG4gICAgICogQG1ldGhvZCBjYW5jZWxFeGNsdXNpdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbUV4Y2x1c2l2ZSBUaGUgd2lkZ2V0IHdoaWNoIGV4Y2x1c2l2ZSBzdGF0ZSBzaG91bGQgYmUgY2FuY2VsZWQuXG4gICAgICovXG4gICAgY2FuY2VsRXhjbHVzaXZlKGl0ZW1FeGNsdXNpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaXRlbUV4Y2x1c2l2ZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgKiBDYWxsaW5nIHRoaXMuc2V0U3RhdGUoKSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGFuIGFkZGl0aW9uYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXh0UHJvcHMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2V0IG9mIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjZWl2aW5nIHByb3BlcnRpZXMgbWVhbnMgdGhhdCB0aGUgY29tcG9uZW50IGlzIGJlaW5nIHJlLXJlbmRlcmVkLlxuICAgICAgICAvLyBSZS1yZW5kZXJpbmcgaXMgdHJpZ2dlcmVkIGJ5IGVkaXRvckludGVyYWN0aW9uLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIHJlc2V0IHRoZSBleGNsdXNpdmUgc3RhdGUgYW5kIHJlbmRlciB0aGUgVUkgYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2VsZWN0aW9uLlxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGl0ZW1FeGNsdXNpdmU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyB0aGUgaXRlbXMgYW5kIHJldHVybnMgb25seSB0aG9zZSB3aXRoIGV4Y2x1c2l2ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcbiAgICAgKiBAbWV0aG9kIGZpbHRlckV4Y2x1c2l2ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIFRoZSB3aWRnZXRzIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fE9iamVjdH0gVGhlIGl0ZW0gd2l0aCBleGVjdXRpdmUgc3RhdGUuXG4gICAgICovXG4gICAgZmlsdGVyRXhjbHVzaXZlKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUgPT09IGl0ZW0ua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBwcm92aWRlZCBvYmplY3Qgd2l0aCB0aHJlZSBtb3JlIHByb3BlcnRpZXM6XG4gICAgICogLSBjYW5jZWxFeGNsdXNpdmUgLSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYSB3aWRnZXQgaW4gb3JkZXIgdG8gY2FuY2VsIGV4ZWN1dGl2ZSBzdGF0ZS5cbiAgICAgKiAtIHJlbmRlckV4Y2x1c2l2ZSAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cbiAgICAgKiAtIHJlcXVlc3RFeGNsdXNpdmUgLSBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYSB3aWRnZXQgaW4gb3JkZXIgdG8gb2J0YWluIGV4Y2x1c2l2ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcbiAgICAgKiBAbWV0aG9kIG1lcmdlRXhjbHVzaXZlUHJvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcbiAgICAgKiAgICB0byBleGNsdXNpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1LZXkgVGhleSBrZXkgb2YgYW4gUmVhY3QgV2lkZ2V0IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIG1lcmdlRXhjbHVzaXZlUHJvcHMob2JqLCBpdGVtS2V5KSB7XG4gICAgICAgIHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShvYmosIHtcbiAgICAgICAgICAgIGNhbmNlbEV4Y2x1c2l2ZTogdGhpcy5jYW5jZWxFeGNsdXNpdmUuYmluZCh0aGlzLCBpdGVtS2V5KSxcbiAgICAgICAgICAgIHJlbmRlckV4Y2x1c2l2ZTogKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUtleSksXG4gICAgICAgICAgICByZXF1ZXN0RXhjbHVzaXZlOiB0aGlzLnJlcXVlc3RFeGNsdXNpdmUuYmluZCh0aGlzLCBpdGVtS2V5KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhbmQgc2V0cyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuICAgICAqIEBtZXRob2QgcmVxdWVzdEV4Y2x1c2l2ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRXhjbHVzaXZlIFRoZSB3aWRnZXQgd2hpY2ggcmVxdWVzdHMgZXhjbHVzaXZlIHN0YXRlLlxuICAgICAqL1xuICAgIHJlcXVlc3RFeGNsdXNpdmUoaXRlbUV4Y2x1c2l2ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGl0ZW1FeGNsdXNpdmU6IGl0ZW1FeGNsdXNpdmVcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIERJUkVDVElPTl9OT05FID0gMDtcbnZhciBESVJFQ1RJT05fTkVYVCA9IDE7XG52YXIgRElSRUNUSU9OX1BSRVYgPSAtMTtcblxudmFyIEFDVElPTl9OT05FID0gMDtcbnZhciBBQ1RJT05fTU9WRV9GT0NVUyA9IDE7XG52YXIgQUNUSU9OX0RJU01JU1NfRk9DVVMgPSAyO1xuXG4vKipcbiAqIFdpZGdldEZvY3VzTWFuYWdlciBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMga2V5Ym9hcmQgbmF2aWdhdGlvbiBpbnNpZGUgYSB3aWRnZXQuIFRvIGRvIHRoaXMsXG4gKiBpdCBleHBvc2VzIHRoZSBmb2xsb3dpbmcgcHJvcHMgYW5kIG1ldGhvZHM6XG4gKlxuICogQGNsYXNzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+IGNsYXNzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50RGlkTW91bnQpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuICAgICAqIFJlZnJlc2hlcyB0aGUgZGVzY2VuZGFudHMgbGlzdC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnREaWRVcGRhdGUpKSB7XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnREaWRVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBjdXJyZW50IGFjdGl2ZSBkZXNjZW5kYW50LlxuICAgICAqXG4gICAgICogU2V2ZXJhbCBXaWRnZXRzIGNhbiBiZSBuZXN0ZWQgaW4gYSBjb21wb25lbnQgaGllcmFyY2h5IGJ5IGF0dGFjaGluZyB0aGlzIGZvY3VzIG1ldGhvZCB0b1xuICAgICAqIHRoZSB3aWRnZXQgRE9NIG5vZGUsIHRyYW5zZmVycmluZyB0aGUgRE9NIGZvY3VzIGNvbnRyb2wgdG8gdGhlIGlubmVyIEZvY3VzTWFuYWdlci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIGZvY3VzXG4gICAgICovXG4gICAgZm9jdXMoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCB0aGlzLl9pc1ZhbGlkVGFyZ2V0KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZXNjZW5kYW50cyAmJiB0aGlzLl9kZXNjZW5kYW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlRGVzY2VuZGFudEVsID0gdGhpcy5fZGVzY2VuZGFudHNbdGhpcy5fYWN0aXZlRGVzY2VuZGFudF07XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIGNsaWNrcyB3aXRoIHRoZSBtb3VzZSwgdGhlIGFjdGl2ZUVsZW1lbnQgaXMgYWxyZWFkeSBzZXQgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgLy8gaXMgbm8gbmVlZCB0byBmb2N1cyBpdC4gRm9jdXNpbmcgb2YgdGhlIGFjdGl2ZSBkZXNjZW5kYW50ICh1c3VhbGx5IHNvbWUgYnV0dG9uKSBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYmVjYXVzZSB0aGUgZm9jdXNlZCBlbGVtZW50IG1pZ2h0IGJlIG5vdCB0aGUgZmlyc3QgYnV0dG9uLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgZGl2IGVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b24uXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZURlc2NlbmRhbnRFbCAmJiAhdGhpcy5wcm9wcy5mb2N1c0ZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rlc2NlbmRhbnRzLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVEZXNjZW5kYW50RWwuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBrZXkgZXZlbnRzIG9uIGEgRE9NIG5vZGUgdG8gZXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgbmF2aWdhdGlvbiB3aGVuIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50IHRoYXQgd2FzIGRldGVjdGVkIG9uIHRoZSB3aWRnZXQgRE9NIG5vZGUuXG4gICAgICogQG1ldGhvZCBoYW5kbGVLZXlcbiAgICAgKi9cbiAgICBoYW5kbGVLZXkoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSAmJiB0aGlzLl9kZXNjZW5kYW50cykge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuX2dldEZvY3VzQWN0aW9uKGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX01PVkVfRk9DVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZUZvY3VzKGFjdGlvbi5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX0RJU01JU1NfRk9DVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRpc21pc3MoYWN0aW9uLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIG1vdmVGb2N1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAoMSBvciAtMSkgb2YgdGhlIGZvY3VzIG1vdmVtZW50IGFtb25nIGRlc2NlbmRhbnRzLlxuICAgICAqL1xuICAgIG1vdmVGb2N1cyhkaXJlY3Rpb24pIHtcbiAgICAgICAgZGlyZWN0aW9uID0gTGFuZy5pc051bWJlcihkaXJlY3Rpb24pID8gZGlyZWN0aW9uIDogMDtcblxuICAgICAgICB0aGlzLl9tb3ZlRm9jdXMoZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3Rpb24sIGlmIGFueSwgdGhhdCBhIGtleWJvYXJkIGV2ZW50IGluIHRoZSBjdXJyZW50IGZvY3VzIG1hbmFnZXIgc3RhdGVcbiAgICAgKiBzaG91bGQgcHJvZHVjZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIF9nZXRGb2N1c0FjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gYWN0aW9uIG9iamVjdCB3aXRoIHR5cGUgYW5kIGRpcmVjdGlvbiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIF9nZXRGb2N1c0FjdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX05PTkVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5rZXlzKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uKGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgYWN0aW9uLnR5cGUgPSBBQ1RJT05fTU9WRV9GT0NVUztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc21pc3NBY3Rpb24gPSB0aGlzLl9nZXRGb2N1c0Rpc21pc3NBY3Rpb24oZXZlbnQsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChkaXNtaXNzQWN0aW9uLmRpc21pc3MpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24uZGlyZWN0aW9uID0gZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgYWN0aW9uLnR5cGUgPSBBQ1RJT05fRElTTUlTU19GT0NVUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzbWlzcyBhY3Rpb24sIGlmIGFueSwgdGhlIGZvY3VzIG1hbmFnZXIgc2hvdWxkIGV4ZWN1dGUgdG8geWllbGQgdGhlIGZvY3VzLiBUaGlzXG4gICAgICogd2lsbCBoYXBwZW4gaW4gYW55IG9mIHRoZXNlIHNjZW5hcmlvcyBpZiBhIGRpc21pc3MgY2FsbGJhY2sgaGFzIGJlZW4gc3BlY2lmaWVkOlxuICAgICAqIC0gQSBkaXNtaXNzIGtleSBoYXMgYmVlbiBwcmVzc2VkXG4gICAgICogLSBJbiBhIG5vbi1jaXJjdWxhciBmb2N1cyBtYW5hZ2VyLCB3aGVuOlxuICAgICAqICAgICAtIFRoZSBhY3RpdmUgZGVzY2VuZGFudCBpcyB0aGUgZmlyc3Qgb25lIGFuZCBhIHByZXYga2V5IGhhcyBiZWVuIHByZXNzZWQuXG4gICAgICogICAgIC0gVGhlIGFjdGl2ZSBkZXNjZW5kYW50IGlzIHRoZSBsYXN0IG9uZSBhbmQgYSBuZXh0IGtleSBoYXMgYmVlbiBwcmVzc2VkLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuICAgICAqIEBtZXRob2QgX2dldEZvY3VzRGlzbWlzc0FjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb2N1c01vdmVEaXJlY3Rpb24gVGhlIGZvY3VzIG1vdmVtZW50IGRpcmVjdGlvbiAoaWYgYW55KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgZGlzbWlzcyBhY3Rpb24gd2l0aCBkaXNtaXNzIGFuZCBkaXJlY3Rpb24gcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBfZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uKGV2ZW50LCBmb2N1c01vdmVEaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGRpc21pc3NBY3Rpb24gPSB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IGZvY3VzTW92ZURpcmVjdGlvbixcbiAgICAgICAgICAgIGRpc21pc3M6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25EaXNtaXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzcykpIHtcbiAgICAgICAgICAgICAgICBkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3NOZXh0KSkge1xuICAgICAgICAgICAgICAgIGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fTkVYVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5kaXNtaXNzUHJldikpIHtcbiAgICAgICAgICAgICAgICBkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpc21pc3NBY3Rpb24uZGlyZWN0aW9uID0gRElSRUNUSU9OX1BSRVY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGlzbWlzc0FjdGlvbi5kaXNtaXNzICYmICF0aGlzLnByb3BzLmNpcmN1bGFyICYmIGZvY3VzTW92ZURpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IChcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNNb3ZlRGlyZWN0aW9uID09PSBESVJFQ1RJT05fUFJFViAmJiB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzTW92ZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OX05FWFQgJiYgdGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9PT0gdGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzbWlzc0FjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXJlY3Rpb24sIGlmIGFueSwgaW4gd2hpY2ggdGhlIGZvY3VzIHNob3VsZCBiZSBtb3ZlZC4gSW4gcHJlc2VuY2Ugb2YgdGhlXG4gICAgICogc2hpZnQga2V5IG1vZGlmaWVyLCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtb3ZlbWVudCBpcyBpbnZlcnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIF9nZXRGb2N1c01vdmVEaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCBkaXJlY3Rpb24gb2YgdGhlIGV4cGVjdGVkIGZvY3VzIG1vdmVtZW50LlxuICAgICAqL1xuICAgIF9nZXRGb2N1c01vdmVEaXJlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5uZXh0KSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRElSRUNUSU9OX05FWFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLnByZXYpKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT05fUFJFVjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5zaGlmS2V5KSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gKj0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGtleUNvZGUgaXMgdmFsaWQgZm9yIHRoZSBnaXZlbiBzZXQgb2Yga2V5cy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcbiAgICAgKiBAbWV0aG9kIF9pc1ZhbGlkS2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ9IGtleXMgQSBrZXkgc2V0LiBDYW4gYmUgYSBudW1iZXIgYW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGFsbG93ZWQga2V5Q29kZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGUgQW4gZXZlbnQga2V5Q29kZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGtleSBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBfaXNWYWxpZEtleShrZXlDb2RlLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiBMYW5nLmlzQXJyYXkoa2V5cykgPyAoa2V5cy5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkgOiAoa2V5Q29kZSA9PT0ga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyB2YWxpZCBmb3IgZm9jdXMgbWFuYWdlbWVudC4gVXNlciBpbnB1dCBlbGVtZW50cyBzdWNoIGFzXG4gICAgICogaW5wdXQsIHNlbGVjdCBvciB0ZXh0YXJlYSBhcmUgZXhjbHVkZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfaXNWYWxpZEtleVxuICAgICAqIEBwYXJhbSB7RE9NTm9kZX0gZWxlbWVudCBBIERPTSBlbGVtZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgZWxlbWVudCBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBfaXNWYWxpZFRhcmdldChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuICh0YWdOYW1lICE9PSAnaW5wdXQnICYmIHRhZ05hbWUgIT09ICdzZWxlY3QnICYmIHRhZ05hbWUgIT09ICd0ZXh0YXJlYScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyBhbW9uZyBkZXNjZW5kYW50cyBpbiB0aGUgZXNwZWNpZmllZCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfbW92ZUZvY3VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uICgxIG9yIC0xKSBvZiB0aGUgZm9jdXMgbW92ZW1lbnQgYW1vbmcgZGVzY2VuZGFudHMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9tb3ZlRm9jdXMoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBudW1EZXNjZW5kYW50cyA9IHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aDtcblxuICAgICAgICB2YXIgZGVzY2VuZGFudCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuXG4gICAgICAgIGRlc2NlbmRhbnQuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIC0xKTtcblxuICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICs9IGRpcmVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5jaXJjdWxhcikge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByb3BlciBtb2R1bG8gcmVzdWx0IHNpbmNlIHJlbWFpbmRlciBvcGVyYXRvciBkb2Vzbid0IGJlaGF2ZSBpbiB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgd2F5IGZvciBuZWdhdGl2ZSBudW1iZXJzXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gKCh0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICUgbnVtRGVzY2VuZGFudHMpICsgbnVtRGVzY2VuZGFudHMpICUgbnVtRGVzY2VuZGFudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5fYWN0aXZlRGVzY2VuZGFudCwgbnVtRGVzY2VuZGFudHMgLSAxKSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjZW5kYW50ID0gdGhpcy5fZGVzY2VuZGFudHNbdGhpcy5fYWN0aXZlRGVzY2VuZGFudF07XG5cbiAgICAgICAgZGVzY2VuZGFudC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgMCk7XG4gICAgICAgIGRlc2NlbmRhbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGRlc2NlbmRhbnRzIGxpc3QgYnkgZXhlY3V0aW5nIHRoZSBDU1Mgc2VsZWN0b3IgYWdhaW4gYW5kIHJlc2V0cyB0aGUgZGVzY2VuZGFudHMgdGFiSW5kZXguXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gICAgICogQG1ldGhvZCBfcmVmcmVzaFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuICAgICAgICBpZiAoZG9tTm9kZSkge1xuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMucHJvcHMuZGVzY2VuZGFudHMpO1xuXG4gICAgICAgICAgICB2YXIgcHJpb3JpdHlEZXNjZW5kYW50cyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW5kYW50cyA9IFtdO1xuXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkZXNjZW5kYW50cykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUYWJJbmRleCA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVRhYkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5RGVzY2VuZGFudHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNjZW5kYW50cy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHByaW9yaXR5RGVzY2VuZGFudHMgPSBwcmlvcml0eURlc2NlbmRhbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoTGFuZy50b0ludChhLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpKSA+IExhbmcudG9JbnQoYi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFiaW5kZXgnKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbmRhbnRzID0gcHJpb3JpdHlEZXNjZW5kYW50cy5jb25jYXQodGhpcy5fZGVzY2VuZGFudHMpO1xuXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fZGVzY2VuZGFudHMuc29tZShmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsImltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIHdoZXJlIGFuIFdpZGdldCBzaG91bGQgYmUgZGlzcGxheWVkIGJhc2VkIG9uIHRoZSBwb2ludFxuICogd2hlcmUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0UG9zaXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PiBjbGFzcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAuLi5XcmFwcGVkQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcbiAgICAgICAgZ3V0dGVyOiB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAxMFxuICAgICAgICB9LFxuICAgICAgICBjb25zdHJhaW5Ub1ZpZXdwb3J0OiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBzY2hlZHVsZWQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBjYW5jZWxBbmltYXRpb25cbiAgICAgKi9cbiAgICBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZUlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBpbiBwYWdlIGNvb3JkaW5hdGVzLFxuICAgICAqIHJlc3RyaWN0ZWQgdG8gZml0IHRvIGdpdmVuIHZpZXdwb3J0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBnZXRDb25zdHJhaW5lZFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgcHJvdmlkZWQgYXMgbnVtYmVyczpcbiAgICAgKiAtIGhlaWdodFxuICAgICAqIC0gbGVmdFxuICAgICAqIC0gdG9wXG4gICAgICogLSB3aWR0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3UGFuZVNpemUgT3B0aW9uYWwuIElmIG5vdCBwcm92aWRlZCwgdGhlIGN1cnJlbnQgdmlld3BvcnQgd2lsbCBiZSB1c2VkLiBTaG91bGQgY29udGFpbiBhdCBsZWFzdCB0aGVzZSBwcm9wZXJ0aWVzOlxuICAgICAqIC0gd2lkdGhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIHdoaWNoIHJlcHJlc2VudCB0aGUgY29uc3RyYWluZWQgcG9zaXRpb24gb2YgdGhlXG4gICAgICogZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRDb25zdHJhaW5lZFBvc2l0aW9uKGF0dHJzLCB2aWV3UGFuZVNpemUpIHtcbiAgICAgICAgdmlld1BhbmVTaXplID0gdmlld1BhbmVTaXplIHx8IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0Vmlld1BhbmVTaXplKCk7XG5cbiAgICAgICAgdmFyIHggPSBhdHRycy5sZWZ0O1xuICAgICAgICB2YXIgeSA9IGF0dHJzLnRvcDtcblxuICAgICAgICBpZiAoYXR0cnMubGVmdCArIGF0dHJzLndpZHRoID4gdmlld1BhbmVTaXplLndpZHRoKSB7XG4gICAgICAgICAgICB4IC09IChhdHRycy5sZWZ0ICsgYXR0cnMud2lkdGggLSB2aWV3UGFuZVNpemUud2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uLCBpbiBwYWdlIGNvb3JkaW5hdGVzLCBhY2NvcmRpbmcgdG8gd2hpY2ggYSB3aWRnZXQgc2hvdWxkIGFwcGVhci5cbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLCB0aGUgd2RpZ2V0IG1heSBhcHBlYXIgYWJvdmUgb2Ygb3Igb24gYm90dG9tIG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJdCBkZXBlbmRzIG9uIHRoZSBwcm9wcyBlZGl0b3JFdmVudCB0byBhbmFseXplIHRoZSBmb2xsb3dpbmcgdXNlci1pbnRlcmFjdGlvbiBwYXJhbWV0ZXJzOlxuICAgICAqIC0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbVxuICAgICAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogLSB7TnVtYmVyfSBwb3MgQ29udGFpbnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3NpdGlvbiwgY29uc2lkZXJlZCBhcyBtb3N0IGFwcHJvcHJpYXRlLlxuICAgICAqIFRoaXMgbWF5IGJlIHRoZSBwb2ludCB3aGVyZSB0aGUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIG9yIGp1c3QgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mXG4gICAgICogdGhlIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQG1ldGhvZCBnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBPYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIGRpcmVjdGlvbiwgeCwgeSwgd2hlcmUgeCBhbmQgeSBhcmUgaW4gcGFnZSBjb29yZGluYXRlcyBhbmQgZGlyZWN0aW9uIGNhbiBiZSBvbmUgb2YgdGhlc2U6XG4gICAgICogQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Agb3IgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cbiAgICAgKi9cbiAgICBnZXRJbnRlcmFjdGlvblBvaW50KCkge1xuICAgICAgICB2YXIgZXZlbnRQYXlsb2FkID0gdGhpcy5wcm9wcy5lZGl0b3JFdmVudCA/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YSA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFldmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3Rpb25EYXRhID0gZXZlbnRQYXlsb2FkLnNlbGVjdGlvbkRhdGE7XG5cbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnRQYXlsb2FkLm5hdGl2ZUV2ZW50O1xuXG4gICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgICB4OiBldmVudFBheWxvYWQubmF0aXZlRXZlbnQucGFnZVgsXG4gICAgICAgICAgICB5OiBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3BcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZGlyZWN0aW9uO1xuXG4gICAgICAgIHZhciBlbmRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZW5kUmVjdDtcblxuICAgICAgICB2YXIgc3RhcnRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uc3RhcnRSZWN0O1xuXG4gICAgICAgIGlmIChlbmRSZWN0ICYmIHN0YXJ0UmVjdCAmJiBzdGFydFJlY3QudG9wID09PSBlbmRSZWN0LnRvcCkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDtcbiAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgcG9pbnQgd2hlcmUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIHNob3cgVG9vbGJhciBhdCB0aGlzIHBvaW50XG4gICAgICAgIC8vIG90aGVyd2lzZSBzaG93IGl0IG9uIHRoZSBtaWRkbGUgb2YgdGhlIHNlbGVjdGlvbi5cblxuICAgICAgICBpZiAocG9zLnggJiYgcG9zLnkpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLl9nZXRYUG9pbnQoc2VsZWN0aW9uRGF0YSwgcG9zLngpO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbihwb3MueSwgc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHBvcy55LCB0aGlzLl9nZXRZUG9pbnQoc2VsZWN0aW9uRGF0YSwgbmF0aXZlRXZlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5sZWZ0ICsgc2VsZWN0aW9uRGF0YS5yZWdpb24ud2lkdGggLyAyO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSkge1xuXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuX2dldFlQb2ludChzZWxlY3Rpb25EYXRhLCBuYXRpdmVFdmVudCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIFdpZGdldC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG4gICAgICogQG1ldGhvZCBfZ2V0WFBvaW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50WCBUaGUgWCBjb29yZGluYXRlIHJlY2VpdmVkIGZyb20gdGhlIG5hdGl2ZSBldmVudCAobW91c2V1cCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgX2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBldmVudFgpIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gcmVnaW9uLnN0YXJ0UmVjdCA/IHJlZ2lvbi5zdGFydFJlY3QubGVmdCA6IHJlZ2lvbi5sZWZ0O1xuICAgICAgICB2YXIgcmlnaHQgPSByZWdpb24uZW5kUmVjdCA/IHJlZ2lvbi5lbmRSZWN0LnJpZ2h0IDogcmVnaW9uLnJpZ2h0O1xuXG4gICAgICAgIHZhciB4O1xuXG4gICAgICAgIGlmIChsZWZ0IDwgZXZlbnRYICYmIHJpZ2h0ID4gZXZlbnRYKSB7XG4gICAgICAgICAgICB4ID0gZXZlbnRYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlZnREaXN0ID0gTWF0aC5hYnMobGVmdCAtIGV2ZW50WCk7XG4gICAgICAgICAgICB2YXIgcmlnaHREaXN0ID0gTWF0aC5hYnMocmlnaHQgLSBldmVudFgpO1xuXG4gICAgICAgICAgICBpZiAobGVmdERpc3QgPCByaWdodERpc3QpIHsgLy8gdXNlciByYWlzZWQgdGhlIG1vdXNlIG9uIGxlZnQgb24gdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHggPSBsZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldEludGVyYWN0aW9uUG9pbnRcbiAgICAgKiBAbWV0aG9kIF9nZXRZUG9pbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmF0aXZlRXZlbnQgVGhlIGRhdGEgYWJvdXQgZXZlbnQgaXMgZmlyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjYWxjdWxhdGVkIFkgcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBfZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gMDtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uRGF0YSAmJiBuYXRpdmVFdmVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRUYXJnZXQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobmF0aXZlRXZlbnQudGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRUYXJnZXQuJCAmJiBlbGVtZW50VGFyZ2V0LmdldFN0eWxlKCdvdmVyZmxvdycpID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB5ID0gbmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldFRvcCArIG5hdGl2ZUV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0IHRha2luZyBpbiBjb25zaWRlcmF0aW9uIHRoZVxuICAgICAqIHt7I2Nyb3NzTGluayBcIldpZGdldFBvc2l0aW9uL2d1dHRlcjphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX0gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgIGdldFdpZGdldFhZUG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBUaGUgbGVmdCBvZmZzZXQgaW4gcGFnZSBjb29yZGluYXRlcyB3aGVyZSBUb29sYmFyIHNob3VsZCBiZSBzaG93bi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRoZSB0b3Agb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIE1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgKiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCBvciBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aXRoIGxlZnQgYW5kIHRvcCBvZmZzZXRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0V2lkZ2V0WFlQb2ludChsZWZ0LCB0b3AsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIHZhciBndXR0ZXIgPSB0aGlzLnByb3BzLmd1dHRlcjtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSB8fCBkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCAtIGd1dHRlci5sZWZ0IC0gKGRvbU5vZGUub2Zmc2V0V2lkdGggLyAyKTtcblxuICAgICAgICAgICAgdG9wID0gKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pID8gKHRvcCArIGd1dHRlci50b3ApIDpcbiAgICAgICAgICAgICAgICAodG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLSBndXR0ZXIudG9wKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFQgfHxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1JJR0hUX1RPX0xFRlQpIHtcblxuICAgICAgICAgICAgbGVmdCA9IChkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9MRUZUX1RPX1JJR0hUKSA/XG4gICAgICAgICAgICAgICAgKGxlZnQgKyBndXR0ZXIubGVmdCArIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMikgOlxuICAgICAgICAgICAgICAgIChsZWZ0IC0gMyAqIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMiAtIGd1dHRlci5sZWZ0KTtcblxuICAgICAgICAgICAgdG9wID0gdG9wIC0gZ3V0dGVyLnRvcCAtIChkb21Ob2RlLm9mZnNldEhlaWdodCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCB0b3BdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBpc1Zpc2libGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNWaXNpYmxlKCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuaGFzQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSB3aWRnZXQgZnJvbSBhIHN0YXJ0aW5nIHBvaW50IHRvIGEgZGVzdGluYXRpb24gcG9pbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cbiAgICAgKiBAbWV0aG9kIG1vdmVUb1BvaW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzdGFydFBvaW50IFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIG1vdmVtZW50LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZW5kUG9pbnQgVGhlIGRlc3RpbmF0aW9uIHBvaW50IGZvciB0aGUgbW92ZW1lbnQuXG4gICAgICovXG4gICAgbW92ZVRvUG9pbnQoc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcbiAgICAgICAgdmFyIGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpO1xuXG4gICAgICAgIGRvbUVsZW1lbnQuc2V0U3R5bGVzKHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YXJ0UG9pbnRbMF0gKyAncHgnLFxuICAgICAgICAgICAgdG9wOiBzdGFydFBvaW50WzFdICsgJ3B4JyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWxsb3ktZWRpdG9yLWludmlzaWJsZScpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LmFkZENsYXNzKCdhZS10b29sYmFyLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG4gICAgICAgICAgICBkb21FbGVtZW50LnNldFN0eWxlcyh7XG4gICAgICAgICAgICAgICAgbGVmdDogZW5kUG9pbnRbMF0gKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcDogZW5kUG9pbnRbMV0gKyAncHgnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgd2lkZ2V0IHdpdGggdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cbiAgICAgKiBAbWV0aG9kIHNob3dcbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUoKSAmJiBkb21Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb25Qb2ludCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsWCxcbiAgICAgICAgICAgICAgICAgICAgZmluYWxZLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsWCxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFk7XG5cbiAgICAgICAgICAgICAgICBmaW5hbFggPSBpbml0aWFsWCA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgnbGVmdCcpKTtcbiAgICAgICAgICAgICAgICBmaW5hbFkgPSBpbml0aWFsWSA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgndG9wJykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuY29uc3RyYWluVG9WaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5nZXRDb25zdHJhaW5lZFBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VGbG9hdChkb21Ob2RlLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmaW5hbFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGZpbmFsWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KGRvbU5vZGUub2Zmc2V0V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsWCA9IHJlcy54O1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFkgPSByZXMueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25Qb2ludC5kaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxZID0gdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFkgPSB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1BvaW50KFtpbml0aWFsWCwgaW5pdGlhbFldLCBbZmluYWxYLCBmaW5hbFldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHdpZGdldCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBpbnRlcmFjdGlvbiBwb2ludC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuICAgICAqIEBtZXRob2QgdXBkYXRlUG9zaXRpb25cbiAgICAgKi9cbiAgICB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgdmFyIGludGVyYWN0aW9uUG9pbnQgPSB0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKTtcblxuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIGlmIChpbnRlcmFjdGlvblBvaW50ICYmIGRvbU5vZGUpIHtcbiAgICAgICAgICAgIHZhciB4eSA9IHRoaXMuZ2V0V2lkZ2V0WFlQb2ludChpbnRlcmFjdGlvblBvaW50LngsIGludGVyYWN0aW9uUG9pbnQueSwgaW50ZXJhY3Rpb25Qb2ludC5kaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkuc2V0U3R5bGVzKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB4eVswXSArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wOiB4eVsxXSArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYW4gYW5pbWF0aW9uIGZyYW1lLCBpZiBwb3NzaWJsZSwgdG8gc2ltdWxhdGUgYW4gYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG4gICAgICogQG1ldGhvZCBfYW5pbWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2NoZWR1bGVkIGZyYW1lLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYW5pbWF0ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Cb2xkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHN0eWxpbmcgYW4gc2VsZWN0aW9uIHdpdGggc3Ryb25nIChib2xkKSBzdHlsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQm9sZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkJvbGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5ib2xkfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1ib2xkXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYm9sZH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1ib2xkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJvbGRcbiAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkJvbGQua2V5ID0gJ2JvbGQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkJvbGRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkJvbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdib2xkJyxcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdleGVjQ29tbWFuZCcsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA2NiAvKkIqL1xuICAgIH0sXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX2JvbGQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbktleXN0cm9rZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbkJvbGRcbikpKSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNhbWVyYUltYWdlIGNsYXNzIHRha2VzIHBob3RvIGZyb20gY2FtZXJhIGFuZCBpbnNlcnRzIGl0IHRvIHRoZSBjb250ZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25DYW1lcmFJbWFnZVxuICovXG5jbGFzcyBCdXR0b25DYW1lcmFJbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgdGhlIHRha2UgcGhvdG8gYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzLnJlZnMuYnV0dG9uVGFrZVBob3RvKS5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLnN0b3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBnZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWE7XG5cbiAgICAgICAgZ2V0VXNlck1lZGlhLmNhbGwobmF2aWdhdG9yLCB7XG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICB9LCB0aGlzLl9oYW5kbGVTdHJlYW1TdWNjZXNzLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVN0cmVhbUVycm9yLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNhbWVyYVwiPlxuICAgICAgICAgICAgICAgIDx2aWRlbyByZWY9XCJ2aWRlb0NvbnRhaW5lclwiPlZpZGVvIHN0cmVhbSBub3QgYXZhaWxhYmxlLjwvdmlkZW8+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJhZS1jYW1lcmEtc2hvb3RcIiBvbkNsaWNrPXt0aGlzLnRha2VQaG90by5iaW5kKHRoaXMpfSByZWY9XCJidXR0b25UYWtlUGhvdG9cIj5UYWtlIHBob3RvPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGNhbnZhcyBjbGFzc05hbWU9XCJhZS1jYW1lcmEtY2FudmFzXCIgcmVmPVwiY2FudmFzQ29udGFpbmVyXCI+PC9jYW52YXM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBwaG90byBmcm9tIHRoZSB2aWRlbyBzdHJlYW0gYW5kIGluc2VydHMgaW4gaW50byBlZGl0b3IncyBjb250ZW50LlxuICAgICAqXG4gICAgICogQGZpcmVzIEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCB0YWtlUGhvdG9cbiAgICAgKi9cbiAgICB0YWtlUGhvdG8oKSB7XG4gICAgICAgIHZhciB2aWRlb0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLnZpZGVvQ29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl92aWRlb0hlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5wcm9wcy52aWRlb1dpZHRoO1xuXG4gICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgICAgIGNhbnZhc0VsLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvRWwsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgaW1nVVJMID0gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblxuICAgICAgICAgICAgdmFyIGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoJzxpbWcgc3JjPVwiJyArIGltZ1VSTCArICdcIj4nKTtcblxuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnaW1hZ2VDYW1lcmFBZGQnLCBlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdmlkZW8gc3RyZWFtIGNhcHR1cmluZyBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQG1ldGhvZCBfaGFuZGxlU3RyZWFtRXJyb3JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlcnJvciBUaGUgZmlyZWQgZXZlbnQgaW4gY2FzZSBvZiBlcnJvci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmVhbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHdpbmRvdy5hbGVydCgnQW4gZXJyb3Igb2NjdXJyZWQhICcgKyBlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHN0cmVhbWluZyB2aWRlbyBpbiB0aGUgdmlkZW8gZWxlbWVudCBhbmQgc2V0cyB3aWR0aC9oZWlnaHQgdG8gdGhlIHZpZGVvXG4gICAgICogYW5kIGNhbnZhcyBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICAgICAqIEBtZXRob2QgX2hhbmRsZVN0cmVhbVN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtIFRoZSB2aWRlbyBzdHJlYW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmVhbVN1Y2Nlc3Moc3RyZWFtKSB7XG4gICAgICAgIHZhciB2aWRlb0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLnZpZGVvQ29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB2aWRlb0VsLnZpZGVvSGVpZ2h0IC8gKHZpZGVvRWwudmlkZW9XaWR0aC90aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucHJvcHMudmlkZW9XaWR0aCAvICg0LzMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWRlb0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuICAgICAgICAgICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgICAgICBjYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5wcm9wcy52aWRlb1dpZHRoKTtcbiAgICAgICAgICAgIGNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcblxuICAgICAgICAgICAgdGhpcy5fdmlkZW9IZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcblxuICAgICAgICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgICAgICAgICAgdmlkZW9FbC5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb0VsLnNyYyA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlkZW9FbC5wbGF5KCk7XG5cbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmJ1dHRvblRha2VQaG90bykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIHRha2VuIGZyb20gdGhlIGNhbWVyYSBhbmQgYWRkZWQgYXMgYW4gZWxlbWVudCB0byB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGV2ZW50IEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnQgaW4gZWRpdG9yLlxuICAgICAqL1xufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGNhbWVyYUltYWdlXG4gKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uQ2FtZXJhSW1hZ2Uua2V5ID0gJ2NhbWVyYUltYWdlJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uQ2FtZXJhSW1hZ2UuZGVmYXVsdFByb3BzID0ge1xuICAgIHZpZGVvV2lkdGg6IDMyMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2FtZXJhSW1hZ2U7XG4iLCJpbXBvcnQgQnV0dG9uQ2FtZXJhSW1hZ2UgZnJvbSAnLi9idXR0b24tY2FtZXJhLWltYWdlLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25DYW1lcmEgY2xhc3MgcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IHdheXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGUuXG4gKiAtIEV4Y2x1c2l2ZTogUmVuZGVycyBCdXR0b25DYW1lcmFJbWFnZSBpbiBvcmRlciB0byB0YWtlIHBob3RvIGZyb20gdGhlIGNhbWVyYS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ2FtZXJhXG4gKi9cbmNsYXNzIEJ1dHRvbkNhbWVyYSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJ1dHRvbkNhbWVyYUltYWdlIHsuLi50aGlzLnByb3BzfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9ICEobmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fFxuICAgICAgICAgICAgICAgIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhICYmIGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWEpO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkaXNhYmxlZCA/IEFsbG95RWRpdG9yLlN0cmluZ3MuY2FtZXJhRGlzYWJsZWQgOiBBbGxveUVkaXRvci5TdHJpbmdzLmNhbWVyYTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e2xhYmVsfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24taW1hZ2UtY2FtZXJhXCIgZGlzYWJsZWQ9e2Rpc2FibGVkfSBvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUuYmluZChCdXR0b25DYW1lcmEua2V5KX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtsYWJlbH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tY2FtZXJhXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBjYW1lcmFcbiAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uQ2FtZXJhLmtleSA9ICdjYW1lcmEnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25DYW1lcmE7XG4iLCJpbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQ29kZSBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgcHJlYCBlbGVtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db2RlXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25Db2RlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29kZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tY29kZVwiIG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZS5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1jb2RlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGNvZGVcbiAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkNvZGUua2V5ID0gJ2NvZGUnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkNvZGVcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkNvZGUuZGVmYXVsdFByb3BzID0ge1xuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICdwcmUnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25Db2RlXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3MgaXMgYSBVSSBjbGFzcyB0aGF0IHJlbmRlcnMgYSBCdXR0b25Db21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlXG4gKiBhIGxpc3QgYXMgYW4gaXRlbSwgd2l0aCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYmVoYXZpb3VyLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZExpc3RJdGVtXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuZGVzY3JpcHRpb259IGNsYXNzTmFtZT17dGhpcy5fZ2V0Q2xhc3NOYW1lKCl9IG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9Pnt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufTwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWUgb2YgV2lkZ2V0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuICAgICAqIEBtZXRob2QgX2dldENsYXNzTmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBXaWRnZXQuXG4gICAgICovXG4gICAgX2dldENsYXNzTmFtZSgpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmljb24pIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSAnIGFlLWljb24tJyArIHRoaXMucHJvcHMuaWNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25Db21tYW5kTGlzdEl0ZW0ua2V5ID0gJ2J1dHRvbkNvbW1hbmRMaXN0SXRlbSc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZExpc3RJdGVtXG4pOyIsImltcG9ydCBCdXR0b25Db21tYW5kTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNvbW1hbmRzTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzaG93aW5nIGEgbGlzdCBvZiBjb21tYW5kcyB0aGF0IGNhbiBiZVxuICogZXhlY3V0ZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29tbWFuZHNMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZHNMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogRm9jdXNlcyBvbiB0aGUgbGlzdCBub2RlIHRvIGFsbG93IGtleWJvYXJkIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1kcm9wZG93biBhZS1hcnJvdy1ib3ggYWUtYXJyb3ctYm94LXRvcC1sZWZ0XCIgb25Gb2N1cz17dGhpcy5mb2N1cy5iaW5kKHRoaXMpfSBvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9IHRhYkluZGV4PVwiMFwiPlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJhZS1saXN0Ym94XCIgaWQ9e3RoaXMucHJvcHMubGlzdElkfSByb2xlPVwibGlzdGJveFwiPlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyQWN0aW9ucyh0aGlzLnByb3BzLmNvbW1hbmRzKX1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZXMgb2YgQnV0dG9uQ29tbWFuZExpc3RJdGVtIHdpdGggdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSByb3cgYWN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3RcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJBY3Rpb25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZW5kZXJlZCBpbnN0YW5jZXMgb2YgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGNsYXNzXG4gICAgICovXG4gICAgX3JlbmRlckFjdGlvbnMoY29tbWFuZHMpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgICAgICB2YXIgaXRlbXM7XG5cbiAgICAgICAgaWYgKGNvbW1hbmRzICYmIGNvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMgPSBjb21tYW5kcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW0uY29tbWFuZH0gcm9sZT1cIm9wdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSBjb21tYW5kPXtpdGVtLmNvbW1hbmR9IGRlc2NyaXB0aW9uPXt0eXBlb2YgaXRlbS5sYWJlbCA9PT0gJ3N0cmluZycgPyBpdGVtLmxhYmVsIDogaXRlbS5sYWJlbCgpfSBlZGl0b3I9e2VkaXRvcn0gLz5cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25Db21tYW5kc0xpc3Qua2V5ID0gJ2J1dHRvbkNvbW1hbmRzTGlzdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25Db21tYW5kc0xpc3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvbkNvbW1hbmRzTGlzdFxuKTsiLCJpbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRHJvcGRvd24gY2xhc3MgcHJvdmlkZXMgbWFya3VwIGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uIGJlaGF2aW91ciB0byBhIGRyb3Bkb3duXG4gKiBvcGVuZWQgZnJvbSBhIGJ1dHRvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRHJvcGRvd25cbiAqL1xuY2xhc3MgQnV0dG9uRHJvcGRvd24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1kcm9wZG93biBhZS1hcnJvdy1ib3ggYWUtYXJyb3ctYm94LXRvcC1sZWZ0XCIgb25Gb2N1cz17dGhpcy5mb2N1cy5iaW5kKHRoaXMpfSBvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9IHRhYkluZGV4PVwiMFwiPlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJhZS1saXN0Ym94XCIgcm9sZT1cImxpc3Rib3hcIj5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGRyb3Bkb3duIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGRyb3Bkb3duXG4gKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uRHJvcGRvd24ua2V5ID0gJ2Ryb3Bkb3duJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqL1xuQnV0dG9uRHJvcGRvd24uZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvbkRyb3Bkb3duXG4pOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIEtFWV9FTlRFUiA9IDEzO1xudmFyIEtFWV9FU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRW1iZWRFZGl0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGFuIGVtYmVkIGxpbmsgaW4gYSBkb2N1bWVudC5cbiAqIFByb3ZpZGVzIFVJIGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhbiBlbWJlZCBsaW5rLlxuICpcbiAqIEBjbGFzcyBCdXR0b25FbWJlZEVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uRW1iZWRFZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5saW5rSW5wdXQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGNvbXBvbmVudFxuICAgICAqIGlzIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIHByZXZlbnQgYWdncmVzc2l2ZSBmb2N1cyBzdGVhbGluZy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSB8fCB0aGlzLnByb3BzLm1hbnVhbFNlbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYmVmb3JlIGZvY3VzaW5nIHRvIGF2b2lkIHVuZGVzaXJlZFxuICAgICAgICAgICAgLy8gc2Nyb2xscyBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2ZvY3VzTGlua0lucHV0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2ZvY3VzTGlua0lucHV0LmJpbmQodGhpcyksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmdldEluaXRpYWxTdGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoaXMuc3RhdGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBnZXRJbml0aWFsU3RhdGVcbiAgICAgKi9cbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgZW1iZWQ7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZW1iZWQgPSBzZWxlY3RlZEVsZW1lbnQuZmluZE9uZSgnW2RhdGEtd2lkZ2V0PVwiYWVfZW1iZWRcIl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBocmVmID0gZW1iZWQgPyBlbWJlZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWUtZW1iZWQtdXJsJykgOiAnJztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudDogZW1iZWQsXG4gICAgICAgICAgICBpbml0aWFsTGluazoge1xuICAgICAgICAgICAgICAgIGhyZWY6IGhyZWZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rSHJlZjogaHJlZlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNsZWFyTGlua1N0eWxlID0ge1xuICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGF0ZS5saW5rSHJlZiA/IDEgOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGlua1wiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVFbWJlZH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGF0YS10eXBlPVwiYnV0dG9uLWVtYmVkLXJlbW92ZVwiIGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lbGVtZW50fSBvbkNsaWNrPXt0aGlzLl9yZW1vdmVFbWJlZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlRW1iZWR9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWJpblwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1pbnB1dCB4eGxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT1cImFlLWlucHV0XCIgb25DaGFuZ2U9e3RoaXMuX2hhbmRsZUxpbmtIcmVmQ2hhbmdlLmJpbmQodGhpcyl9IG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpfSBwbGFjZWhvbGRlcj17QWxsb3lFZGl0b3IuU3RyaW5ncy5lZGl0TGlua30gcmVmPXt0aGlzLmxpbmtJbnB1dH0gdHlwZT1cInRleHRcIiB2YWx1ZT17dGhpcy5zdGF0ZS5saW5rSHJlZn0+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1pY29uLXJlbW92ZVwiIG9uQ2xpY2s9e3RoaXMuX2NsZWFyTGluay5iaW5kKHRoaXMpfSBzdHlsZT17Y2xlYXJMaW5rU3R5bGV9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFyfT48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGlzYWJsZWQ9eyF0aGlzLl9pc1ZhbGlkU3RhdGUoKX0gb25DbGljaz17dGhpcy5fZW1iZWRMaW5rLmJpbmQodGhpcyl9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLW9rXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBsaW5rIGlucHV0LiBUaGlzIG9ubHkgY2hhbmdlcyB0aGUgY29tcG9uZW50IGludGVybmFsIHN0YXRlLCBidXQgZG9lcyBub3RcbiAgICAgKiBhZmZlY3QgdGhlIGxpbmsgZWxlbWVudCBvZiB0aGUgZWRpdG9yLiBPbmx5IHRoZSBfcmVtb3ZlTGluayBhbmQgX3VwZGF0ZUxpbmsgbWV0aG9kc1xuICAgICAqIGFyZSB0cmFuc2xhdGVkIHRvIHRoZSBlZGl0b3IgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIF9jbGVhckxpbmtcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NsZWFyTGluaygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsaW5rSHJlZjogJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgdGhlIGVtYmVkVXJsIGNvbW1hbmQgdG8gdHJhbnNmb3JtIHRoZSBsaW5rIGludG8gYW4gZW1iZWQgbWVkaWEgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBfZW1iZWRMaW5rXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9lbWJlZExpbmsoKSB7XG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIG5hdGl2ZUVkaXRvci5leGVjQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuc3RhdGUubGlua0hyZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuICAgICAgICAvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG4gICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX2ZvY3VzTGlua0lucHV0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9mb2N1c0xpbmtJbnB1dCgpIHtcbiAgICAgICAgdGhpcy5saW5rSW5wdXQuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcbiAgICAgKiAtIEVudGVyOiBDcmVhdGVzL3VwZGF0ZXMgdGhlIGxpbmsuXG4gICAgICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX2hhbmRsZUtleURvd25cbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtYmVkTGluaygpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG4gICAgICAgICAgICAvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayBpbnB1dCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlTGlua0hyZWZDaGFuZ2VcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFuZGxlTGlua0hyZWZDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsaW5rSHJlZjogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgbGluayBzdGF0ZSBpcyB2YWxpZCBzbyB0aGUgdXNlciBjYW4gc2F2ZSB0aGUgbGluay4gQSB2YWxpZCBzdGF0ZVxuICAgICAqIG1lYW5zIHRoYXQgd2UgaGF2ZSBhIG5vbi1lbXB0eSBocmVmIHRoYXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgb25lLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuICAgICAqIEBtZXRob2QgX2lzVmFsaWRTdGF0ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzdGF0ZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgX2lzVmFsaWRTdGF0ZSgpIHtcbiAgICAgICAgdmFyIHZhbGlkU3RhdGUgPVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5saW5rSHJlZiAmJiAoXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5saW5rSHJlZiAhPT0gdGhpcy5zdGF0ZS5pbml0aWFsTGluay5ocmVmXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB2YWxpZFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGVtYmVkIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcbiAgICAgKiBAbWV0aG9kIF9yZW1vdmVFbWJlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlRW1iZWQoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIHZhciBlbWJlZFdyYXBwZXIgPSB0aGlzLnN0YXRlLmVsZW1lbnQuZ2V0QXNjZW5kYW50KGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0NsYXNzKCdja2Vfd2lkZ2V0X3dyYXBwZXInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1iZWRXcmFwcGVyLnJlbW92ZSgpO1xuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgZW1iZWRFZGl0XG4gKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkVtYmVkRWRpdC5rZXkgPSAnZW1iZWRFZGl0JztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uRW1iZWRFZGl0O1xuIiwiaW1wb3J0IEJ1dHRvbkVtYmVkRWRpdCBmcm9tICcuL2J1dHRvbi1lbWJlZC1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25FbWJlZCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhbiBlbWJlZCBsaW5rIGluIGEgZG9jdW1lbnQuXG4gKiBCdXR0b25FbWJlZCByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgbW9kZXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGVcbiAqIC0gRXhjbHVzaXZlOiBUaGUgQnV0dG9uRW1iZWRFZGl0IFVJIHdpdGggYWxsIHRoZSBsaW5rIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkVtYmVkXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqL1xuY2xhc3MgQnV0dG9uRW1iZWQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJ1dHRvbkVtYmVkRWRpdCB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24tZW1iZWRcIiBvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hZGRcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdGhlIGxpbmsgYnV0dG9uIHRvIGJlIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIGFsbG93IHRoZSBlbWJlZGRpbmcgb2YgYSBsaW5rLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG4gICAgICogQG1ldGhvZCBfcmVxdWVzdEV4Y2x1c2l2ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVxdWVzdEV4Y2x1c2l2ZSgpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkVtYmVkLmtleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGVtYmVkXG4gKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uRW1iZWQgLmtleSA9ICdlbWJlZCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkVtYmVkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyBDS0VESVRPUi5TSElGVCArIDc2IC8qTCovXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uS2V5c3Ryb2tlKFxuICAgIEJ1dHRvbkVtYmVkXG4pOyIsImltcG9ydCBCdXR0b25BY3Rpb25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IMSBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgaDFgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkgxXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25IMSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkgxXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5oMX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24taDFcIiBvbkNsaWNrPXt0aGlzLmFwcGx5U3R5bGUuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmgxfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWgxXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGgxXG4gKiBAbWVtYmVyb2YgQnV0dG9uSDFcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSDEua2V5ID0gJ2gxJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25IMVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSDEuZGVmYXVsdFByb3BzID0ge1xuICAgIHN0eWxlOiB7XG4gICAgICAgIGVsZW1lbnQ6ICdoMSdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbkgxXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkgyIGNsYXNzIHByb3ZpZGVzIHdyYXBzIGEgc2VsZWN0aW9uIGluIGBoMmAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSDJcbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkgyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSDJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmgyfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1oMlwiIG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZS5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDJ9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24taDJcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaDJcbiAqIEBtZW1iZXJvZiBCdXR0b25IMlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25IMi5rZXkgPSAnaDInO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkgyXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25IMi5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgICAgZWxlbWVudDogJ2gyJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uSDJcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IbGluZSBjbGFzcyBwcm92aWRlcyBpbnNlcnRzIGhvcml6b250YWwgbGluZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSGxpbmVcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkhsaW5lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5ob3Jpem9udGFscnVsZX0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGF0YS10eXBlPVwiYnV0dG9uLWhsaW5lXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaG9yaXpvbnRhbHJ1bGV9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tc2VwYXJhdG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGhsaW5lXG4gKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSGxpbmUua2V5ID0gJ2hsaW5lJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25IbGluZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSGxpbmUuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdob3Jpem9udGFscnVsZScsXG4gICAgc3R5bGU6IHtcbiAgICAgICAgZWxlbWVudDogJ2hyJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbkhsaW5lXG4pKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGFuIGltYWdlIGluIHRoZSBjZW50ZXIuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlclwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduQ2VudGVyfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLWNlbnRlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpbWFnZUNlbnRlclxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSW1hZ2VBbGlnbkNlbnRlci5rZXkgPSAnaW1hZ2VDZW50ZXInO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkltYWdlQWxpZ25DZW50ZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdqdXN0aWZ5Y2VudGVyJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25MZWZ0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGFuIGltYWdlIG9uIGxlZnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnbkxlZnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduTGVmdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLWxlZnRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW1hZ2VMZWZ0XG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSW1hZ2VBbGlnbkxlZnQua2V5ID0gJ2ltYWdlTGVmdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbkltYWdlQWxpZ25MZWZ0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeWxlZnQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRBY3RpdmUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgICAgICBCdXR0b25JbWFnZUFsaWduTGVmdFxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25SaWdodCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhbiBpbWFnZSBvbiByaWdodC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1hbGlnbi1yaWdodFwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tcmlnaHRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW1hZ2VSaWdodFxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JbWFnZUFsaWduUmlnaHQua2V5ID0gJ2ltYWdlUmlnaHQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSW1hZ2VBbGlnblJpZ2h0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeXJpZ2h0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4pKSk7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZSBjbGFzcyBpbnNlcnRzIGFuIGltYWdlIHRvIHRoZSBjb250ZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbWFnZVxuICovXG5jbGFzcyBCdXR0b25JbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmZpbGVJbnB1dCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgaW5wdXRTeWxlID0ge2Rpc3BsYXk6ICdub25lJ307XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmltYWdlfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBkYXRhLXR5cGU9XCJidXR0b24taW1hZ2VcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24taW1hZ2VcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICAgICAgICA8aW5wdXQgYWNjZXB0PVwiaW1hZ2UvKlwiIG9uQ2hhbmdlPXt0aGlzLl9vbklucHV0Q2hhbmdlLmJpbmQodGhpcyl9IHJlZj17dGhpcy5maWxlSW5wdXR9IHN0eWxlPXtpbnB1dFN5bGV9IHR5cGU9XCJmaWxlXCIvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltdWxhdGVzIGNsaWNrIG9uIHRoZSBpbnB1dCBlbGVtZW50LiBUaGlzIHdpbGwgb3BlbiBicm93c2VyJ3MgbmF0aXZlIGZpbGUgb3BlbiBkaWFsb2cuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VcbiAgICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIHJlY2VpdmVkIGNsaWNrIGV2ZW50IG9uIHRoZSBidXR0b24uXG4gICAgICovXG4gICAgaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuZmlsZUlucHV0LmN1cnJlbnQuY2xpY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbiBpbnB1dCBjaGFuZ2UsIHJlYWRzIHRoZSBjaG9zZW4gZmlsZSBhbmQgZmlyZXMgYW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aXRoIHRoZSBpbWFnZSB3aGljaCB3aWxsIGJlIGFkZGVkXG4gICAgICogdG8gdGhlIGNvbnRlbnQuIFRoZSBpbWFnZSBmaWxlIHdpbGwgYmUgcGFzc2VkIGluIHRoZSBgaW1hZ2VGaWxlc2AgcHJvcGVydHkuXG4gICAgICogSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnMgcmV0dXJucyBgZmFsc2VgIG9yIGNhbmNlbHMgdGhlIGV2ZW50LCB0aGUgaW1hZ2Ugd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGNvbnRlbnQuXG4gICAgICogT3RoZXJ3aXNlLCBhbiBldmVudCBgaW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgaW5zZXJ0ZWQgZWxlbWVudCBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLlxuICAgICAqIFRoZSBwYXNzZWQgcGFyYW1zIHdpbGwgYmU6XG4gICAgICogLSBgZWxgIC0gdGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnRcbiAgICAgKiAtIGBmaWxlYCAtIHRoZSBvcmlnaW5hbCBpbWFnZSBmaWxlIGZyb20gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBmaXJlcyBCdXR0b25JbWFnZSNiZWZvcmVJbWFnZUFkZFxuICAgICAqIEBmaXJlcyBCdXR0b25JbWFnZSNpbWFnZUFkZFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuICAgICAqIEBtZXRob2QgX29uSW5wdXRDaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX29uSW5wdXRDaGFuZ2UoKSB7XG4gICAgICAgIHZhciBpbnB1dEVsID0gdGhpcy5maWxlSW5wdXQuY3VycmVudDtcblxuICAgICAgICAvLyBPbiBJRTExIHRoZSBmdW5jdGlvbiBtaWdodCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhcnJheSBvZlxuICAgICAgICAvLyBmaWxlcy4gSW4gc3VjaCBhIGNhc2UsIG5vIGFjdGlvbnMgd2lsbCBiZSB0YWtlbi5cbiAgICAgICAgaWYgKCFpbnB1dEVsLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHZhciBmaWxlID0gaW5wdXRFbC5maWxlc1swXTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZWRpdG9yLmZpcmUoJ2JlZm9yZUltYWdlQWRkJywge1xuICAgICAgICAgICAgICAgIGltYWdlRmlsZXM6IGZpbGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoISFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbCgnPGltZyBzcmM9XCInICsgZXZlbnQudGFyZ2V0LnJlc3VsdCArICdcIj4nKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZVxuICAgICAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblxuICAgICAgICBpbnB1dEVsLnZhbHVlID0gJyc7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGltYWdlXG4gKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSW1hZ2Uua2V5ID0gJ2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uSW1hZ2U7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbmRlbnRCbG9jayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBpbmRlbnRpbmcgdGhlIHNlbGVjdGVkIGJsb2Nrcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW5kZW50QmxvY2tcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbmRlbnRCbG9jayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkluZGVudEJsb2NrXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbmRlbnR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWluZGVudC1ibG9ja1wiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmluZGVudH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1pbmRlbnQtYmxvY2tcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW5kZW50QmxvY2tcbiAqIEBtZW1iZXJvZiBCdXR0b25JbmRlbnRCbG9ja1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25JbmRlbnRCbG9jay5rZXkgPSAnaW5kZW50QmxvY2snO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkluZGVudEJsb2NrXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25JbmRlbnRCbG9jay5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2luZGVudCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvbkluZGVudEJsb2NrXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkl0YWxpYyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHlsaW5nIGFuIHNlbGVjdGlvbiB3aXRoIGl0YWxpYyAoZW0pIHN0eWxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25JdGFsaWNcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25JdGFsaWMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25JdGFsaWNcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLml0YWxpY30gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24taXRhbGljXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaXRhbGljfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWl0YWxpY1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBpdGFsaWNcbiAqIEBtZW1iZXJvZiBCdXR0b25JdGFsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uSXRhbGljLmtleSA9ICdpdGFsaWMnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uSXRhbGljLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnaXRhbGljJyxcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdleGVjQ29tbWFuZCcsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA3MyAvKkkqL1xuICAgIH0sXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX2l0YWxpYydcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uS2V5c3Ryb2tlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uSXRhbGljXG4pKSkpOyIsImltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHNob3dpbmcgYSBsaXN0IG9mXG4gKiBpdGVtcyB0aGF0IGNhbiBiZSBzZWxlY3RlZCBmb3IgdGhlIGxpbmsuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoIW5leHRQcm9wcy50ZXJtIHx8IG5leHRQcm9wcy50ZXJtICE9PSB0aGlzLnByb3BzLnRlcm0pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcblxuICAgICAgICAgICAgaWYgKG5leHRQcm9wcy50ZXJtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fdXBkYXRlSXRlbXMsIHRoaXMucHJvcHMuZGVsYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3BzLmF1dG9jb21wbGV0ZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZm9jdXMsIDApO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXRBdXRvY29tcGxldGVTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmV4cGFuZGVkIHx8ICF0aGlzLnN0YXRlLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJ1dHRvbkRyb3Bkb3duPlxuICAgICAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJBdXRvY29tcGxldGVJdGVtcyh0aGlzLnN0YXRlLml0ZW1zKX1cbiAgICAgICAgICAgIDwvQnV0dG9uRHJvcGRvd24+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGJlZm9yZSByZW5kZXJpbmcgd2hlbiBuZXcgcHJvcHMgb3Igc3RhdGUgYXJlIGJlaW5nIHJlY2VpdmVkLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlciBvciB3aGVuIGZvcmNlVXBkYXRlIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAgICAgKiBAbWV0aG9kICBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcyBhbmQgc3RhdGUgd2lsbCBub3RcbiAgICAgKiByZXF1aXJlIGEgY29tcG9uZW50IHVwZGF0ZS5cbiAgICAgKi9cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQcm9wcy5leHBhbmRlZCAhPT0gdGhpcy5wcm9wcy5leHBhbmRlZCB8fCBuZXh0UHJvcHMudGVybSAhPT0gdGhpcy5wcm9wcy50ZXJtIHx8IG5leHRTdGF0ZS5pdGVtcyAhPT0gdGhpcy5zdGF0ZS5pdGVtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc2V0IG9mIGxpc3QgaXRlbXMgZm9yIHRoZSBwcm92aWRlZCBpdGVtc1xuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gICAgICogQG1ldGhvZCBfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBMaXN0IG9mIGF1dG9jb21wbGV0ZSBpdGVtcyB0byByZW5kZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJlbmRlcmVkIGxpc3QgaXRlbSBpbnN0YW5jZXNcbiAgICAgKi9cbiAgICBfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaXRlbXMgPSBpdGVtcyB8fCBbXTtcblxuICAgICAgICB2YXIgaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrID0gdGhpcy5wcm9wcy5oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2s7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy50ZXJtID09PSBpdGVtLnVybCA/ICdhZS10b29sYmFyLWVsZW1lbnQgYWN0aXZlJyA6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW0udXJsfSByb2xlPVwib3B0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IG9uQ2xpY2s9e2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGlja30gZGF0YS12YWx1ZT17aXRlbS51cmx9PntpdGVtLnRpdGxlfTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGF0YSBhY2NvcmRpbmcgdG8ge3RoaXMucHJvcHMudGVybX0gYW5kIGNhbGxzIHNldFN0YXRlKCkgd2l0aCB0aGUgcmV0dXJuZWQgZGF0YVxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gICAgICogQG1ldGhvZCBfdXBkYXRlSXRlbXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUl0ZW1zKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wcy50ZXJtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzLnByb3BzLmRhdGEodGhpcy5wcm9wcy50ZXJtKSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLnByb3BzLmV4cGFuZGVkICYmIGluc3RhbmNlLnByb3BzLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluc3RhbmNlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpdGVtczogaXRlbXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgYnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdC5rZXkgPSAnYnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IGZhbHNlLFxuICAgIGRhdGE6IFtdLFxuICAgIGRlbGF5OiAxMDAsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50JyxcbiAgICBrZXlzOiB7XG4gICAgICAgIGRpc21pc3M6IFsyN10sXG4gICAgICAgIGRpc21pc3NOZXh0OiBbMzldLFxuICAgICAgICBkaXNtaXNzUHJldjogWzM3XSxcbiAgICAgICAgbmV4dDogWzQwXSxcbiAgICAgICAgcHJldjogWzM4XVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuKTsiLCJpbXBvcnQgQnV0dG9uQ2ZnUHJvcHMgZnJvbSAnLi4vYmFzZS9idXR0b24tcHJvcHMuanMnO1xuaW1wb3J0IEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IGZyb20gJy4vYnV0dG9uLWxpbmstYXV0b2NvbXBsZXRlLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25MaW5rVGFyZ2V0RWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLXRhcmdldC1lZGl0LmpzeCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0RHJvcGRvd24gZnJvbSAnLi4vYmFzZS93aWRnZXQtZHJvcGRvd24uanMnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua0VkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSBsaW5rIGluIGEgZG9jdW1lbnQuXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcsIGVkaXRpbmcgYW5kIHJlbW92aW5nIGEgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua0VkaXRcbiAqIEB1c2VzIEJ1dHRvbkNmZ1Byb3BzXG4gKiBAdXNlcyBXaWRnZXREcm9wZG93blxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmtFZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5saW5rSW5wdXQgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuX2dldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBGb2N1c2VzIG9uIHRoZSBsaW5rIGlucHV0IHRvIGltbWVkaWF0ZWx5IGFsbG93IGVkaXRpbmcuIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBjb21wb25lbnRcbiAgICAgKiBpcyByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBwcmV2ZW50IGFnZ3Jlc3NpdmUgZm9jdXMgc3RlYWxpbmcuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSB8fCB0aGlzLnByb3BzLm1hbnVhbFNlbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYmVmb3JlIGZvY3VzaW5nIHRvIGF2b2lkIHVuZGVzaXJlZFxuICAgICAgICAgICAgLy8gc2Nyb2xscyBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgdGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRJbml0aWFsU3RhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB0YXJnZXRTZWxlY3RvciA9IHtcbiAgICAgICAgICAgIGFsbG93ZWRUYXJnZXRzOiB0aGlzLnByb3BzLmFsbG93ZWRUYXJnZXRzLFxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLnByb3BzLmVkaXRvcixcbiAgICAgICAgICAgIGhhbmRsZUxpbmtUYXJnZXRDaGFuZ2U6IHRoaXMuX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGVjdGVkVGFyZ2V0OiB0aGlzLnN0YXRlLmxpbmtUYXJnZXQgfHwgQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0RGVmYXVsdFxuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldFNlbGVjdG9yID0gdGhpcy5tZXJnZURyb3Bkb3duUHJvcHModGFyZ2V0U2VsZWN0b3IsIEJ1dHRvbkxpbmtUYXJnZXRFZGl0LmtleSk7XG5cbiAgICAgICAgdmFyIGF1dG9jb21wbGV0ZURyb3Bkb3duO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkYXRhRm4gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgICAgIGlmICghTGFuZy5pc0Z1bmN0aW9uKGRhdGFGbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgICAgICAgICBkYXRhRm4gPSAoKSA9PiBpdGVtcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IHRoaXMuc3RhdGUuYXV0b2NvbXBsZXRlU2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YUZuLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5wcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrOiB0aGlzLl9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2ssXG4gICAgICAgICAgICAgICAgb25EaXNtaXNzOiB0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLFxuICAgICAgICAgICAgICAgIHNldEF1dG9jb21wbGV0ZVN0YXRlOiB0aGlzLl9zZXRBdXRvY29tcGxldGVTdGF0ZSxcbiAgICAgICAgICAgICAgICB0ZXJtOiB0aGlzLnN0YXRlLmxpbmtIcmVmXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhdXRvY29tcGxldGVEcm9wZG93blByb3BzID0gdGhpcy5tZXJnZURyb3Bkb3duUHJvcHMoYXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wcywgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qua2V5KTtcblxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlRHJvcGRvd24gPSA8QnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qgey4uLmF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHN9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1dHRvbkNsZWFyTGluaztcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5saW5rSHJlZikge1xuICAgICAgICAgICAgYnV0dG9uQ2xlYXJMaW5rID0gPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1pY29uLXJlbW92ZVwiIG9uQ2xpY2s9e3RoaXMuX2NsZWFyTGluay5iaW5kKHRoaXMpfSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jbGVhcn0+PC9idXR0b24+O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyUHJvcCA9IHt9O1xuXG4gICAgICAgIGlmICghQ0tFRElUT1IuZW52LmllICYmIEFsbG95RWRpdG9yLlN0cmluZ3MpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyUHJvcC5wbGFjZWhvbGRlciA9IEFsbG95RWRpdG9yLlN0cmluZ3MuZWRpdExpbms7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZUxpbmt9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lbGVtZW50fSBvbkNsaWNrPXt0aGlzLl9yZW1vdmVMaW5rLmJpbmQodGhpcyl9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tdW5saW5rXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHh4bFwiPlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5zaG93VGFyZ2V0U2VsZWN0b3IgJiYgPEJ1dHRvbkxpbmtUYXJnZXRFZGl0IHsuLi50YXJnZXRTZWxlY3Rvcn0gLz59XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPVwiYWUtaW5wdXRcIiBvbkNoYW5nZT17dGhpcy5faGFuZGxlTGlua0hyZWZDaGFuZ2UuYmluZCh0aGlzKX0gb25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3duLmJpbmQodGhpcyl9IHsgLi4ucGxhY2Vob2xkZXJQcm9wIH0gcmVmPXt0aGlzLmxpbmtJbnB1dH0gdHlwZT1cInRleHRcIiB2YWx1ZT17dGhpcy5zdGF0ZS5saW5rSHJlZn0+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICAgICAgICAgIHthdXRvY29tcGxldGVEcm9wZG93bn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b25DbGVhckxpbmt9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIGRpc2FibGVkPXshdGhpcy5faXNWYWxpZFN0YXRlKCl9IG9uQ2xpY2s9e3RoaXMuX3VwZGF0ZUxpbmsuYmluZCh0aGlzKX0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tb2tcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGlzLnN0YXRlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfZ2V0SW5pdGlhbFN0YXRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBjb25zdCB7ZWRpdG9yLCBkZWZhdWx0TGlua1RhcmdldH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGxpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKSkuZ2V0RnJvbVNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCBocmVmID0gbGluayA/IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJykgOiAnJztcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbGluayA/IGxpbmsuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSA6IGRlZmF1bHRMaW5rVGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRvY29tcGxldGVTZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBlbGVtZW50OiBsaW5rLFxuICAgICAgICAgICAgaW5pdGlhbExpbms6IHtcbiAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlua0hyZWY6IGhyZWYsXG4gICAgICAgICAgICBsaW5rVGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGxpbmsgaW5wdXQuIFRoaXMgb25seSBjaGFuZ2VzIHRoZSBjb21wb25lbnQgaW50ZXJuYWwgc3RhdGUsIGJ1dCBkb2VzIG5vdFxuICAgICAqIGFmZmVjdCB0aGUgbGluayBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIE9ubHkgdGhlIF9yZW1vdmVMaW5rIGFuZCBfdXBkYXRlTGluayBtZXRob2RzXG4gICAgICogYXJlIHRyYW5zbGF0ZWQgdG8gdGhlIGVkaXRvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfY2xlYXJMaW5rXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jbGVhckxpbmsoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbGlua0hyZWY6ICcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfZm9jdXNMaW5rSW5wdXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZvY3VzTGlua0lucHV0KCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmb2N1c0xpbmtFbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5zdGFuY2UubGlua0lucHV0LmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmb2N1c0xpbmtFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZvY3VzTGlua0VsLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcbiAgICAgKiAtIEVudGVyOiBDcmVhdGVzL3VwZGF0ZXMgdGhlIGxpbmsuXG4gICAgICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzIHx8IGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5rKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZVNlbGVjdGVkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgICAgIG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcikuYWR2YW5jZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlIGxpbmsgaW5wdXQgY2hhbmdlcyBvbiB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfaGFuZGxlTGlua0hyZWZDaGFuZ2VcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFuZGxlTGlua0hyZWZDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsaW5rSHJlZjogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlIGxpbmsgdGFyZ2V0IGNoYW5nZXMgb24gdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICAgICAqIEBtZXRob2QgX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2VcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXRlbURyb3Bkb3duOiBudWxsLFxuICAgICAgICAgICAgbGlua1RhcmdldDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gYW4gYXV0b2NvbXBsZXRlIGxpbmsgcmVzdWx0IGlzIHNlbGVjdGVkIGJ5IHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2tcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpdGVtRHJvcGRvd246IG51bGwsXG4gICAgICAgICAgICBsaW5rSHJlZjogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCBsaW5rIHN0YXRlIGlzIHZhbGlkIHNvIHRoZSB1c2VyIGNhbiBzYXZlIHRoZSBsaW5rLiBBIHZhbGlkIHN0YXRlXG4gICAgICogbWVhbnMgdGhhdCB3ZSBoYXZlIGEgbm9uLWVtcHR5IGhyZWYgYW5kIHRoYXQgZWl0aGVyIHRoYXQgb3IgdGhlIGxpbmsgdGFyZ2V0IGFyZSBkaWZmZXJlbnRcbiAgICAgKiBmcm9tIHRoZSBvcmlnaW5hbCBsaW5rLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfaXNWYWxpZFN0YXRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBfaXNWYWxpZFN0YXRlKCkge1xuICAgICAgICB2YXIgdmFsaWRTdGF0ZSA9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtIcmVmICYmIChcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtIcmVmICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLmhyZWYgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmxpbmtUYXJnZXQgIT09IHRoaXMuc3RhdGUuaW5pdGlhbExpbmsudGFyZ2V0XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB2YWxpZFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpbmsgaW4gdGhlIGVkaXRvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG4gICAgICogQG1ldGhvZCBfcmVtb3ZlTGlua1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlTGluaygpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG4gICAgICAgIHZhciBsaW5rVXRpbHMgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgYm9va21hcmtzID0gc2VsZWN0aW9uLmNyZWF0ZUJvb2ttYXJrcygpO1xuXG4gICAgICAgIGxpbmtVdGlscy5yZW1vdmUodGhpcy5zdGF0ZS5lbGVtZW50LCB7IGFkdmFuY2U6IHRydWUgfSk7XG5cbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEJvb2ttYXJrcyhib29rbWFya3MpO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcbiAgICAgICAgLy8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGxpbmsgYnV0dG9uKVxuICAgICAgICB0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG4gICAgICAgIGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYXV0b2NvbXBsZXRlU2VsZWN0ZWQgc3RhdGUgdG8gZm9jdXMgYW5kIHNlbGVjdCBhdXRvY29tcGxldGXCtHMgZHJvcGRvd25cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICAgICAqIEBtZXRob2QgX3NldEF1dG9jb21wbGV0ZVN0YXRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRBdXRvY29tcGxldGVTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZVNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsaW5rIGluIHRoZSBlZGl0b3IgZWxlbWVudC4gSWYgdGhlIGVsZW1lbnQgZGlkbid0IGV4aXN0IHByZXZpb3VzbHksIGl0IHdpbGxcbiAgICAgKiBjcmVhdGUgYSBuZXcgPGE+IGVsZW1lbnQgd2l0aCB0aGUgaHJlZiBzcGVjaWZpZWQgaW4gdGhlIGxpbmsgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVMaW5rXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVMaW5rKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvciwge2FwcGVuZFByb3RvY29sOiB0aGlzLnByb3BzLmFwcGVuZFByb3RvY29sfSk7XG4gICAgICAgIHZhciBsaW5rQXR0cnMgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuc3RhdGUubGlua1RhcmdldFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbW9kaWZ5U2VsZWN0aW9uID0geyBhZHZhbmNlOiB0cnVlIH07XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubGlua0hyZWYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsaW5rQXR0cnMuaHJlZiA9IHRoaXMuc3RhdGUubGlua0hyZWY7XG5cbiAgICAgICAgICAgICAgICBsaW5rVXRpbHMudXBkYXRlKGxpbmtBdHRycywgdGhpcy5zdGF0ZS5lbGVtZW50LCBtb2RpZnlTZWxlY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5rVXRpbHMuY3JlYXRlKHRoaXMuc3RhdGUubGlua0hyZWYsIGxpbmtBdHRycywgbW9kaWZ5U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuICAgICAgICAvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG4gICAgICAgIHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGxpbmtFZGl0XG4gKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uTGlua0VkaXQua2V5ID0gJ2xpbmtFZGl0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uTGlua0VkaXQuZGVmYXVsdFByb3BzID0ge1xuICAgIGFwcGVuZFByb3RvY29sOiB0cnVlLFxuICAgIGF1dG9jb21wbGV0ZVVybDogJycsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgY3VzdG9tSW5kZXhTdGFydDogdHJ1ZSxcbiAgICBkZWZhdWx0TGlua1RhcmdldDogJycsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50JyxcbiAgICBrZXlzOiB7XG4gICAgICAgIGRpc21pc3M6IFsyN10sXG4gICAgICAgIGRpc21pc3NOZXh0OiBbMzldLFxuICAgICAgICBkaXNtaXNzUHJldjogWzM3XSxcbiAgICAgICAgbmV4dDogWzQwXSxcbiAgICAgICAgcHJldjogWzM4XVxuICAgIH0sXG4gICAgc2hvd1RhcmdldFNlbGVjdG9yOiB0cnVlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25DZmdQcm9wcyhcbiAgICBXaWRnZXREcm9wZG93bihcbiAgICBXaWRnZXRGb2N1c01hbmFnZXIoXG4gICAgICAgIEJ1dHRvbkxpbmtFZGl0XG4pKSk7XG4iLCJpbXBvcnQgQnV0dG9uVGFyZ2V0TGlzdCBmcm9tICcuL2J1dHRvbi10YXJnZXQtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua1RhcmdldEVkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGhlIHRhcmdldCBvZiBhIGxpbmtcbiAqIGluIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua1RhcmdldEVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uTGlua1RhcmdldEVkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgaGFuZGxlTGlua1RhcmdldENoYW5nZSA9IHRoaXMucHJvcHMuaGFuZGxlTGlua1RhcmdldENoYW5nZTtcbiAgICAgICAgdmFyIGFsbG93ZWRMaW5rVGFyZ2V0cyA9IHRoaXMucHJvcHMuYWxsb3dlZFRhcmdldHM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGluay10YXJnZXQgYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWNvbnRhaW5lci1kcm9wZG93bi1tZWRpdW0gYWUtaGFzLWRyb3Bkb3duXCIgdGFiSW5kZXg9XCIwXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfSBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fSBjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIiBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLmJpbmQodGhpcyl9IHJvbGU9XCJjb21ib2JveFwiIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPnt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYXJyb3dcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmV4cGFuZGVkICYmIChcbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblRhcmdldExpc3QgZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSBhbGxvd2VkTGlua1RhcmdldHM9e2FsbG93ZWRMaW5rVGFyZ2V0c30gaGFuZGxlTGlua1RhcmdldENoYW5nZT17aGFuZGxlTGlua1RhcmdldENoYW5nZX0gc2VsZWN0ZWRUYXJnZXQ9e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9Lz5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGJlZm9yZSByZW5kZXJpbmcgd2hlbiBuZXcgcHJvcHMgb3Igc3RhdGUgYXJlIGJlaW5nIHJlY2VpdmVkLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlciBvciB3aGVuIGZvcmNlVXBkYXRlIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1RhcmdldEVkaXRcbiAgICAgKiBAbWV0aG9kICBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcyBhbmQgc3RhdGUgd2lsbCBub3RcbiAgICAgKiByZXF1aXJlIGEgY29tcG9uZW50IHVwZGF0ZS5cbiAgICAgKi9cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBuZXh0UHJvcHMuZXhwYW5kZWQgIT09IHRoaXMucHJvcHMuZXhwYW5kZWQgfHwgbmV4dFByb3BzLnNlbGVjdGVkVGFyZ2V0ICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBsaW5rVGFyZ2V0RWRpdFxuICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtUYXJnZXRFZGl0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbkxpbmtUYXJnZXRFZGl0LmtleSA9ICdsaW5rVGFyZ2V0RWRpdCc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkxpbmtUYXJnZXRFZGl0O1xuIiwiaW1wb3J0IEJ1dHRvbkNmZ1Byb3BzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXByb3BzLmpzJztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25LZXlzdHJva2UgZnJvbSAnLi4vYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgbGluayBpbiBhIGRvY3VtZW50LiBCdXR0b25MaW5rXG4gKiByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgbW9kZXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGVcbiAqIC0gRXhjbHVzaXZlOiBUaGUgQnV0dG9uTGlua0VkaXQgVUkgd2l0aCBhbGwgdGhlIGxpbmsgZWRpdGlvbiBjb250cm9scy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua1xuICogQHVzZXMgQnV0dG9uQ2ZnUHJvcHNcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmsgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgY29udGFpbmVkIHdpdGhpbiBhIGxpbmsuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuICAgICAqIEBtZXRob2QgaXNBY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgbGluaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gKG5ldyBDS0VESVRPUi5MaW5rKHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykpLmdldEZyb21TZWxlY3Rpb24oKSAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMubWVyZ2VCdXR0b25DZmdQcm9wcygpO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxCdXR0b25MaW5rRWRpdCB7Li4ucHJvcHN9IC8+XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MubGlua30gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLWxpbmtcIiBvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1saW5rXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIHRoZSBsaW5rIGJ1dHRvbiB0byBiZSByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYSBsaW5rLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcbiAgICAgKiBAbWV0aG9kIF9yZXF1ZXN0RXhjbHVzaXZlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZXF1ZXN0RXhjbHVzaXZlKCkge1xuICAgICAgICB0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUoQnV0dG9uTGluay5rZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBsaW5rXG4gKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25MaW5rLmtleSA9ICdsaW5rJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25MaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA3NiAvKkwqL1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNmZ1Byb3BzKFxuICAgIEJ1dHRvbktleXN0cm9rZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvbkxpbmtcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uT3JkZXJlZExpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgb3JkZXJlZCBsaXN0cyBpbiBhbiBlZGl0b3IuXG4gKlxuICogQGNsYXNzIEJ1dHRvbk9yZGVyZWRMaXN0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbk9yZGVyZWRMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3RcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLm51bWJlcmVkbGlzdH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tb2xcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5udW1iZXJlZGxpc3R9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tbnVtYmVyZWQtbGlzdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBvbFxuICogQG1lbWJlcm9mIEJ1dHRvbk9yZGVyZWRMaXN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvbk9yZGVyZWRMaXN0LmtleSA9ICdvbCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3RcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvbk9yZGVyZWRMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnbnVtYmVyZWRsaXN0JyxcbiAgICBzdHlsZToge1xuICAgICAgICBlbGVtZW50OiAnb2wnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvbk9yZGVyZWRMaXN0XG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uT3V0ZGVudEJsb2NrIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG91dGRlbnRpbmcgYmxvY2tzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25PdXRkZW50QmxvY2tcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25PdXRkZW50QmxvY2sgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25PdXRkZW50QmxvY2tcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLm91dGRlbnR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLW91dGRlbnQtYmxvY2tcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5vdXRkZW50fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLW91dGRlbnQtYmxvY2tcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgaW5kZW50QmxvY2tcbiAqIEBtZW1iZXJvZiBCdXR0b25PdXRkZW50QmxvY2tcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uT3V0ZGVudEJsb2NrLmtleSA9ICdvdXRkZW50QmxvY2snO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uT3V0ZGVudEJsb2NrLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnb3V0ZGVudCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvbk91dGRlbnRCbG9ja1xuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYSBwYXJhZ3JhcGggb24gbGVmdC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnR9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1sZWZ0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLWxlZnRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgcGFyYWdyYXBoTGVmdFxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQua2V5ID0gJ3BhcmFncmFwaExlZnQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnanVzdGlmeWxlZnQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvbkNvbW1hbmRBY3RpdmUoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgICAgICBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnRcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhIHBhcmFncmFwaCBvbiByaWdodC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tcmlnaHRcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFsaWduLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHBhcmFncmFwaFJpZ2h0XG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0LmtleSA9ICdwYXJhZ3JhcGhSaWdodCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2p1c3RpZnlyaWdodCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2VudGVyaW5nIGEgcGFyYWdyYXBoLlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduQ2VudGVyfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1wYXJhZ3JhcGgtY2VudGVyXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tYWxpZ24tY2VudGVyXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHBhcmFncmFwaENlbnRlclxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaENlbnRlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25QYXJhZ3JhcGhDZW50ZXIua2V5ID0gJ3BhcmFncmFwaENlbnRlcic7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25QYXJhZ3JhcGhDZW50ZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdqdXN0aWZ5Y2VudGVyJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25Db21tYW5kQWN0aXZlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICAgICAgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG4pKSk7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZS5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBqdXN0ZnlpbmcgYSBwYXJhZ3JhcGguXG4gKlxuICogQGNsYXNzIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25KdXN0aWZ5fSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeVwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduSnVzdGlmeX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hbGlnbi1qdXN0aWZpZWRcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgcGFyYWdyYXBoSnVzdGlmeVxuICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uUGFyYWdyYXBoSnVzdGlmeS5rZXkgPSAncGFyYWdyYXBoSnVzdGlmeSc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUGFyYWdyYXBoSnVzdGlmeS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ2p1c3RpZnlibG9jaydcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uQ29tbWFuZEFjdGl2ZShcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgICAgIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUXVvdGUgY2xhc3Mgd3JhcHMgYSBzZWxlY3Rpb24gaW4gYGJsb2NrcXVvdGVgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblF1b3RlXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblF1b3RlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uUXVvdGVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnF1b3RlfSBhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9IGNsYXNzTmFtZT17Y3NzQ2xhc3N9IGRhdGEtdHlwZT1cImJ1dHRvbi1xdW90ZVwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnF1b3RlfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXF1b3RlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHF1b3RlXG4gKiBAbWVtYmVyb2YgQnV0dG9uUXVvdGVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uUXVvdGUua2V5ID0gJ3F1b3RlJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25RdW90ZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUXVvdGUuZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbW1hbmQ6ICdibG9ja3F1b3RlJyxcbiAgICBzdHlsZToge1xuICAgICAgICBlbGVtZW50OiAnYmxvY2txdW90ZSdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uUXVvdGVcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblJlbW92ZUZvcm1hdCBjbGFzcyByZW1vdmVzIHN0eWxlIGZvcm1hdHRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25SZW1vdmVGb3JtYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25SZW1vdmVGb3JtYXRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVmb3JtYXR9IGNsYXNzTmFtZT0nYWUtYnV0dG9uJyBkYXRhLXR5cGU9XCJidXR0b24tcmVtb3ZlZm9ybWF0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlZm9ybWF0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXJlbW92ZWZvcm1hdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCByZW1vdmVGb3JtYXRcbiAqIEBtZW1iZXJvZiBCdXR0b25SZW1vdmVGb3JtYXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uUmVtb3ZlRm9ybWF0LmtleSA9ICdyZW1vdmVGb3JtYXQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uUmVtb3ZlRm9ybWF0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAncmVtb3ZlRm9ybWF0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25SZW1vdmVGb3JtYXRcbik7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC5qcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMuanMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0cmlrZSBjbGFzcyBzdHlsZXMgYSBzZWxlY3Rpb24gd2l0aCBzdHJpa2Ugc3R5bGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0cmlrZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdHJpa2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3RyaWtlXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHJpa2V9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXN0cmlrZVwiIG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmQuYmluZCh0aGlzKX0gdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0cmlrZX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1zdHJpa2VcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgc3RyaWtlXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3RyaWtlXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblN0cmlrZS5rZXkgPSAnc3RyaWtlJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2VcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblN0cmlrZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY29tbWFuZDogJ3N0cmlrZScsXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX3N0cmlrZSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25TdHJpa2VcbikpKTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBjbGFzcyBwcm92aWRlcyB0aGUgaGVhZGVyIG9mIGFuIGxpc3Qgb2Ygc3R5bGUgaXRlbXMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG4gKi9cbmNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc3R5bGVzICYmIHRoaXMucHJvcHMuc3R5bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1saXN0LWhlYWRlclwiPnt0aGlzLnByb3BzLm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25zU3R5bGVzTGlzdEhlYWRlcjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBwcmV2aWV3aW5nIGEgc3R5bGUgZGVmaW5pdGlvblxuICogaW5zaWRlIGEgbGlzdCBhbmQgYXBwbHlpbmcgaXQgdG8gdGhlIGN1cnJlbnQgZWRpdG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxpIHJvbGU9XCJvcHRpb25cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiIG9uQ2xpY2s9e3RoaXMuX3JlbW92ZVN0eWxlcy5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0+e0FsbG95RWRpdG9yLlN0cmluZ3Mubm9ybWFsfTwvYnV0dG9uPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBpbmxpbmUgc3R5bGVzIGFuZCBjb25maWd1cmVkIGJsb2NrIGVsZW1lbnRzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gICAgICogQG1ldGhvZCBfcmVtb3ZlU3R5bGVzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVTdHlsZXMoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgncmVtb3ZlRm9ybWF0Jyk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5yZW1vdmVCbG9ja3MuZm9yRWFjaChmdW5jdGlvbihibG9ja0l0ZW0pIHtcbiAgICAgICAgICAgIHZhciBibG9ja1N0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHtlbGVtZW50OiBibG9ja0l0ZW19KTtcblxuICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVN0eWxlKGJsb2NrU3R5bGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUua2V5ID0gJ2J1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUuZGVmYXVsdFByb3BzID0ge1xuICAgIHJlbW92ZUJsb2NrczogWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdwcmUnXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmU7XG4iLCJpbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0SXRlbSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBwcmV2aWV3aW5nIGEgc3R5bGUgZGVmaW5pdGlvblxuICogaW5zaWRlIGEgbGlzdCBhbmQgYXBwbHlpbmcgaXQgdG8gdGhlIGN1cnJlbnQgZWRpdG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdHlsZXNMaXN0SXRlbSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICAvLyBTdHlsZXMgd2l0aCB3aWxkY2FyZCBlbGVtZW50ICgqKSBnZW5lcmF0ZSBhbiBlbXB0eSB0YWcgaW4gdGhlaXIgcHJldmlldyA8IGNsYXNzPVwiY3VzdG9tLWNsYXNzXCIgLz4uXG4gICAgICAgIC8vIFdlIGRlZmF1bHQgdG8gZWxlbWVudCBzcGFuIGFuZCByZW1vdmUgdGhlIG1hcmdpbnMgdG8gb2J0YWluIGEgbW9yZSBjb25zaXN0ZW50IHNldCBvZiBwcmV2aWV3cy5cbiAgICAgICAgdmFyIHN0eWxlQ2ZnID0ge1xuICAgICAgICAgICAgZWxlbWVudDogJ3NwYW4nLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc3R5bGVDZmcgPSBDS0VESVRPUi50b29scy5tZXJnZShzdHlsZUNmZywgdGhpcy5wcm9wcy5zdHlsZSk7XG5cbiAgICAgICAgdGhpcy5fcHJldmlldyA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNmZykuYnVpbGRQcmV2aWV3KHRoaXMucHJvcHMubmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGRhbmdlcm91c2VseVNldElubnRlckhUTUwgc2luY2Ugd2UncmUgbm90IGluIGNvbnRyb2wgb2YgdGhlIHN0eWxlXG4gICAgICAgIC8vIHByZXZpZXcgdGhhdCBpcyBnZW5lcmF0ZWQgYnkgQ0tFZGl0b3IuXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLm5hbWUgPT09IHRoaXMucHJvcHMuYWN0aXZlU3R5bGUgPyAnYWUtdG9vbGJhci1lbGVtZW50IGFjdGl2ZScgOiAnYWUtdG9vbGJhci1lbGVtZW50JztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tfX2h0bWw6IHRoaXMuX3ByZXZpZXd9fSBvbkNsaWNrPXt0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fT48L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBpdGVtIHN0eWxlIHRvIHRoZSBlZGl0b3Igc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG4gICAgICogQG1ldGhvZCBfb25DbGlja1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfb25DbGljaygpIHtcbiAgICAgICAgLy8gVHlwaWNhbGx5LCB3ZSB3YW50IHRoZSBzdHlsZSB0byBiZSB0aGUgb25seSBvbmUgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHNvXG4gICAgICAgIC8vIHdlIGV4ZWN1dGUgdGhlICdyZW1vdmVGb3JtYXQnIGNvbW1hbmQgZmlyc3QuIE5vdGUgdGhhdCBibG9jayBzdHlsZXMgd29uJ3QgYmUgY2xlYW5lZC5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhpcyBpcyBjb25zaXN0ZW50IHdpdGggb3RoZXIgZWRpdG9ycyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBmZWF0dXJlLlxuICAgICAgICB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpLmV4ZWNDb21tYW5kKCdyZW1vdmVGb3JtYXQnKTtcblxuICAgICAgICB0aGlzLmFwcGx5U3R5bGUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgYnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25TdHlsZXNMaXN0SXRlbS5rZXkgPSAnYnV0dG9uU3R5bGVzTGlzdEl0ZW0nO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZShcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbikpOyIsImltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLXJlbW92ZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWhlYWRlci5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3R5bGVzTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzaG93aW5nIGEgbGlzdCBvZiBzdHlsZXMgdGhhdCBjYW4gYmVcbiAqIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzTGlzdFxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlc0xpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBGb2N1c2VzIG9uIHRoZSBsaXN0IG5vZGUgdG8gYWxsb3cga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIGJsb2NrU3R5bGVzID0gW107XG4gICAgICAgIHZhciBpbmxpbmVTdHlsZXMgPSBbXTtcbiAgICAgICAgdmFyIG9iamVjdFN0eWxlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMucHJvcHMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKGl0ZW0uc3R5bGUpO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUudHlwZSA9PT0gQ0tFRElUT1IuU1RZTEVfQkxPQ0spIHtcbiAgICAgICAgICAgICAgICBibG9ja1N0eWxlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS50eXBlID09PSBDS0VESVRPUi5TVFlMRV9JTkxJTkUpIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUudHlwZSA9PT0gQ0tFRElUT1IuU1RZTEVfT0JKRUNUKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0U3R5bGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2Jsb2NrU3R5bGVzID0gYmxvY2tTdHlsZXM7XG4gICAgICAgIHRoaXMuX2lubGluZVN0eWxlcyA9IGlubGluZVN0eWxlcztcbiAgICAgICAgdGhpcy5fb2JqZWN0U3R5bGVzID0gb2JqZWN0U3R5bGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgcmVtb3ZlU3R5bGVzSXRlbTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaG93UmVtb3ZlU3R5bGVzSXRlbSkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVzSXRlbSA9IDxCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBlZGl0b3I9e3RoaXMucHJvcHMuZWRpdG9yfSBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxCdXR0b25Ecm9wZG93biB7Li4udGhpcy5wcm9wc30+XG4gICAgICAgICAgICAgICAge3JlbW92ZVN0eWxlc0l0ZW19XG5cbiAgICAgICAgICAgICAgICA8QnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIgbmFtZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5ibG9ja1N0eWxlc30gc3R5bGVzPXt0aGlzLl9ibG9ja1N0eWxlc30gLz5cbiAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyU3R5bGVzSXRlbXModGhpcy5fYmxvY2tTdHlsZXMpfVxuXG4gICAgICAgICAgICAgICAgPEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIG5hbWU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaW5saW5lU3R5bGVzfSBzdHlsZXM9e3RoaXMuX2lubGluZVN0eWxlc30gLz5cbiAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyU3R5bGVzSXRlbXModGhpcy5faW5saW5lU3R5bGVzKX1cblxuICAgICAgICAgICAgICAgIDxCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBuYW1lPXtBbGxveUVkaXRvci5TdHJpbmdzLm9iamVjdFN0eWxlc30gc3R5bGVzPXt0aGlzLl9vYmplY3RTdHlsZXN9IC8+XG4gICAgICAgICAgICAgICAge3RoaXMuX3JlbmRlclN0eWxlc0l0ZW1zKHRoaXMuX29iamVjdFN0eWxlcyl9XG4gICAgICAgICAgICA8L0J1dHRvbkRyb3Bkb3duPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgaW5zdGFuY2VzIG9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtIHdpdGggdGhlIHByZXZpZXcgb2YgdGhlIGNvcnJlc3BvbmRlbnQgYmxvY2ssIGlubGluZSBvciBvYmplY3Qgc3R5bGVzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJTdHlsZXNJdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlcyBMaXN0IG9mIHN0eWxlcyBmb3Igd2hpY2ggcHJldmlldyBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZW5kZXJlZCBpbnN0YW5jZXMgb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gY2xhc3NcbiAgICAgKi9cbiAgICBfcmVuZGVyU3R5bGVzSXRlbXMoc3R5bGVzKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICAgICAgdmFyIGl0ZW1zO1xuXG4gICAgICAgIGlmIChzdHlsZXMgJiYgc3R5bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMgPSBzdHlsZXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtpdGVtLm5hbWV9IHJvbGU9XCJvcHRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25TdHlsZXNMaXN0SXRlbSBhY3RpdmVTdHlsZT17dGhpcy5wcm9wcy5hY3RpdmVTdHlsZX0gZWRpdG9yPXtlZGl0b3J9IG5hbWU9e2l0ZW0ubmFtZX0gc3R5bGU9e2l0ZW0uc3R5bGV9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0XG4gKi9cbkJ1dHRvblN0eWxlc0xpc3Qua2V5ID0gJ2J1dHRvblN0eWxlc0xpc3QnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblN0eWxlc0xpc3QuZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfSxcbiAgICBzaG93UmVtb3ZlU3R5bGVzSXRlbTogdHJ1ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvblN0eWxlc0xpc3Rcbik7IiwiaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0eWxlcyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHlsaW5nIGEgc2VsZWN0aW9uIHdpdGggYSBsaXN0IG9mXG4gKiBjb25maWd1cmFibGUgYW5kIGN1c3RvbWl6YWJsZSBzdHlsZXMuIFRoZSBhbGxvd2VkIHN0eWxlcyBmb2xsb3cgQ0tFRElUT1IuU3R5bGUgY29uZmlndXJhdGlvblxuICogKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUpXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc1xuICovXG5jbGFzcyBCdXR0b25TdHlsZXMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGFjdGl2ZVN0eWxlID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5ub3JtYWw7XG5cbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuX2dldFN0eWxlcygpO1xuXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja0FjdGl2ZShpdGVtLnN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVN0eWxlID0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHZhciBidXR0b25TdHlsZXNMaXN0O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICBidXR0b25TdHlsZXNMaXN0ID0gPEJ1dHRvblN0eWxlc0xpc3QgYWN0aXZlU3R5bGU9e2FjdGl2ZVN0eWxlfSBlZGl0b3I9e3RoaXMucHJvcHMuZWRpdG9yfSBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IHNob3dSZW1vdmVTdHlsZXNJdGVtPXt0aGlzLnByb3BzLnNob3dSZW1vdmVTdHlsZXNJdGVtfSBzdHlsZXM9e3N0eWxlc30gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtaGFzLWRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfSBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0eWxlcyArICcgJyArIGFjdGl2ZVN0eWxlfSBjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIiBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLmJpbmQodGhpcyl9IHJvbGU9XCJjb21ib2JveFwiIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHlsZXMgKyAnICcgKyBhY3RpdmVTdHlsZX0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPnthY3RpdmVTdHlsZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFycm93XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICB7YnV0dG9uU3R5bGVzTGlzdH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc1xuICAgICAqIEBtZXRob2QgX2NoZWNrQWN0aXZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlQ29uZmlnIFN0eWxlIGRlZmluaXRpb24gYXMgcGVyIGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgc3R5bGUgaXMgYXBwbGllZCB0byB0aGUgc2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgX2NoZWNrQWN0aXZlKHN0eWxlQ29uZmlnKSB7XG4gICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIC8vIFN0eWxlcyB3aXRoIHdpbGRjYXJkIGVsZW1lbnQgKCopIHdvbid0IGJlIGNvbnNpZGVyZWQgYWN0aXZlIGJ5IENLRWRpdG9yLiBEZWZhdWx0aW5nXG4gICAgICAgIC8vIHRvIGEgJ3NwYW4nIGVsZW1lbnQgd29ya3MgZm9yIG1vc3Qgb2YgdGhvc2UgY2FzZXMgd2l0aCBubyBkZWZpbmVkIGVsZW1lbnQuXG4gICAgICAgIHN0eWxlQ29uZmlnID0gQ0tFRElUT1IudG9vbHMubWVyZ2Uoe2VsZW1lbnQ6ICdzcGFuJ30sIHN0eWxlQ29uZmlnKTtcblxuICAgICAgICB2YXIgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpO1xuXG4gICAgICAgIHJldHVybiBzdHlsZS5jaGVja0FjdGl2ZShuYXRpdmVFZGl0b3IuZWxlbWVudFBhdGgoKSwgbmF0aXZlRWRpdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHN0eWxlcy4gRWFjaCBzdHlsZSBjb25zaXN0cyBmcm9tIHR3byBwcm9wZXJ0aWVzOlxuICAgICAqIC0gbmFtZSAtIHRoZSBzdHlsZSBuYW1lLCBmb3IgZXhhbXBsZSBcImgxXCJcbiAgICAgKiAtIHN0eWxlIC0gYW4gb2JqZWN0IHdpdGggb25lIHByb3BlcnR5LCBjYWxsZWQgYGVsZW1lbnRgIHdoaWNoIHZhbHVlXG4gICAgICogcmVwcmVzZW50cyB0aGUgc3R5bGUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc1xuICAgICAqIEBtZXRob2QgX2dldFN0eWxlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHN0eWxlcy5cbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdHlsZXMgfHwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuaDEsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ2gxJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5oMixcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAnaDInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmZvcm1hdHRlZCxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAncHJlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5jaXRlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdjaXRlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2RlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdjb2RlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgc3R5bGVzXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblN0eWxlcy5rZXkgPSAnc3R5bGVzJztcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGVzOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdWJzY3JpcHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYXBwbHlpbmcgc3Vic2NyaXB0IHN0eWxlIHRvIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN1YnNjcmlwdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdWJzY3JpcHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25TdWJzY3JpcHRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1YnNjcmlwdH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tc3Vic2NyaXB0XCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3Vic2NyaXB0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXN1YnNjcmlwdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzdWJzY3JpcHRcbiAqIEBtZW1iZXJvZiBCdXR0b25TdWJzY3JpcHRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU3Vic2NyaXB0LmtleSA9ICdzdWJzY3JpcHQnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblN1YnNjcmlwdFxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uU3Vic2NyaXB0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnc3Vic2NyaXB0JyxcbiAgICBzdHlsZTogJ2NvcmVTdHlsZXNfc3Vic2NyaXB0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvblN1YnNjcmlwdFxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQuanMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZS5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdXBlcnNjcmlwdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhcHBseWluZyBzdXBlcnNjcmlwdCBzdHlsZSB0byBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdXBlcnNjcmlwdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdXBlcnNjcmlwdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblN1cGVyc2NyaXB0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdXBlcnNjcmlwdH0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tc3VwZXJzY3JpcHRcIiBvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdXBlcnNjcmlwdH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1zdXBlcnNjcmlwdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzdXBlcnNjcmlwdFxuICogQG1lbWJlcm9mIEJ1dHRvblN1cGVyc2NyaXB0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblN1cGVyc2NyaXB0LmtleSA9ICdzdXBlcnNjcmlwdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uU3VwZXJzY3JpcHRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cbkJ1dHRvblN1cGVyc2NyaXB0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnc3VwZXJzY3JpcHQnLFxuICAgIHN0eWxlOiAnY29yZVN0eWxlc19zdXBlcnNjcmlwdCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uU3RhdGVDbGFzc2VzKFxuICAgIEJ1dHRvblN0eWxlKFxuICAgICAgICBCdXR0b25TdXBlcnNjcmlwdFxuKSkpOyIsImltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVDZWxsIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIGNlbGxzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUNlbGxcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVDZWxsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDZWxsXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBidXR0b25Db21tYW5kc0xpc3Q7XG4gICAgICAgIHZhciBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZUNlbGwua2V5ICsgJ0xpc3QnO1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0ID0gPEJ1dHRvbkNvbW1hbmRzTGlzdCBjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX0gZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gbGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1oYXMtZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2VsbH0gYXJpYS1vd25zPXtidXR0b25Db21tYW5kc0xpc3RJZH0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgb25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2VsbH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFlLWljb24tY2VsbFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICB7YnV0dG9uQ29tbWFuZHNMaXN0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG4gICAgICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDZWxsXG4gICAgICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGF2YWlsYWJsZSBjb21tYW5kcy5cbiAgICAgKi9cbiAgICBfZ2V0Q29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbEluc2VydEJlZm9yZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbEluc2VydEJlZm9yZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2VsbEluc2VydEFmdGVyJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsSW5zZXJ0QWZ0ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxEZWxldGUnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxEZWxldGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxNZXJnZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbE1lcmdlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsTWVyZ2VEb3duJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsTWVyZ2VEb3duXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjZWxsTWVyZ2VSaWdodCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbE1lcmdlUmlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxIb3Jpem9udGFsU3BsaXQnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxTcGxpdEhvcml6b250YWxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NlbGxWZXJ0aWNhbFNwbGl0JyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsU3BsaXRWZXJ0aWNhbFxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0YWJsZUNlbGxcbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNlbGxcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVGFibGVDZWxsLmtleSA9ICd0YWJsZUNlbGwnO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZUNlbGw7IiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZUNvbHVtbiBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSBjb2x1bW5zLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUNvbHVtblxuICovXG5jbGFzcyBCdXR0b25UYWJsZUNvbHVtbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ29sdW1uXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBidXR0b25Db21tYW5kc0xpc3QsXG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZUNvbHVtbi5rZXkgKyAnTGlzdCc7XG4gICAgICAgICAgICBidXR0b25Db21tYW5kc0xpc3QgPSA8QnV0dG9uQ29tbWFuZHNMaXN0IGNvbW1hbmRzPXt0aGlzLl9nZXRDb21tYW5kcygpfSBlZGl0b3I9e3RoaXMucHJvcHMuZWRpdG9yfSBsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfSBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH0gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW59IGFyaWEtb3ducz17YnV0dG9uQ29tbWFuZHNMaXN0SWR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzKX0gcm9sZT1cImxpc3Rib3hcIiB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1ufT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1jb2x1bW5cIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge2J1dHRvbkNvbW1hbmRzTGlzdH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuICAgICAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ29sdW1uXG4gICAgICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGF2YWlsYWJsZSBjb21tYW5kcy5cbiAgICAgKi9cbiAgICBfZ2V0Q29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY29sdW1uSW5zZXJ0QmVmb3JlJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5JbnNlcnRCZWZvcmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NvbHVtbkluc2VydEFmdGVyJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5JbnNlcnRBZnRlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY29sdW1uRGVsZXRlJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5EZWxldGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdGFibGVDb2x1bW5cbiAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYWJsZUNvbHVtbi5rZXkgPSAndGFibGVDb2x1bW4nO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZUNvbHVtbjsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbnZhciBLRVlfRU5URVIgPSAxMztcbnZhciBLRVlfRVNDID0gMjc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlRWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIHRhYmxlIGluIGEgZG9jdW1lbnQuXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcgYSB0YWJsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVFZGl0XG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlRWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAgICAgKiBAbWV0aG9kIGdldEluaXRpYWxTdGF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnJvd3NSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5jb2xzUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb2xzOiAzLFxuICAgICAgICAgICAgcm93czogM1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQgKG5vdCBvbiB0aGUgc2VydmVyKSxcbiAgICAgKiBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogRm9jdXNlcyBvbiB0aGUgbGluayBpbnB1dCB0byBpbW1lZGlhdGVseSBhbGxvdyBlZGl0aW5nLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5yb3dzUmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGFibGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gICAgICogQG1ldGhvZCBfY3JlYXRlVGFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVRhYmxlKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIHRhYmxlVXRpbHMgPSBuZXcgQ0tFRElUT1IuVGFibGUoZWRpdG9yKTtcblxuICAgICAgICB0YWJsZVV0aWxzLmNyZWF0ZSh7XG4gICAgICAgICAgICBhdHRyczogdGhpcy5wcm9wcy50YWJsZUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjb2xzOiB0aGlzLnN0YXRlLmNvbHMsXG4gICAgICAgICAgICByb3dzOiB0aGlzLnN0YXRlLnJvd3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIGNoYW5nZSBpbiBpbnB1dCB2YWx1ZS4gU2V0cyB0aGUgcHJvdmlkZWQgdmFsdWUgZnJvbSB0aGUgdXNlciBiYWNrIHRvIHRoZSBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVDaGFuZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCB3aGljaCB2YWx1ZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVDaGFuZ2UoaW5wdXROYW1lLCBldmVudCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICAgICAgc3RhdGVbaW5wdXROYW1lXSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb25pdG9ycyBrZXkgaW50ZXJhY3Rpb24gaW5zaWRlIHRoZSBpbnB1dCBlbGVtZW50IHRvIHJlc3BvbmQgdG8gdGhlIGtleXM6XG4gICAgICogLSBFbnRlcjogQ3JlYXRlcyB0aGUgdGFibGUuXG4gICAgICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICAgICAqIEBtZXRob2QgX2hhbmRsZUtleURvd25cbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRhYmxlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgcm93c0lkID0gdGltZSArICdyb3dzJztcbiAgICAgICAgdmFyIGNvbHNJZCA9IHRpbWUgKyAnY29scyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtdGFibGVcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17cm93c0lkfT57QWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dzfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgc21hbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT1cImFlLWlucHV0XCIgaWQ9e3Jvd3NJZH0gb25DaGFuZ2U9e3RoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMsICdyb3dzJyl9IG1pbj1cIjFcIiBvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd24uYmluZCh0aGlzKX0gcGxhY2Vob2xkZXI9XCJSb3dzXCIgcmVmPXt0aGlzLnJvd3NSZWZ9IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17dGhpcy5zdGF0ZS5yb3dzfT48L2lucHV0PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2NvbHNJZH0+e0FsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1uc308L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHNtYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzc05hbWU9XCJhZS1pbnB1dFwiIGlkPXtjb2xzSWR9IG9uQ2hhbmdlPXt0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZCh0aGlzLCAnY29scycpfSBtaW49XCIxXCIgb25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3duLmJpbmQodGhpcyl9IHBsYWNlaG9sZGVyPVwiQ29sdW1zXCIgcmVmPXt0aGlzLmNvbHNSZWZ9IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17dGhpcy5zdGF0ZS5jb2xzfT48L2lucHV0PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPVwiQ29uZmlybVwiIGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiIG9uQ2xpY2s9e3RoaXMuX2NyZWF0ZVRhYmxlLmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLW9rXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHRhYmxlRWRpdFxuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYWJsZUVkaXQua2V5ID0gJ3RhYmxlRWRpdCc7XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICovXG5CdXR0b25UYWJsZUVkaXQuZGVmYXVsdFByb3BzID0ge1xuICAgIHRhYmxlQXR0cmlidXRlczoge1xuICAgICAgICBib3JkZXI6IDEsXG4gICAgICAgIGNlbGxQYWRkaW5nOiAwLFxuICAgICAgICBjZWxsU3BhY2luZzogMCxcbiAgICAgICAgc3R5bGU6ICd3aWR0aDogMTAwJSdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZUVkaXQ7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlSGVhZGluZyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSBoZWFkaW5nLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUhlYWRpbmdcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVIZWFkaW5nIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVIZWFkaW5nXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBidXR0b25Db21tYW5kc0xpc3Q7XG4gICAgICAgIHZhciBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZUhlYWRpbmcua2V5ICsgJ0xpc3QnO1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0ID0gPEJ1dHRvbkNvbW1hbmRzTGlzdCBjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX0gZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gbGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3RpdmVIZWFkaW5nID0gbmV3IENLRURJVE9SLlRhYmxlKHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykpLmdldEhlYWRpbmcoKTtcbiAgICAgICAgdmFyIGFjdGl2ZUhlYWRpbmdJbnRybyA9IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVycyArICc6JztcbiAgICAgICAgdmFyIGFjdGl2ZUhlYWRpbmdMYWJlbCA9IEFsbG95RWRpdG9yLlN0cmluZ3NbJ2hlYWRlcnMnICsgYWN0aXZlSGVhZGluZ107XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duLXhsIGFlLWhhcy1kcm9wZG93blwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH0gYXJpYS1sYWJlbD1cIlwiIGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiIG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzKX0gcm9sZT1cImNvbWJvYm94XCIgdGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9IHRpdGxlPVwiXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPnthY3RpdmVIZWFkaW5nSW50cm99IDxzdHJvbmc+e2FjdGl2ZUhlYWRpbmdMYWJlbH08L3N0cm9uZz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWFycm93XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICB7YnV0dG9uQ29tbWFuZHNMaXN0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG4gICAgICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVIZWFkaW5nXG4gICAgICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGF2YWlsYWJsZSBjb21tYW5kcy5cbiAgICAgKi9cbiAgICBfZ2V0Q29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndGFibGVIZWFkaW5nTm9uZScsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc05vbmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3RhYmxlSGVhZGluZ1JvdycsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc1Jvd1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndGFibGVIZWFkaW5nQ29sdW1uJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5oZWFkZXJzQ29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdCb3RoJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5oZWFkZXJzQm90aFxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0YWJsZVJvd1xuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYWJsZUhlYWRpbmcua2V5ID0gJ3RhYmxlSGVhZGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlSGVhZGluZzsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZVJlbW92ZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciByZW1vdmluZyBhIHRhYmxlXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSZW1vdmVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVUYWJsZX0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGF0YS10eXBlPVwiYnV0dG9uLXRhYmxlLXJlbW92ZVwiIG9uQ2xpY2s9e3RoaXMuX3JlbW92ZVRhYmxlLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVUYWJsZX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1iaW5cIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSB0YWJsZSBpbiB0aGUgZWRpdG9yIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSZW1vdmVcbiAgICAgKiBAbWV0aG9kIF9yZW1vdmVUYWJsZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlVGFibGUoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuICAgICAgICB2YXIgdGFibGVVdGlscyA9IG5ldyBDS0VESVRPUi5UYWJsZShlZGl0b3IpO1xuXG4gICAgICAgIHRhYmxlVXRpbHMucmVtb3ZlKCk7XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0YWJsZVJlbW92ZVxuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlUmVtb3ZlXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhYmxlUmVtb3ZlLmtleSA9ICd0YWJsZVJlbW92ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlUmVtb3ZlOyIsImltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVSb3cgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgcm93cy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVSb3dcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJvd1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgYnV0dG9uQ29tbWFuZHNMaXN0O1xuICAgICAgICB2YXIgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNvbW1hbmRzTGlzdElkID0gQnV0dG9uVGFibGVSb3cua2V5ICsgJ0xpc3QnO1xuICAgICAgICAgICAgYnV0dG9uQ29tbWFuZHNMaXN0ID0gPEJ1dHRvbkNvbW1hbmRzTGlzdCBjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX0gZWRpdG9yPXt0aGlzLnByb3BzLmVkaXRvcn0gbGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH0gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1oYXMtZHJvcGRvd25cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9IGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Mucm93fSBhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfSBjbGFzc05hbWU9XCJhZS1idXR0b25cIiBvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLmJpbmQodGhpcyl9IHJvbGU9XCJjb21ib2JveFwiIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yb3d9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXJvd1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICB7YnV0dG9uQ29tbWFuZHNMaXN0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG4gICAgICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSb3dcbiAgICAgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuICAgICAqL1xuICAgIF9nZXRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdyb3dJbnNlcnRCZWZvcmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLnJvd0luc2VydEJlZm9yZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAncm93SW5zZXJ0QWZ0ZXInLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLnJvd0luc2VydEFmdGVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdyb3dEZWxldGUnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLnJvd0RlbGV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0YWJsZVJvd1xuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlUm93XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhYmxlUm93LmtleSA9ICd0YWJsZVJvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlUm93OyIsImltcG9ydCBCdXR0b25UYWJsZUVkaXQgZnJvbSAnLi9idXR0b24tdGFibGUtZWRpdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGUgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSB0YWJsZSBpbiBhIGRvY3VtZW50LiBCdXR0b25UYWJsZVxuICogcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IG1vZGVzOlxuICpcbiAqIC0gTm9ybWFsOiBKdXN0IGEgYnV0dG9uIHRoYXQgYWxsb3dzIHRvIHN3aXRjaCB0byB0aGUgZWRpdGlvbiBtb2RlXG4gKiAtIEV4Y2x1c2l2ZTogVGhlIEJ1dHRvblRhYmxlRWRpdCBVSSB3aXRoIGFsbCB0aGUgdGFibGUgZWRpdGlvbiBjb250cm9scy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJ1dHRvblRhYmxlRWRpdCB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy50YWJsZX0gY2xhc3NOYW1lPVwiYWUtYnV0dG9uXCIgZGF0YS10eXBlPVwiYnV0dG9uLXRhYmxlXCIgb25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MudGFibGV9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXRhYmxlXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB0YWJsZVxuICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblRhYmxlLmtleSA9ICd0YWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlOyIsImltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFyZ2V0TGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjaGFuZ2luZyB0aGUgdGFyZ2V0IG9mIGEgbGlua1xuICogaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYXJnZXRMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uVGFyZ2V0TGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBsaXN0VGFyZ2V0cyA9IHRoaXMuX3JlbmRlckxpc3RUYXJnZXRzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxCdXR0b25Ecm9wZG93biB7Li4udGhpcy5wcm9wc30+XG4gICAgICAgICAgICAgICAge2xpc3RUYXJnZXRzfVxuICAgICAgICAgICAgPC9CdXR0b25Ecm9wZG93bj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aGUgYWxsb3dlZCBsaW5rIHRhcmdldCBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG4gICAgICogQG1ldGhvZCBfZ2V0QWxsb3dlZFRhcmdldEl0ZW1zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYWxsb3dlZCB0YXJnZXQgaXRlbXMuXG4gICAgICovXG4gICAgX2dldEFsbG93ZWRUYXJnZXRJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuYWxsb3dlZExpbmtUYXJnZXRzIHx8IFt7XG4gICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0RGVmYXVsdCxcbiAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0U2VsZixcbiAgICAgICAgICAgIHZhbHVlOiAnX3NlbGYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXRCbGFuayxcbiAgICAgICAgICAgIHZhbHVlOiAnX2JsYW5rJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0UGFyZW50LFxuICAgICAgICAgICAgdmFsdWU6ICdfcGFyZW50J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0VG9wLFxuICAgICAgICAgICAgdmFsdWU6ICdfdG9wJ1xuICAgICAgICB9XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBhbGxvd2VkIGxpbmsgdGFyZ2V0IGl0ZW1zLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3RcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJMaXN0VGFyZ2V0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHJlbmRlcmVkIGxpbmsgaXRlbXNcbiAgICAgKi9cbiAgICBfcmVuZGVyTGlzdFRhcmdldHMoKSB7XG4gICAgICAgIHZhciB0YXJnZXRzID0gdGhpcy5fZ2V0QWxsb3dlZFRhcmdldEl0ZW1zKCk7XG5cbiAgICAgICAgdmFyIGhhbmRsZUxpbmtUYXJnZXRDaGFuZ2UgPSB0aGlzLnByb3BzLmhhbmRsZUxpbmtUYXJnZXRDaGFuZ2U7XG5cbiAgICAgICAgdGFyZ2V0cyA9IHRhcmdldHMubWFwKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXQgPT09IHRhcmdldC52YWx1ZSA/ICdhZS10b29sYmFyLWVsZW1lbnQgYWN0aXZlJyA6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxsaSBrZXk9e3RhcmdldC52YWx1ZX0gcm9sZT1cIm9wdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBkYXRhLXZhbHVlPXt0YXJnZXQudmFsdWV9IG9uQ2xpY2s9e2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2V9Pnt0YXJnZXQubGFiZWx9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldHM7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IGxpbmtUYXJnZXRFZGl0XG4gKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25UYXJnZXRMaXN0LmtleSA9ICd0YXJnZXRMaXN0JztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICovXG5CdXR0b25UYXJnZXRMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgZGlzbWlzc05leHQ6IFszOV0sXG4gICAgICAgIGRpc21pc3NQcmV2OiBbMzddLFxuICAgICAgICBuZXh0OiBbNDBdLFxuICAgICAgICBwcmV2OiBbMzhdXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKFxuICAgIEJ1dHRvblRhcmdldExpc3Rcbik7IiwiaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblR3aXR0ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYSBsaW5rIHdoaWNoXG4gKiBhbGxvd3MgcGVvcGxlIHRvIHR3ZWV0IHBhcnQgb2YgdGhlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVHdpdHRlclxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblR3aXR0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgcmVtb3ZlcyB0aGUgdHdpdHRlciBsaW5rIG9uIHRoZSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICAgICAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljaygpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgdmFyIGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgbGlua1V0aWxzLnJlbW92ZShsaW5rVXRpbHMuZ2V0RnJvbVNlbGVjdGlvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmtVdGlscy5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0SHJlZigpLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2FlLXR3aXR0ZXItbGluaycsXG4gICAgICAgICAgICAgICAgICAgICd0YXJnZXQnOiAnX2JsYW5rJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgbGluayB0aGF0IHBvaW50cyB0byB0d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICAgICAqIEBtZXRob2QgaXNBY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgdHdpdHRlciBsaW5rLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICAgIHZhciBsaW5rID0gbmV3IENLRURJVE9SLkxpbmsodGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKSkuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgICAgIHJldHVybiAobGluayAmJiAobGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKS5pbmRleE9mKCd0d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQnKSAhPT0gLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSAnYWUtYnV0dG9uICcgKyB0aGlzLmdldFN0YXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MudHdpdHRlcn0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXR3aXR0ZXJcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyl9IHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy50d2l0dGVyfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXR3aXR0ZXJcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIGFwcHJvcHJpYXRlIHR3aXR0ZXIgdXJsIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCB0ZXh0IGFuZCB0aGUgY29uZmlndXJhdGlvblxuICAgICAqIG9wdGlvbnMgcmVjZWl2ZWQgdmlhIHByb3BzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcbiAgICAgKiBAbWV0aG9kIF9nZXRIcmVmXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQSB2YWxpZCB0d2l0dGVyIHVybCB3aXRoIHRoZSBzZWxlY3RlZCB0ZXh0IGFuZCBnaXZlbiBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIF9nZXRIcmVmKCkge1xuICAgICAgICB2YXIgbmF0aXZlRWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkVGV4dCA9IG5hdGl2ZUVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMucHJvcHMudXJsO1xuICAgICAgICB2YXIgdmlhID0gdGhpcy5wcm9wcy52aWE7XG4gICAgICAgIHZhciB0d2l0dGVySHJlZiA9ICdodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD90ZXh0PScgKyBzZWxlY3RlZFRleHQ7XG5cbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgdHdpdHRlckhyZWYgKz0gJyZ1cmw9JyArIHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWEpIHtcbiAgICAgICAgICAgIHR3aXR0ZXJIcmVmICs9ICcmdmlhPScgKyB2aWE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHdpdHRlckhyZWY7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHR3aXR0ZXJcbiAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblR3aXR0ZXIua2V5ID0gJ3R3aXR0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uVHdpdHRlclxuKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVW5vcmRlcmVkbGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyB1bm9yZGVyZWQgbGlzdHMgaW4gYW4gZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Vbm9yZGVyZWRsaXN0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblVub3JkZXJlZGxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25Vbm9yZGVyZWRsaXN0XG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9ICdhZS1idXR0b24gJyArIHRoaXMuZ2V0U3RhdGVDbGFzc2VzKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5idWxsZXRlZGxpc3R9IGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX0gY2xhc3NOYW1lPXtjc3NDbGFzc30gZGF0YS10eXBlPVwiYnV0dG9uLXVsXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYnVsbGV0ZWRsaXN0fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLWJ1bGxldGVkLWxpc3RcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgdWxcbiAqIEBtZW1iZXJvZiBCdXR0b25Vbm9yZGVyZWRsaXN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cbkJ1dHRvblVub3JkZXJlZGxpc3Qua2V5ID0gJ3VsJztcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBCdXR0b25Vbm9yZGVyZWRsaXN0XG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5CdXR0b25Vbm9yZGVyZWRsaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAnYnVsbGV0ZWRsaXN0JyxcbiAgICBzdHlsZToge1xuICAgICAgICBlbGVtZW50OiAndWwnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcbiAgICBCdXR0b25TdGF0ZUNsYXNzZXMoXG4gICAgQnV0dG9uU3R5bGUoXG4gICAgICAgIEJ1dHRvblVub3JkZXJlZGxpc3RcbikpKTsiLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25LZXlzdHJva2UgZnJvbSAnLi4vYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUuanMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVW5kZXJsaW5lIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHVuZGVybHlpbmcgYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVW5kZXJsaW5lXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uVW5kZXJsaW5lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50e1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnVuZGVybGluZX0gYXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfSBjbGFzc05hbWU9e2Nzc0NsYXNzfSBkYXRhLXR5cGU9XCJidXR0b24tdW5kZXJsaW5lXCIgb25DbGljaz17dGhpcy5leGVjQ29tbWFuZC5iaW5kKHRoaXMpfSB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0gdGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MudW5kZXJsaW5lfT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhZS1pY29uLXVuZGVybGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCB1bmRlcmxpbmVcbiAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uVW5kZXJsaW5lLmtleSA9ICd1bmRlcmxpbmUnO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEJ1dHRvblVuZGVybGluZVxuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuQnV0dG9uVW5kZXJsaW5lLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb21tYW5kOiAndW5kZXJsaW5lJyxcbiAgICBrZXlzdHJva2U6IHtcbiAgICAgICAgZm46ICdleGVjQ29tbWFuZCcsXG4gICAgICAgIGtleXM6IENLRURJVE9SLkNUUkwgKyA4NSAvKlUqL1xuICAgIH0sXG4gICAgc3R5bGU6ICdjb3JlU3R5bGVzX3VuZGVybGluZSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG4gICAgQnV0dG9uS2V5c3Ryb2tlKFxuICAgIEJ1dHRvblN0YXRlQ2xhc3NlcyhcbiAgICBCdXR0b25TdHlsZShcbiAgICAgICAgQnV0dG9uVW5kZXJsaW5lXG4pKSkpOyIsImltcG9ydCBCdXR0b25Cb2xkIGZyb20gJy4vYnV0dG9uLWJvbGQuanN4JztcbmltcG9ydCBCdXR0b25DYW1lcmFJbWFnZSBmcm9tICcuL2J1dHRvbi1jYW1lcmEtaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25DYW1lcmEgZnJvbSAnLi9idXR0b24tY2FtZXJhLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ29kZSBmcm9tICcuL2J1dHRvbi1jb2RlLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGZyb20gJy4vYnV0dG9uLWNvbW1hbmQtbGlzdC1pdGVtLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IEJ1dHRvbkVtYmVkRWRpdCBmcm9tICcuL2J1dHRvbi1lbWJlZC1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uRW1iZWQgZnJvbSAnLi9idXR0b24tZW1iZWQuanN4JztcbmltcG9ydCBCdXR0b25IMSBmcm9tICcuL2J1dHRvbi1oMS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkgyIGZyb20gJy4vYnV0dG9uLWgyLmpzeCc7XG5pbXBvcnQgQnV0dG9uSGxpbmUgZnJvbSAnLi9idXR0b24taGxpbmUuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGZyb20gJy4vYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvbkltYWdlQWxpZ25MZWZ0IGZyb20gJy4vYnV0dG9uLWltYWdlLWFsaWduLWxlZnQuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZUFsaWduUmlnaHQgZnJvbSAnLi9idXR0b24taW1hZ2UtYWxpZ24tcmlnaHQuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZSBmcm9tICcuL2J1dHRvbi1pbWFnZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkluZGVudEJsb2NrIGZyb20gJy4vYnV0dG9uLWluZGVudC1ibG9jay5qc3gnO1xuaW1wb3J0IEJ1dHRvbkl0YWxpYyBmcm9tICcuL2J1dHRvbi1pdGFsaWMuanN4JztcbmltcG9ydCBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCBmcm9tICcuL2J1dHRvbi1saW5rLWF1dG9jb21wbGV0ZS1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0VkaXQgZnJvbSAnLi9idXR0b24tbGluay1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua1RhcmdldEVkaXQgZnJvbSAnLi9idXR0b24tbGluay10YXJnZXQtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmsgZnJvbSAnLi9idXR0b24tbGluay5qc3gnO1xuaW1wb3J0IEJ1dHRvbk9sIGZyb20gJy4vYnV0dG9uLW9sLmpzeCc7XG5pbXBvcnQgQnV0dG9uT3V0ZGVudEJsb2NrIGZyb20gJy4vYnV0dG9uLW91dGRlbnQtYmxvY2suanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgZnJvbSAnLi9idXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnQuanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0IGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1yaWdodC5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaENlbnRlciBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtY2VudGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeS5qc3gnO1xuaW1wb3J0IEJ1dHRvblF1b3RlIGZyb20gJy4vYnV0dG9uLXF1b3RlLmpzeCc7XG5pbXBvcnQgQnV0dG9uUmVtb3ZlRm9ybWF0IGZyb20gJy4vYnV0dG9uLXJlbW92ZS1mb3JtYXQuanN4JztcbmltcG9ydCBCdXR0b25TdHJpa2UgZnJvbSAnLi9idXR0b24tc3RyaWtlLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEhlYWRlciBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1oZWFkZXIuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLXJlbW92ZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzIGZyb20gJy4vYnV0dG9uLXN0eWxlcy5qc3gnO1xuaW1wb3J0IEJ1dHRvblN1YnNjcmlwdCBmcm9tICcuL2J1dHRvbi1zdWJzY3JpcHQuanN4JztcbmltcG9ydCBCdXR0b25TdXBlcnNjcmlwdCBmcm9tICcuL2J1dHRvbi1zdXBlcnNjcmlwdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlQ2VsbCBmcm9tICcuL2J1dHRvbi10YWJsZS1jZWxsLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVDb2x1bW4gZnJvbSAnLi9idXR0b24tdGFibGUtY29sdW1uLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVFZGl0IGZyb20gJy4vYnV0dG9uLXRhYmxlLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUhlYWRpbmcgZnJvbSAnLi9idXR0b24tdGFibGUtaGVhZGluZy5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlUmVtb3ZlIGZyb20gJy4vYnV0dG9uLXRhYmxlLXJlbW92ZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlUm93IGZyb20gJy4vYnV0dG9uLXRhYmxlLXJvdy5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlIGZyb20gJy4vYnV0dG9uLXRhYmxlLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFyZ2V0TGlzdCBmcm9tICcuL2J1dHRvbi10YXJnZXQtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblR3aXR0ZXIgZnJvbSAnLi9idXR0b24tdHdpdHRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvblVsIGZyb20gJy4vYnV0dG9uLXVsLmpzeCc7XG5pbXBvcnQgQnV0dG9uVW5kZXJsaW5lIGZyb20gJy4vYnV0dG9uLXVuZGVybGluZS5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgW0J1dHRvbkJvbGQua2V5XTogQnV0dG9uQm9sZCxcbiAgICBbQnV0dG9uQ2FtZXJhSW1hZ2Uua2V5XTogQnV0dG9uQ2FtZXJhSW1hZ2UsXG4gICAgW0J1dHRvbkNhbWVyYS5rZXldOiBCdXR0b25DYW1lcmEsXG4gICAgW0J1dHRvbkNvZGUua2V5XTogQnV0dG9uQ29kZSxcbiAgICBbQnV0dG9uQ29tbWFuZExpc3RJdGVtLmtleV06IEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSxcbiAgICBbQnV0dG9uQ29tbWFuZHNMaXN0LmtleV06IEJ1dHRvbkNvbW1hbmRzTGlzdCxcbiAgICBbQnV0dG9uRHJvcGRvd24ua2V5XTogQnV0dG9uRHJvcGRvd24sXG4gICAgW0J1dHRvbkVtYmVkRWRpdC5rZXldOiBCdXR0b25FbWJlZEVkaXQsXG4gICAgW0J1dHRvbkVtYmVkLmtleV06IEJ1dHRvbkVtYmVkLFxuICAgIFtCdXR0b25IMS5rZXldOiBCdXR0b25IMSxcbiAgICBbQnV0dG9uSDIua2V5XTogQnV0dG9uSDIsXG4gICAgW0J1dHRvbkhsaW5lLmtleV06IEJ1dHRvbkhsaW5lLFxuICAgIFtCdXR0b25JbWFnZUFsaWduQ2VudGVyLmtleV06IEJ1dHRvbkltYWdlQWxpZ25DZW50ZXIsXG4gICAgW0J1dHRvbkltYWdlQWxpZ25MZWZ0LmtleV06IEJ1dHRvbkltYWdlQWxpZ25MZWZ0LFxuICAgIFtCdXR0b25JbWFnZUFsaWduUmlnaHQua2V5XTogQnV0dG9uSW1hZ2VBbGlnblJpZ2h0LFxuICAgIFtCdXR0b25JbWFnZS5rZXldOiBCdXR0b25JbWFnZSxcbiAgICBbQnV0dG9uSW5kZW50QmxvY2sua2V5XTogQnV0dG9uSW5kZW50QmxvY2ssXG4gICAgW0J1dHRvbkl0YWxpYy5rZXldOiBCdXR0b25JdGFsaWMsXG4gICAgW0J1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0LmtleV06IEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0LFxuICAgIFtCdXR0b25MaW5rRWRpdC5rZXldOiBCdXR0b25MaW5rRWRpdCxcbiAgICBbQnV0dG9uTGlua1RhcmdldEVkaXQua2V5XTogQnV0dG9uTGlua1RhcmdldEVkaXQsXG4gICAgW0J1dHRvbkxpbmsua2V5XTogQnV0dG9uTGluayxcbiAgICBbQnV0dG9uT2wua2V5XTogQnV0dG9uT2wsXG4gICAgW0J1dHRvbk91dGRlbnRCbG9jay5rZXldOiBCdXR0b25PdXRkZW50QmxvY2ssXG4gICAgW0J1dHRvblBhcmFncmFwaEFsaWduTGVmdC5rZXldOiBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQsXG4gICAgW0J1dHRvblBhcmFncmFwaEFsaWduUmlnaHQua2V5XTogQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCxcbiAgICBbQnV0dG9uUGFyYWdyYXBoQ2VudGVyLmtleV06IEJ1dHRvblBhcmFncmFwaENlbnRlcixcbiAgICBbQnV0dG9uUGFyYWdyYXBoSnVzdGlmeS5rZXldOiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LFxuICAgIFtCdXR0b25RdW90ZS5rZXldOiBCdXR0b25RdW90ZSxcbiAgICBbQnV0dG9uUmVtb3ZlRm9ybWF0LmtleV06IEJ1dHRvblJlbW92ZUZvcm1hdCxcbiAgICBbQnV0dG9uU3RyaWtlLmtleV06IEJ1dHRvblN0cmlrZSxcbiAgICBbQnV0dG9uU3R5bGVzTGlzdEhlYWRlci5rZXldOiBCdXR0b25TdHlsZXNMaXN0SGVhZGVyLFxuICAgIFtCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZS5rZXldOiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSxcbiAgICBbQnV0dG9uU3R5bGVzTGlzdEl0ZW0ua2V5XTogQnV0dG9uU3R5bGVzTGlzdEl0ZW0sXG4gICAgW0J1dHRvblN0eWxlc0xpc3Qua2V5XTogQnV0dG9uU3R5bGVzTGlzdCxcbiAgICBbQnV0dG9uU3R5bGVzLmtleV06IEJ1dHRvblN0eWxlcyxcbiAgICBbQnV0dG9uU3Vic2NyaXB0LmtleV06IEJ1dHRvblN1YnNjcmlwdCxcbiAgICBbQnV0dG9uU3VwZXJzY3JpcHQua2V5XTogQnV0dG9uU3VwZXJzY3JpcHQsXG4gICAgW0J1dHRvblRhYmxlQ2VsbC5rZXldOiBCdXR0b25UYWJsZUNlbGwsXG4gICAgW0J1dHRvblRhYmxlQ29sdW1uLmtleV06IEJ1dHRvblRhYmxlQ29sdW1uLFxuICAgIFtCdXR0b25UYWJsZUVkaXQua2V5XTogQnV0dG9uVGFibGVFZGl0LFxuICAgIFtCdXR0b25UYWJsZUhlYWRpbmcua2V5XTogQnV0dG9uVGFibGVIZWFkaW5nLFxuICAgIFtCdXR0b25UYWJsZVJlbW92ZS5rZXldOiBCdXR0b25UYWJsZVJlbW92ZSxcbiAgICBbQnV0dG9uVGFibGVSb3cua2V5XTogQnV0dG9uVGFibGVSb3csXG4gICAgW0J1dHRvblRhYmxlLmtleV06IEJ1dHRvblRhYmxlLFxuICAgIFtCdXR0b25UYXJnZXRMaXN0LmtleV06IEJ1dHRvblRhcmdldExpc3QsXG4gICAgW0J1dHRvblR3aXR0ZXIua2V5XTogQnV0dG9uVHdpdHRlcixcbiAgICBbQnV0dG9uVWwua2V5XTogQnV0dG9uVWwsXG4gICAgW0J1dHRvblVuZGVybGluZS5rZXldOiBCdXR0b25VbmRlcmxpbmVcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0RXhjbHVzaXZlIGZyb20gJy4vYmFzZS93aWRnZXQtZXhjbHVzaXZlLmpzJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBUaGUgbWFpbiBlZGl0b3IgVUkgY2xhc3MgbWFuYWdlcyBhIGhpZXJhcmNoeSBvZiB3aWRnZXRzICh0b29sYmFycyBhbmQgYnV0dG9ucykuXG4gKlxuICogQGNsYXNzIFVJXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBVSSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoaWRkZW46IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdlZGl0b3JJbnRlcmFjdGlvbicsIHRoaXMuX29uRWRpdG9ySW50ZXJhY3Rpb24sIHRoaXMpO1xuICAgICAgICBlZGl0b3Iub24oJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMuX29uQWN0aW9uUGVyZm9ybWVkLCB0aGlzKTtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXknLCB0aGlzLl9vbkVkaXRvcktleSwgdGhpcyk7XG5cbiAgICAgICAgLy8gU2V0IHVwIGV2ZW50cyBmb3IgaGlkaW5nIHRoZSBVSSB3aGVuIHVzZXIgc3RvcHMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZWRpdG9yLlxuICAgICAgICAvLyBUaGlzIG1heSBoYXBwZW4gd2hlbiBoZSBqdXN0IGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuIEhvd2V2ZXIsXG4gICAgICAgIC8vIHRoaXMgZG9lcyBub3QgaW5jbHVkZSBhIHNpdHVhdGlvbiB3aGVuIGhlIGNsaWNrcyBvbiBzb21lIGJ1dHRvbiwgcGFydCBvZlxuICAgICAgICAvLyBlZGl0b3IncyBVSS5cblxuICAgICAgICAvLyBJdCBpcyBub3QgZWFzeSB0byBkZWJvdW5jZSBfc2V0VUlIaWRkZW4gb24gbW91c2Vkb3duLCBiZWNhdXNlIGlmIHdlXG4gICAgICAgIC8vIGRlYm91bmNlIGl0LCB3aGVuIHRoZSBoYW5kbGVyIGlzIGJlaW5nIGludm9rZWQsIHRoZSB0YXJnZXQgbWlnaHQgYmUgbm8gbW9yZSBwYXJ0XG4gICAgICAgIC8vIG9mIHRoZSBlZGl0b3IncyBVSSAtIG9uQWN0aW9uUGVyZm9ybWVkIGNhdXNlcyByZS1yZW5kZXIuXG4gICAgICAgIHRoaXMuX21vdXNlZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRVSUhpZGRlbihldmVudC50YXJnZXQpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fa2V5RG93bkxpc3RlbmVyID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFVJSGlkZGVuKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9LCB0aGlzLnByb3BzLmV2ZW50c0RlbGF5LCB0aGlzKTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlEb3duTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuICAgICAqIEZpcmVzIGBhcmlhVXBkYXRlYCBldmVudCBwYXNzaW5nIEFSSUEgcmVsYXRlZCBtZXNzYWdlcy5cbiAgICAgKiBGaXJlcyBgZWRpdG9yVXBkYXRlYCBldmVudCBwYXNzaW5nIHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCBwcm9wZXJ0aWVzIGFuZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGlmIChkb21Ob2RlKSB7XG4gICAgICAgICAgICBlZGl0b3IuZmlyZSgnYXJpYVVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLl9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2UoZG9tTm9kZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLmZpcmUoJ2VkaXRvclVwZGF0ZScsIHtcbiAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgcHJldlN0YXRlOiBwcmV2U3RhdGUsXG4gICAgICAgICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXRBcmlhVXBkYXRlVGVtcGxhdGUoYXJpYVVwZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2FyaWFVcGRhdGVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FyaWFVcGRhdGVUZW1wbGF0ZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlc1thcmlhVXBkYXRlXSkge1xuICAgICAgICAgICAgdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlc1thcmlhVXBkYXRlXSA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZSh0aGlzLl9nZXRBcmlhVXBkYXRlcygpW2FyaWFVcGRhdGVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlcyBmb3IgQVJJQSBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9nZXRBcmlhVXBkYXRlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gQVJJQSByZWxhdGVzIG1lc3NhZ2VzLiBEZWZhdWx0OlxuICAgICAqIHtcbiAgICAgKiAgICAgIG5vVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTm9Ub29sYmFyLFxuICAgICAqICAgICAgb25lVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlT25lVG9vbGJhcixcbiAgICAgKiAgICAgIG1hbnlUb29sYmFyczogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTWFueVRvb2xiYXJzXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBfZ2V0QXJpYVVwZGF0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmFyaWFVcGRhdGVzIHx8IHtcbiAgICAgICAgICAgIG5vVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTm9Ub29sYmFyLFxuICAgICAgICAgICAgb25lVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlT25lVG9vbGJhcixcbiAgICAgICAgICAgIG1hbnlUb29sYmFyczogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTWFueVRvb2xiYXJzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBUklBIG1lc3NhZ2Ugd2hpY2ggcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhdmFpbGFibGUgdG9vbGJhcnMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAbWV0aG9kIF9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZG9tTm9kZSBUaGUgRE9NIG5vZGUgZnJvbSB3aGljaCB0aGUgYXZhaWxhYmxlIHRvb2xiYXJzIHdpbGwgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEFSSUEgbWVzc2FnZSBmb3IgdGhlIG51bWJlciBvZiBhdmFpbGFibGUgdG9vbGJhcnNcbiAgICAgKi9cbiAgICBfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlKGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIHRvb2xiYXJzTm9kZUxpc3QgPSBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidG9vbGJhclwiXScpO1xuXG4gICAgICAgIGlmICghdG9vbGJhcnNOb2RlTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBcmlhVXBkYXRlcygpLm5vVG9vbGJhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b29sYmFyTmFtZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0b29sYmFyc05vZGVMaXN0KS5tYXAoZnVuY3Rpb24odG9vbGJhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sYmFyLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhcmlhVXBkYXRlID0gdG9vbGJhck5hbWVzLmxlbmd0aCA9PT0gMSA/ICdvbmVUb29sYmFyJyA6ICdtYW55VG9vbGJhcnMnO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXJpYVVwZGF0ZVRlbXBsYXRlKGFyaWFVcGRhdGUpLm91dHB1dCh7XG4gICAgICAgICAgICAgICAgdG9vbGJhcnM6IHRvb2xiYXJOYW1lcy5qb2luKCcsJykucmVwbGFjZSgvLChbXixdKikkLywgJyBhbmQgJyArICckMScpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlZG93bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fa2V5RG93bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlEb3duTGlzdGVuZXIuZGV0YWNoKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5RG93bkxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGVkaXRvci4gVGhpcyBtYXkgaW5jbHVkZSBzZXZlcmFsIHRvb2xiYXJzIGFuZCBidXR0b25zLlxuICAgICAqIFRoZSBlZGl0b3IncyBVSSBhbHNvIHRha2VzIGNhcmUgb2YgcmVuZGVyaW5nIHRoZSBpdGVtcyBpbiBleGNsdXNpdmUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvb2xiYXJzID0gT2JqZWN0LmtleXModGhpcy5wcm9wcy50b29sYmFycykubWFwKGZ1bmN0aW9uKHRvb2xiYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBBbGxveUVkaXRvci5Ub29sYmFyc1t0b29sYmFyXSB8fCB3aW5kb3dbdG9vbGJhcl07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRvb2xiYXJzID0gdGhpcy5maWx0ZXJFeGNsdXNpdmUodG9vbGJhcnMpLm1hcChmdW5jdGlvbih0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoe1xuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5wcm9wcy50b29sYmFyc1t0b29sYmFyLmtleV0sXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLnByb3BzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBlZGl0b3JFdmVudDogdGhpcy5zdGF0ZS5lZGl0b3JFdmVudCxcbiAgICAgICAgICAgICAgICBrZXk6IHRvb2xiYXIua2V5LFxuICAgICAgICAgICAgICAgIG9uRGlzbWlzczogdGhpcy5fb25EaXNtaXNzVG9vbGJhckZvY3VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IHRoaXMuc3RhdGUuc2VsZWN0aW9uRGF0YVxuICAgICAgICAgICAgfSwgdG9vbGJhci5rZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh0b29sYmFyLCBwcm9wcyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtdG9vbGJhcnNcIiBvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgIHt0b29sYmFyc31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRvIHRoZSBlZGl0b3IncyBgYWN0aW9uUGVyZm9ybWVkYCBldmVudC4gU2V0cyBzdGF0ZSBhbmQgcmVkcmF3cyB0aGUgVUkgb2YgdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBVSVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWV0aG9kIF9vbkFjdGlvblBlcmZvcm1lZFxuICAgICAqIEBwYXJhbSB7U3ludGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50XG4gICAgICovXG4gICAgX29uQWN0aW9uUGVyZm9ybWVkKGV2ZW50KSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXRlbUV4Y2x1c2l2ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZWQgd2hlbiBhIGRpc21pc3Mga2V5IGlzIHByZXNzZWQgb3ZlciBhIHRvb2xiYXIgdG8gcmV0dXJuIHRoZSBmb2N1cyB0byB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFVJXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2QgX29uRGlzbWlzc1Rvb2xiYXJGb2N1c1xuICAgICAqL1xuICAgIF9vbkRpc21pc3NUb29sYmFyRm9jdXMoKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRvIHRoZSBlZGl0b3IncyBgdXNlckludGVyYWN0aW9uYCBldmVudC4gUmV0cmlldmVzIHRoZSBkYXRhIGFib3V0IHRoZSB1c2VyIHNlbGVjdGlvbiBhbmRcbiAgICAgKiBwcm92aWRlcyBpdCB2aWEgY29tcG9uZW50J3Mgc3RhdGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfb25FZGl0b3JJbnRlcmFjdGlvblxuICAgICAqIEBwYXJhbSB7U3ludGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50XG4gICAgICovXG4gICAgX29uRWRpdG9ySW50ZXJhY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBlZGl0b3JFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgaXRlbUV4Y2x1c2l2ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IGV2ZW50LmRhdGEuc2VsZWN0aW9uRGF0YVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIG9uIHRoZSBhY3RpdmUgdG9vbGJhciB3aGVuIHRoZSBjb21iaW5hdGlvbiBBTFQrRjEwIGlzIHByZXNzZWQgaW5zaWRlIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfb25FZGl0b3JLZXlcbiAgICAgKi9cbiAgICBfb25FZGl0b3JLZXkoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS5kb21FdmVudC4kO1xuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5hbHRLZXkgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gMTIxKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHRhcmdldCB3aXRoIHdoaWNoIHRoZSB1c2VyIGludGVyYWN0ZWQgaXMgcGFydCBvZiBlZGl0b3IncyBVSSBvciBpdCBpc1xuICAgICAqIHRoZSBlZGl0YWJsZSBhcmVhLiBJZiBub25lIG9mIHRoZXNlLCBzZXRzIHRoZSBzdGF0ZSBvZiBlZGl0b3IncyBVSSB0byBiZSBoaWRkZW4uXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVUlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1ldGhvZCBfc2V0VUlIaWRkZW5cbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHRhcmdldCBUaGUgRE9NIGVsZW1lbnQgd2l0aCB3aGljaCB1c2VyIGludGVyYWN0ZWQgbGFzdGx5LlxuICAgICAqL1xuICAgIF9zZXRVSUhpZGRlbih0YXJnZXQpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuICAgICAgICBpZiAoZG9tTm9kZSkge1xuICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5lZGl0YWJsZSgpO1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBuZXcgQ0tFRElUT1IuZG9tLm5vZGUodGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKCFlZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IChlZGl0YWJsZS4kID09PSB0YXJnZXQpIHx8IGVkaXRhYmxlLmNvbnRhaW5zKHRhcmdldE5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkpLmNvbnRhaW5zKHRhcmdldE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIFVJXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5VSS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgZGVzY2VuZGFudHM6ICdbY2xhc3NePWFlLXRvb2xiYXItXScsXG4gICAgZXZlbnRzRGVsYXk6IDAsXG4gICAga2V5czoge1xuICAgICAgICBuZXh0OiA5XG4gICAgfVxufTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIGNvbXBvbmVudCB1cGRhdGVzIGFuZCB3aGVuIGl0IGlzIHJlbmRlcmVkIGluIHRoZSBET00uXG4gKiBUaGUgcGF5bG9hZCBjb25zaXN0cyBmcm9tIGEgYG1lc3NhZ2VgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIEFSSUEgbWVzc2FnZS5cbiAqXG4gKiBAZXZlbnQgYXJpYVVwZGF0ZVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBjb21wb25lbnQgdXBkYXRlcy4gVGhlIHBheWxvYWQgY29uc2lzdHMgZnJvbSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICogLSBwcmV2UHJvcHMgLSBUaGUgcHJldmlvdXMgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByZXZTdGF0ZSAtIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByb3BzIC0gVGhlIGN1cnJlbnQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBldmVudCBhcmlhVXBkYXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0RXhjbHVzaXZlKFxuICAgIFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICAgICAgVUlcbikpOyIsImltcG9ydCBUb29sYmFyQWRkIGZyb20gJy4vdG9vbGJhci1hZGQuanN4JztcbmltcG9ydCBUb29sYmFyU3R5bGVzIGZyb20gJy4vdG9vbGJhci1zdHlsZXMuanN4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFtUb29sYmFyQWRkLmtleV06IFRvb2xiYXJBZGQsXG4gICAgW1Rvb2xiYXJTdHlsZXMua2V5XTogVG9vbGJhclN0eWxlc1xufTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgVG9vbGJhckJ1dHRvbnMgZnJvbSAnLi4vYmFzZS90b29sYmFyLWJ1dHRvbnMuanMnO1xuaW1wb3J0IFdpZGdldEFycm93Qm94IGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWFycm93LWJveC5qcyc7XG5pbXBvcnQgV2lkZ2V0RHJvcGRvd24gZnJvbSAnLi4vYmFzZS93aWRnZXQtZHJvcGRvd24uanMnO1xuaW1wb3J0IFdpZGdldEV4Y2x1c2l2ZSBmcm9tICcuLi9iYXNlL3dpZGdldC1leGNsdXNpdmUuanMnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyLmpzJztcbmltcG9ydCBXaWRnZXRQb3NpdGlvbiBmcm9tICcuLi9iYXNlL3dpZGdldC1wb3NpdGlvbi5qcyc7XG5cbnZhciBQT1NJVElPTl9MRUZUID0gMTtcbnZhciBQT1NJVElPTl9SSUdIVCA9IDI7XG5cbi8qKlxuICogVGhlIFRvb2xiYXJBZGQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWRkaW5nIGNvbnRlbnQgdG8gdGhlIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckFkZFxuICogQHVzZXMgVG9vbGJhckJ1dHRvbnNcbiAqIEB1c2VzIFdpZGdldEFycm93Qm94XG4gKiBAdXNlcyBXaWRnZXREcm9wZG93blxuICogQHVzZXMgV2lkZ2V0RXhjbHVzaXZlXG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqIEB1c2VzIFdpZGdldFBvc2l0aW9uXG4gKi9cbmNsYXNzIFRvb2xiYXJBZGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnR7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50IChub3Qgb24gdGhlIHNlcnZlciksXG4gICAgICogaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gICAgICogQG1ldGhvZCBjb21wb25lbnREaWRVcGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlByb3BzIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0YXRlIENvbXBvbmVudCdzIHByZXZpb3VzIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZXhjbHVzaXZlIHJlbmRlcmluZywgZm9jdXMgdGhlIGZpcnN0IGRlc2NlbmRhbnQgKGJ1dHRvbilcbiAgICAgICAgLy8gc28gdGhlIHVzZXIgd2lsbCBiZSBhYmxlIHRvIHN0YXJ0IGludGVyYWN0aW5nIHdpdGggdGhlIGJ1dHRvbnMgaW1tZWRpYXRlbHkuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBidXR0b25zIGZvciBhZGRpbmcgY29udGVudCBvciBoaWRlcyB0aGUgdG9vbGJhclxuICAgICAqIGlmIHVzZXIgaW50ZXJhY3RlZCB3aXRoIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIFNvbWUgb3BlcmF0aW9ucyBzdWNoIGFzIGByZXF1ZXN0RXhjbHVzaXZlYCBtYXkgZm9yY2UgZWRpdG9yIHRvIGJsdXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBpbnZhbGlkYXRlIHRoZSBgcHJvcHMuZWRpdG9yRXZlbnRgIHN0b3JlZCB2YWx1ZSwgd2l0aG91dCBjYXVzaW5nIGEgYHByb3BzYCBjaGFuZ2UuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBpZiB0aGUgZWRpdG9yIGlzIGVtcHR5LCBgYWVfcGxhY2Vob2xkZXJgIHBsdWdpbiB3aWxsIHJlbW92ZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IGZyb20gdGhlIERPTSBhbmQgd2lsbCBwcmV2ZW50IGBhZGRgIHRvb2xiYXIgZnJvbSByZW5kZXJpbmcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0IHNob3VsZCBiZSBzYWZlIHRvIGFzc3VtZSB0aGF0IGlmIHlvdSBoYXZlIGJlZW4gYWJsZSB0byByZW5kZXIgdGhlIHRvb2xiYXJcbiAgICAgICAgLy8gYW5kIHJlcXVlc3QgdGhlIGV4Y2x1c2l2ZSBtb2RlLCB0aGVuIHJlbmRlcmluZyBtaWdodCBiZSBrZXB0IHVudGlsIHRoZSBleGNsdXNpdmUgbW9kZSBpcyBsZWZ0LlxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZWRpdG9yRXZlbnQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGEubmF0aXZlRXZlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YS5uYXRpdmVFdmVudC50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1dHRvbnMgPSB0aGlzLl9nZXRCdXR0b25zKCk7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLl9nZXRUb29sYmFyQ2xhc3NOYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hZGR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBkYXRhLXRhYmluZGV4PXt0aGlzLnByb3BzLmNvbmZpZy50YWJJbmRleCB8fCAwfSBvbkZvY3VzPXt0aGlzLmZvY3VzLmJpbmQodGhpcyl9IG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKX0gcm9sZT1cInRvb2xiYXJcIiB0YWJJbmRleD1cIi0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbnN9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBidXR0b25zIHRoYXQgd2lsbCBldmVudHVhbGx5IHJlbmRlciB0byBIVE1MLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIF9nZXRCdXR0b25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGJ1dHRvbnMgd2hpY2ggaGF2ZSB0byBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBfZ2V0QnV0dG9ucygpIHtcbiAgICAgICAgdmFyIGJ1dHRvbnM7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBidXR0b25zID0gdGhpcy5nZXRUb29sYmFyQnV0dG9ucyh0aGlzLnByb3BzLmNvbmZpZy5idXR0b25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEgJiYgdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbikge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAoXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hZGR9IGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1idXR0b24tYWRkXCIgb25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcywgVG9vbGJhckFkZC5rZXkpfSB0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hZGR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWUtaWNvbi1hZGRcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnV0dG9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGFzcyBuYW1lIG9mIHRoZSB0b29sYmFyIGluIGNhc2Ugb2YgYm90aCBleGNsdXNpdmUgYW5kIG5vcm1hbCBtb2RlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIF9nZXRUb29sYmFyQ2xhc3NOYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNsYXNzIG5hbWUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0VG9vbGJhckNsYXNzTmFtZSgpIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gJ2FlLXRvb2xiYXItYWRkJztcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGNzc0NsYXNzID0gJ2FlLXRvb2xiYXIgJyArIHRoaXMuZ2V0QXJyb3dCb3hDbGFzc2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzQ2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgaW4gZXhjbHVzaXZlIG9yIG5vcm1hbCBtb2RlLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVQb3NpdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIHZhciByZWdpb247XG5cbiAgICAgICAgLy8gSWYgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmICghUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uID0gdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlZ2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGFydFJlY3QgPSByZWdpb24uc3RhcnRSZWN0IHx8IHJlZ2lvbjtcblxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBuYXRpdmVFZGl0b3IuZWRpdGFibGUoKS5nZXRDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdDtcblxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucHJvcHMuY29uZmlnLnBvc2l0aW9uIHx8IHRoaXMucHJvcHMucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFBPU0lUSU9OX0xFRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IGNsaWVudFJlY3QubGVmdCAtIGRvbU5vZGUub2Zmc2V0V2lkdGggLSB0aGlzLnByb3BzLmd1dHRlckV4Y2x1c2l2ZS5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gY2xpZW50UmVjdC5yaWdodCArIHRoaXMucHJvcHMuZ3V0dGVyRXhjbHVzaXZlLmxlZnQgKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUubGVmdCA9IG9mZnNldExlZnQ7XG5cbiAgICAgICAgICAgICAgICBkb21Ob2RlLnN0eWxlLnRvcCA9IE1hdGguZmxvb3IoKHJlZ2lvbi5ib3R0b20gKyByZWdpb24udG9wKSAvIDIpICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFZGl0b3IuZWxlbWVudC5nZXRTdHlsZSgnb3ZlcmZsb3cnKSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUudG9wID0gTWF0aC5mbG9vcihyZWdpb24udG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQvMiArIHN0YXJ0UmVjdC5oZWlnaHQvMikgKyAncHgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUudG9wID0gTWF0aC5mbG9vciggbmF0aXZlRWRpdG9yLmVsZW1lbnQuJC5vZmZzZXRUb3AgKyAoc3RhcnRSZWN0LmhlaWdodCAvIDIpIC0gKGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMikgKSArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS5vcGFjaXR5ID0gMTtcblxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2FlLWFycm93LWJveCcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBhZGRcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJBZGQua2V5ID0gJ2FkZCc7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY29uc3RhbnQgZm9yIHBvc2l0aW9uaW5nIHRoZSBUb29sYmFyIG9uIGxlZnQgb2YgdGhlIGVkaXRhYmxlIGFyZWEuXG4gKlxuICogQGRlZmF1bHQgMVxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsZWZ0XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJBZGQubGVmdCA9IFBPU0lUSU9OX0xFRlQ7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY29uc3RhbnQgZm9yIHBvc2l0aW9uaW5nIHRoZSBUb29sYmFyIG9uIHJpZ2h0IG9mIHRoZSBlZGl0YWJsZSBhcmVhLlxuICpcbiAqIEBkZWZhdWx0IDJcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmlnaHRcbiAqIEBzdGF0aWNcbiAqL1xuVG9vbGJhckFkZC5yaWdodCA9IFBPU0lUSU9OX1JJR0hUO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cblRvb2xiYXJBZGQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIGRlc2NlbmRhbnRzOiAnLmFlLWJ1dHRvbicsXG4gICAgZ3V0dGVyRXhjbHVzaXZlOiB7XG4gICAgICAgIGxlZnQ6IDEwLFxuICAgICAgICB0b3A6IDBcbiAgICB9LFxuICAgIGtleXM6IHtcbiAgICAgICAgZGlzbWlzczogWzI3XSxcbiAgICAgICAgbmV4dDogWzM5LCA0MF0sXG4gICAgICAgIHByZXY6IFszNywgMzhdXG4gICAgfSxcbiAgICBwb3NpdGlvbjogUE9TSVRJT05fTEVGVFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0QXJyb3dCb3goXG4gICAgV2lkZ2V0RHJvcGRvd24oXG4gICAgV2lkZ2V0RXhjbHVzaXZlKFxuICAgIFdpZGdldEZvY3VzTWFuYWdlcihcbiAgICBXaWRnZXRQb3NpdGlvbihcbiAgICBUb29sYmFyQnV0dG9ucyhcbiAgICAgICAgVG9vbGJhckFkZFxuKSkpKSkpOyIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nLmpzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBUb29sYmFyQnV0dG9ucyBmcm9tICcuLi9iYXNlL3Rvb2xiYXItYnV0dG9ucy5qcyc7XG5pbXBvcnQgV2lkZ2V0QXJyb3dCb3ggZnJvbSAnLi4vYmFzZS93aWRnZXQtYXJyb3ctYm94LmpzJztcbmltcG9ydCBXaWRnZXREcm9wZG93biBmcm9tICcuLi9iYXNlL3dpZGdldC1kcm9wZG93bi5qcyc7XG5pbXBvcnQgV2lkZ2V0RXhjbHVzaXZlIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZS5qcyc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMnO1xuaW1wb3J0IFdpZGdldFBvc2l0aW9uIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LXBvc2l0aW9uLmpzJztcblxuLyoqXG4gKiBUaGUgVG9vbGJhclN0eWxlcyBjbGFzcyBob3N0cyB0aGUgYnV0dG9ucyBmb3Igc3R5bGluZyBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBUb29sYmFyU3R5bGVzXG4gKiBAdXNlcyBUb29sYmFyQnV0dG9uc1xuICogQHVzZXMgV2lkZ2V0QXJyb3dCb3hcbiAqIEB1c2VzIFdpZGdldERyb3Bkb3duXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICogQHVzZXMgV2lkZ2V0UG9zaXRpb25cbiAqL1xuY2xhc3MgVG9vbGJhclN0eWxlcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQgKG5vdCBvbiB0aGUgc2VydmVyKSxcbiAgICAgKiBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQncyB1cGRhdGVzIGFyZSBmbHVzaGVkIHRvIHRoZSBET00uXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcbiAgICAgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2UHJvcHMgVGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3RhdGUgQ29tcG9uZW50J3MgcHJldmlvdXMgc3RhdGUuXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBidXR0b25zIGZvciBhZGRpbmcgY29udGVudCBvciBoaWRlcyB0aGUgdG9vbGJhclxuICAgICAqIGlmIHVzZXIgaW50ZXJhY3RlZCB3aXRoIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gdGhpcy5fZ2V0Q3VycmVudFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZ2V0QXJyb3dCb3hDbGFzc2VzRm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihjdXJyZW50U2VsZWN0aW9uLmdldEFycm93Qm94Q2xhc3Nlcyk7XG4gICAgICAgICAgICB2YXIgYXJyb3dCb3hDbGFzc2VzO1xuXG4gICAgICAgICAgICBpZiAoZ2V0QXJyb3dCb3hDbGFzc2VzRm4pIHtcbiAgICAgICAgICAgICAgICBhcnJvd0JveENsYXNzZXMgPSBnZXRBcnJvd0JveENsYXNzZXNGbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJvd0JveENsYXNzZXMgPSB0aGlzLmdldEFycm93Qm94Q2xhc3NlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3NzQ2xhc3NlcyA9ICdhZS10b29sYmFyLXN0eWxlcyAnICsgYXJyb3dCb3hDbGFzc2VzO1xuXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuZ2V0VG9vbGJhckJ1dHRvbnMoXG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5idXR0b25zLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFudWFsU2VsZWN0aW9uOiB0aGlzLnByb3BzLmVkaXRvckV2ZW50ID8gdGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhLm1hbnVhbFNlbGVjdGlvbiA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblR5cGU6IGN1cnJlbnRTZWxlY3Rpb24ubmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdiBhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0eWxlc30gY2xhc3NOYW1lPXtjc3NDbGFzc2VzfSBkYXRhLXRhYmluZGV4PXt0aGlzLnByb3BzLmNvbmZpZy50YWJJbmRleCB8fCAwfSBvbkZvY3VzPXt0aGlzLmZvY3VzLmJpbmQodGhpcyl9IG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKX0gcm9sZT1cInRvb2xiYXJcIiB0YWJJbmRleD1cIi0xXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7YnV0dG9uc31cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBmdW5jdGlvbiBmcm9tIFN0cmluZy4gSXQgY29udmVydHMgYSBmdWxseSBxdWFsaWZpZWQgc3RyaW5nIGludG8gdGhlIG1hcHBlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gICAgICogQG1ldGhvZCBfZ2V0U2VsZWN0aW9uRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gc2VsZWN0aW9uRm4gQSBmdW5jdGlvbiwgb3IgYSBmdWxseSBxdWFsaWZpZWQgc3RyaW5nIHBvaW50aW5nIHRvIHRoZSBkZXNpcmVkIG9uZSAoZS5nLiAnQWxsb3lFZGl0b3IuU2VsZWN0aW9uVGVzdC5pbWFnZScpLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIG1hcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0U2VsZWN0aW9uRnVuY3Rpb24oc2VsZWN0aW9uRm4pIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkZ1bmN0aW9uO1xuXG4gICAgICAgIGlmIChMYW5nLmlzRnVuY3Rpb24oc2VsZWN0aW9uRm4pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25GdW5jdGlvbiA9IHNlbGVjdGlvbkZuO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoTGFuZy5pc1N0cmluZyhzZWxlY3Rpb25GbikpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNlbGVjdGlvbkZuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1lbWJlciA9IHdpbmRvdztcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwcm9wZXJ0eSAmJiBMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXIpICYmIExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcltwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1lbWJlciA9IGN1cnJlbnRNZW1iZXJbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihjdXJyZW50TWVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZ1bmN0aW9uID0gY3VycmVudE1lbWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25GdW5jdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXplcyB0aGUgY3VycmVudCBlZGl0b3Igc2VsZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBzZWxlY3Rpb24gY29uZmlndXJhdGlvbiB0aGF0IG1hdGNoZXMuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICAgICAqIEBtZXRob2QgX2dldEN1cnJlbnRTZWxlY3Rpb25cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWF0Y2hlZCBzZWxlY3Rpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0Q3VycmVudFNlbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIGV2ZW50UGF5bG9hZCA9IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQgPyB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGEgOiBudWxsO1xuICAgICAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgICAgIGlmIChldmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY29uZmlnLnNlbGVjdGlvbnMuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RGbiA9IHRoaXMuX2dldFNlbGVjdGlvbkZ1bmN0aW9uKGl0ZW0udGVzdCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmICh0ZXN0Rm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZlbnRQYXlsb2FkLm1hbnVhbFNlbGVjdGlvbiA9PT0gaXRlbS5uYW1lIHx8wqB0ZXN0Rm4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXZlbnRQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLnByb3BzLmVkaXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCBzZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbGJhci5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gICAgICogQG1ldGhvZCBfdXBkYXRlUG9zaXRpb25cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICAvLyBJZiBjb21wb25lbnQgaXMgbm90IG1vdW50ZWQsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgaWYgKCFSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLl9nZXRDdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gSWYgY3VycmVudCBzZWxlY3Rpb24gaGFzIGEgZnVuY3Rpb24gY2FsbGVkIGBzZXRQb3NpdGlvbmAsIGNhbGwgaXRcbiAgICAgICAgLy8gYW5kIGNoZWNrIHRoZSByZXR1cm5lZCB2YWx1ZS4gSWYgZmFsc2UsIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IHBvc2l0aW9uaW5nIGxvZ2ljLlxuICAgICAgICBpZiAoY3VycmVudFNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHNldFBvc2l0aW9uRm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihjdXJyZW50U2VsZWN0aW9uLnNldFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgaWYgKHNldFBvc2l0aW9uRm4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXRQb3NpdGlvbkZuLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3JFdmVudDogdGhpcy5wcm9wcy5lZGl0b3JFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRGF0YTogdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuVG9vbGJhclN0eWxlcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgZGVzY2VuZGFudHM6ICcuYWUtaW5wdXQsIC5hZS1idXR0b246bm90KFtkaXNhYmxlZF0pLCAuYWUtdG9vbGJhci1lbGVtZW50JyxcbiAgICBrZXlzOiB7XG4gICAgICAgIGRpc21pc3M6IFsyN10sXG4gICAgICAgIG5leHQ6IFszOSwgNDBdLFxuICAgICAgICBwcmV2OiBbMzcsIDM4XVxuICAgIH1cbn07XG5cbi8qKlxuKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbipcbiogQGRlZmF1bHQgc3R5bGVzXG4qIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4qIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiogQHN0YXRpY1xuKi9cblRvb2xiYXJTdHlsZXMua2V5ID0gJ3N0eWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEFycm93Qm94KFxuICAgIFdpZGdldERyb3Bkb3duKFxuICAgIFdpZGdldEV4Y2x1c2l2ZShcbiAgICBXaWRnZXRGb2N1c01hbmFnZXIoXG4gICAgV2lkZ2V0UG9zaXRpb24oXG4gICAgVG9vbGJhckJ1dHRvbnMoXG4gICAgICAgIFRvb2xiYXJTdHlsZXNcbikpKSkpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV91aWJyaWRnZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBleHRlbmRzIENLRURJVE9SLnVpLmFkZCBmdW5jdGlvbiBzbyBhbiBhZGQgaGFuZGxlciBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICogb24gdG9wIG9mIHRoZSBvcmlnaW5hbCBvbmVzLiBJdCBicmlkZ2VzIHRoZSBjYWxscyB0byBhZGQgY29tcG9uZW50cyB2aWE6XG4gICAgICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIHR5cGUsIGRlZmluaXRpb24pXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV91aWJyaWRnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV91aWJyaWRnZScsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBiZWZvcmVJbml0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVJbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFVJQWRkRm4gPSBlZGl0b3IudWkuYWRkO1xuXG4gICAgICAgICAgICBlZGl0b3IudWkuYWRkID0gZnVuY3Rpb24obmFtZSwgdHlwZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVUlBZGRGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVIYW5kbGVyID0gdGhpcy5fLmhhbmRsZXJzW3R5cGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVIYW5kbGVyICYmIHR5cGVIYW5kbGVyLmFkZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlSGFuZGxlci5hZGQobmFtZSwgZGVmaW5pdGlvbiwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgQWxsb3lFZGl0b3IucmVnaXN0ZXJCcmlkZ2VCdXR0b24obmFtZSwgZWRpdG9yLl9fcHJvY2Vzc2luZ1BsdWdpbl9fLnBsdWdpbi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBEZWJvdW5jZSB1dGlsIGZ1bmN0aW9uLiBJZiBhIGZ1bmN0aW9uIGV4ZWN1dGlvbiBpcyBleHBlbnNpdmUsIGl0IG1pZ2h0IGJlIGRlYm91bmNlZC4gVGhpcyBtZWFuc1xuICAgICAqIHRoYXQgaXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lIGFmdGVyIGl0cyBsYXN0IGNhbGwuIEZvciBleGFtcGxlLCBpZiB3ZSBhdHRhY2ggYVxuICAgICAqIGEgZnVuY3Rpb24gb24gc2Nyb2xsIGV2ZW50LCBpdCBtaWdodCBiZSBjYWxsZWQgaHVuZHJlZHMgdGltZXMgcGVyIHNlY29uZC4gSW4gdGhpcyBjYXNlIGl0IG1heSBiZVxuICAgICAqIGRlYm91bmNlZCB3aXRoLCBsZXQncyBzYXkgMTAwbXMuIFRoZSByZWFsIGV4ZWN1dGlvbiBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgaGFwcGVuIDEwMG1zIGFmdGVyIGxhc3RcbiAgICAgKiBzY3JvbGwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAgICAgKiBAbWV0aG9kIGRlYm91bmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgd2hpY2ggdGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgd2hpY2ggaGFzIHRvIGJlIGNhbGxlZCBhZnRlciBnaXZlbiB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENLRURJVE9SLnRvb2xzLmRlYm91bmNlID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UgfHwgZnVuY3Rpb24oY2FsbGJhY2ssIHRpbWVvdXQsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGRlYm91bmNlSGFuZGxlO1xuXG4gICAgICAgIHZhciBjYWxsRm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYWxsQ29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlSGFuZGxlKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdGFydEluZGV4ID0gMDsgc3RhcnRJbmRleCA8IGxlbjsgKytzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJndW1lbnRzW3N0YXJ0SW5kZXhdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNhbGxBcmdzID0gcmVzdWx0LmNvbmNhdChhcmdzIHx8IFtdKTtcblxuICAgICAgICAgICAgZGVib3VuY2VIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNhbGxDb250ZXh0LCBjYWxsQXJncyk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjYWxsRm4uZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VIYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjYWxsRm47XG4gICAgfTtcbn0oKSk7IiwiaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UnO1xuaW1wb3J0IGxpbmsgZnJvbSAnLi9saW5rJztcbmltcG9ydCBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucyc7XG5pbXBvcnQgc2VsZWN0aW9uUmVnaW9uIGZyb20gJy4vc2VsZWN0aW9uLXJlZ2lvbic7XG5pbXBvcnQgdGFibGUgZnJvbSAnLi90YWJsZSc7XG5pbXBvcnQgdG9vbHMgZnJvbSAnLi90b29scyc7XG5pbXBvcnQgdWljb3JlIGZyb20gJy4vdWljb3JlJztcblxuZXhwb3J0IHtcbiAgICBkZWJvdW5jZSxcbiAgICBsaW5rLFxuICAgIHBsdWdpbnMsXG4gICAgc2VsZWN0aW9uUmVnaW9uLFxuICAgIHRhYmxlLFxuICAgIHRvb2xzLFxuICAgIHVpY29yZVxufTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFJFR0VYX0JPT0tNQVJLX1NDSEVNRSA9IC9eIy4qL2k7XG4gICAgdmFyIFJFR0VYX0VNQUlMX1NDSEVNRSA9IC9eW2EtejAtOVxcdTA0MzAtXFx1MDQ0RlxcLl8tXStAL2k7XG4gICAgdmFyIFJFR0VYX1VSSV9TQ0hFTUUgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSopXFw6fF5cXC8vaTtcblxuICAgIC8qKlxuICAgICAqIExpbmsgY2xhc3MgdXRpbGl0eS4gUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRlLCBkZWxldGUgYW5kIHVwZGF0ZSBsaW5rcy5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5MaW5rXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGluayhlZGl0b3IsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuYXBwZW5kUHJvdG9jb2wgPSBjb25maWcgJiYgY29uZmlnLmFwcGVuZFByb3RvY29sID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBMaW5rLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IExpbmssXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkdmFuY2VzIHRoZSBlZGl0b3Igc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGF2YWlsYWJsZSBwb3NpdGlvbiBhZnRlciBhXG4gICAgICAgICAqIGdpdmVuIGxpbmsgb3IgdGhlIG9uZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIGFkdmFuY2VTZWxlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGluayBUaGUgbGluayBlbGVtZW50IHdoaWNoIGxpbmsgc3R5bGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBhZHZhbmNlU2VsZWN0aW9uOiBmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICBsaW5rID0gbGluayB8fCB0aGlzLmdldEZyb21TZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVUb0VsZW1lbnRFZGl0RW5kKGxpbmspO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHROb2RlID0gcmFuZ2UuZ2V0TmV4dEVkaXRhYmxlTm9kZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlICYmICF0aGlzLl9lZGl0b3IuZWxlbWVudC5lcXVhbHMobmV4dE5vZGUuZ2V0Q29tbW9uQW5jZXN0b3IobGluaykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZXNwYWNlID0gL1xccy8uZXhlYyhuZXh0Tm9kZS5nZXRUZXh0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB3aGl0ZXNwYWNlID8gd2hpdGVzcGFjZS5pbmRleCArIDEgOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5leHROb2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobmV4dE5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0UmFuZ2VzKFtyYW5nZV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBsaW5rIHdpdGggZ2l2ZW4gVVJJIGFzIGhyZWYuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgQSBjb25maWcgb2JqZWN0IHdpdGggbGluayBhdHRyaWJ1dGVzLiBUaGVzZSBtaWdodCBiZSBhcmJpdHJhcnkgRE9NIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RpZnlTZWxlY3Rpb24gQSBjb25maWcgb2JqZWN0IHdpdGggYW4gYWR2YW5jZSBhdHRyaWJ1dGUgdG8gaW5kaWNhdGUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgbW92ZWQgYWZ0ZXIgdGhlIGxpbmsgY3JlYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBVUkkgVGhlIFVSSSBvZiB0aGUgbGluay5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oVVJJLCBhdHRycywgbW9kaWZ5U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG5ldyBDS0VESVRPUi5kb20udGV4dChVUkksIHRoaXMuX2VkaXRvci5kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFVSSSA9IHRoaXMuX2dldENvbXBsZXRlVVJJKFVSSSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rQXR0cnMgPSBDS0VESVRPUi50b29scy5tZXJnZSh7XG4gICAgICAgICAgICAgICAgJ2RhdGEtY2tlLXNhdmVkLWhyZWYnOiBVUkksXG4gICAgICAgICAgICAgICAgaHJlZjogVVJJXG4gICAgICAgICAgICB9LCBhdHRycyk7XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogbGlua0F0dHJzLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICdhJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN0eWxlLnR5cGUgPSBDS0VESVRPUi5TVFlMRV9JTkxJTkU7XG4gICAgICAgICAgICBzdHlsZS5hcHBseVRvUmFuZ2UocmFuZ2UsIHRoaXMuX2VkaXRvcik7XG5cbiAgICAgICAgICAgIGlmIChtb2RpZnlTZWxlY3Rpb24gJiYgbW9kaWZ5U2VsZWN0aW9uLmFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIGxpbmsgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuICAgICAgICAgKiBAbWV0aG9kIGdldEZyb21TZWxlY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IFRoZSByZXRyaWV2ZWQgbGluayBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEZyb21TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCAmJiBzZWxlY3RlZEVsZW1lbnQuaXMoJ2EnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKVswXTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2hyaW5rKENLRURJVE9SLlNIUklOS19URVhUKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZGl0b3IuZWxlbWVudFBhdGgocmFuZ2UuZ2V0Q29tbW9uQW5jZXN0b3IoKSkuY29udGFpbnMoJ2EnLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBsaW5rIGZyb20gdGhlIGVkaXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmsgVGhlIGxpbmsgZWxlbWVudCB3aGljaCBsaW5rIHN0eWxlIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kaWZ5U2VsZWN0aW9uIEEgY29uZmlnIG9iamVjdCB3aXRoIGFuIGFkdmFuY2UgYXR0cmlidXRlIHRvIGluZGljYXRlIGlmIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vdmVkIGFmdGVyIHRoZSBsaW5rIGNyZWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihsaW5rLCBtb2RpZnlTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG5cbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaW5rLnJlbW92ZShlZGl0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBhbHdheXNSZW1vdmVFbGVtZW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiAnYScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IENLRURJVE9SLlNUWUxFX0lOTElORVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gJ3JlbW92ZVN0eWxlKCknIHJlbW92ZXMgdGhlIHN0eWxlIGZyb20gdGhlIGVkaXRvcidzIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vICBXZSBuZWVkIHRvIGZvcmNlIHRoZSBzZWxlY3Rpb24gdG8gYmUgdGhlIHdob2xlIGxpbmsgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vICB0byByZW1vdmUgaXQgcHJvcGVybHkuXG5cbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3RFbGVtZW50KHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKSk7XG5cbiAgICAgICAgICAgICAgICBlZGl0b3IucmVtb3ZlU3R5bGUoc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBocmVmIG9mIGFuIGFscmVhZHkgZXhpc3RpbmcgbGluay5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmsgVGhlIGxpbmsgZWxlbWVudCB3aGljaCBocmVmIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGF0dHJzIFRoZSBhdHRyaWJ1dGVzIHRvIHVwZGF0ZSBvciByZW1vdmUuIEF0dHJpYnV0ZXMgd2l0aCBudWxsIHZhbHVlcyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RpZnlTZWxlY3Rpb24gQSBjb25maWcgb2JqZWN0IHdpdGggYW4gYWR2YW5jZSBhdHRyaWJ1dGUgdG8gaW5kaWNhdGUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgbW92ZWQgYWZ0ZXIgdGhlIGxpbmsgY3JlYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBsaW5rLCBtb2RpZnlTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9ICB0aGlzO1xuXG4gICAgICAgICAgICBsaW5rID0gbGluayB8fCB0aGlzLmdldEZyb21TZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJpID0gaW5zdGFuY2UuX2dldENvbXBsZXRlVVJJKGF0dHJzKTtcblxuICAgICAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICdkYXRhLWNrZS1zYXZlZC1ocmVmJzogdXJpLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVBdHRycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNldEF0dHJzID0ge307XG5cbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUF0dHJzLnB1c2goJ2RhdGEtY2tlLXNhdmVkLWhyZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXR0cnMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVyaSA9IGluc3RhbmNlLl9nZXRDb21wbGV0ZVVSSShhdHRyc1trZXldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJzWydkYXRhLWNrZS1zYXZlZC1ocmVmJ10gPSB1cmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cnNba2V5XSA9IHVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cnNba2V5XSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxpbmsucmVtb3ZlQXR0cmlidXRlcyhyZW1vdmVBdHRycyk7XG4gICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGVzKHNldEF0dHJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVNlbGVjdGlvbihsaW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBVUkkgYmVnaW5zIHdpdGggYSAnIycgc3ltYm9sIHRvIGRldGVybWluZSBpZiBpdCdzIGFuIG9uIHBhZ2UgYm9va21hcmsuXG4gICAgICAgICAqIElmIGl0IGRvZXNuJ3QsIGl0IHRoZW4gY2hlY2tzIGlmIHRoZSBVUkkgaGFzIGFuICdAJyBzeW1ib2wuIElmIGl0IGRvZXMgYW5kIHRoZSBVUklcbiAgICAgICAgICogbG9va3MgbGlrZSBhbiBlbWFpbCBhbmQgZG9lc24ndCBoYXZlICdtYWlsdG86JywgJ21haWx0bzonIGlzIGFkZGVkIHRvIHRoZSBVUkkuXG4gICAgICAgICAqIElmIGl0IGRvZXNuJ3QgYW5kIHRoZSBVUkkgZG9lc24ndCBoYXZlIGEgc2NoZW1lLCB0aGUgZGVmYXVsdCAnaHR0cCcgc2NoZW1lIHdpdGhcbiAgICAgICAgICogaGllcmFyY2hpY2FsIHBhdGggJy8vJyBpcyBhZGRlZCB0byB0aGUgVVJJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcbiAgICAgICAgICogQG1ldGhvZCBfZ2V0Q29tcGxldGVVUklcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFVSSSBUaGUgVVJJIG9mIHRoZSBsaW5rLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIFVSSSB1cGRhdGVkIHdpdGggdGhlIHByb3RvY29sLlxuICAgICAgICAgKi9cbiAgICAgICAgX2dldENvbXBsZXRlVVJJOiBmdW5jdGlvbihVUkkpIHtcbiAgICAgICAgICAgIGlmIChSRUdFWF9CT09LTUFSS19TQ0hFTUUudGVzdChVUkkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVSSTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUkVHRVhfRU1BSUxfU0NIRU1FLnRlc3QoVVJJKSkge1xuICAgICAgICAgICAgICAgIFVSSSA9ICdtYWlsdG86JyArIFVSSTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIVJFR0VYX1VSSV9TQ0hFTUUudGVzdChVUkkpKSB7XG4gICAgICAgICAgICAgICAgVVJJID0gdGhpcy5hcHBlbmRQcm90b2NvbCA/ICdodHRwOi8vJyArIFVSSSA6IFVSSTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFVSSTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDS0VESVRPUi5MaW5rID0gQ0tFRElUT1IuTGluayB8fCBMaW5rO1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gV3JhcHMgZWFjaCBvZiB0aGUgcGx1Z2luIGxpZmVjeWNsZSBtZXRob2RzIGluIGEgY2xvc3VyZSB0aGF0IHdpbGxcbiAgICAvLyBzZXQgdXAgdGhlIGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXyB2YXJpYWJsZSBzbyBpdCBjYW4gYmUgZ2xvYmFsbHlcbiAgICAvLyBhY2Nlc3NlZCBleHBvc2luZyB0aGUgcGx1Z2luIGJlaW5nIHByb2Nlc3NlZCBhbmQgdGhlIGxpZmVjeWNsZSBwaGFzZVxuICAgIC8vIGluIHdoaWNoIGl0IGlzIGhhcHBlbmluZ1xuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtPYmplY3R9IHBsdWdpbiBUaGUgcGx1Z2luIHRvIHdyYXAgbGlmZWN5Y2xlIG1ldGhvZHNcbiAgICB2YXIgd3JhcFBsdWdpbkxpZmVjeWNsZSA9IGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICB2YXIgbWV0aG9kcyA9IFsnYmVmb3JlSW5pdCcsICdpbml0JywgJ2FmdGVySW5pdCddO1xuXG4gICAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luW21ldGhvZE5hbWVdID0gQ0tFRElUT1IudG9vbHMub3ZlcnJpZGUocGx1Z2luW21ldGhvZE5hbWVdLCBmdW5jdGlvbihvcmlnaW5hbFBsdWdpbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlOiBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luOiBwbHVnaW5cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18gPSBwYXlsb2FkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFBsdWdpbk1ldGhvZC5jYWxsKHRoaXMsIGVkaXRvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBGaWx0ZXJzIHRoZSByZXF1aXJlcyBvYmplY3QgdG8gcmVtb3ZlIHVud2FudGVkIGRlcGVuZGVuY2llcy4gQXQgdGhpcyBwb2ludFxuICAgIC8vIG9ubHkgJ3Rvb2xiYXInIGhhcyBiZWVuIGlkZW50aWZpZWQsIGJ1dCBtb3JlIGNhbiBhcHBlYXIuIEFuIHVud2FudGVkIHBsdWdpblxuICAgIC8vIGRlcGVuZGVuY3kgaXMgb25lIHRoYXQgcHJldmVudHMgYSBuZWNlc3NhcnkgcGx1Z2luIGZyb20gYmVpbmcgcmVtb3ZlZFxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gcmVxdWlyZXMgVGhlIHJlcXVpcmVzIG9iamVjdFxuICAgIC8vIEByZXR1cm4ge3N0cmluZ30gVGhlIGZpbHRlcmVkIHJlcXVpcmVzIG9iamVjdFxuICAgIHZhciBmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHJlcXVpcmVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXF1aXJlcyA9IHJlcXVpcmVzLnNwbGl0KCcsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVxdWlyZXMuZmlsdGVyKGZ1bmN0aW9uKHJlcXVpcmUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlICE9PSAndG9vbGJhcic7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDS0VESVRPUi5wbHVnaW5zIGNsYXNzIHV0aWxpdHkgd2hpY2ggYWRkcyBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gdGhvc2Ugb2YgQ0tFZGl0b3IuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2luc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIENLRURJVE9SLnBsdWdpbnMubG9hZCBtZXRob2Qgc28gd2UgY2FuIGV4dGVuZCB0aGUgbGlmZWN5Y2xlIG1ldGhvZHMgb2ZcbiAgICAgKiB0aGUgbG9hZGVkIHBsdWdpbnMgdG8gYWRkIHNvbWUgbWV0YWluZm9ybWF0aW9uIGFib3V0IHRoZSBwbHVnaW4gYmVpbmcgcHJvY2Vzc2VkXG4gICAgICpcblx0ICogQHBhcmFtIHtTdHJpbmcvQXJyYXl9IG5hbWVzIFRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkLiBJdCBtYXkgYmUgYVxuXHQgKiBzdHJpbmcgd2l0aCBhIHNpbmdsZSByZXNvdXJjZSBuYW1lLCBvciBhbiBhcnJheSB3aXRoIHNldmVyYWwgbmFtZXMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYWxsIHJlc291cmNlc1xuXHQgKiBhcmUgbG9hZGVkLiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGxvYWRlZCBuYW1lcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVGhlIHNjb3BlIG9iamVjdCB0byBiZSB1c2VkIGZvciB0aGUgY2FsbGJhY2sgY2FsbC5cbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2luc1xuICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmxvYWQgPSBDS0VESVRPUi50b29scy5vdmVycmlkZShDS0VESVRPUi5wbHVnaW5zLmxvYWQsIGZ1bmN0aW9uKHBsdWdpbnNMb2FkKXtcbiAgICAgICAgLy8gV3JhcCBvcmlnaW5hbCBsb2FkIGZ1bmN0aW9uIHNvIHdlIGNhbiB0cmFuc2Zvcm0gdGhlIHBsdWdpbiBpbnB1dCBwYXJhbWV0ZXJcbiAgICAgICAgLy8gYmVmb3JlIHBhc3NpbmcgaXQgZG93biB0byB0aGUgb3JpZ2luYWwgY2FsbGJhY2tcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWVzLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgICAgIHBsdWdpbnNMb2FkLmNhbGwodGhpcywgbmFtZXMsIGZ1bmN0aW9uKHBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5OYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5yZXF1aXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5yZXF1aXJlcyA9IGZpbHRlclVud2FudGVkRGVwZW5kZW5jaWVzKHBsdWdpbi5yZXF1aXJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBQbHVnaW5MaWZlY3ljbGUocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSwgcGx1Z2lucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3NlbGVjdGlvbnJlZ2lvbicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSA9IDA7XG4gICAgQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1AgPSAxO1xuICAgIENLRURJVE9SLlNFTEVDVElPTl9MRUZUX1RPX1JJR0hUID0gMjtcbiAgICBDS0VESVRPUi5TRUxFQ1RJT05fUklHSFRfVE9fTEVGVCA9IDM7XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Rpb25SZWdpb24gdXRpbGl0eSBjbGFzcyB3aGljaCBwcm92aWRlcyBtZXRhZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uLiBUaGUgbWV0YWRhdGEgbWF5IGJlIHRoZSBzdGFydCBhbmQgZW5kXG4gICAgICogcmVjdGFuZ2xlcywgY2FyZXQgcmVnaW9uLCBldGMuICoqVGhpcyBjbGFzcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBzdGFuZGFsb25lLiBJdHMgZnVuY3Rpb25zIHdpbGxcbiAgICAgKiBiZSBtZXJnZWQgaW50byBlYWNoIGVkaXRvciBpbnN0YW5jZSwgc28gdGhlIGRldmVsb3BlciBtYXkgdXNlIHRoZW0gZGlyZWN0bHkgdmlhIHRoZSBlZGl0b3IsIHdpdGhvdXQgbWFraW5nXG4gICAgICogYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyoqLlxuICAgICAqXG4gICAgICogQGNsYXNzIFNlbGVjdGlvblJlZ2lvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvblJlZ2lvbigpIHt9XG5cbiAgICBTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uUmVnaW9uLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHR3byBwb2ludHMgaW4gcGFnZSBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb2ludCBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2VsZWN0aW9uRnJvbVJhbmdlKHgsIHksIHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHJhbmdlLiBBIHJhbmdlIGNvbnNpc3RzIGZyb20gdHdvIHBvaW50cyBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVNlbGVjdGlvbkZyb21SYW5nZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRYIFggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFkgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFggWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRZIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU2VsZWN0aW9uRnJvbVJhbmdlOiBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSkge1xuICAgICAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgICAgIHZhciBlbmRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHJhbmdlO1xuICAgICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoZW5kWCwgZW5kWSk7XG5cbiAgICAgICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHN0YXJ0Lm9mZnNldE5vZGU7XG4gICAgICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kLm9mZnNldE5vZGU7XG5cbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IHN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBlbmQub2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHN0YXJ0WCwgc3RhcnRZKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KGVuZFgsIGVuZFkpO1xuXG4gICAgICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydC5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBlbmRDb250YWluZXIgPSBlbmQuc3RhcnRDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IHN0YXJ0LnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCA9IGVuZC5zdGFydE9mZnNldDtcblxuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobmV3IENLRURJVE9SLmRvbS5ub2RlKHN0YXJ0Q29udGFpbmVyKSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChuZXcgQ0tFRElUT1IuZG9tLm5vZGUoZW5kQ29udGFpbmVyKSwgZW5kT2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0UmFuZ2VzKFtyYW5nZV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi51bmxvY2soKTtcblxuICAgICAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlVG9Qb2ludChzdGFydFgsIHN0YXJ0WSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kUmFuZ2UgPSByYW5nZS5kdXBsaWNhdGUoKTtcbiAgICAgICAgICAgICAgICBlbmRSYW5nZS5tb3ZlVG9Qb2ludChlbmRYLCBlbmRZKTtcblxuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb0VuZCcsIGVuZFJhbmdlKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZWdpb24gb2YgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGNhcmV0LiBUaGUgcG9pbnRzIGFyZSBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGdldENhcmV0UmVnaW9uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIC0gYm90dG9tXG4gICAgICAgICAqIC0gbGVmdFxuICAgICAgICAgKiAtIHJpZ2h0XG4gICAgICAgICAqIC0gdG9wXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDYXJldFJlZ2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHtcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBib29rbWFya3MgPSBzZWxlY3Rpb24uY3JlYXRlQm9va21hcmtzKCk7XG5cbiAgICAgICAgICAgIGlmICghYm9va21hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBib29rbWFya05vZGVFbCA9IGJvb2ttYXJrc1swXS5zdGFydE5vZGUuJDtcblxuICAgICAgICAgICAgYm9va21hcmtOb2RlRWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuXG4gICAgICAgICAgICByZWdpb24gPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoYm9va21hcmtOb2RlRWwpLmdldENsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgYm9va21hcmtOb2RlRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib29rbWFya05vZGVFbCk7XG5cbiAgICAgICAgICAgIHZhciBzY3JvbGxQb3MgPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIHJlZ2lvbi5ib3R0b20gPSBzY3JvbGxQb3MueSArIHJlZ2lvbi5ib3R0b207XG4gICAgICAgICAgICByZWdpb24ubGVmdCA9IHNjcm9sbFBvcy54ICsgcmVnaW9uLmxlZnQ7XG4gICAgICAgICAgICByZWdpb24ucmlnaHQgPSBzY3JvbGxQb3MueCArIHJlZ2lvbi5yaWdodDtcbiAgICAgICAgICAgIHJlZ2lvbi50b3AgPSBzY3JvbGxQb3MueSArIHJlZ2lvbi50b3A7XG5cbiAgICAgICAgICAgIHJldHVybiByZWdpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgZGF0YSBmb3IgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNlbGVjdGlvbkRhdGFcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBkYXRhOlxuICAgICAgICAgKiAtIGVsZW1lbnQgLSBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGVsZW1lbnQsIGlmIGFueVxuICAgICAgICAgKiAtIHRleHQgLSBUaGUgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgKiAtIHJlZ2lvbiAtIFRoZSBkYXRhLCByZXR1cm5lZCBmcm9tIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvblJlZ2lvbjptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlbGVjdGlvbkRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmdldE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIHRleHQ6IHNlbGVjdGlvbi5nZXRTZWxlY3RlZFRleHQoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVzdWx0LnJlZ2lvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uUmVnaW9uKHNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlZ2lvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBvYmplY3Qgd2hpY2ggaXMgYmVpbmcgcmV0dXJuZWQgZnJvbVxuICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRDbGllbnRSZWN0c1JlZ2lvbjptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0gd2l0aCB0aHJlZSBtb3JlIHByb3BlcnRpZXM6XG4gICAgICAgICAqIC0gZGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLiBDYW4gYmUgb25lIG9mIHRoZXNlOlxuICAgICAgICAgKiAgIDEuIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG4gICAgICAgICAqICAgMi4gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1BcbiAgICAgICAgICogLSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBzZWxlY3Rpb24gcmVnaW9uXG4gICAgICAgICAqIC0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiByZWdpb25cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlbGVjdGlvblJlZ2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5nZXRDbGllbnRSZWN0c1JlZ2lvbigpO1xuXG4gICAgICAgICAgICByZWdpb24uZGlyZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25EaXJlY3Rpb24oKTtcblxuICAgICAgICAgICAgcmVnaW9uLmhlaWdodCA9IHJlZ2lvbi5ib3R0b20gLSByZWdpb24udG9wO1xuICAgICAgICAgICAgcmVnaW9uLndpZHRoID0gcmVnaW9uLnJpZ2h0IC0gcmVnaW9uLmxlZnQ7XG5cbiAgICAgICAgICAgIHJldHVybiByZWdpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBpc1NlbGVjdGlvbkVtcHR5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0aW9uRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcztcblxuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHJldHVybiAoc2VsZWN0aW9uLmdldFR5cGUoKSA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX05PTkUpIHx8XG4gICAgICAgICAgICAgICAgKChyYW5nZXMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKCkpICYmIHJhbmdlcy5sZW5ndGggPT09IDEgJiYgcmFuZ2VzWzBdLmNvbGxhcHNlZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgb2JqZWN0IHdpdGggZGF0YSBhYm91dCB0aGUgW2NsaWVudCByZWN0YW5nbGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC5nZXRDbGllbnRSZWN0cykgb2YgdGhlIHNlbGVjdGlvbixcbiAgICAgICAgICogbm9ybWFsaXplZCBhY3Jvc3MgYnJvd3Nlcy4gQWxsIG9mZnNldHMgYmVsb3cgYXJlIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Q2xpZW50UmVjdHNSZWdpb25cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZGF0YTpcbiAgICAgICAgICogLSBib3R0b20gLSBib3R0b20gb2Zmc2V0IG9mIGFsbCBjbGllbnQgcmVjdGFuZ2xlc1xuICAgICAgICAgKiAtIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcbiAgICAgICAgICogLSByaWdodCAtIHJpZ2h0IG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcbiAgICAgICAgICogLSB0b3AgLSB0b3Agb2Zmc2V0IG9mIGFsbCBjbGllbnQgcmVjdGFuZ2xlc1xuICAgICAgICAgKiAtIHN0YXJ0UmVjdCAtIEFuIE9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbjpcbiAgICAgICAgICogICAgICsgYm90dG9tIC0gYm90dG9tIG9mZnNldFxuICAgICAgICAgKiAgICAgKyBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICogICAgICsgbGVmdCAtIGxlZnQgb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogICAgICsgcmlnaHQgLSByaWdodCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuICAgICAgICAgKiAgICAgKyB0b3AgLSB0b3Agb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogICAgICsgd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgICAgKiAtIGVuZFJlY3QgLSBBbiBPYmplY3QsIHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG4gICAgICAgICAqICAgICArIGJvdHRvbSAtIGJvdHRvbSBvZmZzZXRcbiAgICAgICAgICogICAgICsgaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAqICAgICArIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqICAgICArIHJpZ2h0IC0gcmlnaHQgb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICogICAgICsgdG9wIC0gdG9wIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAqICAgICArIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlcmUgaXMgbm8gbmF0aXZlIHNlbGVjdGlvbiwgdGhlIG9iamVjdHMgd2lsbCBiZSBmaWxsZWQgd2l0aCAwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2xpZW50UmVjdHNSZWdpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgbmF0aXZlU2VsZWN0aW9uID0gc2VsZWN0aW9uLmdldE5hdGl2ZSgpO1xuXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFJlY3QgPSB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHtcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgZW5kUmVjdDogZGVmYXVsdFJlY3QsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRSZWN0OiBkZWZhdWx0UmVjdFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFuYXRpdmVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYm90dG9tID0gMDtcbiAgICAgICAgICAgIHZhciBjbGllbnRSZWN0cztcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgcmFuZ2VDb3VudDtcbiAgICAgICAgICAgIHZhciByaWdodCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIHZhciB0b3AgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgaWYgKG5hdGl2ZVNlbGVjdGlvbi5jcmVhdGVSYW5nZSkge1xuICAgICAgICAgICAgICAgIGNsaWVudFJlY3RzID0gbmF0aXZlU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VDb3VudCA9IG5hdGl2ZVNlbGVjdGlvbi5yYW5nZUNvdW50O1xuICAgICAgICAgICAgICAgIGNsaWVudFJlY3RzID0gKG5hdGl2ZVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkgPyBuYXRpdmVTZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpIDogW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLmdldENhcmV0UmVnaW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBjbGllbnRSZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNsaWVudFJlY3RzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmxlZnQgPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaXRlbS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmlnaHQgPiByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBpdGVtLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9wIDwgdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBpdGVtLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmJvdHRvbSA+IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gaXRlbS5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUG9zID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3cod2luZG93KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgcmVnaW9uLmJvdHRvbSA9IHNjcm9sbFBvcy55ICsgYm90dG9tO1xuICAgICAgICAgICAgICAgIHJlZ2lvbi5sZWZ0ID0gc2Nyb2xsUG9zLnggKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHJlZ2lvbi5yaWdodCA9IHNjcm9sbFBvcy54ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnRvcCA9IHNjcm9sbFBvcy55ICsgdG9wO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRSZWN0ID0gY2xpZW50UmVjdHNbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uLmVuZFJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHNjcm9sbFBvcy55ICsgZW5kUmVjdC5ib3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGVuZFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2Nyb2xsUG9zLnggKyBlbmRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2Nyb2xsUG9zLnggKyBlbmRSZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBzY3JvbGxQb3MueSArIGVuZFJlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGVuZFJlY3Qud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZWdpb24uc3RhcnRSZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzY3JvbGxQb3MueSArIHN0YXJ0UmVjdC5ib3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHN0YXJ0UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzY3JvbGxQb3MueCArIHN0YXJ0UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNjcm9sbFBvcy54ICsgc3RhcnRSZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBzY3JvbGxQb3MueSArIHN0YXJ0UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc3RhcnRSZWN0LndpZHRoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLiBUaGUgZGlyZWN0aW9uIGlzIGZyb20gdG9wIHRvIGJvdHRvbSBvciBmcm9tIGJvdHRvbSB0byB0b3AuXG4gICAgICAgICAqIEZvciBJRSA8IDkgaXQgaXMgbm90IHBvc3NpYmxlLCBzbyB0aGUgZGlyZWN0aW9uIGZvciB0aGVzZSBicm93c2VycyB3aWxsIGJlIGFsd2F5cyBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRTZWxlY3Rpb25EaXJlY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIGEgbnVtYmVyIHdoaWNoIHJlcHJlc2VudHMgc2VsZWN0aW9uIGRpcmVjdGlvbi4gSXQgbWlnaHQgYmUgb25lIG9mIHRoZXNlOlxuICAgICAgICAgKiAtIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NO1xuICAgICAgICAgKiAtIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VsZWN0aW9uRGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVNlbGVjdGlvbiA9IHNlbGVjdGlvbi5nZXROYXRpdmUoKTtcblxuICAgICAgICAgICAgaWYgKCFuYXRpdmVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5jaG9yTm9kZTtcblxuICAgICAgICAgICAgaWYgKChhbmNob3JOb2RlID0gbmF0aXZlU2VsZWN0aW9uLmFuY2hvck5vZGUpICYmIGFuY2hvck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBhbmNob3JOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5hdGl2ZVNlbGVjdGlvbi5mb2N1c05vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwb3NpdGlvbiAmJiBuYXRpdmVTZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID4gbmF0aXZlU2VsZWN0aW9uLmZvY3VzT2Zmc2V0IHx8IHBvc2l0aW9uID09PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV9zZWxlY3Rpb25yZWdpb24nLCB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cixcbiAgICAgICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGF0dHIgaW4gU2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlLCBhdHRyKSAmJiB0eXBlb2YgZWRpdG9yW2F0dHJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yW2F0dHJdID0gU2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZVthdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgSUVfTk9OX0RJUkVDVExZX0VESVRBQkxFX0VMRU1FTlQgPSB7XG4gICAgICAgICd0YWJsZSc6IDEsXG4gICAgICAgICdjb2wnOiAxLFxuICAgICAgICAnY29sZ3JvdXAnOiAxLFxuICAgICAgICAndGJvZHknOiAxLFxuICAgICAgICAndGQnOiAxLFxuICAgICAgICAndGZvb3QnOiAxLFxuICAgICAgICAndGgnOiAxLFxuICAgICAgICAndGhlYWQnOiAxLFxuICAgICAgICAndHInOiAxXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRhYmxlIGNsYXNzIHV0aWxpdHkuIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0ZSwgZGVsZXRlIGFuZCB1cGRhdGUgdGFibGVzLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLlRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUYWJsZShlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yO1xuICAgIH1cblxuICAgIFRhYmxlLkhFQURJTkdfQk9USCA9ICdCb3RoJztcbiAgICBUYWJsZS5IRUFESU5HX0NPTCA9ICdDb2x1bW4nO1xuICAgIFRhYmxlLkhFQURJTkdfTk9ORSA9ICdOb25lJztcbiAgICBUYWJsZS5IRUFESU5HX1JPVyA9ICdSb3cnO1xuXG4gICAgVGFibGUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogVGFibGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB0YWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRhYmxlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNyZWF0ZWQgdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5fY3JlYXRlRWxlbWVudCgndGFibGUnKTtcblxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8wqB7fTtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHJvd3MgYW5kIGNvbHMuXG4gICAgICAgICAgICB2YXIgdGJvZHkgPSB0YWJsZS5hcHBlbmQodGhpcy5fY3JlYXRlRWxlbWVudCgndGJvZHknKSk7XG4gICAgICAgICAgICB2YXIgcm93cyA9IGNvbmZpZy5yb3dzIHx8IDE7XG4gICAgICAgICAgICB2YXIgY29scyA9IGNvbmZpZy5jb2xzIHx8IDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHRib2R5LmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0cicpKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5hcHBlbmQodGhpcy5fY3JlYXRlRWxlbWVudCgndGQnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRCb2d1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHRhYmxlLCBjb25maWcuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkaW5nKHRhYmxlLCBjb25maWcuaGVhZGluZyk7XG5cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgdGFibGUgZWxlbWVudCBpZiB3ZSdyZSBjcmVhdGluZyBvbmUuXG4gICAgICAgICAgICBlZGl0b3IuaW5zZXJ0RWxlbWVudCh0YWJsZSk7XG5cbiAgICAgICAgICAgIHZhciBmaXJzdENlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC5yb3dzWzBdLmNlbGxzWzBdKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZVRvUG9zaXRpb24oZmlyc3RDZWxsLCBDS0VESVRPUi5QT1NJVElPTl9BRlRFUl9TVEFSVCk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYSB0YWJsZSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAbWV0aG9kIGdldEZyb21TZWxlY3Rpb25cbiAgICAgICAgICogQHJldHVybiB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IFRoZSByZXRyaWV2ZWQgdGFibGUgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRGcm9tU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5pcygndGFibGUnKSkge1xuICAgICAgICAgICAgICAgIHRhYmxlID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZXMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Via2l0IGNvdWxkIHJlcG9ydCB0aGUgZm9sbG93aW5nIHJhbmdlIG9uIGNlbGwgc2VsZWN0aW9uICgjNDk0OCk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDx0YWJsZT48dHI+PHRkPlsmbmJzcDs8L3RkPjwvdHI+PC90YWJsZT5dXG5cbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKENLRURJVE9SLmVudi53ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlc1swXS5zaHJpbmsoQ0tFRElUT1IuTk9ERV9FTEVNRU5UKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdGhpcy5fZWRpdG9yLmVsZW1lbnRQYXRoKHJhbmdlc1swXS5nZXRDb21tb25BbmNlc3Rvcih0cnVlKSkuY29udGFpbnMoJ3RhYmxlJywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHRhYmxlIGNhbiBiZSBjb25zaWRlcmVkIGFzIGVkaXRhYmxlLiBUaGlzIG1ldGhvZFxuICAgICAgICAgKiB3b3JrYXJvdW5kcyBhIGxpbWl0YXRpb24gb2YgSUUgd2hlcmUgZm9yIHNvbWUgZWxlbWVudHMgKGxpa2UgdGFibGUpLFxuICAgICAgICAgKiBgaXNDb250ZW50RWRpdGFibGVgIHJldHVybnMgYWx3YXlzIGZhbHNlLiBUaGlzIGlzIGJlY2F1c2UgSUUgZG9lcyBub3Qgc3VwcG9ydFxuICAgICAgICAgKiBgY29udGVudGVkaXRhYmxlYCBvbiBzdWNoIGVsZW1lbnRzLiBIb3dldmVyLCBkZXNwaXRlIHN1Y2ggZWxlbWVudHNcbiAgICAgICAgICogY2Fubm90IGJlIHNldCBhcyBjb250ZW50IGVkaXRhYmxlIGRpcmVjdGx5LCBhIGNvbnRlbnQgZWRpdGFibGUgU1BBTixcbiAgICAgICAgICogb3IgRElWIGVsZW1lbnQgY2FuIGJlIHBsYWNlZCBpbnNpZGUgdGhlIGluZGl2aWR1YWwgdGFibGUgY2VsbHMuXG4gICAgICAgICAqIFNlZSBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3ODM3JTI4dj1WUy44NSUyOS5hc3B4XG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQG1ldGhvZCBpc0VkaXRhYmxlXG4gICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSB0YWJsZSBlbGVtZW50IHRvIHRlc3QgaWYgZWRpdGFibGVcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzRWRpdGFibGU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCFDS0VESVRPUi5lbnYuaWUgfHwgIWVsLmlzKElFX05PTl9ESVJFQ1RMWV9FRElUQUJMRV9FTEVNRU5UKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZWwuaXNSZWFkT25seSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAhPT0gJ2ZhbHNlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRWRpdGFibGUoZWwuZ2V0UGFyZW50KCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHdoaWNoIGhlYWRpbmcgc3R5bGUgaXMgc2V0IGZvciB0aGUgZ2l2ZW4gdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQG1ldGhvZCBnZXRIZWFkaW5nXG4gICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IHRhYmxlIFRoZSB0YWJsZSB0byBnYXRoZXIgdGhlIGhlYWRpbmcgZnJvbS4gSWYgbnVsbCwgaXQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGhlYWRpbmcgb2YgdGhlIHRhYmxlLiBFeHBlY3RlZCB2YWx1ZXMgYXJlIGBDS0VESVRPUi5UYWJsZS5OT05FYCwgYENLRURJVE9SLlRhYmxlLlJPV2AsIGBDS0VESVRPUi5UYWJsZS5DT0xgIGFuZCBgQ0tFRElUT1IuVGFibGUuQk9USGAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWFkaW5nOiBmdW5jdGlvbih0YWJsZSkge1xuICAgICAgICAgICAgdGFibGUgPSB0YWJsZSB8fCB0aGlzLmdldEZyb21TZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgaWYgKCF0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcm93SGVhZGluZ1NldHRpbmdzID0gdGFibGUuJC50SGVhZCAhPT0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGNvbEhlYWRpbmdTZXR0aW5ncyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFsbCBvZiB0aGUgZmlyc3QgY2VsbHMgaW4gZXZlcnkgcm93IGFyZSBUSFxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGFibGUuJC5yb3dzLmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBqdXN0IG9uZSBjZWxsIGlzbid0IGEgVEggdGhlbiBpdCBpc24ndCBhIGhlYWRlciBjb2x1bW5cbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRhYmxlLiQucm93c1tyb3ddLmNlbGxzWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNlbGwgJiYgY2VsbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbEhlYWRpbmdTZXR0aW5ncyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoZWFkaW5nU2V0dGluZ3MgPSBUYWJsZS5IRUFESU5HX05PTkU7XG5cbiAgICAgICAgICAgIGlmIChyb3dIZWFkaW5nU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBoZWFkaW5nU2V0dGluZ3MgPSBUYWJsZS5IRUFESU5HX1JPVztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbEhlYWRpbmdTZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGhlYWRpbmdTZXR0aW5ncyA9IChoZWFkaW5nU2V0dGluZ3MgPT09IFRhYmxlLkhFQURJTkdfUk9XID8gVGFibGUuSEVBRElOR19CT1RIIDogVGFibGUuSEVBRElOR19DT0wpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGVhZGluZ1NldHRpbmdzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgdGFibGUgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IHRhYmxlIFRoZSB0YWJsZSBlbGVtZW50IHdoaWNoIHRhYmxlIHN0eWxlIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbih0YWJsZSkge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcblxuICAgICAgICAgICAgaWYgKHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGFibGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhYmxlID0gZWRpdG9yLmVsZW1lbnRQYXRoKCkuY29udGFpbnMoJ3RhYmxlJywgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRhYmxlJ3MgcGFyZW50IGhhcyBvbmx5IG9uZSBjaGlsZCByZW1vdmUgaXQgYXMgd2VsbCAodW5sZXNzIGl0J3MgYSB0YWJsZSBjZWxsLCBvciB0aGUgZWRpdGFibGUgZWxlbWVudCkgKCM1NDE2LCAjNjI4OSwgIzEyMTEwKVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGFibGUuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAxICYmICFwYXJlbnQuaXMoJ3RkJywgJ3RoJykgJiYgIXBhcmVudC5lcXVhbHMoZWRpdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5tb3ZlVG9Qb3NpdGlvbih0YWJsZSwgQ0tFRElUT1IuUE9TSVRJT05fQkVGT1JFX1NUQVJUKTtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWducyBwcm92aWRlZCBhdHRyaWJ1dGVzIHRvIGEgdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRBdHRyaWJ1dGVzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YWJsZSBUaGUgdGFibGUgdG8gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGFzc2lnbmVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBUaGUgYXR0cmlidXRlcyB3aGljaCBoYXZlIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSB0YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QXR0cmlidXRlczogZnVuY3Rpb24odGFibGUsIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFwcHJvcHJpYXRlIHRhYmxlIGhlYWRpbmcgc3R5bGUgdG8gYSB0YWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAbWV0aG9kIHNldEhlYWRpbmdcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGhlYWRpbmcgc2hvdWxkIGJlIHNldC4gSWYgbnVsbCwgaXQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkaW5nIFRoZSB0YWJsZSBoZWFkaW5nIHRvIGJlIHNldC4gQWNjZXB0ZWQgdmFsdWVzIGFyZTogYENLRURJVE9SLlRhYmxlLk5PTkVgLCBgQ0tFRElUT1IuVGFibGUuUk9XYCwgYENLRURJVE9SLlRhYmxlLkNPTGAgYW5kIGBDS0VESVRPUi5UYWJsZS5CT1RIYC5cbiAgICAgICAgICovXG4gICAgICAgIHNldEhlYWRpbmc6IGZ1bmN0aW9uKHRhYmxlLCBoZWFkaW5nKSB7XG4gICAgICAgICAgICB0YWJsZSA9IHRhYmxlIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgaSwgbmV3Q2VsbDtcbiAgICAgICAgICAgIHZhciB0YWJsZUhlYWQ7XG4gICAgICAgICAgICB2YXIgdGFibGVCb2R5ID0gdGFibGUuZ2V0RWxlbWVudHNCeVRhZygndGJvZHknKS5nZXRJdGVtKDApO1xuXG4gICAgICAgICAgICB2YXIgdGFibGVIZWFkaW5nID0gdGhpcy5nZXRIZWFkaW5nKHRhYmxlKTtcbiAgICAgICAgICAgIHZhciBoYWRDb2xIZWFkaW5nID0gKHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19DT0wgfHwgdGFibGVIZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0JPVEgpO1xuXG4gICAgICAgICAgICB2YXIgbmVlZENvbEhlYWRpbmcgPSBoZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0NPTCB8fCBoZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0JPVEg7XG4gICAgICAgICAgICB2YXIgbmVlZFJvd0hlYWRpbmcgPSBoZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX1JPVyB8fCBoZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0JPVEg7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIG5lZWQgcm93IGhlYWRpbmcgYW5kIGRvbid0IGhhdmUgYSA8dGhlYWQ+IGVsZW1lbnQgeWV0LCBtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gZmlyc3Qgcm93IG9mIHRoZSB0YWJsZSB0byB0aGUgaGVhZCBhbmQgY29udmVydCB0aGUgbm9kZXMgdG8gPHRoPiBvbmVzLlxuICAgICAgICAgICAgaWYgKCF0YWJsZS4kLnRIZWFkICYmIG5lZWRSb3dIZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlRmlyc3RSb3cgPSB0YWJsZUJvZHkuZ2V0RWxlbWVudHNCeVRhZygndHInKS5nZXRJdGVtKDApO1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZUZpcnN0Um93Q2hpbGRDb3VudCA9IHRhYmxlRmlyc3RSb3cuZ2V0Q2hpbGRDb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIFREIHRvIFRIOlxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWJsZUZpcnN0Um93Q2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGFibGVGaXJzdFJvdy5nZXRDaGlsZChpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGJvb2ttYXJrIG5vZGVzLiAoIzYxNTUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnR5cGUgPT09IENLRURJVE9SLk5PREVfRUxFTUVOVCAmJiAhY2VsbC5kYXRhKCdja2UtYm9va21hcmsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5yZW5hbWVOb2RlKCd0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgJ2NvbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFibGVIZWFkID0gdGhpcy5fY3JlYXRlRWxlbWVudCh0YWJsZS4kLmNyZWF0ZVRIZWFkKCkpO1xuICAgICAgICAgICAgICAgIHRhYmxlSGVhZC5hcHBlbmQodGFibGVGaXJzdFJvdy5yZW1vdmUoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgcm93IGhlYWRpbmcgYW5kIHdlIGhhdmUgYSA8dGhlYWQ+IGVsZW1lbnQsIG1vdmUgdGhlXG4gICAgICAgICAgICAvLyByb3cgb3V0IG9mIHRoZXJlIGFuZCBpbnRvIHRoZSA8dGJvZHk+IGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAodGFibGUuJC50SGVhZCAhPT0gbnVsbCAmJiAhbmVlZFJvd0hlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSByb3cgb3V0IG9mIHRoZSBUSGVhZCBhbmQgcHV0IGl0IGluIHRoZSBUQm9keTpcbiAgICAgICAgICAgICAgICB0YWJsZUhlYWQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KHRhYmxlLiQudEhlYWQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRmlyc3RSb3cgPSB0YWJsZUJvZHkuZ2V0Rmlyc3QoKTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICh0YWJsZUhlYWQuZ2V0Q2hpbGRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Rmlyc3RSb3cgPSB0YWJsZUhlYWQuZ2V0Rmlyc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0Um93Q2hpbGRDb3VudCA9IG5ld0ZpcnN0Um93LmdldENoaWxkQ291bnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Rmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwgPSBuZXdGaXJzdFJvdy5nZXRDaGlsZChpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NlbGwudHlwZSA9PT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5yZW5hbWVOb2RlKCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCdzY29wZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3Rmlyc3RSb3cuaW5zZXJ0QmVmb3JlKHByZXZpb3VzRmlyc3RSb3cpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhYmxlSGVhZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFibGVIZWFkaW5nID0gdGhpcy5nZXRIZWFkaW5nKHRhYmxlKTtcbiAgICAgICAgICAgIHZhciBoYXNDb2xIZWFkaW5nID0gKHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19DT0wgfHwgdGFibGVIZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0JPVEgpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBuZWVkIGNvbHVtbiBoZWFkaW5nIGFuZCB0aGUgdGFibGUgZG9lc24ndCBoYXZlIGl0LCBjb252ZXJ0IGV2ZXJ5IGZpcnN0IGNlbGwgaW5cbiAgICAgICAgICAgIC8vIGV2ZXJ5IHJvdyBpbnRvIGEgYDx0aCBzY29wZT1cInJvd1wiPmAgZWxlbWVudC5cbiAgICAgICAgICAgIGlmICghaGFzQ29sSGVhZGluZyAmJiBuZWVkQ29sSGVhZGluZykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlLiQucm93c1tpXS5jZWxsc1swXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1tpXS5jZWxsc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLnJlbmFtZU5vZGUoJ3RoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLnNldEF0dHJpYnV0ZSgnc2NvcGUnLCAncm93Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgY29sdW1uIGhlYWRpbmcgYnV0IHRoZSB0YWJsZSBoYXMgaXQsIGNvbnZlcnQgZXZlcnkgZmlyc3QgY2VsbCBpbiBldmVyeVxuICAgICAgICAgICAgLy8gcm93IGJhY2sgaW50byBhIGA8dGQ+YCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKGhhZENvbEhlYWRpbmcgJiYgIW5lZWRDb2xIZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhYmxlLiQucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1tpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5nZXRQYXJlbnQoKS5nZXROYW1lKCkgPT09ICd0Ym9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQocm93LiQuY2VsbHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5yZW5hbWVOb2RlKCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoJ3Njb3BlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQgdXNpbmcgdGhlIHBhc3NlZCB0YWcgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZXRob2QgX2NyZWF0ZUVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIHRhZyBuYW1lIGZyb20gd2hpY2ggYW4gZWxlbWVudCBzaG91bGQgYmUgY3JlYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gSW5zdGFuY2Ugb2YgQ0tFRElUT1IgRE9NIGVsZW1lbnQgY2xhc3NcbiAgICAgICAgICovXG4gICAgICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG5hbWUsIHRoaXMuX2VkaXRvci5kb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ0tFRElUT1Iub24oJ2luc3RhbmNlUmVhZHknLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgaGVhZGluZ0NvbW1hbmRzID0gW1RhYmxlLkhFQURJTkdfTk9ORSwgVGFibGUuSEVBRElOR19ST1csIFRhYmxlLkhFQURJTkdfQ09MLCBUYWJsZS5IRUFESU5HX0JPVEhdO1xuXG4gICAgICAgIHZhciB0YWJsZVV0aWxzID0gbmV3IFRhYmxlKGV2ZW50LmVkaXRvcik7XG5cbiAgICAgICAgaGVhZGluZ0NvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24oaGVhZGluZykge1xuICAgICAgICAgICAgZXZlbnQuZWRpdG9yLmFkZENvbW1hbmQoJ3RhYmxlSGVhZGluZycgKyBoZWFkaW5nLCB7XG4gICAgICAgICAgICAgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlVXRpbHMuc2V0SGVhZGluZyhudWxsLCBoZWFkaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBDS0VESVRPUi5UYWJsZSA9IENLRURJVE9SLlRhYmxlIHx8IFRhYmxlO1xufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBDS0VESVRPUi50b29scyBjbGFzcyB1dGlsaXR5IHdoaWNoIGFkZHMgYWRkaXRpb25hbCBtZXRob2RzIHRvIHRob3NlIG9mIENLRWRpdG9yLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnRvb2xzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHJlcXVlc3QgdXNpbmcgdGhlIEpTT05QIHRlY2huaXF1ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICAgICAqIEBtZXRob2QganNvbnBcbiAgICAgKiBAcGFyYW0ge0NLRURJVE9SLnRlbXBsYXRlfSB1cmxUZW1wbGF0ZSBUaGUgdGVtcGxhdGUgb2YgdGhlIFVSTCB0byBiZSByZXF1ZXN0ZWQuIEFsbCBwcm9wZXJ0aWVzIHBhc3NlZCBpbiBgdXJsUGFyYW1zYCBjYW4gYmUgdXNlZCwgcGx1cyBhIGB7Y2FsbGJhY2t9YCwgd2hpY2ggcmVwcmVzZW50IGEgSlNPTlAgY2FsbGJhY2ssIG11c3QgYmUgZGVmaW5lZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBjYXNlIG9mIHN1Y2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JDYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVybFBhcmFtcyBQYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgYHVybFRlbXBsYXRlYC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAgLSBpZDogdGhlIHRyYW5zYWN0aW9uIElEXG4gICAgICogIC0gYSBgY2FuY2VsKClgIG1ldGhvZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBDS0VESVRPUi50b29scy5qc29ucCA9IGZ1bmN0aW9uKHVybFRlbXBsYXRlLCB1cmxQYXJhbXMsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFja0tleSA9IENLRURJVE9SLnRvb2xzLmdldE5leHROdW1iZXIoKTtcblxuICAgICAgICB1cmxQYXJhbXMgPSB1cmxQYXJhbXMgfHwge307XG4gICAgICAgIHVybFBhcmFtcy5jYWxsYmFjayA9ICdDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzWycgKyBjYWxsYmFja0tleSArICddJztcblxuICAgICAgICBpZiAoIUNLRURJVE9SLl8uanNvbnBDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIENLRURJVE9SLl8uanNvbnBDYWxsYmFja3MgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIENLRURJVE9SLl8uanNvbnBDYWxsYmFja3NbY2FsbGJhY2tLZXldID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5VcCgpO1xuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNjcmlwdEVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsVGVtcGxhdGUub3V0cHV0KHVybFBhcmFtcykpO1xuICAgICAgICBzY3JpcHRFbGVtZW50Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYW5VcCgpO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgICAgIGlmIChzY3JpcHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgQ0tFRElUT1IuXy5qc29ucENhbGxiYWNrc1tjYWxsYmFja0tleV07XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBDS0VESVRPUi5kb2N1bWVudC5nZXRCb2R5KCkuYXBwZW5kKHNjcmlwdEVsZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYW5jZWw6IGNsZWFuVXAsXG4gICAgICAgICAgICBpZDogY2FsbGJhY2tLZXlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIHByb3BlcnRpZXMgb2YgYWxsIHRoZSBzdXBwbGllZFxuICAgICAqIG9iamVjdHMuIFRoZSBwcm9wZXJ0aWVzIGZyb20gbGF0ZXIgb2JqZWN0cyB3aWxsIG92ZXJ3cml0ZSB0aG9zZSBpbiBlYXJsaWVyXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIFBhc3NpbmcgaW4gYSBzaW5nbGUgb2JqZWN0IHdpbGwgY3JlYXRlIGEgc2hhbGxvdyBjb3B5IG9mIGl0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENLRURJVE9SLnRvb2xzXG4gICAgICogQG1ldGhvZCBtZXJnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzKiBPbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgbWVyZ2VkIG9iamVjdC5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQ0tFRElUT1IudG9vbHMubWVyZ2UgPSBDS0VESVRPUi50b29scy5tZXJnZSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZXMgZXZlbnQgb24gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICAgICAqIEBtZXRob2Qgc2ltdWxhdGVcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IHNob3VkIGJlIHNpbXVhbHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHdoaWNoIGhhdmUgdG8gYmUgc2ltdWxhdGVkLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBDS0VESVRPUi50b29scy5zaW11bGF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICBldmVudEluc3RhbmNlLmluaXRFdmVudChldmVudCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnRJbnN0YW5jZSk7XG4gICAgfTtcbn0oKSk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfdWljb3JlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVJQ29yZSBjbGFzcyB3aGljaCB3aWxsIGhhbmRsZSB1c2VyIGludGVyYWN0aW9ucyB3aXRoIHRoZSBlZGl0b3IuIFRoZXNlIGludGVyYWN0aW9uc1xuICAgICAqIG1pZ2h0IGJlIHRyaWdnZXJlZCB2aWEgbW91c2UsIGtleWJvYXJkIG9yIHRvdWNoIGRldmljZXMuIFRoZSBjbGFzcyBmaWxsIGZpcmUgYW4gZXZlbnQgdmlhXG4gICAgICogQ0tFZGl0b3IncyBldmVudCBzeXN0ZW0gLSBcImVkaXRvckludGVyYWN0aW9uXCIuIFRoZSBVSSBtYXkgbGlzdGVuIHRvIHRoaXMgZXZlbnQgYW5kXG4gICAgICogZXhlY3V0ZSBzb21lIGFjdGlvbnMgLSBmb3IgZXhhbXBsZSB0byBzaG93L2hpZGUgdG9vbGJhcnMuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0IGlmIHVzZXIgcHJlc3NlcyB0aGUgRXNjIGtleSwgJ2VkaXRvckludGVyYWN0aW9uJyBldmVudCB3b24ndCBiZSBmaXJlZC4gSG93ZXZlciwgdGhpcyBiZWhhdmlvdXIgY2FuIGJlIGNoYW5nZWRcbiAgICAgKiBieSBzZXR0aW5nIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL2FsbG93RXNjOmF0dHJpYnV0ZVwifX17ey9jcm9zc0xpbmt9fSBjb25maWcgcHJvcGVydHkgaW4gZWRpdG9yJ3MgY29uZmlndXJhdGlvbiB0byB0cnVlLlxuICAgICAqXG4gICAgICogQGNsYXNzIGFlX3VpY29yZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB1c2VyIGludGVyYWN0cyBzb21laG93IHdpdGggdGhlIGJyb3dzZXIuIFRoaXMgbWF5IGJlIGNsaWNraW5nIHdpdGggdGhlIG1vdXNlLCBwcmVzc2luZyBrZXlib2FyZCBidXR0b24sXG4gICAgICogb3IgdG91Y2hpbmcgc2NyZWVuLiBUaGlzIGV2ZW4gd2lsbCBiZSBub3QgZmlyZWQgYWZ0ZXIgZWFjaCBpbnRlcmFjdGlvbi4gSXQgd2lsbCBiZSBkZWJvdW5jZWQuIEJ5IGRlZmF1bHQgdGhlIHRpbWVvdXRcbiAgICAgKiBpcyA1MG1zLiBUaGlzIHZhbHVlIGNhbiBiZSBvdmVyd3JpdHRlbiB2aWEge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvdGltZW91dDphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBwcm9wZXJ0eSBvZiBlZGl0b3IncyBjb25maWd1cmF0aW9uLCBsaWtlOiBlZGl0b3IuY29uZmlnLnVpY29yZS50aW1lb3V0ID0gMTAwXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG4gICAgICogQGV2ZW50IGFlX3VpY29yZSNlZGl0b3JJbnRlcmFjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogLSBuYXRpdmVFdmVudCAtIFRoZSBldmVudCBhcyByZWNlaXZlZCBmcm9tIENLRWRpdG9yLlxuICAgICAqIC0gc2VsZWN0aW9uRGF0YSAtIFRoZSBkYXRhLCByZXR1cm5lZCBmcm9tIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBieSBVSSBlbGVtZW50cyBsaWtlIFRvb2xiYXJzIG9yIEJ1dHRvbnMgd2hlbiB0aGVpciBzdGF0ZSBjaGFuZ2VzLiBUaGUgbGlzdGVuZXIgdXBkYXRlcyB0aGUgbGl2ZSByZWdpb24gd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBhZV91aWNvcmVcbiAgICAgKiBAZXZlbnQgYWVfdWljb3JlI2FyaWFVcGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIC0gbWVzc2FnZSAtIFRoZSBwcm92aWRlZCBtZXNzYWdlIGZyb20gdGhlIFVJIGVsZW1lbnQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGVkaXRvciB3aWxsIHN0aWxsIGZpcmUge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvZWRpdG9ySW50ZXJhY3Rpb246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQsXG4gICAgICogaWYgdXNlciBwcmVzc2VzIEVzYyBrZXkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG4gICAgICogQGF0dHJpYnV0ZSBhbGxvd0VzY1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBkZWZhdWx0IHRpbWVvdXQgYWZ0ZXIgd2hpY2ggdGhlIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL2VkaXRvckludGVyYWN0aW9uOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50XG4gICAgICogd2lsbCBiZSBmaXJlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBhZV91aWNvcmVcbiAgICAgKiBAYXR0cmlidXRlIHRpbWVvdXRcbiAgICAgKiBAZGVmYXVsdCA1MCAobXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG5cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX3VpY29yZScsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXIgbGlmZWN5Y2xlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgVUlDb3JlIHBsdWdpbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgQ0tFZGl0b3IgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBhcmlhU3RhdGUgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBhcmlhRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUFyaWFFbGVtZW50KGVkaXRvci5pZCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdWlUYXNrc1RpbWVvdXQgPSBlZGl0b3IuY29uZmlnLnVpY29yZSA/IGVkaXRvci5jb25maWcudWljb3JlLnRpbWVvdXQgOiA1MDtcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVVSSA9IENLRURJVE9SLnRvb2xzLmRlYm91bmNlKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5uYW1lICE9PSAna2V5dXAnIHx8IGV2ZW50LmRhdGEuJC5rZXlDb2RlICE9PSAyNyB8fCBlZGl0b3IuY29uZmlnLmFsbG93RXNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkRhdGEgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50LmRhdGEuJCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IHNlbGVjdGlvbkRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1aVRhc2tzVGltZW91dFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQXJpYSA9IENLRURJVE9SLnRvb2xzLmRlYm91bmNlKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYUVsZW1lbnQuaW5uZXJIVE1MID0gYXJpYVN0YXRlLmpvaW4oJy4gJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVpVGFza3NUaW1lb3V0XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVNb3VzZUxlYXZlID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWVVSU5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFlLXVpJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZVVJTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWVVSU5vZGVzW2ldLmNvbnRhaW5zKGV2ZW50LmRhdGEuJC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVVJKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdWlUYXNrc1RpbWVvdXRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdhcmlhVXBkYXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlQXJpYSBpcyBkZWJvdW5jZWQgZnVuY3Rpb24sIHNvIGlmIGl0IGlzIGJlaW5nIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgaXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBjYW5jZWxlZCB1bnRpbCBzb21lIHRpbWUgcGFzc2VzLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24gaGVyZSB3ZSBleHBsaWNpdGx5IGFwcGVuZCB0aGUgY3VycmVudCBtZXNzYWdlIHRvIHRoZSBsaXN0IG9mIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjYWxsIGhhbmRsZUFyaWEuIFNpbmNlIGl0IGlzIGRlYm91bmNlZCwgd2hlbiBzb21lIHRpbWVvdXQgcGFzc2VzLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgdGhlIG1lc3NhZ2VzIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbGl2ZSByZWdpb24gYW5kIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cblxuICAgICAgICAgICAgICAgICAgICBhcmlhU3RhdGUucHVzaChldmVudC5kYXRhLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUFyaWEoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2N1c0hhbmRsZXIgPSBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2ZvY3VzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0hhbmRsZXIucmVtb3ZlTGlzdGVuZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdrZXl1cCcsIGhhbmRsZVVJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAnbW91c2V1cCcsIGhhbmRsZVVJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAnbW91c2VsZWF2ZScsIGhhbmRsZU1vdXNlTGVhdmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVVSShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdkZXN0cm95JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJpYUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhcmlhRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlVUkuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYW5kIGFwcGxpZXMgYW4gSFRNTCBlbGVtZW50IHRvIHRoZSBib2R5IG9mIHRoZSBkb2N1bWVudCB3aGljaCB3aWxsIGNvbnRhaW4gQVJJQSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9jcmVhdGVBcmlhRWxlbWVudFxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBwcm92aWRlZCBpZCBvZiB0aGUgZWxlbWVudC4gSXQgd2lsbCBiZSB1c2VkIGFzIHByZWZpeCBmb3IgdGhlIGZpbmFsIGVsZW1lbnQgSWQuXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIGNyZWF0ZWQgYW5kIGFwcGxpZWQgdG8gRE9NIGVsZW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9jcmVhdGVBcmlhRWxlbWVudDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICAgICAgc3RhdHVzRWxlbWVudC5jbGFzc05hbWUgPSAnYWUtc3Itb25seSc7XG5cbiAgICAgICAgICAgICAgICBzdGF0dXNFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICAgICAgICAgIHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3N0YXR1cycpO1xuICAgICAgICAgICAgICAgIHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGlkICsgJ0xpdmVSZWdpb24nKTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHVzRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KCkpOyIsImltcG9ydCBMYW5nIGZyb20gJy4vbGFuZy5qcyc7XG5cbi8qKlxuICogQXR0cmlidXRlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBjbGFzcyBBdHRyaWJ1dGVcbiAqIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIEF0dHJpYnV0ZShjb25maWcpIHtcbiAgICB0aGlzLl9fY29uZmlnX18gPSBjb25maWcgfHwge307XG4gICAgdGhpcy5fX0FUVFJTX18gPSB7fTtcbn1cblxuQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQXR0cmlidXRlLFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIHdoaWNoIHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7QW55fSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5BVFRSU1thdHRyXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRBdHRyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQoYXR0cikpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXQoYXR0cik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VyVmFsdWUgPSB0aGlzLl9fQVRUUlNfX1thdHRyXTtcblxuICAgICAgICBpZiAoY3VycmVudEF0dHIuZ2V0dGVyKSB7XG4gICAgICAgICAgICBjdXJWYWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLmdldHRlciwgY3VyVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1clZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIHdoaWNoIHZhbHVlIHNob3VsZCBiZSBzZXQuXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBzaG91bGQgYmUgc2V0IHRvIHRoZSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihhdHRyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgY3VycmVudEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLkFUVFJTW2F0dHJdO1xuXG4gICAgICAgIGlmICghY3VycmVudEF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZChhdHRyKSkge1xuICAgICAgICAgICAgdGhpcy5faW5pdChhdHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50QXR0ci5yZWFkT25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLndyaXRlT25jZSAmJiB0aGlzLl9pc0luaXRpYWxpemVkKGF0dHIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEF0dHIudmFsaWRhdG9yICYmICF0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci52YWxpZGF0b3IsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLnNldHRlcikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci5zZXR0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19BVFRSU19fW2F0dHJdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBwcm92aWRlZCBwYXJhbSBhcyBmdW5jdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG4gICAgICogSWYgcGFyYW0gcHJvdmlkZWQgYXMgc3RyaW5nLCBhIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24gaW4gdGhpcyBvYmplY3Qgd2lsbFxuICAgICAqIGJlIGNhbGxlZC4gSWYgcHJvdmlkZWQgcGFyYW0gaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBkaXJlY3RseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG4gICAgICogQG1ldGhvZCBfY2FsbFN0cmluZ09yRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gIHtBbnl8QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB3aGljaCB3aWxsIGJlIHByb3ZpZGVkIHRvIHRoZSBjYWxsZWQgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259IHN0cmluZ09yRnVuY3Rpb24gVGhlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBjYWxsZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7QW55fSBUaGUgcmV0dXJuZWQgdmFsdWUgZnJvbSB0aGUgY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2NhbGxTdHJpbmdPckZ1bmN0aW9uOiBmdW5jdGlvbihzdHJpbmdPckZ1bmN0aW9uLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIGlmICghTGFuZy5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgICBhcmdzID0gW2FyZ3NdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKExhbmcuaXNTdHJpbmcoc3RyaW5nT3JGdW5jdGlvbikgJiYgTGFuZy5pc0Z1bmN0aW9uKHRoaXNbc3RyaW5nT3JGdW5jdGlvbl0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzW3N0cmluZ09yRnVuY3Rpb25dLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKExhbmcuaXNGdW5jdGlvbihzdHJpbmdPckZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3RyaW5nT3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGF0dHJpYnV0ZS4gU2V0cyBpdHMgZGVmYXVsdCB2YWx1ZSBkZXBlbmRpbmcgb24gdGhlIGZsYWdzIG9mIHRoZVxuICAgICAqIGF0dHJpYnV0ZSBhbmQgdGhlIHBhc3NlZCBjb25maWd1cmF0aW9uIG9iamVjdCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG4gICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgd2hpY2ggaGF2ZSB0byBiZSBpbml0aWFsaXplZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHZhciBjdXJyZW50QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuQVRUUlNbYXR0cl07XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgZGVmYXVsdCB2YWx1ZSBvciBwYXNzZWQgb25lIHZpYSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICB2YXIgaGFzRGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnRBdHRyLCAndmFsdWUnKTtcbiAgICAgICAgdmFyIGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX19jb25maWdfXywgYXR0cik7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgdmFsdWVGbiwgc2V0IHRoZSB2YWx1ZSB0byBiZSB0aGUgcmVzdWx0IG9mIGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICBpZiAoY3VycmVudEF0dHIudmFsdWVGbikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci52YWx1ZUZuLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX19BVFRSU19fW2F0dHJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBpZiB0aGUgYXR0cmlidXRlIGhhcyByZWFkT25seSBmbGFnLCBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgYXR0cmlidXRlLFxuICAgICAgICAvLyByZWdhcmRsZXNzIGlmIHRoZXJlIGlzIHZhbHVlIG9yIG5vdFxuICAgICAgICBlbHNlIGlmIChjdXJyZW50QXR0ci5yZWFkT25seSkge1xuICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50QXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGlmIHRoZSBhdHRyaWJ1dGUgaGFzIHdyaXRlT25jZSB2YWx1ZSwgc2V0IGl0IGZyb20gdGhlIHBhc3NlZCBjb25maWd1cmF0aW9uIG9yIGZyb20gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWUsIGluIHRoaXMgb3JkZXIuIE90aGVyd2lzZSwgcmV0dXJuIG1pc2VyYWJsZS5cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEF0dHIud3JpdGVPbmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzUGFzc2VkVmFsdWVWaWFDb25maWcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX19jb25maWdfX1thdHRyXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50QXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIHR3byBjYXNlcyBiZWxvdyBhcmUgZWFzeSAtIHNldCB0aGUgdmFsdWUgdG8gYmUgZnJvbSB0aGUgcGFzc2VkIGNvbmZpZyBvclxuICAgICAgICAvLyBmcm9tIHRoZSBkZWZhdWx0IHZhbHVlLCBpbiB0aGlzIG9yZGVyLlxuICAgICAgICBlbHNlIGlmIChoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fY29uZmlnX19bYXR0cl07XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgdmFsaWRhdG9yLCBhbmQgdXNlciBwYXNzZWQgY29uZmlnIG9iamVjdCAtIGNoZWNrIHRoZSByZXR1cm5lZCB2YWx1ZS5cbiAgICAgICAgLy8gSWYgaXQgaXMgZmFsc2UsIHRoZW4gc2V0IGFzIGluaXRpYWwgdmFsdWUgdGhlIGRlZmF1bHQgb25lLlxuICAgICAgICAvLyBIb3dldmVyLCBpZiB0aGVyZSBpcyBubyBkZWZhdWx0IHZhbHVlLCBqdXN0IHJldHVybi5cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRyLnZhbGlkYXRvciAmJiBoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZyAmJiAhdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIudmFsaWRhdG9yLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBzZXR0ZXIgYW5kIHVzZXIgcGFzc2VkIGNvbmZpZyBvYmplY3QgLSBwYXNzIHRoZSB2YWx1ZSB0aG91Z2h0IHRoZSBzZXR0ZXIuXG4gICAgICAgIC8vIFRoZSB2YWx1ZSBtaWdodCBiZSBvbmUgZnJvbSBkZWZhdWx0Rm4sIGRlZmF1bHQgdmFsdWUgb3IgcHJvdmlkZWQgZnJvbSB0aGUgY29uZmlnLlxuICAgICAgICBpZiAoY3VycmVudEF0dHIuc2V0dGVyICYmIGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnNldHRlciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWxseSwgc2V0IHRoZSB2YWx1ZSBhcyBpbml0aWFsIHZhbHVlIHRvIHRoZSBzdG9yYWdlIHdpdGggdmFsdWVzLlxuICAgICAgICB0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYW4gYXR0cmlidXRlIGlzIGluaXRpYWxpemVkLiBBbiBhdHRyaWJ1dGUgaXMgY29uc2lkZXJlZCBhcyBpbml0aWFsaXplZFxuICAgICAqIHdoZW4gdGhlcmUgaXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhpcyBuYW1lIGluIHRoZSBsb2NhbCBjb2xsZWN0aW9uIG9mIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgKiBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG4gICAgICogQG1ldGhvZCBfaXNJbml0aWFsaXplZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgd2hpY2ggc2hvdWxkIGJlIGNoZWNrZWQgaWYgaXQgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIGhhcyBiZWVuIGluaXRpYWxpemVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgX2lzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9fQVRUUlNfXywgYXR0cik7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRlOyIsImltcG9ydCBBdHRyaWJ1dGUgZnJvbSAnLi9hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi9sYW5nLmpzJztcbmltcG9ydCBleHRlbmQgZnJvbSAnLi9vb3AuanMnO1xuXG4vKipcbiAqIFF1aWNrIGFuZCBkaXJ0eSBpbXBsIG9mIEJhc2UgY2xhc3MuXG4gKlxuICogQGNsYXNzIEJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCYXNlKGNvbmZpZykge1xuICAgIEJhc2Uuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgICB0aGlzLmluaXQoY29uZmlnKTtcbn1cblxuZXh0ZW5kKEJhc2UsIEF0dHJpYnV0ZSwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBgaW5pdGlhbGl6ZXJgIG1ldGhvZCBvZiBlYWNoIGNsYXNzIHdoaWNoIGV4dGVuZHMgQmFzZSBzdGFydGluZyBmcm9tIHRoZSBwYXJlbnQgdG8gdGhlIGNoaWxkLlxuICAgICAqIFdpbGwgcGFzcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gZWFjaCBpbml0aWFsaXplciBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQmFzZVxuICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fY2FsbENoYWluKCdpbml0aWFsaXplcicsIGNvbmZpZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBgZGVzdHJ1Y3RvcmAgbWV0aG9kIG9mIGVhY2ggY2xhc3Mgd2hpY2ggZXh0ZW5kcyBCYXNlIHN0YXJ0aW5nIGZyb20gdGhlIHBhcmVudCB0byB0aGUgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQmFzZVxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jYWxsQ2hhaW4oJ2Rlc3RydWN0b3InKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSBtZXRob2Qgb2YgZWFjaCBjbGFzcywgd2hpY2ggaXMgYmVpbmcgcHJlc2VudCBpbiB0aGUgaGllcmFyY2h5IHN0YXJ0aW5nIGZyb20gcGFyZW50IHRvIHRoZSBjaGlsZC5cbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBCYXNlXG4gICAgICogQG1ldGhvZCBfY2FsbENoYWluXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRoZSBtZXRob2Qgc2hvdWxkIGJlIGludm9rZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2F0ICBUaGUgbWV0aG9kLCB3aGljaCBzaG91bGQgYmUgaW52b2tlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2FsbENoYWluOiBmdW5jdGlvbih3YXQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuXG4gICAgICAgIHZhciBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgICAgICB3aGlsZSAoY3Rvcikge1xuICAgICAgICAgICAgaWYgKExhbmcuaXNGdW5jdGlvbihjdG9yLnByb3RvdHlwZVt3YXRdKSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGN0b3IucHJvdG90eXBlW3dhdF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdG9yID0gY3Rvci5zdXBlcmNsYXNzID8gY3Rvci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyciA9IGFyci5yZXZlcnNlKCk7XG5cbiAgICAgICAgYXJncyA9IExhbmcuaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJyW2ldO1xuXG4gICAgICAgICAgICBpdGVtLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U7IiwiLyoqXG4gKiBQcm92aWRlcyBjb3JlIGxhbmd1YWdlIHV0aWxpdGllcy5cbiAqXG4gKiBAY2xhc3MgTGFuZ1xuICovXG5jb25zdCBMYW5nID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgaXNBcnJheVxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpc0FycmF5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBib29sZWFuLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIGlzQm9vbGVhblxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBib29sZWFuLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgaXNGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIE5VTEwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgaXNOdWxsXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIE5VTEwsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaXNOdWxsOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgbnVtYmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIGlzTnVtYmVyXG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpc051bWJlcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIGlzT2JqZWN0XG4gICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpc09iamVjdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlICYmICh2YWx1ZVR5cGUgPT09ICdvYmplY3QnIHx8IExhbmcuaXNGdW5jdGlvbih2YWx1ZSkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYW5nXG4gICAgICogQG1ldGhvZCBpc1N0cmluZ1xuICAgICAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBpc1N0cmluZzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3VwcGxpZXIgdG8gdGhlIHJlY2VpdmVyLlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aWxsIGFkZCBhbGwgcHJvcGVydGllcywgbm90IG9ubHkgdGhlc2Ugb3duZWQgYnkgdGhlIHN1cHBsaWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExhbmdcbiAgICAgKiBAbWV0aG9kIG1peFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNlaXZlciBUaGUgb2JqZWN0IHdoaWNoIHdpbGwgcmVjZWl2ZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdXBwbGllciBUaGUgb2JqZWN0IHdoaWNoIHByb3ZpZGVzIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVjZWl2ZXIuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIG1peDogZnVuY3Rpb24ocmVjZWl2ZXIsIHN1cHBsaWVyKSB7XG4gICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN1cHBsaWVyKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzdXBwbGllciwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyW2tleV0gPSBzdXBwbGllcltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHZhbHVlIHRvIEludGVnZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGFuZ1xuICAgICAqIEBtZXRob2QgdG9JbnRcbiAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY29udmVydGVkIHRvIEludGVnZXIuXG4gICAgICogQHJldHVybiB7SW50ZWdlcn0gVGhlIGNvbnZlcnRlZCB2YWx1ZS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdG9JbnQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IExhbmc7IiwiaW1wb3J0IExhbmcgZnJvbSAnLi9sYW5nJztcblxuLyoqXG4gKiBTZXRzIHRoZSBwcm90b3R5cGUsIGNvbnN0cnVjdG9yIGFuZCBzdXBlcmNsYXNzIHByb3BlcnRpZXMgdG8gc3VwcG9ydCBhbiBpbmhlcml0YW5jZSBzdHJhdGVneVxuICogdGhhdCBjYW4gY2hhaW4gY29uc3RydWN0b3JzIGFuZCBtZXRob2RzLiBTdGF0aWMgbWVtYmVycyB3aWxsIG5vdCBiZSBpbmhlcml0ZWQuXG4gKlxuICogQG1lbWJlcm9mIE9PUFxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2VpdmVyIFRoZSBjbGFzcyB3aGljaCB3aWxsIGV4dGVuZCBhbm90aGVyIGNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwcGxpZXIgVGhlIGNsYXNzIHdoaWNoIHdpbGwgcHJvdmlkZSB0aGUgcHJvcGVydGllcyB0aGUgY2hpbGQgY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9Qcm9wcyBQcm90b3R5cGUgcHJvcGVydGllcyB0byBhZGQvb3ZlcnJpZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGljUHJvcHMgU3RhdGljIHByb3BlcnRpZXMgdG8gYWRkL292ZXJ3cml0ZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZXh0ZW5kZWQgY2xhc3MuXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IGV4dGVuZCA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBzdXBwbGllciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAoIXN1cHBsaWVyIHx8ICFyZWNlaXZlcikge1xuICAgICAgICB0aHJvdyAnZXh0ZW5kIGZhaWxlZCwgdmVyaWZ5IGRlcGVuZGVuY2llcyc7XG4gICAgfVxuXG4gICAgdmFyIHN1cHBsaWVyUHJvdG8gPSBzdXBwbGllci5wcm90b3R5cGUsIHJlY2VpdmVyUHJvdG8gPSBPYmplY3QuY3JlYXRlKHN1cHBsaWVyUHJvdG8pO1xuICAgIHJlY2VpdmVyLnByb3RvdHlwZSA9IHJlY2VpdmVyUHJvdG87XG5cbiAgICByZWNlaXZlclByb3RvLmNvbnN0cnVjdG9yID0gcmVjZWl2ZXI7XG4gICAgcmVjZWl2ZXIuc3VwZXJjbGFzcyA9IHN1cHBsaWVyUHJvdG87XG5cbiAgICAvLyBhc3NpZ24gY29uc3RydWN0b3IgcHJvcGVydHlcbiAgICBpZiAoc3VwcGxpZXIgIT09IE9iamVjdCAmJiBzdXBwbGllclByb3RvLmNvbnN0cnVjdG9yID09PSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHN1cHBsaWVyUHJvdG8uY29uc3RydWN0b3IgPSBzdXBwbGllcjtcbiAgICB9XG5cbiAgICAvLyBhZGQgcHJvdG90eXBlIG92ZXJyaWRlc1xuICAgIGlmIChwcm90b1Byb3BzKSB7XG4gICAgICAgIExhbmcubWl4KHJlY2VpdmVyUHJvdG8sIHByb3RvUHJvcHMpO1xuICAgIH1cblxuICAgIC8vIGFkZCBvYmplY3Qgb3ZlcnJpZGVzXG4gICAgaWYgKHN0YXRpY1Byb3BzKSB7XG4gICAgICAgIExhbmcubWl4KHJlY2VpdmVyLCBzdGF0aWNQcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY2VpdmVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZXh0ZW5kOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaXNJRSA9IENLRURJVE9SLmVudi5pZTtcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfYWRkaW1hZ2VzJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhbGxvd3MgRHJhZyZEcm9wIG9mIGltYWdlcyBkaXJlY3RseSBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLiBUaGUgaW1hZ2Ugd2lsbCBiZSBlbmNvZGVkXG4gICAgICogYXMgRGF0YSBVUkkuIEFuIGV2ZW50IGBiZWZvcmVJbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBsaXN0IG9mIGRyb3BwZWQgaW1hZ2VzLiBJZiBhbnkgb2YgdGhlIGxpc3RlbmVyc1xuICAgICAqIHJldHVybnMgYGZhbHNlYCBvciBjYW5jZWxzIHRoZSBldmVudCwgdGhlIGltYWdlcyB3b24ndCBiZSBhZGRlZCB0byB0aGUgY29udGVudC4gT3RoZXJ3aXNlLFxuICAgICAqIGFuIGV2ZW50IGBpbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBpbnNlcnRlZCBlbGVtZW50IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGJlZm9yZSBhZGRpbmcgaW1hZ2VzIHRvIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjYmVmb3JlSW1hZ2VBZGRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZUZpbGVzIEFycmF5IG9mIGltYWdlIGZpbGVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIGFkZGVkIHRvIHRoZSBlZGl0b3Igc3VjY2Vzc2Z1bGx5LlxuICAgICAqXG4gICAgICogQGV2ZW50IENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzI2ltYWdlQWRkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1hZ2Ugd2l0aCBzcmMgYXMgRGF0YSBVUklcbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgVGhlIGltYWdlIGZpbGVcbiAgICAgKi9cblxuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfYWRkaW1hZ2VzJywge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ2RyYWdlbnRlcicsICdkcmFnb3ZlcicsICdkcm9wJyBhbmQgYHBhc3RlYCBldmVudHMgb24gdGhlIGVkaXRpbmcgYXJlYS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2RyYWdlbnRlcicsIHRoaXMuX29uRHJhZ0VudGVyLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2RyYWdvdmVyJywgdGhpcy5fb25EcmFnT3ZlciwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdkcm9wJywgdGhpcy5fb25EcmFnRHJvcCwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdwYXN0ZScsIHRoaXMuX29uUGFzdGUsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFjY2VwdHMgYW4gYXJyYXkgb2YgZHJvcHBlZCBmaWxlcyB0byB0aGUgZWRpdG9yLiBUaGVuLCBpdCBmaWx0ZXJzIHRoZSBpbWFnZXMgYW5kIHNlbmRzIHRoZW0gZm9yIGZ1cnRoZXJcbiAgICAgICAgICAgICAqIHByb2Nlc3NpbmcgdG8ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMvX3Byb2Nlc3NGaWxlOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBmaXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNiZWZvcmVJbWFnZUFkZFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgX2hhbmRsZUZpbGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWxlcyBBcnJheSBvZiBkcm9wcGVkIGZpbGVzLiBPbmx5IHRoZSBpbWFnZXMgZnJvbSB0aGlzIGxpc3Qgd2lsbCBiZSBwcm9jZXNzZWQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfaGFuZGxlRmlsZXM6IGZ1bmN0aW9uKGZpbGVzLCBlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZTtcbiAgICAgICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZUZpbGVzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGVkaXRvci5maXJlKCdiZWZvcmVJbWFnZUFkZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VGaWxlczogaW1hZ2VGaWxlc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEhcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWFnZUZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0gaW1hZ2VGaWxlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0ZpbGUoZmlsZSwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlcyBkcmFnIGRyb3AgZXZlbnQuIFRoZSBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIHNlbGVjdGlvbiBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgKiBwb2ludCBhbmQgd2lsbCBzZW5kIGEgbGlzdCBvZiBmaWxlcyB0byBiZSBwcm9jZXNzZWQgdG9cbiAgICAgICAgICAgICAqIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzL19oYW5kbGVGaWxlczptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9vbkRyYWdEcm9wXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZXZlbnQgZHJhZ2Ryb3AgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3JcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX29uRHJhZ0Ryb3A6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgbmV3IENLRURJVE9SLmRvbS5ldmVudChuYXRpdmVFdmVudCkucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvci5jcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQobmF0aXZlRXZlbnQuY2xpZW50WCwgbmF0aXZlRXZlbnQuY2xpZW50WSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVGaWxlcyhuYXRpdmVFdmVudC5kYXRhVHJhbnNmZXIuZmlsZXMsIGVkaXRvcik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZXMgZHJhZyBlbnRlciBldmVudC4gSW4gY2FzZSBvZiBJRSwgdGhpcyBmdW5jdGlvbiB3aWxsIHByZXZlbnQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9vbkRyYWdFbnRlclxuICAgICAgICAgICAgICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IGRyYWdlbnRlciBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfb25EcmFnRW50ZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmVudEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZXMgZHJhZyBvdmVyIGV2ZW50LiBJbiBjYXNlIG9mIElFLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uRHJhZ092ZXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBkcmFnb3ZlciBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfb25EcmFnT3ZlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJRSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBwYXN0ZWQgZGF0YSBpcyBpbWFnZSBhbmQgcGFzc2VzIGl0IHRvXG4gICAgICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcy9fcHJvY2Vzc0ZpbGU6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9vblBhc3RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZXZlbnQgQSBgcGFzdGVgIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vblBhc3RlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuJCAmJiBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtcyAmJiBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXN0ZWREYXRhID0gZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEuaXRlbXNbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3RlZERhdGEudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VGaWxlID0gcGFzdGVkRGF0YS5nZXRBc0ZpbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0ZpbGUoaW1hZ2VGaWxlLCBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJldmVudHMgYSBuYXRpdmUgZXZlbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3ByZXZlbnRFdmVudFxuICAgICAgICAgICAgICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBiZSBwcmV2ZW50ZWQuXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9wcmV2ZW50RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmV2ZW50KGV2ZW50LmRhdGEuJCk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm9jZXNzZXMgYW4gaW1hZ2UgZmlsZS4gVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gaW1nIGVsZW1lbnQgYW5kIHNldHMgYXMgc291cmNlXG4gICAgICAgICAgICAgKiBhIERhdGEgVVJJLCB0aGVuIGZpcmVzIGFuICdpbWFnZUFkZCcgZXZlbnQgdmlhIENLRWRpdG9yJ3MgZXZlbnQgc3lzdGVtLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBmaXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNpbWFnZUFkZFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3ByZXZlbnRFdmVudFxuICAgICAgICAgICAgICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBiZSBwcmV2ZW50ZWQuXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9wcm9jZXNzRmlsZTogZnVuY3Rpb24oZmlsZSwgZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluID0gcmVhZGVyLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbCgnPGltZyBzcmM9XCInICsgYmluICsgJ1wiPicpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KCkpOyIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2F1dG9saW5rJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERpc2FibGVzIHRoZSBhdXRvIFVSTCBkZXRlY3Rpb24gZmVhdHVyZSBpbiBJRSwgdGhlaXIgbGFja3MgZnVuY3Rpb25hbGl0eTpcbiAgICAvLyBUaGV5IGNvbnZlcnQgdGhlIGxpbmtzIG9ubHkgb24gc3BhY2UuIFdlIGRvIG9uIHNwYWNlLCBjb21tYSwgc2VtaWNvbG9uIGFuZCBFbnRlci5cbiAgICBpZiAoL01TSUUgKFteO10qKXxUcmlkZW50Lio7IHJ2OihbMC05Ll0rKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnQXV0b1VybERldGVjdCcsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIEtFWV9CQUNLID0gODtcblxuICAgIHZhciBLRVlfQ09NTUEgPSAxODg7XG5cbiAgICB2YXIgS0VZX0VOVEVSID0gMTM7XG5cbiAgICB2YXIgS0VZX1NFTUlDT0xPTiA9IDE4NjtcblxuICAgIHZhciBLRVlfU1BBQ0UgPSAzMjtcblxuICAgIHZhciBERUxJTUlURVJTID0gW0tFWV9DT01NQSwgS0VZX0VOVEVSLCBLRVlfU0VNSUNPTE9OLCBLRVlfU1BBQ0VdO1xuXG4gICAgdmFyIFJFR0VYX0xBU1RfV09SRCA9IC9bXlxcc10rL21nO1xuXG4gICAgdmFyIFJFR0VYX1VSTCA9IC8oaHR0cHM/XFw6XFwvXFwvfHd3d1xcLikoLVxcLik/KFteKFxccy8/XFwuIy0pXStcXC4/KSsoXFxiXFwvW15cXHNdKik/JC9pO1xuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGxpbmtzIHdoZW4gdXNlciB0eXBlcyB0ZXh0IHdoaWNoIGxvb2tzIGxpa2UgVVJMLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2F1dG9saW5rJywge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGBrZXl1cGAgZXZlbnQgb24gdGhlIGVkaXRpbmcgYXJlYS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAna2V5dXAnLCB0aGlzLl9vbktleVVwLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGxhc3Qgd29yZCBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyLiBSZWFkcyBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgKiBjYXJldCBwb3NpdGlvbiBiYWNrd2FyZHMgdW50aWwgaXQgZmluZHMgdGhlIGZpcnN0IHdoaXRlIHNwYWNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX2dldExhc3RXb3JkXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBsYXN0IHdvcmQgaW50cm9kdWNlZCBieSB1c2VyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9nZXRMYXN0V29yZDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzVGV4dCA9ICcnO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgcHJlc3NlZCBFbnRlciwgc28gd2UgaGF2ZSB0byBsb29rIG9uIHRoZSBwcmV2aW91cyBub2RlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRLZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzTm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLmdldFByZXZpb3VzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBub2RlIGlzIGEgU1BBQ0UsIChpdCBkb2VzIG5vdCBoYXZlICdnZXRMYXN0JyBtZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGl0IGFuZCBmaW5kIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHJldmlvdXNOb2RlLmdldExhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSBwcmV2aW91c05vZGUuZ2V0UHJldmlvdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkID0gcHJldmlvdXNOb2RlLmdldExhc3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBicm93c2VyLCB0aGUgbGFzdCBjaGlsZCBub2RlIG1heSBiZSBhIDxCUj5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICh3aGljaCBkb2VzIG5vdCBoYXZlICdnZXRUZXh0JyBtZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gaWdub3JlIGl0IGFuZCBmaW5kIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsYXN0Q2hpbGQgJiYgIWxhc3RDaGlsZC5nZXRUZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBsYXN0Q2hpbGQuZ2V0UHJldmlvdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBsYXN0Q2hpbGQgaXMgYWxyZWFkeSBhIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobGFzdENoaWxkICYmIGxhc3RDaGlsZC4kLmhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydENvbnRhaW5lciA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVGV4dCA9IGxhc3RDaGlsZCA/IGxhc3RDaGlsZC5nZXRUZXh0KCkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHByZXZpb3VzVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExhc3QgY2hhcmFjdGVyIGlzIHRoZSBkZWxpbWl0ZXIsIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RleHQgPSB0aGlzLl9zdGFydENvbnRhaW5lci5nZXRUZXh0KCkuc3Vic3RyaW5nKDAsIG9mZnNldCAtIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RXb3JkID0gJyc7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBwcmV2aW91c1RleHQubWF0Y2goUkVHRVhfTEFTVF9XT1JEKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0V29yZCA9IG1hdGNoLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0V29yZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBsaW5rIGlzIGEgdmFsaWQgVVJMLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgaXNWYWxpZFVSTFxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmsgVGhlIGxpbmsgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgVVJMXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGxpbmsgaXMgYSB2YWxpZCBVUkwsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfaXNWYWxpZFVSTDogZnVuY3Rpb24obGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRUdFWF9VUkwudGVzdChsaW5rKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdGVucyB0byB0aGUgYGtleWRvd25gIGV2ZW50IGFuZCBpZiB0aGUga2V5Y29kZSBpcyBgQmFja3NwYWNlYCwgcmVtb3ZlcyB0aGUgcHJldmlvdXNseVxuICAgICAgICAgICAgICogY3JlYXRlZCBsaW5rLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uS2V5RG93blxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZlbnQgRXZlbnRGYWNhZGUgb2JqZWN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbktleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgIGVkaXRhYmxlLnJlbW92ZUxpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcblxuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFdmVudC5rZXlDb2RlID09PSBLRVlfQkFDSykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpbmsoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9ja0xpbmsgPSBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMaXN0ZW5zIHRvIHRoZSBgRW50ZXJgIGFuZCBgU3BhY2VgIGtleSBldmVudHMgaW4gb3JkZXIgdG8gY2hlY2sgaWYgdGhlIGxhc3Qgd29yZFxuICAgICAgICAgICAgICogaW50cm9kdWNlZCBieSB0aGUgdXNlciBzaG91bGQgYmUgcmVwbGFjZWQgYnkgYSBsaW5rIGVsZW1lbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuICAgICAgICAgICAgICogQG1ldGhvZCBfb25LZXlVcFxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZlbnQgRXZlbnRGYWNhZGUgb2JqZWN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbktleVVwOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVFdmVudCA9IGV2ZW50LmRhdGEuJDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRLZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICAgICAgICAgICAgICAgIGlmIChERUxJTUlURVJTLmluZGV4T2YodGhpcy5fY3VycmVudEtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFdvcmQgPSB0aGlzLl9nZXRMYXN0V29yZChlZGl0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkVVJMKGxhc3RXb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwbGFjZUNvbnRlbnRCeUxpbmsoZWRpdG9yLCBsYXN0V29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlcGxhY2VzIGNvbnRlbnQgYnkgYSBsaW5rIGVsZW1lbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGZpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmsjYXV0b2xpbmtBZGRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlcGxhY2VDb250ZW50QnlMaW5rXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBUaGUgdGV4dCB0aGF0IGhhcyB0byBiZSByZXBsYWNlZCBieSBhbiBsaW5rIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3JlcGxhY2VDb250ZW50QnlMaW5rOiBmdW5jdGlvbihlZGl0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IENLRURJVE9SLmRvbS5lbGVtZW50LmdldCh0aGlzLl9zdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgY29udGVudCwgc28gQ0tFRElUT1IuTGluayBjYW4gcHJvcGVybHkgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgICAgIHZhciBja0xpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuICAgICAgICAgICAgICAgIGNrTGluay5jcmVhdGUoY29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2tMaW5rID0gY2tMaW5rO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmtOb2RlID0gY2tMaW5rLmdldEZyb21TZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZmlyZSgnYXV0b2xpbmtBZGQnLCBsaW5rTm9kZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0tleUV2ZW50KGVkaXRvcik7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgcmFuZ2UgaXMgb24gdGhlIGxpbmsgYW5kIGl0IGlzIHNlbGVjdGVkLiBXZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGZvY3VzIHRvIHRoZSBjYXJldCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHVzZXIgcHJlc3NlZCBgRW50ZXJgLCBnZXQgdGhlIG5leHQgZWRpdGFibGUgbm9kZSBhdCBwb3NpdGlvbiAwLFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIGN1cnNvciBhdCB0aGUgbmV4dCBjaGFyYWN0ZXIgb2YgdGhlIGxpbmsgKHRoZSB3aGl0ZSBzcGFjZSlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEVkaXRhYmxlTm9kZSA9IHJhbmdlLmdldE5leHRFZGl0YWJsZU5vZGUoKTtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChuZXh0RWRpdGFibGVOb2RlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5leHRFZGl0YWJsZU5vZGUsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IHJhbmdlLmdldE5leHROb2RlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobmV4dE5vZGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobmV4dE5vZGUsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaXJlZCB3aGVuIGEgVVJMIGlzIGRldGVjdGVkIGluIHRleHQgYW5kIGNvbnZlcnRlZCB0byBhIGxpbmsuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGV2ZW50IENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmsjYXV0b2xpbmtBZGRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBOb2RlIG9mIHRoZSBjcmVhdGVkIGxpbmsuXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBjcmVhdGVkIGxpbmsgZWxlbWVudCwgYW5kIHJlcGxhY2VzIGl0IGJ5IGl0cyB0ZXh0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlbW92ZUxpbmtcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3JlbW92ZUxpbms6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgY2FyZXRPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgbGluaywgc28gQ0tFRElUT1IuTGluayBjYW4gcHJvcGVybHkgcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtOb2RlID0gdGhpcy5fc3RhcnRDb250YWluZXIuZ2V0TmV4dCgpIHx8IHRoaXMuX3N0YXJ0Q29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5ld1JhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQobGlua05vZGUsIDApO1xuICAgICAgICAgICAgICAgIG5ld1JhbmdlLnNldEVuZEFmdGVyKGxpbmtOb2RlKTtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NrTGluay5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBmb2N1cyB0byB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIGNhcmV0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgY2FyZXRPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN1YnNjcmliZSB0byBhIGtleSBldmVudCBvZiB0aGUgZWRpdGFibGUgYXJpYS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9zdWJzY3JpYmVUb0tleUV2ZW50XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9zdWJzY3JpYmVUb0tleUV2ZW50OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgcHJpb3JpdHkgb2Yga2V5ZG93biBsaXN0ZW5lciAtIDEgbWVhbnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgLy8gSW4gQ2hyb21lIG9uIHByZXNzaW5nIGBFbnRlcmAgdGhlIGxpc3RlbmVyIGlzIG5vdCBiZWluZyBpbnZva2VkLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vZGV2LmNrZWRpdG9yLmNvbS90aWNrZXQvMTE4NjEgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9hdXRvbGlzdCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgS0VZX0JBQ0sgPSA4O1xuXG4gICAgdmFyIEtFWV9TUEFDRSA9IDMyO1xuXG4gICAgdmFyIERFRkFVTFRfQ09ORklHID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICByZWdleDogL15cXCokLyxcbiAgICAgICAgICAgIHR5cGU6ICdidWxsZXRlZGxpc3QnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlZ2V4OiAvXjFcXC4kLyxcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXJlZGxpc3QnXG4gICAgICAgIH1cbiAgICBdO1xuXG5cdC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBvcmRlcmVkL3Vub3JkZXJlZCBsaXN0IHdoZW4gdXNlciB0eXBlcyB0ZXh0IHdoaWNoIGxvb2tzIGxpa2UgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3RcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX2F1dG9saXN0Jywge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tlZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGBrZXlkb3duYCBldmVudCBvbiB0aGUgY29udGVudCBlZGl0aW5nIGFyZWEuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2tzIGZvciBwcmVzc2luZyB0aGUgYEJhY2tzcGFjZWAga2V5IGluIG9yZGVyIHRvIHVuZG8gdGhlIGxpc3QgY3JlYXRpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAgICAgICAgICogQG1ldGhvZCBfY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2NoZWNrRm9yQmFja3NwYWNlQW5kVW5kbzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVFdmVudCA9IGV2ZW50LmRhdGEuJDtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUucmVtb3ZlTGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9CQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgndW5kbycpO1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5zZXJ0SHRtbChldmVudC5saXN0ZW5lckRhdGEuYnVsbGV0ICsgJyZuYnNwOycpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgY3VycmVudCBsaW5lIHRvIGZpbmQgbWF0Y2ggd2l0aCBNQVRDSEVTIG9iamVjdCB0byBjcmVhdGUgT0wgb3IgVUwuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuICAgICAgICAgICAgICogQG1ldGhvZCBfY2hlY2tMaW5lXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2VkaXRvcn0gRWRpdG9yIG9iamVjdFxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBkZXRlY3RlZCBsaXN0IGNvbmZpZyBpZiBhbnlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2dldExpc3RDb25maWc6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWdSZWdleCA9IGVkaXRvci5jb25maWcuYXV0b2xpc3QgfHwgREVGQVVMVF9DT05GSUc7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lci5nZXRUZXh0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYnVsbGV0ID0gdGV4dENvbnRhaW5lci5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZyhyYW5nZS5zdGFydE9mZnNldCwgdGV4dENvbnRhaW5lci5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciByZWdleExlbiA9IGNvbmZpZ1JlZ2V4Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHZhciBhdXRvbGlzdENmZyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIWF1dG9saXN0Q2ZnICYmIHJlZ2V4TGVuID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4SXRlbSA9IGNvbmZpZ1JlZ2V4W2luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhJdGVtLnJlZ2V4LnRlc3QoYnVsbGV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b2xpc3RDZmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0OiBidWxsZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZWdleEl0ZW0udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhdXRvbGlzdENmZztcbiAgICAgICAgICAgIH0sXG5cblx0XHRcdC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGxpc3Qgd2l0aCBkaWZmZXJlbnQgdHlwZXM6IEJ1bGxldGVkIG9yIE51bWJlcmVkIGxpc3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9jcmVhdGVMaXN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGlzdENvbmZpZyBPYmplY3QgdGhhdCBjb250YWlucyBidWxsZXQsIHRleHQgYW5kIHR5cGUgZm9yIGNyZWF0aW5nIHRoZSBsaXN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG5cdFx0XHQgKi9cbiAgICAgICAgICAgIF9jcmVhdGVMaXN0OiBmdW5jdGlvbihsaXN0Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IGxpc3RDb25maWcuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyLnNldFRleHQobGlzdENvbmZpZy50ZXh0KTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQobGlzdENvbmZpZy50eXBlKTtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGtleWRvd24gaW4gb3JkZXIgdG8gY2hlY2sgaWYgdGhlIG5leHQga2V5IHByZXNzIGlzIGBCYWNrc3BhY2VgLlxuICAgICAgICAgICAgICAgIC8vIElmIHNvLCB0aGUgY3JlYXRpb24gb2YgdGhlIGxpc3Qgd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdrZXlkb3duJywgdGhpcy5fY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBidWxsZXQ6IGxpc3RDb25maWcuYnVsbGV0XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9LFxuXG5cdFx0XHQvKipcbiAgICAgICAgICAgICAqIExpc3RlbnMgdG8gdGhlIGBTcGFjZWAga2V5IGV2ZW50cyB0byBjaGVjayBpZiB0aGUgbGFzdCB3b3JkXG4gICAgICAgICAgICAgKiBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyIHNob3VsZCBiZSByZXBsYWNlZCBieSBhIGxpc3QgKE9MIG9yIFVMKVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3RcbiAgICAgICAgICAgICAqIEBtZXRob2QgX29uS2V5RG93blxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vbktleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9TUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdENvbmZpZyA9IHRoaXMuX2dldExpc3RDb25maWcoZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxpc3QobGlzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblx0KTtcbn0oKSk7IiwiLyoqXG4gKiBDS0VkaXRvciBwbHVnaW46IERyYWdhYmxlIGltYWdlIHJlc2l6aW5nXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3N0dXIvY2stZHJhZ3Jlc2l6ZVxuICogLSBTaG93cyBzZW1pLXRyYW5zcGFyZW50IG92ZXJsYXkgd2hpbGUgcmVzaXppbmdcbiAqIC0gRW5mb3JjZXMgQXNwZWN0IFJhdGlvICh1bmxlc3MgaG9sZGluZyBzaGlmdClcbiAqIC0gU25hcCB0byBzaXplIG9mIG90aGVyIGltYWdlcyBpbiBlZGl0b3JcbiAqIC0gRXNjYXBlIHdoaWxlIGRyYWdnaW5nIGNhbmNlbHMgcmVzaXplXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2RyYWdyZXNpemUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIElNQUdFX0hBTkRMRVMgPSB7XG4gICAgICAgIGJvdGg6IFsndGwnLCAndG0nLCAndHInLCAnbG0nLCAncm0nLCAnYmwnLCAnYm0nLCAnYnInXSxcbiAgICAgICAgaGVpZ2h0OiBbJ3RsJywgJ3RtJywgJ3RyJywgJ2JsJywgJ2JtJywgJ2JyJ10sXG4gICAgICAgIHNjYWxlOiBbJ3RsJywgJ3RyJywgJ2JsJywgJ2JyJ10sXG4gICAgICAgIHdpZHRoOiBbJ3RsJywgJ3RyJywgJ2xtJywgJ3JtJywgJ2JsJywgJ2JyJ10sXG4gICAgfTtcblxuICAgIHZhciBQT1NJVElPTl9FTEVNRU5UX0ZOID0ge1xuICAgICAgICBibDogZnVuY3Rpb24oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KGhhbmRsZSwgLTMgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBNYXRoLnJvdW5kKGJveC53aWR0aCAvIDIpIC0gMyArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgYnI6IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCAtMyArIGxlZnQsIE1hdGgucm91bmQoYm94LmhlaWdodCAvIDIpIC0gMyArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRsOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBsZWZ0IC0gMywgdG9wIC0gMyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBNYXRoLnJvdW5kKGJveC53aWR0aCAvIDIpIC0gMyArIGxlZnQsIC0zICsgdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHI6IGZ1bmN0aW9uKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCAtMyArIHRvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJtOiBmdW5jdGlvbihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG4gICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBib3gud2lkdGggLSA0ICsgbGVmdCwgTWF0aC5yb3VuZChib3guaGVpZ2h0IC8gMikgLSAzICsgdG9wKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgSU1BR0VfU05BUF9UT19TSVpFID0gNztcblxuICAgIHZhciBpc0ZpcmVmb3ggPSAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG5cbiAgICB2YXIgaXNXZWJLaXQgPSAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG5cbiAgICB2YXIgZW5hYmxlUGx1Z2luID0gaXNXZWJLaXQgfHwgaXNGaXJlZm94O1xuXG4gICAgaWYgKGVuYWJsZVBsdWdpbikge1xuICAgICAgICAvLyBDU1MgaXMgYWRkZWQgaW4gYSBjb21wcmVzc2VkIGZvcm1cbiAgICAgICAgQ0tFRElUT1IuYWRkQ3NzKCdpbWc6OnNlbGVjdGlvbntjb2xvcjpyZ2JhKDAsMCwwLDApfWltZy5ja2ltZ3JzentvdXRsaW5lOjFweCBkYXNoZWQgIzAwMH0jY2tpbWdyc3p7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MDtoZWlnaHQ6MDtjdXJzb3I6ZGVmYXVsdDt6LWluZGV4OjEwMDAxfSNja2ltZ3JzeiBzcGFue2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MDtoZWlnaHQ6MDtiYWNrZ3JvdW5kLXNpemU6MTAwJSAxMDAlO29wYWNpdHk6LjY1O291dGxpbmU6MXB4IGRhc2hlZCAjMDAwfSNja2ltZ3JzeiBpe3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NXB4O2hlaWdodDo1cHg7YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzAwMH0jY2tpbWdyc3ogaS5hY3RpdmUsI2NraW1ncnN6IGk6aG92ZXJ7YmFja2dyb3VuZDojMDAwfSNja2ltZ3JzeiBpLmJyLCNja2ltZ3JzeiBpLnRse2N1cnNvcjpud3NlLXJlc2l6ZX0jY2tpbWdyc3ogaS5ibSwjY2tpbWdyc3ogaS50bXtjdXJzb3I6bnMtcmVzaXplfSNja2ltZ3JzeiBpLmJsLCNja2ltZ3JzeiBpLnRye2N1cnNvcjpuZXN3LXJlc2l6ZX0jY2tpbWdyc3ogaS5sbSwjY2tpbWdyc3ogaS5ybXtjdXJzb3I6ZXctcmVzaXplfWJvZHkuZHJhZ2dpbmctYnIsYm9keS5kcmFnZ2luZy1iciAqLGJvZHkuZHJhZ2dpbmctdGwsYm9keS5kcmFnZ2luZy10bCAqe2N1cnNvcjpud3NlLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibSxib2R5LmRyYWdnaW5nLWJtICosYm9keS5kcmFnZ2luZy10bSxib2R5LmRyYWdnaW5nLXRtICp7Y3Vyc29yOm5zLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibCxib2R5LmRyYWdnaW5nLWJsICosYm9keS5kcmFnZ2luZy10cixib2R5LmRyYWdnaW5nLXRyICp7Y3Vyc29yOm5lc3ctcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWxtLGJvZHkuZHJhZ2dpbmctbG0gKixib2R5LmRyYWdnaW5nLXJtLGJvZHkuZHJhZ2dpbmctcm0gKntjdXJzb3I6ZXctcmVzaXplIWltcG9ydGFudH0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2RyYWdyZXNpemUnLCB7XG4gICAgICAgIG9uTG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZVBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZVBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICBpbml0KGVkaXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaW5pdChlZGl0b3IpIHtcbiAgICAgICAgdmFyIHdpbmRvdyA9IGVkaXRvci53aW5kb3cuJCxcbiAgICAgICAgICAgIGRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50LiQ7XG5cbiAgICAgICAgaWYgKGlzRmlyZWZveCkge1xuICAgICAgICAgICAgLy8gRGlzYWJsZSB0aGUgbmF0aXZlIGltYWdlIHJlc2l6aW5nXG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNuYXBUb1NpemUgPSAodHlwZW9mIElNQUdFX1NOQVBfVE9fU0laRSA9PT0gJ3VuZGVmaW5lZCcpID8gbnVsbCA6IElNQUdFX1NOQVBfVE9fU0laRTtcblxuICAgICAgICBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUgPSBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUgfHwgJ2JvdGgnO1xuXG4gICAgICAgIHZhciByZXNpemVyID0gbmV3IFJlc2l6ZXIoZWRpdG9yLCB7XG4gICAgICAgICAgICBpbWFnZVNjYWxlUmVzaXplOiBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUsXG4gICAgICAgICAgICBzbmFwVG9TaXplOiBzbmFwVG9TaXplXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtb3VzZURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChyZXNpemVyLmlzSGFuZGxlKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaW5pdERyYWcoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duTGlzdGVuZXIsIGZhbHNlKTtcblxuICAgICAgICBmdW5jdGlvbiBzZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgYW4gZWxlbWVudCBpcyBzZWxlY3RlZCBhbmQgdGhhdCBlbGVtZW50IGlzIGFuIElNR1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5nZXRUeXBlKCkgIT09IENLRURJVE9SLlNFTEVDVElPTl9OT05FICYmIHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKS5pcygnaW1nJykpIHtcbiAgICAgICAgICAgICAgICAvLyBBbmQgd2UncmUgbm90IHJpZ2h0IG9yIG1pZGRsZSBjbGlja2luZyBvbiB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5ldmVudCB8fCAhd2luZG93LmV2ZW50LmJ1dHRvbiB8fCB3aW5kb3cuZXZlbnQuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZXIuc2hvdyhzZWxlY3Rpb24uZ2V0U3RhcnRFbGVtZW50KCkuJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNpemVyLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5vbignc2VsZWN0aW9uQ2hhbmdlJywgc2VsZWN0aW9uQ2hhbmdlKTtcblxuICAgICAgICBlZGl0b3Iub24oJ2dldERhdGEnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGUuZGF0YS5kYXRhVmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC88ZGl2IGlkPVwiY2tpbWdyc3pcIihbXFxzXFxTXSo/KTxcXC9kaXY+L2ksICcnKTtcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcYihja2ltZ3JzeilcXGIvZywgJycpO1xuICAgICAgICAgICAgZS5kYXRhLmRhdGFWYWx1ZSA9IGh0bWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5vbignYmVmb3JlVW5kb0ltYWdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGhhbmRsZXMgYmVmb3JlIHVuZG8gaW1hZ2VzIGFyZSBzYXZlZFxuICAgICAgICAgICAgcmVzaXplci5oaWRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5vbignYWZ0ZXJVbmRvSW1hZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGhhbmRsZXMgYWZ0ZXIgdW5kbyBpbWFnZXMgYXJlIHNhdmVkXG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGhhbmRsZXMgd2hlbiBlZGl0b3IgbG9zZXMgZm9jdXNcbiAgICAgICAgICAgIHJlc2l6ZXIuaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlZGl0b3Iub24oJ2JlZm9yZU1vZGVVbmxvYWQnLCBmdW5jdGlvbiBzZWxmKCkge1xuICAgICAgICAgICAgZWRpdG9yLnJlbW92ZUxpc3RlbmVyKCdiZWZvcmVNb2RlVW5sb2FkJywgc2VsZik7XG4gICAgICAgICAgICByZXNpemVyLmhpZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzaXplRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdja2ltZ3JzeicpO1xuXG4gICAgICAgICAgICBpZiAocmVzaXplRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0ZpcmVmb3gpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgcmVzaXplZFxuICAgICAgICB2YXIgcmVzaXplVGltZW91dDtcbiAgICAgICAgZWRpdG9yLndpbmRvdy5vbigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgYW55IHJlc2l6ZSB3YWl0aW5nIHRvIGhhcHBlblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICAgICAgLy8gRGVsYXkgcmVzaXplIHRvIFwiZGVib3VuY2VcIlxuICAgICAgICAgICAgcmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoc2VsZWN0aW9uQ2hhbmdlLCA1MCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlc2l6ZXIoZWRpdG9yLCBjZmcpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMud2luZG93ID0gZWRpdG9yLndpbmRvdy4kO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50LiQ7XG4gICAgICAgIHRoaXMuY2ZnID0gY2ZnIHx8IHt9O1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBSZXNpemVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICBjb250YWluZXIuaWQgPSAnY2tpbWdyc3onO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3KTtcblxuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXMgPSB7fTtcblxuICAgICAgICAgICAgSU1BR0VfSEFORExFU1t0aGlzLmNmZy5pbWFnZVNjYWxlUmVzaXplXS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOYW1lLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXNbaGFuZGxlTmFtZV0gPSBpbnN0YW5jZS5oYW5kbGVzW2hhbmRsZU5hbWVdID0gaW5zdGFuY2UuY3JlYXRlSGFuZGxlKGhhbmRsZU5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoYW5kbGVzW25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlSGFuZGxlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGlzSGFuZGxlOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIGhhbmRsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlc1tuXSA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBzaG93OiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2ZnLnNuYXBUb1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm90aGVySW1hZ2VzID0gdG9BcnJheSh0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vdGhlckltYWdlcy5zcGxpY2UodGhpcy5vdGhlckltYWdlcy5pbmRleE9mKGVsKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5ib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgZWwpO1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KHRoaXMuY29udGFpbmVyLCBib3gubGVmdCwgYm94LnRvcCk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdja2ltZ3JzeicpO1xuICAgICAgICAgICAgdGhpcy5zaG93SGFuZGxlcygpO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjbGFzcyBmcm9tIGFsbCBpbWcuY2tpbWdyc3pcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2tpbWdyc3onKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdja2ltZ3JzeicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oaWRlSGFuZGxlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdERyYWc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vcmlnaHQtY2xpY2sgb3IgbWlkZGxlLWNsaWNrXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc2l6ZXIgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRyYWcgPSBuZXcgRHJhZ0V2ZW50KHRoaXMud2luZG93LCB0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgICAgIGRyYWcub25TdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuc2hvd1ByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICByZXNpemVyLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkcmFnLm9uRHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuY2FsY3VsYXRlU2l6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXNpemVyLnVwZGF0ZVByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICB2YXIgYm94ID0gcmVzaXplci5wcmV2aWV3Qm94O1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIudXBkYXRlSGFuZGxlcyhib3gsIGJveC5sZWZ0LCBib3gudG9wKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkcmFnLm9uUmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXIuaGlkZVByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICByZXNpemVyLmhpZGUoKTtcbiAgICAgICAgICAgICAgICByZXNpemVyLmVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGFuIHVuZG8gc25hcHNob3QgYmVmb3JlIHRoZSBpbWFnZSBpcyBwZXJtYW5lbnRseSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgcmVzaXplci5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZHJhZy5vbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplci5yZXNpemVDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgYW5vdGhlciBzbmFwc2hvdCBhZnRlciB0aGUgaW1hZ2UgaXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHJlc2l6ZXIuZWRpdG9yLmZpcmUoJ3NhdmVTbmFwc2hvdCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRyYWcuc3RhcnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUhhbmRsZXM6IGZ1bmN0aW9uKGJveCwgbGVmdCwgdG9wKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCB8fCAwO1xuICAgICAgICAgICAgdG9wID0gdG9wIHx8IDA7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcztcblxuICAgICAgICAgICAgZm9yICh2YXIgaGFuZGxlIGluIGhhbmRsZXMpIHtcbiAgICAgICAgICAgICAgICBQT1NJVElPTl9FTEVNRU5UX0ZOW2hhbmRsZV0oaGFuZGxlc1toYW5kbGVdLCBsZWZ0LCB0b3AsIGJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVzKHRoaXMuYm94KTtcbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXNbbl0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBoYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlc1tuXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG93UHJldmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB0aGlzLmVsLnNyYyArICdcIiknO1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVTaXplKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcoKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlUHJldmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5wcmV2aWV3Qm94O1xuICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50KHRoaXMucHJldmlldywgYm94LmxlZnQsIGJveC50b3ApO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnN0eWxlLndpZHRoID0gdGhpcy5wcmV2aWV3Qm94LndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zdHlsZS5oZWlnaHQgPSB0aGlzLnByZXZpZXdCb3guaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZVByZXZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGJveCA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCB0aGlzLnByZXZpZXcpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJveC5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY3VsYXRlU2l6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGJveCA9IHRoaXMucHJldmlld0JveCA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5ib3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmJveC5oZWlnaHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgYXR0ciA9IGRhdGEudGFyZ2V0LmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgaWYgKH5hdHRyLmluZGV4T2YoJ3InKSkge1xuICAgICAgICAgICAgICAgIGJveC53aWR0aCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC53aWR0aCArIGRhdGEuZGVsdGEueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZignYicpKSB7XG4gICAgICAgICAgICAgICAgYm94LmhlaWdodCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC5oZWlnaHQgKyBkYXRhLmRlbHRhLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKH5hdHRyLmluZGV4T2YoJ2wnKSkge1xuICAgICAgICAgICAgICAgIGJveC53aWR0aCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC53aWR0aCAtIGRhdGEuZGVsdGEueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZigndCcpKSB7XG4gICAgICAgICAgICAgICAgYm94LmhlaWdodCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC5oZWlnaHQgLSBkYXRhLmRlbHRhLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiBkcmFnZ2luZyBjb3JuZXIsIGVuZm9yY2UgYXNwZWN0IHJhdGlvICh1bmxlc3Mgc2hpZnQga2V5IGlzIGJlaW5nIGhlbGQpXG4gICAgICAgICAgICBpZiAoYXR0ci5pbmRleE9mKCdtJykgPCAwICYmICFkYXRhLmtleXMuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLmJveC53aWR0aCAvIHRoaXMuYm94LmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYm94LndpZHRoIC8gYm94LmhlaWdodCA+IHJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIGJveC5oZWlnaHQgPSBNYXRoLnJvdW5kKGJveC53aWR0aCAvIHJhdGlvKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib3gud2lkdGggPSBNYXRoLnJvdW5kKGJveC5oZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc25hcFRvU2l6ZSA9IHRoaXMuY2ZnLnNuYXBUb1NpemU7XG5cbiAgICAgICAgICAgIGlmIChzbmFwVG9TaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVycyA9IHRoaXMub3RoZXJJbWFnZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gZ2V0Qm91bmRpbmdCb3godGhpcy53aW5kb3csIG90aGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhib3gud2lkdGggLSBvdGhlci53aWR0aCkgPD0gc25hcFRvU2l6ZSAmJiBNYXRoLmFicyhib3guaGVpZ2h0IC0gb3RoZXIuaGVpZ2h0KSA8PSBzbmFwVG9TaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3gud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveC5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9yZWNhbGN1bGF0ZSBsZWZ0IG9yIHRvcCBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKH5hdHRyLmluZGV4T2YoJ2wnKSkge1xuICAgICAgICAgICAgICAgIGJveC5sZWZ0ID0gdGhpcy5ib3gud2lkdGggLSBib3gud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAofmF0dHIuaW5kZXhPZigndCcpKSB7XG4gICAgICAgICAgICAgICAgYm94LnRvcCA9IHRoaXMuYm94LmhlaWdodCAtIGJveC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2l6ZUNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc2l6ZUVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmVsLCB0aGlzLnJlc3VsdC53aWR0aCwgdGhpcy5yZXN1bHQuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBEcmFnRXZlbnQod2luZG93LCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIG1vdXNlbW92ZTogYmluZCh0aGlzLm1vdXNlbW92ZSwgdGhpcyksXG4gICAgICAgICAgICBrZXlkb3duOiBiaW5kKHRoaXMua2V5ZG93biwgdGhpcyksXG4gICAgICAgICAgICBtb3VzZXVwOiBiaW5kKHRoaXMubW91c2V1cCwgdGhpcylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBEcmFnRXZlbnQucHJvdG90eXBlID0ge1xuICAgICAgICBzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmF0dHIgPSBlLnRhcmdldC5jbGFzc05hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0ge1xuICAgICAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShlKTtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZlbnRzLm1vdXNlbW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnRzLmtleWRvd24sIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50cy5tb3VzZXVwLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZHJhZ2dpbmctJyArIHRoaXMuYXR0cik7XG4gICAgICAgICAgICB0aGlzLm9uU3RhcnQgJiYgdGhpcy5vblN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9zID0ge1xuICAgICAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0ge1xuICAgICAgICAgICAgICAgIHg6IGUuY2xpZW50WCAtIHRoaXMuc3RhcnRQb3MueCxcbiAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFkgLSB0aGlzLnN0YXJ0UG9zLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmtleXMgPSB7XG4gICAgICAgICAgICAgICAgc2hpZnQ6IGUuc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgICAgIGFsdDogZS5hbHRLZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoZSk7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZyAmJiB0aGlzLm9uRHJhZygpO1xuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvL21vdXNlIGJ1dHRvbiByZWxlYXNlZCBvdXRzaWRlIHdpbmRvdzsgbW91c2V1cCB3YXNuJ3QgZmlyZWQgKENocm9tZSlcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNldXAoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGtleWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vZXNjYXBlIGtleSBjYW5jZWxzIGRyYWdnaW5nXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShlKTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlICYmIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnZ2luZy0nICsgdGhpcy5hdHRyKTtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZlbnRzLm1vdXNlbW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnRzLmtleWRvd24sIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50cy5tb3VzZXVwLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLm9uUmVsZWFzZSAmJiB0aGlzLm9uUmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vaGVscGVyIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoLFxuICAgICAgICAgICAgYXJyID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IG9ialtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmQoZm4sIGN0eCkge1xuICAgICAgICBpZiAoZm4uYmluZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmJpbmQoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpb25FbGVtZW50KGVsLCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IFN0cmluZyhsZWZ0KSArICdweCc7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IFN0cmluZyh0b3ApICsgJ3B4JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVFbGVtZW50KGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBpbWFnZVNjYWxlUmVzaXplID0gdGhpcy5lZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemU7XG4gICAgICAgIGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gU3RyaW5nKHdpZHRoKSArICdweCc7XG4gICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBTdHJpbmcoaGVpZ2h0KSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ3dpZHRoJyB8fCBpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IFN0cmluZyh3aWR0aCkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBTdHJpbmcoaGVpZ2h0KSArICdweCc7XG4gICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9ICdhdXRvJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KHdpbmRvdywgZWwpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuIiwiLyoqXG4gKiBDS0VkaXRvciBwbHVnaW46IEltYWdlMlxuICogLSBTaG93IGdyaXBwZXIgdG8gcmVzaXplIGltYWdlcyBvbiBJRVxuICovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfZHJhZ3Jlc2l6ZV9pZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWxpZ25tZW50c09iaiA9IHtcbiAgICAgICAgY2VudGVyOiAxLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMlxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFNldCBjdXJzb3IgY3NzIGRlcGVuZCBvbiBpbWFnZVNjYWxlUmVzaXplIGNvbmZpZ1xuICAgICAqKi9cblxuICAgIHZhciBjdXJzb3IgPSB7XG4gICAgICAgIGJvdGg6ICdud3NlLXJlc2l6ZScsXG4gICAgICAgIGhlaWdodDogJ25zLXJlc2l6ZScsXG4gICAgICAgIHNjYWxlOiAnbndzZS1yZXNpemUnLFxuICAgICAgICB3aWR0aDogJ2V3LXJlc2l6ZScsXG4gICAgfTtcblxuICAgIHZhciByZWdleFBlcmNlbnQgPSAvXlxccyooXFxkK1xcJSlcXHMqJC9pO1xuXG4gICAgdmFyIHRlbXBsYXRlID0gJzxpbWcgYWx0PVwiXCIgc3JjPVwiXCIgLz4nO1xuXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2RyYWdyZXNpemVfaWUnLCB7XG4gICAgICAgIGhpZHBpOiB0cnVlLFxuXG4gICAgICAgIGljb25zOiAnaW1hZ2UnLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHdpZGdldERlZihlZGl0b3IpO1xuXG4gICAgICAgICAgICAvLyBSZWdpc3RlciB0aGUgd2lkZ2V0LlxuICAgICAgICAgICAgZWRpdG9yLndpZGdldHMuYWRkKCdpbWFnZScsIGltYWdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIENLRURJVE9SLmFkZENzcyhcbiAgICAgICAgICAgICAgICAnLmNrZV9pbWFnZV9yZXNpemVyX253c2UtcmVzaXpleycgK1xuICAgICAgICAgICAgICAgICdjdXJzb3I6IG53c2UtcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplcl9ucy1yZXNpemV7JyArXG4gICAgICAgICAgICAgICAgJ2N1cnNvcjogbnMtcmVzaXplOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplcl9ud3NlLXJlc2l6ZXsnICtcbiAgICAgICAgICAgICAgICAnY3Vyc29yOiBud3NlLXJlc2l6ZTsnICtcbiAgICAgICAgICAgICAgICAnfScgK1xuICAgICAgICAgICAgICAgICcuY2tlX2ltYWdlX3Jlc2l6ZXJfZXctcmVzaXpleycgK1xuICAgICAgICAgICAgICAgICdjdXJzb3I6IGV3LXJlc2l6ZTsnICtcbiAgICAgICAgICAgICAgICAnfScgK1xuICAgICAgICAgICAgICAgICcuY2tlX2ltYWdlX25vY2FwdGlvbnsnICtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHJlbW92ZSB1bndhbnRlZCBzcGFjZSBzbyByZXNpemVcbiAgICAgICAgICAgICAgICAvLyB3cmFwcGVyIGlzIGRpc3BsYXllZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAnbGluZS1oZWlnaHQ6MCcgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2VfaW1hZ2VfcmVzaXplcnsnICtcbiAgICAgICAgICAgICAgICAnZGlzcGxheTpub25lOycgK1xuICAgICAgICAgICAgICAgICdwb3NpdGlvbjphYnNvbHV0ZTsnICtcbiAgICAgICAgICAgICAgICAnd2lkdGg6MTBweDsnICtcbiAgICAgICAgICAgICAgICAnaGVpZ2h0OjEwcHg7JyArXG4gICAgICAgICAgICAgICAgJ2JvdHRvbTotNXB4OycgK1xuICAgICAgICAgICAgICAgICdyaWdodDotNXB4OycgK1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kOiMwMDA7JyArXG4gICAgICAgICAgICAgICAgJ291dGxpbmU6MXB4IHNvbGlkICNmZmY7JyArXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkcmFnIGhhbmRsZXIgZnJvbSBiZWluZyBtaXNwbGFjZWQgKCMxMTIwNykuXG4gICAgICAgICAgICAgICAgJ2xpbmUtaGVpZ2h0OjA7JyArXG4gICAgICAgICAgICAgICAgJ2N1cnNvcjpud3NlLXJlc2l6ZTsnICtcbiAgICAgICAgICAgICAgICAnfScgK1xuICAgICAgICAgICAgICAgICcuY2tlX2ltYWdlX3Jlc2l6ZXJfd3JhcHBlcnsnICtcbiAgICAgICAgICAgICAgICAncG9zaXRpb246cmVsYXRpdmU7JyArXG4gICAgICAgICAgICAgICAgJ2Rpc3BsYXk6aW5saW5lLWJsb2NrOycgK1xuICAgICAgICAgICAgICAgICdsaW5lLWhlaWdodDowOycgK1xuICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgJy5ja2Vfd2lkZ2V0X3dyYXBwZXI6aG92ZXIgLmNrZV9pbWFnZV9yZXNpemVyLCcgK1xuICAgICAgICAgICAgICAgICcuY2tlX2ltYWdlX3Jlc2l6ZXIuY2tlX2ltYWdlX3Jlc2l6aW5neycgK1xuICAgICAgICAgICAgICAgICdkaXNwbGF5OmJsb2NrJyArXG4gICAgICAgICAgICAgICAgJ30nXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlcXVpcmVzOiAnd2lkZ2V0J1xuICAgIH0pO1xuXG4gICAgLy8gV2lnZXQgc3RhdGVzIChmb3JtcykgZGVwZW5kaW5nIG9uIGFsaWdubWVudCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAvL1xuICAgIC8vIE5vbi1jYXB0aW9uZWQgd2lkZ2V0IChpbmxpbmUgc3R5bGVzKVxuICAgIC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJub25lICDilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnT4gICDilII8aW1nIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0gLz4gICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgICAvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxwIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPuKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPHAgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+IOKUgiAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiAgIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnT4gIOKUgjxpbWcgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0gLz4gIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgIC8vXG4gICAgLy8gTm9uLWNhcHRpb25lZCB3aWRnZXQgKGNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzIGRlZmluZWQpXG4gICAgLy8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgIC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBjbGFzcz3igJ1sZWZ04oCdPiAgICAgICAgIOKUgjxpbWcgY2xhc3M94oCdbGVmdOKAnSAvPiAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPHAgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8cCBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCICAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIGNsYXNzPeKAnXJpZ2h04oCdPiAgICAgICAg4pSCPGltZyBjbGFzcz3igJ1yaWdodOKAnSAvPiAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgIC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgLy9cbiAgICAvLyBDYXB0aW9uZWQgd2lkZ2V0IChpbmxpbmUgc3R5bGVzKVxuICAgIC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdPiAgICAgICAgICAgIOKUgjxmaWd1cmUgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnSAvPiAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlciBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4gICAgIOKUgjxkaXYgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+ICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIHN0eWxlPeKAnWRpc3BsYXk6aW5saW5lLWJsb2Nr4oCdIC8+4pSCIDxmaWd1cmUgc3R5bGU94oCdZGlzcGxheTppbmxpbmUtYmxvY2vigJ0gLz7ilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdPiAgICAgICAgICAg4pSCPGZpZ3VyZSBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnSAvPiAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgLy9cbiAgICAvLyBDYXB0aW9uZWQgd2lkZ2V0IChjb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcyBkZWZpbmVkKVxuICAgIC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICAvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICAgLy8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBjbGFzcz3igJ1sZWZ04oCdPiAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgY2xhc3M94oCdbGVmdOKAnSAvPiAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlciBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAgICAgIOKUgjxkaXYgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAgIC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBjbGFzcz3igJ1yaWdodOKAnT4gICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgY2xhc3M94oCdcmlnaHTigJ0gLz4gICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgLy8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG4gICAgLy8gQHJldHVybnMge09iamVjdH1cbiAgICBmdW5jdGlvbiB3aWRnZXREZWYoZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSA9IGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSB8fCAnYm90aCc7XG5cbiAgICAgICAgZWRpdG9yLm9uKCdpbWFnZUFkZCcsIGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgICAgIGVkaXRvci53aWRnZXRzLmluaXRPbihpbWFnZURhdGEuZGF0YS5lbCwgJ2ltYWdlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXM7XG5cbiAgICAgICAgdmFyIGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3M7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVscGVycyA9IENLRURJVE9SLnBsdWdpbnMuaW1hZ2UyO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5wYXJ0cy5pbWFnZTtcblxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBhbHQ6IGltYWdlLmdldEF0dHJpYnV0ZSgnYWx0JykgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIGhhc0NhcHRpb246ICEhdGhpcy5wYXJ0cy5jYXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGltYWdlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIC8vIExvY2sgcmF0aW8gaXMgb24gYnkgZGVmYXVsdCAoIzEwODMzKS5cbiAgICAgICAgICAgICAgICAgICAgbG9jazogdGhpcy5yZWFkeSA/IGhlbHBlcnMuY2hlY2tIYXNOYXR1cmFsUmF0aW8oaW1hZ2UpIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3NyYycpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW1hZ2UuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8ICcnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHVzZWQgJ2EnIGluIHdpZGdldCNwYXJ0cyBkZWZpbml0aW9uLCBpdCBjb3VsZCBoYXBwZW4gdGhhdFxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGVkIGVsZW1lbnQgaXMgYSBjaGlsZCBvZiB3aWRnZXQucGFydHMjY2FwdGlvbi4gU2luY2UgdGhlcmUncyBubyBjbGV2ZXJcbiAgICAgICAgICAgICAgICAvLyB3YXkgdG8gc29sdmUgaXQgd2l0aCBDU1Mgc2VsZWN0b3JzLCBpdCdzIGRvbmUgbGlrZSB0aGF0LiAoIzExNzgzKS5cbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IGltYWdlLmdldEFzY2VuZGFudCgnYScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgJiYgdGhpcy53cmFwcGVyLmNvbnRhaW5zKGxpbmspKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMubGluayA9IGxpbms7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIGNvbmZpZ3VyYXRpb24sIHJlYWQgc3R5bGUvY2xhc3MgZnJvbSBlbGVtZW50IGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gcmVtb3ZlIGl0LiBSZW1vdmVkIHN0eWxlL2NsYXNzIHdpbGwgYmUgc2V0IG9uIHdyYXBwZXIgaW4gI2RhdGEgbGlzdGVuZXIuXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogQ2VudGVyIGFsaWdubWVudCBpcyBkZXRlY3RlZCBkdXJpbmcgdXBjYXN0LCBzbyBvbmx5IGxlZnQvcmlnaHQgY2FzZXNcbiAgICAgICAgICAgICAgICAvLyBhcmUgY2hlY2tlZCBiZWxvdy5cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuYWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWduRWxlbWVudCA9IGRhdGEuaGFzQ2FwdGlvbiA/IHRoaXMuZWxlbWVudCA6IGltYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIGluaXRpYWwgbGVmdC9yaWdodCBhbGlnbm1lbnQgZnJvbSB0aGUgY2xhc3Mgc2V0IG9uIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbkNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbkVsZW1lbnQuaGFzQ2xhc3MoYWxpZ25DbGFzc2VzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFsaWduRWxlbWVudC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25FbGVtZW50LnJlbW92ZUNsYXNzKGFsaWduQ2xhc3Nlc1thbGlnbm1lbnRzT2JqW2RhdGEuYWxpZ25dXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYWxpZ24gPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBpbml0aWFsIGZsb2F0IHN0eWxlIGZyb20gZmlndXJlL2ltYWdlIGFuZCB0aGVuIHJlbW92ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFsaWduID0gYWxpZ25FbGVtZW50LmdldFN0eWxlKCdmbG9hdCcpIHx8ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduRWxlbWVudC5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCByaWQgb2YgZXh0cmEgdmVydGljYWwgc3BhY2Ugd2hlbiB0aGVyZSdzIG5vIGNhcHRpb24uXG4gICAgICAgICAgICAgICAgLy8gSXQgd2lsbCBpbXByb3ZlIHRoZSBsb29rIG9mIHRoZSByZXNpemVyLlxuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlclsoZGF0YS5oYXNDYXB0aW9uID8gJ3JlbW92ZScgOiAnYWRkJykgKyAnQ2xhc3MnXSgnY2tlX2ltYWdlX25vY2FwdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXREYXRhKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5jb25maWcuaW1hZ2UyX2Rpc2FibGVSZXNpemVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplcih0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuICAgICAgICAgICAgLy8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNhZGRDbGFzc1xuICAgICAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhbGxvd2VkQ29udGVudDogZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQoZWRpdG9yKSxcblxuICAgICAgICAgICAgLy8gVGhpcyB3aWRnZXQgY29udmVydHMgc3R5bGUtZHJpdmVuIGRpbWVuc2lvbnMgdG8gYXR0cmlidXRlcy5cbiAgICAgICAgICAgIGNvbnRlbnRUcmFuc2Zvcm1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBbJ2ltZ1t3aWR0aF06IHNpemVUb0F0dHJpYnV0ZSddXG4gICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcblxuICAgICAgICAgICAgICAgIC8vIEltYWdlIGNhbid0IGJlIGNhcHRpb25lZCB3aGVuIGZpZ2NhcHRpb24gaXMgZGlzYWxsb3dlZCAoIzExMDA0KS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhhc0NhcHRpb24gJiYgIWVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmNhcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5oYXNDYXB0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSW1hZ2UgY2FuJ3QgYmUgYWxpZ25lZCB3aGVuIGZsb2F0aW5nIGlzIGRpc2FsbG93ZWQgKCMxMTAwNCkuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hbGlnbiAhPSAnbm9uZScgJiYgIWVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmFsaWduKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYWxpZ24gPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHdpZGdldC5wYXJ0cy5saW5rIHNpbmNlIGl0IHdpbGwgbm90IGF1dG8tdXBkYXRlIHVubGVzcyB3aWRnZXRcbiAgICAgICAgICAgICAgICAvLyBpcyBkZXN0cm95ZWQgYW5kIHJlLWluaXRlZC5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5saW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcnRzLmxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcnRzLmxpbms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFydHMubGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5saW5rID0gdGhpcy5wYXJ0cy5pbWFnZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucGFydHMuaW1hZ2Uuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIGFsdDogdGhpcy5kYXRhLmFsdCxcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6IHRoaXMucGFydHMuaW1hZ2UuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA/IHRoaXMucGFydHMuaW1hZ2UuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA6IHRydWUsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpbnRlcm5hbCBpcyByZXF1aXJlZCBieSB0aGUgZWRpdG9yLlxuICAgICAgICAgICAgICAgICAgICAnZGF0YS1ja2Utc2F2ZWQtc3JjJzogdGhpcy5kYXRhLnNyYyxcblxuICAgICAgICAgICAgICAgICAgICBzcmM6IHRoaXMuZGF0YS5zcmNcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHNoaWZ0aW5nIG5vbi1jYXB0aW9uZWQgLT4gY2FwdGlvbmVkLCByZW1vdmUgY2xhc3Nlc1xuICAgICAgICAgICAgICAgIC8vIHJlbGF0ZWQgdG8gc3R5bGVzIGZyb20gPGltZy8+LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9sZERhdGEgJiYgIXRoaXMub2xkRGF0YS5oYXNDYXB0aW9uICYmIHRoaXMuZGF0YS5oYXNDYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgaW4gdGhpcy5kYXRhLmNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMuaW1hZ2UucmVtb3ZlQ2xhc3MoYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UgYWNjb3JkaW5nIHRvIGdhdGhlcmVkIGRhdGEuXG4gICAgICAgICAgICAgICAgLy8gRG8gaXQgb25seSB3aGVuIHRoZSBhdHRyaWJ1dGVzIGFyZSBhbGxvd2VkICgjMTEwMDQpLlxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShmZWF0dXJlcy5kaW1lbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERpbWVuc2lvbnModGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgY3VycmVudCBkYXRhLlxuICAgICAgICAgICAgICAgIHRoaXMub2xkRGF0YSA9IENLRURJVE9SLnRvb2xzLmV4dGVuZCh7fSwgdGhpcy5kYXRhKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRvd25jYXN0OiBkb3duY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSxcblxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gVGhpcyB3aWRnZXQgaGFzIGFuIGVkaXRhYmxlIGNhcHRpb24uXG4gICAgICAgICAgICBlZGl0YWJsZXM6IHtcbiAgICAgICAgICAgICAgICBjYXB0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRDb250ZW50OiAnYnIgZW0gc3Ryb25nIHN1YiBzdXAgdSBzOyBhWyFocmVmLHRhcmdldF0nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmVhdHVyZXM6IGdldFdpZGdldEZlYXR1cmVzKGVkaXRvciksXG5cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBJbWFnZTIuXG4gICAgICAgICAgICAvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2dldENsYXNzZXNcbiAgICAgICAgICAgIGdldENsYXNzZXM6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBbXS5jb25jYXQoY2FwdGlvbmVkQ2xhc3MsIGFsaWduQ2xhc3Nlcykuam9pbignfCcpICsgJykkJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMucmVwb3NpdG9yeS5wYXJzZUVsZW1lbnRDbGFzc2VzKGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIGNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3Mgbm9yIGNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBiZWxvbmcgdG8gc3R5bGUgY2xhc3Nlcy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyBpbiBjbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NSZWdleC50ZXN0KGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNsYXNzZXNbY107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKSxcblxuICAgICAgICAgICAgZ2V0TGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSAodGhpcy5kYXRhLmFsdCB8fCAnJykgKyAnICcgKyB0aGlzLnBhdGhOYW1lO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIEltYWdlMi5cbiAgICAgICAgICAgIC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjaGFzQ2xhc3NcbiAgICAgICAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuaGFzQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuICAgICAgICAgICAgICAgIGltYWdlOiAnaW1nJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIEltYWdlMi5cbiAgICAgICAgICAgIC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjcmVtb3ZlQ2xhc3NcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgZ2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVxdWlyZWRDb250ZW50OiAnaW1nW3NyYyxhbHRdJyxcblxuICAgICAgICAgICAgc3R5bGVhYmxlRWxlbWVudHM6ICdpbWcgZmlndXJlJyxcblxuICAgICAgICAgICAgLy8gVGVtcGxhdGUgb2YgdGhlIHdpZGdldDogcGxhaW4gaW1hZ2UuXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cbiAgICAgICAgICAgIHVwY2FzdDogdXBjYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgRW5oYW5jZWQgSW1hZ2UgKGltYWdlMikgcGx1Z2luIGhlbHBlcnMuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAc2luZ2xldG9uXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5pbWFnZTIgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCBpbWFnZSByYXRpbyBtYXRjaGVzIHRoZSBuYXR1cmFsIG9uZVxuICAgICAgICAgKiBieSBjb21wYXJpbmcgZGltZW5zaW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2VcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjaGVja0hhc05hdHVyYWxSYXRpbzogZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICB2YXIgJCA9IGltYWdlLiQsXG4gICAgICAgICAgICAgICAgbmF0dXJhbCA9IHRoaXMuZ2V0TmF0dXJhbChpbWFnZSk7XG5cbiAgICAgICAgICAgIC8vIFRoZSByZWFzb24gZm9yIHR3byBhbHRlcm5hdGl2ZSBjb21wYXJpc29ucyBpcyB0aGF0IHRoZSByb3VuZGluZyBjYW4gY29tZSBmcm9tXG4gICAgICAgICAgICAvLyBib3RoIGRpbWVuc2lvbnMsIGUuZy4gdGhlcmUgYXJlIHR3byBjYXNlczpcbiAgICAgICAgICAgIC8vIFx0MS4gaGVpZ2h0IGlzIGNvbXB1dGVkIGFzIGEgcm91bmRlZCByZWxhdGlvbiBvZiB0aGUgcmVhbCBoZWlnaHQgYW5kIHRoZSB2YWx1ZSBvZiB3aWR0aCxcbiAgICAgICAgICAgIC8vXHQyLiB3aWR0aCBpcyBjb21wdXRlZCBhcyBhIHJvdW5kZWQgcmVsYXRpb24gb2YgdGhlIHJlYWwgd2lkdGggYW5kIHRoZSB2YWx1ZSBvZiBoZWlnaC5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCQuY2xpZW50V2lkdGggLyBuYXR1cmFsLndpZHRoICogbmF0dXJhbC5oZWlnaHQpID09ICQuY2xpZW50SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgkLmNsaWVudEhlaWdodCAvIG5hdHVyYWwuaGVpZ2h0ICogbmF0dXJhbC53aWR0aCkgPT0gJC5jbGllbnRXaWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBuYXR1cmFsIGRpbWVuc2lvbnMgb2YgdGhlIGltYWdlLiBGb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAqIGl0IHVzZXMgbmF0dXJhbChXaWR0aHxIZWlnaHQpLiBGb3Igb2xkIG9uZXMgKElFOCkgaXQgY3JlYXRlc1xuICAgICAgICAgKiBhIG5ldyBpbWFnZSBhbmQgcmVhZHMgdGhlIGRpbWVuc2lvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXROYXR1cmFsOiBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2UuJC5uYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGltYWdlLiQubmF0dXJhbEhlaWdoLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW1hZ2UuJC5uYXR1cmFsV2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdoLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW1nLndpZHRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgd2lkZ2V0cyBmcm9tIGFsbCA8aW1nPiBhbmRcbiAgICAvLyA8ZmlndXJlIGNsYXNzPVwie2NvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3N9XCI+IGVsZW1lbnRzLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuICAgIC8vIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICBmdW5jdGlvbiB1cGNhc3RXaWRnZXRFbGVtZW50KGVkaXRvcikge1xuICAgICAgICB2YXIgaXNDZW50ZXJXcmFwcGVyID0gY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKTtcblxuICAgICAgICB2YXIgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuICAgICAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcbiAgICAgICAgLy8gQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbCwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsLm5hbWU7XG5cbiAgICAgICAgICAgIHZhciBpbWFnZTtcblxuICAgICAgICAgICAgLy8gIzExMTEwIERvbid0IGluaXRpYWxpemUgb24gcGFzdGVkIGZha2Ugb2JqZWN0cy5cbiAgICAgICAgICAgIGlmIChlbC5hdHRyaWJ1dGVzWydkYXRhLWNrZS1yZWFsZWxlbWVudCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIGNlbnRlciB3cmFwcGVyIGlzIGZvdW5kLCB0aGVyZSBhcmUgMyBwb3NzaWJsZSBjYXNlczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAxLiA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48ZmlndXJlPi4uLjwvZmlndXJlPjwvZGl2Pi5cbiAgICAgICAgICAgIC8vICAgIEluIHRoaXMgY2FzZSBjZW50ZXJpbmcgaXMgZG9uZSB3aXRoIGEgY2xhc3Mgc2V0IG9uIHdpZGdldC53cmFwcGVyLlxuICAgICAgICAgICAgLy8gICAgU2ltcGx5IHJlcGxhY2UgY2VudGVyaW5nIHdyYXBwZXIgd2l0aCBmaWd1cmUgKGl0J3Mgbm8gbG9uZ2VyIG5lY2Vzc2FyeSkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMi4gPHAgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxpbWcvPjwvcD4uXG4gICAgICAgICAgICAvLyAgICBOb3RoaW5nIHRvIGRvIGhlcmU6IDxwPiByZW1haW5zIGZvciBzdHlsaW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDMuIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxpbWcvPjwvZGl2Pi5cbiAgICAgICAgICAgIC8vICAgIE5vdGhpbmcgdG8gZG8gaGVyZSAoMi4pIGJ1dCB0aGF0IGNhc2UgaXMgb25seSBwb3NzaWJsZSBpbiBlbnRlck1vZGUgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyAgICB0aGFuIEVOVEVSX1AuXG4gICAgICAgICAgICBpZiAoaXNDZW50ZXJXcmFwcGVyKGVsKSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09ICdkaXYnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWd1cmUgPSBlbC5nZXRGaXJzdCgnZmlndXJlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAjMS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZ3VyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVwbGFjZVdpdGgoZmlndXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZmlndXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENhc2VzICMyIGFuZCAjMyAoaGFuZGxlZCB0cmFuc3BhcmVudGx5KVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNlbnRlcmluZyB3cmFwcGVyLCBzYXZlIGl0IGluIGRhdGEuXG4gICAgICAgICAgICAgICAgZGF0YS5hbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgICAgICAgICAgICAgLy8gSW1hZ2UgY2FuIGJlIHdyYXBwZWQgaW4gbGluayA8YT48aW1nLz48L2E+LlxuICAgICAgICAgICAgICAgIGltYWdlID0gZWwuZ2V0Rmlyc3QoJ2ltZycpIHx8IGVsLmdldEZpcnN0KCdhJykuZ2V0Rmlyc3QoJ2ltZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBjZW50ZXIgd3JhcHBlciBoYXMgYmVlbiBmb3VuZC5cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gJ2ZpZ3VyZScgJiYgZWwuaGFzQ2xhc3MoY2FwdGlvbmVkQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBlbC5nZXRGaXJzdCgnaW1nJykgfHwgZWwuZ2V0Rmlyc3QoJ2EnKS5nZXRGaXJzdCgnaW1nJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGNhc3QgbGlua2VkIGltYWdlIGxpa2UgPGE+PGltZy8+PC9hPi5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShlbCkpIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IGVsLm5hbWUgPT0gJ2EnID8gZWwuY2hpbGRyZW5bMF0gOiBlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBpbWFnZSwgdGhlbiBjb29sLCB3ZSBnb3QgYSB3aWRnZXQuXG4gICAgICAgICAgICAvLyBOb3cganVzdCByZW1vdmUgZGltZW5zaW9uIGF0dHJpYnV0ZXMgZXhwcmVzc2VkIHdpdGggJS5cbiAgICAgICAgICAgIGZvciAodmFyIGQgaW4gZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBpbWFnZS5hdHRyaWJ1dGVzW2RdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbiAmJiBkaW1lbnNpb24ubWF0Y2gocmVnZXhQZXJjZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW1hZ2UuYXR0cmlidXRlc1tkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdHJhbnNmb3JtcyB0aGUgd2lkZ2V0IHRvIHRoZSBleHRlcm5hbCBmb3JtYXRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbi5cbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuICAgIGZ1bmN0aW9uIGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpIHtcbiAgICAgICAgdmFyIGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuICAgICAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiA8YT48aW1nLz48L2E+LCA8aW1nLz4gaXMgdGhlIGVsZW1lbnQgdG8gaG9sZFxuICAgICAgICAgICAgLy8gaW5saW5lIHN0eWxlcyBvciBjbGFzc2VzIChpbWFnZTJfYWxpZ25DbGFzc2VzKS5cbiAgICAgICAgICAgIHZhciBhdHRyc0hvbGRlciA9IGVsLm5hbWUgPT0gJ2EnID8gZWwuZ2V0Rmlyc3QoKSA6IGVsO1xuXG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBhdHRyc0hvbGRlci5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICB2YXIgYWxpZ24gPSB0aGlzLmRhdGEuYWxpZ247XG5cbiAgICAgICAgICAgIC8vIERlLXdyYXAgdGhlIGltYWdlIGZyb20gcmVzaXplIGhhbmRsZSB3cmFwcGVyLlxuICAgICAgICAgICAgLy8gT25seSBibG9jayB3aWRnZXRzIGhhdmUgb25lLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXNpemVXcmFwcGVyID0gZWwuZ2V0Rmlyc3QoJ3NwYW4nKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNpemVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZVdyYXBwZXIucmVwbGFjZVdpdGgocmVzaXplV3JhcHBlci5nZXRGaXJzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiAxXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGlnbiAmJiBhbGlnbiAhPSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gQ0tFRElUT1IudG9vbHMucGFyc2VDc3NUZXh0KGF0dHJzLnN0eWxlIHx8ICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHdpZGdldCBpcyBjYXB0aW9uZWQgKDxmaWd1cmU+KSBhbmQgaW50ZXJuYWxseSBjZW50ZXJpbmcgaXMgZG9uZVxuICAgICAgICAgICAgICAgIC8vIHdpdGggd2lkZ2V0J3Mgd3JhcHBlciBzdHlsZS9jbGFzcywgaW4gdGhlIGV4dGVybmFsIGRhdGEgcmVwcmVzZW50YXRpb24sXG4gICAgICAgICAgICAgICAgLy8gPGZpZ3VyZT4gbXVzdCBiZSB3cmFwcGVkIHdpdGggYW4gZWxlbWVudCBob2xkaW5nIGFuIHN0eWxlL2NsYXNzOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gXHQ8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9ja1wiPi4uLjwvZmlndXJlPlxuICAgICAgICAgICAgICAgIC8vIFx0PC9kaXY+XG4gICAgICAgICAgICAgICAgLy8gb3JcbiAgICAgICAgICAgICAgICAvLyBcdDxkaXYgY2xhc3M9XCJzb21lLWNlbnRlci1jbGFzc1wiPlxuICAgICAgICAgICAgICAgIC8vIFx0XHQ8ZmlndXJlIGNsYXNzPVwiaW1hZ2VcIj4uLi48L2ZpZ3VyZT5cbiAgICAgICAgICAgICAgICAvLyBcdDwvZGl2PlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduID09ICdjZW50ZXInICYmIGVsLm5hbWUgPT0gJ2ZpZ3VyZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC53cmFwV2l0aChuZXcgQ0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50KCdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25DbGFzc2VzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IGFsaWduQ2xhc3Nlc1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3RleHQtYWxpZ246Y2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGxlZnQvcmlnaHQsIGFkZCBmbG9hdCBzdHlsZSB0byB0aGUgZG93bmNhc3RlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFsaWduIGluIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMVxuICAgICAgICAgICAgICAgICAgICB9KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbkNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzSG9sZGVyLmFkZENsYXNzKGFsaWduQ2xhc3Nlc1thbGlnbm1lbnRzT2JqW2FsaWduXV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzWydmbG9hdCddID0gYWxpZ247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZWxlbWVudCBzdHlsZXMuXG4gICAgICAgICAgICAgICAgaWYgKCFhbGlnbkNsYXNzZXMgJiYgIUNLRURJVE9SLnRvb2xzLmlzRW1wdHkoc3R5bGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5zdHlsZSA9IENLRURJVE9SLnRvb2xzLndyaXRlQ3NzVGV4dChzdHlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhbiBlbGVtZW50IGlzIGEgY2VudGVyaW5nIHdyYXBwZXIuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yXG4gICAgLy8gQHJldHVybnMge0Z1bmN0aW9ufVxuICAgIGZ1bmN0aW9uIGNlbnRlcldyYXBwZXJDaGVja2VyKGVkaXRvcikge1xuICAgICAgICB2YXIgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuICAgICAgICB2YXIgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzO1xuXG4gICAgICAgIHZhciB2YWxpZENoaWxkcmVuID0ge1xuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIGZpZ3VyZTogMSxcbiAgICAgICAgICAgIGltZzogMVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIFdyYXBwZXIgbXVzdCBiZSBlaXRoZXIgPGRpdj4gb3IgPHA+LlxuICAgICAgICAgICAgaWYgKCEoZWwubmFtZSBpbiB7XG4gICAgICAgICAgICAgICAgICAgIGRpdjogMSxcbiAgICAgICAgICAgICAgICAgICAgcDogMVxuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcblxuICAgICAgICAgICAgLy8gQ2VudGVyaW5nIHdyYXBwZXIgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQuXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgICAgICAgICAgLy8gT25seSA8ZmlndXJlPiBvciA8aW1nIC8+IGNhbiBiZSBmaXJzdCAob25seSkgY2hpbGQgb2YgY2VudGVyaW5nIHdyYXBwZXIsXG4gICAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGl0cyB0eXBlLlxuICAgICAgICAgICAgaWYgKCEoY2hpbGQubmFtZSBpbiB2YWxpZENoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgY2VudGVyaW5nIHdyYXBwZXIgaXMgPHA+LCBvbmx5IDxpbWcgLz4gY2FuIGJlIHRoZSBjaGlsZC5cbiAgICAgICAgICAgIC8vICAgPHAgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxpbWcgLz48L3A+XG4gICAgICAgICAgICBpZiAoZWwubmFtZSA9PSAncCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDZW50ZXJpbmcgPGRpdj4gY2FuIGhvbGQgPGltZy8+IG9yIDxmaWd1cmU+LCBkZXBlbmRpbmcgb24gZW50ZXJNb2RlLlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSA8ZmlndXJlPiBpcyB0aGUgZmlyc3QgKG9ubHkpIGNoaWxkLCBpdCBtdXN0IGhhdmUgYSBjbGFzcy5cbiAgICAgICAgICAgICAgICAvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxmaWd1cmU+Li4uPC9maWd1cmU+PGRpdj5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSAnZmlndXJlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmhhc0NsYXNzKGNhcHRpb25lZENsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2VudGVyaW5nIDxkaXY+IGNhbiBob2xkIDxpbWcvPiBvciA8YT48aW1nLz48L2E+IG9ubHkgd2hlbiBlbnRlck1vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgRU5URVJfKEJSfERJVikuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZyAvPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxhPjxpbWcgLz48L2E+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuZW50ZXJNb2RlID09IENLRURJVE9SLkVOVEVSX1ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgZW50ZXJNb2RlLCBhIGNoaWxkIHdoaWNoIGlzIG5vdCA8ZmlndXJlPiBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDZW50ZXJpbmcgd3JhcHBlciBnb3QgdG8gYmUuLi4gY2VudGVyaW5nLiBJZiBpbWFnZTJfYWxpZ25DbGFzc2VzIGFyZSBkZWZpbmVkLFxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNlbnRlcmluZyBjbGFzcy4gT3RoZXJ3aXNlLCBjaGVjayB0aGUgc3R5bGUuXG4gICAgICAgICAgICBpZiAoYWxpZ25DbGFzc2VzID8gZWwuaGFzQ2xhc3MoYWxpZ25DbGFzc2VzWzFdKSA6XG4gICAgICAgICAgICAgICAgQ0tFRElUT1IudG9vbHMucGFyc2VDc3NUZXh0KGVsLmF0dHJpYnV0ZXMuc3R5bGUgfHwgJycsIHRydWUpWyd0ZXh0LWFsaWduJ10gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrcyB3aGV0aGVyIGVsZW1lbnQgaXMgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4uXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH1cbiAgICBmdW5jdGlvbiBpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGVsKSB7XG4gICAgICAgIGlmIChlbC5uYW1lID09ICdpbWcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbC5uYW1lID09ICdhJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLmxlbmd0aCA9PSAxICYmIGVsLmdldEZpcnN0KCdpbWcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHdpZGdldCBpbWFnZSBhY2NvcmRpbmcgdG8gY3VycmVudCB3aWRnZXQgZGF0YS5cbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuICAgIGZ1bmN0aW9uIHNldERpbWVuc2lvbnMod2lkZ2V0KSB7XG4gICAgICAgIHZhciBkYXRhID0gd2lkZ2V0LmRhdGE7XG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IGRhdGEud2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB3aWRnZXQucGFydHMuaW1hZ2U7XG5cbiAgICAgICAgZm9yICh2YXIgZCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uc1tkXSkge1xuICAgICAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZShkLCBkaW1lbnNpb25zW2RdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UucmVtb3ZlQXR0cmlidXRlKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lcyBhbGwgZmVhdHVyZXMgcmVsYXRlZCB0byBkcmFnLWRyaXZlbiBpbWFnZSByZXNpemluZy5cbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuICAgIGZ1bmN0aW9uIHNldHVwUmVzaXplcih3aWRnZXQpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IHdpZGdldC5lZGl0b3I7XG5cbiAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgdmFyIGRvYyA9IGVkaXRvci5kb2N1bWVudDtcblxuICAgICAgICAvLyBTdG9yZSB0aGUgcmVzaXplciBpbiBhIHdpZGdldCBmb3IgdGVzdGluZyAoIzExMDA0KS5cbiAgICAgICAgdmFyIHJlc2l6ZXIgPSB3aWRnZXQucmVzaXplciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cbiAgICAgICAgcmVzaXplci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXInKTtcbiAgICAgICAgcmVzaXplci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfJyArIGN1cnNvcltlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemVdKTtcbiAgICAgICAgcmVzaXplci5hcHBlbmQobmV3IENLRURJVE9SLmRvbS50ZXh0KCdcXHUyMDBiJywgZG9jKSk7XG5cbiAgICAgICAgLy8gSW5saW5lIHdpZGdldHMgZG9uJ3QgbmVlZCBhIHJlc2l6ZXIgd3JhcHBlciBhcyBhbiBpbWFnZSBzcGFucyB0aGUgZW50aXJlIHdpZGdldC5cbiAgICAgICAgaWYgKCF3aWRnZXQuaW5saW5lKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VPckxpbmsgPSB3aWRnZXQucGFydHMubGluayB8fCB3aWRnZXQucGFydHMuaW1hZ2U7XG5cbiAgICAgICAgICAgIHZhciBvbGRSZXNpemVXcmFwcGVyID0gaW1hZ2VPckxpbmsuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgICAgIHZhciByZXNpemVXcmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAgICAgICAgICAgcmVzaXplV3JhcHBlci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfd3JhcHBlcicpO1xuICAgICAgICAgICAgcmVzaXplV3JhcHBlci5hcHBlbmQoaW1hZ2VPckxpbmspO1xuICAgICAgICAgICAgcmVzaXplV3JhcHBlci5hcHBlbmQocmVzaXplcik7XG4gICAgICAgICAgICB3aWRnZXQuZWxlbWVudC5hcHBlbmQocmVzaXplV3JhcHBlciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIHdyYXBwZXIgd2hpY2ggY291bGQgY2FtZSBmcm9tIGUuZy4gcGFzdGVkIEhUTUxcbiAgICAgICAgICAgIC8vIGFuZCB3aGljaCBjb3VsZCBiZSBjb3JydXB0ZWQgKGUuZy4gcmVzaXplciBzcGFuIGhhcyBiZWVuIGxvc3QpLlxuICAgICAgICAgICAgaWYgKG9sZFJlc2l6ZVdyYXBwZXIuaXMoJ3NwYW4nKSkge1xuICAgICAgICAgICAgICAgIG9sZFJlc2l6ZVdyYXBwZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWRnZXQud3JhcHBlci5hcHBlbmQocmVzaXplcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWVzIG9mIHNpemUgdmFyaWFibGVzIGFuZCBtb3VzZSBvZmZzZXRzLlxuICAgICAgICByZXNpemVyLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB3aWRnZXQucGFydHMuaW1hZ2U7XG5cbiAgICAgICAgICAgIC8vIFwiZmFjdG9yXCIgY2FuIGJlIGVpdGhlciAxIG9yIC0xLiBJLmUuOiBGb3IgcmlnaHQtYWxpZ25lZCBpbWFnZXMsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHN1YnRyYWN0IHRoZSBkaWZmZXJlbmNlIHRvIGdldCBwcm9wZXIgd2lkdGgsIGV0Yy4gV2l0aG91dCBcImZhY3RvclwiLFxuICAgICAgICAgICAgLy8gcmVzaXplciBzdGFydHMgd29ya2luZyB0aGUgb3Bwb3NpdGUgd2F5LlxuICAgICAgICAgICAgdmFyIGZhY3RvciA9IHdpZGdldC5kYXRhLmFsaWduID09ICdyaWdodCcgPyAtMSA6IDE7XG5cbiAgICAgICAgICAgIC8vIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICAgIC8vIHdoZW4gYnV0dG9uIGdldHMgcHJlc3NlZC5cbiAgICAgICAgICAgIHZhciBzdGFydFggPSBldnQuZGF0YS4kLnNjcmVlblg7XG5cbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBldnQuZGF0YS4kLnNjcmVlblk7XG5cbiAgICAgICAgICAgIC8vIFRoZSBpbml0aWFsIGRpbWVuc2lvbnMgYW5kIGFzcGVjdCByYXRpbyBvZiB0aGUgaW1hZ2UuXG4gICAgICAgICAgICB2YXIgc3RhcnRXaWR0aCA9IGltYWdlLiQuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgICAgIHZhciBzdGFydEhlaWdodCA9IGltYWdlLiQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgIC8vIEEgY2xhc3MgYXBwbGllZCB0byBlZGl0YWJsZSBkdXJpbmcgcmVzaXppbmcuXG4gICAgICAgICAgICB2YXIgY3Vyc29yQ2xhc3MgPSAnY2tlX2ltYWdlX3MnICsgKCF+ZmFjdG9yID8gJ3cnIDogJ2UnKTtcblxuICAgICAgICAgICAgdmFyIG5hdGl2ZUV2dCwgbmV3V2lkdGgsIG5ld0hlaWdodCwgdXBkYXRlRGF0YTtcblxuICAgICAgICAgICAgdmFyIG1vdmVEaWZmWCwgbW92ZURpZmZZLCBtb3ZlUmF0aW87XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIHVuZG8gc25hcHNob3QgZmlyc3Q6IGJlZm9yZSByZXNpemluZy5cbiAgICAgICAgICAgIGVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblxuICAgICAgICAgICAgLy8gTW91c2Vtb3ZlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCBvbiBtb3VzZXVwLlxuICAgICAgICAgICAgYXR0YWNoVG9Eb2N1bWVudHMoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBsaXN0ZW5lcnMpO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbW91c2Vtb3ZlIGxpc3RlbmVyLiBVcGRhdGUgd2lkZ2V0IGRhdGEgaWYgdmFsaWQuXG4gICAgICAgICAgICBhdHRhY2hUb0RvY3VtZW50cygnbW91c2V1cCcsIG9uTW91c2VVcCwgbGlzdGVuZXJzKTtcblxuICAgICAgICAgICAgLy8gVGhlIGVudGlyZSBlZGl0YWJsZSB3aWxsIGhhdmUgdGhlIHNwZWNpYWwgY3Vyc29yIHdoaWxlIHJlc2l6aW5nIGdvZXMgb24uXG4gICAgICAgICAgICBlZGl0YWJsZS5hZGRDbGFzcyhjdXJzb3JDbGFzcyk7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gYWx3YXlzIGtlZXAgdGhlIHJlc2l6ZXIgZWxlbWVudCB2aXNpYmxlIHdoaWxlIHJlc2l6aW5nLlxuICAgICAgICAgICAgcmVzaXplci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6aW5nJyk7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaGVzIGFuIGV2ZW50IHRvIGEgZ2xvYmFsIGRvY3VtZW50IGlmIGlubGluZSBlZGl0b3IuXG4gICAgICAgICAgICAvLyBBZGRpdGlvbmFsbHksIGlmIGNsYXNzaWMgKGBpZnJhbWVgLWJhc2VkKSBlZGl0b3IsIGFsc28gYXR0YWNoZXMgdGhlIHNhbWUgZXZlbnQgdG8gYGlmcmFtZWAncyBkb2N1bWVudC5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaFRvRG9jdW1lbnRzKG5hbWUsIGNhbGxiYWNrLCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdsb2JhbERvYyA9IENLRURJVE9SLmRvY3VtZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkb2MuZXF1YWxzKGdsb2JhbERvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goZ2xvYmFsRG9jLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goZG9jLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKGxpc3RlbmVycy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaG93IHZhcmlhYmxlcyByZWZlciB0byB0aGUgZ2VvbWV0cnkuXG4gICAgICAgICAgICAvLyBOb3RlOiB4IGNvcnJlc3BvbmRzIHRvIG1vdmVPZmZzZXQsIHRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIG1vdXNlXG4gICAgICAgICAgICAvLyBOb3RlOiBvIGNvcnJlc3BvbmRzIHRvIFtzdGFydFgsIHN0YXJ0WV0uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gXHQrLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgIC8vIFx0fCAgICAgIEkgICAgICAgfCAgICAgIElJICAgICAgfFxuICAgICAgICAgICAgLy8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAvLyBcdCstLS0tLS0tLS0tLS0tIG8gLS0tLS0tLS0tLS0tLSsgXyBfIF9cbiAgICAgICAgICAgIC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgIF5cblxuICAgICAgICAgICAgLy8gXHR8ICAgICAgVkkgICAgICB8ICAgICBJSUkgICAgICB8ICAgICAgfCBtb3ZlRGlmZllcbiAgICAgICAgICAgIC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgIHggXyBfIF8gXyBfIHZcbiAgICAgICAgICAgIC8vIFx0Ky0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLXwtLS0tK1xuICAgICAgICAgICAgLy8gXHQgICAgICAgICAgICAgICB8ICAgICAgICAgfFxuICAgICAgICAgICAgLy8gXHQgICAgICAgICAgICAgICAgPC0tLS0tLS0+XG4gICAgICAgICAgICAvLyBcdCAgICAgICAgICAgICAgICBtb3ZlRGlmZlhcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZVNjYWxlUmVzaXplID0gZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplO1xuXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZ0ID0gZXZ0LmRhdGEuJDtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgaG93IGZhciB0aGUgbW91c2UgaXMgZnJvbSB0aGUgcG9pbnQgdGhlIGJ1dHRvbiB3YXMgcHJlc3NlZC5cbiAgICAgICAgICAgICAgICBtb3ZlRGlmZlggPSBuYXRpdmVFdnQuc2NyZWVuWCAtIHN0YXJ0WDtcbiAgICAgICAgICAgICAgICBtb3ZlRGlmZlkgPSBzdGFydFkgLSBuYXRpdmVFdnQuc2NyZWVuWTtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgbW92ZSBkaWZmZXJlbmNlLlxuICAgICAgICAgICAgICAgIG1vdmVSYXRpbyA9IE1hdGguYWJzKG1vdmVEaWZmWCAvIG1vdmVEaWZmWSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ3dpZHRoJyB8fCBpbWFnZVNjYWxlUmVzaXplID09PSAnYm90aCcgfHwgaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdXaWR0aCA9IHN0YXJ0V2lkdGggKyBmYWN0b3IgKiBtb3ZlRGlmZlg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdoZWlnaHQnIHx8IGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBzdGFydEhlaWdodCAtIG1vdmVEaWZmWTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSBuZXdXaWR0aCB8fCBzdGFydFdpZHRoO1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IG5ld0hlaWdodCB8fCBzdGFydEhlaWdodDtcblxuICAgICAgICAgICAgICAgIC8vIERvbid0IHVwZGF0ZSBhdHRyaWJ1dGVzIGlmIGxlc3MgdGhhbiAxMC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHByZXZlbnQgaW1hZ2VzIHRvIHZpc3VhbGx5IGRpc2FwcGVhci5cbiAgICAgICAgICAgICAgICBpZiAobmV3V2lkdGggPj0gMTUgJiYgKG5ld0hlaWdodCA+PSAxNSB8fCBuZXdIZWlnaHQgPT09ICdhdXRvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgICAgICAgICAgIHZhciBsO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKChsID0gbGlzdGVuZXJzLnBvcCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBsLnJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBkZWZhdWx0IGN1cnNvciBieSByZW1vdmluZyBzcGVjaWFsIGNsYXNzLlxuICAgICAgICAgICAgICAgIGVkaXRhYmxlLnJlbW92ZUNsYXNzKGN1cnNvckNsYXNzKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gYnJpbmcgYmFjayB0aGUgcmVndWxhciBiZWhhdmlvdXIgb2YgdGhlIHJlc2l6ZXIuXG4gICAgICAgICAgICAgICAgcmVzaXplci5yZW1vdmVDbGFzcygnY2tlX2ltYWdlX3Jlc2l6aW5nJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuc2V0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIGFub3RoZXIgdW5kbyBzbmFwc2hvdDogYWZ0ZXIgcmVzaXppbmcuXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCB1cGRhdGUgZGF0YSB0d2ljZSBvciBtb3JlLlxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgd2lkZ2V0IHJlc2l6ZXIgd2hlbiBkYXRhIGNoYW5nZXMuXG4gICAgICAgIHdpZGdldC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc2l6ZXJbd2lkZ2V0LmRhdGEuYWxpZ24gPT0gJ3JpZ2h0JyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnY2tlX2ltYWdlX3Jlc2l6ZXJfbGVmdCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICB3aWRnZXQucGFydHMuaW1hZ2Uub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBlZGl0b3IuXy5lZGl0YWJsZS5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0RWxlbWVudCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkRhdGEgPSBlZGl0b3IuXy5lZGl0YWJsZS5lZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZmlyZSgnZWRpdG9ySW50ZXJhY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRGF0YTogc2VsZWN0aW9uRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBzZXQgb2Ygd2lkZ2V0IGFsbG93ZWRDb250ZW50IHJ1bGVzLCBkZXBlbmRpbmdcbiAgICAvLyBvbiBjb25maWd1cmF0aW9ucyBsaWtlIGNvbmZpZyNpbWFnZTJfYWxpZ25DbGFzc2VzIG9yXG4gICAgLy8gY29uZmlnI2ltYWdlMl9jYXB0aW9uZWRDbGFzcy5cbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuICAgIC8vIEByZXR1cm5zIHtPYmplY3R9XG4gICAgZnVuY3Rpb24gZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQoZWRpdG9yKSB7XG4gICAgICAgIHZhciBydWxlcyA9IHtcbiAgICAgICAgICAgIGZpZ2NhcHRpb246IHRydWUsXG4gICAgICAgICAgICBmaWd1cmU6IHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiAnIScgKyBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltZzoge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6ICchc3JjLGFsdCx3aWR0aCxoZWlnaHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBzZXQgb2Ygd2lkZ2V0IGZlYXR1cmUgcnVsZXMsIGRlcGVuZGluZ1xuICAgIC8vIG9uIGVkaXRvciBjb25maWd1cmF0aW9uLiBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBtYXkgbm90IGNvdmVyXG4gICAgLy8gYWxsIHRoZSBwb3NzaWJsZSBjYXNlcyBzaW5jZSByZXF1aXJlZENvbnRlbnQgc3VwcG9ydHMgYSBzaW5nbGVcbiAgICAvLyB0YWcgb25seS5cbiAgICAvL1xuICAgIC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuICAgIC8vIEByZXR1cm5zIHtPYmplY3R9XG4gICAgZnVuY3Rpb24gZ2V0V2lkZ2V0RmVhdHVyZXMoZWRpdG9yKSB7XG4gICAgICAgIHZhciBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXM7XG5cbiAgICAgICAgdmFyIGZlYXR1cmVzID0ge1xuICAgICAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRlbnQ6ICdpbWcnICtcbiAgICAgICAgICAgICAgICAgICAgKGFsaWduQ2xhc3NlcyA/ICcoJyArIGFsaWduQ2xhc3Nlc1swXSArICcpJyA6ICd7ZmxvYXR9JylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXB0aW9uOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRDb250ZW50OiAnZmlnY2FwdGlvbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRlbnQ6ICdpbWdbd2lkdGgsaGVpZ2h0XSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBlbGVtZW50IHdoaWNoIGlzIHN0eWxlZCwgY29uc2lkZXJpbmcgY3VycmVudFxuICAgIC8vIHN0YXRlIG9mIHRoZSB3aWRnZXQuXG4gICAgLy9cbiAgICAvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2FwcGx5U3R5bGVcbiAgICAvLyBAcGFyYW0ge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fSB3aWRnZXRcbiAgICAvLyBAcmV0dXJucyB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9XG4gICAgZnVuY3Rpb24gZ2V0U3R5bGVhYmxlRWxlbWVudCh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHdpZGdldC5kYXRhLmhhc0NhcHRpb24gPyB3aWRnZXQuZWxlbWVudCA6IHdpZGdldC5wYXJ0cy5pbWFnZTtcbiAgICB9XG59KSgpO1xuXG5DS0VESVRPUi5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzID0gJ2ltYWdlJzsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9lbWJlZCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgUkVHRVhfSFRUUCA9IC9eaHR0cHM/LztcblxuICAgIHZhciBSRUdFWF9ERUZBVUxUX0xJTksgPSAvPGEgaHJlZj0vO1xuXG4gICAgdmFyIFBST1ZJREVSUyA9IFsneW91dHViZScsICd0d2l0dGVyJ107XG5cbiAgICBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1VSTF9UUEwgPSAnaHR0cDovL2FsbG95LmlmcmFtZS5seS9hcGkvb2VtYmVkP3VybD17dXJsfSZjYWxsYmFjaz17Y2FsbGJhY2t9JztcbiAgICBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1dJREdFVF9UUEwgPSAnPGRpdiBkYXRhLWFlLWVtYmVkLXVybD1cInt1cmx9XCI+PC9kaXY+JztcbiAgICBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwgPSAnPGEgaHJlZj1cInt1cmx9XCI+e3VybH08L2E+JztcbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWRkcyB0aGUgaW5mcmFzdHJ1Y3R1cmUgdG8gZW1iZWQgdXJscyBhcyBtZWRpYSBvYmplY3RzIHVzaW5nIGFuIG9lbWJlZFxuICAgICAqIHNlcnZpY2UuIEJ5IGRlZmF1bHQsIGFuZCBmb3IgZGVtb2luZyBwdXJwb3NlcyBvbmx5LCB0aGUgb2VtYmVkIHNlcnZpY2UgaXMgaG9zdGVkIGluIGlmcmFtZS5seVxuICAgICAqIGF0IC8vYWxsb3kuaWZyYW1lLmx5L2FwaS9vZW1iZWQ/dXJsPXt1cmx9JmNhbGxiYWNrPXtjYWxsYmFja30uIE5vdGUgdGhpcyBzaG91bGQgYmUgY2hhbmdlZCB0b1xuICAgICAqIGEgc2VsZi1ob3N0ZWQgb3IgcGFpZCBzZXJ2aWNlIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLiBBY2Nlc3MgdG8gdGhlIGFsbG95LmlmcmFtZS5seSBlbmRwb2ludFxuICAgICAqIG1heSBiZSByZXN0cmljdGVkIHBlciBkb21haW4gZHVlIHRvIHNpZ25pZmljYW50IHRyYWZmaWMuXG4gICAgICpcbiAgICAgKiBUaGlzIHBsdWdpbiBhZGRzIGFuIGBlbWJlZFVybGAgY29tbWFuZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGVhc2lseSBlbWJlZCBhIFVSTCBhbmQgdHJhbnNmb3JtIGl0XG4gICAgICogdG8gYW4gZW1iZWRkZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX2VtYmVkXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV9lbWJlZCcsIHtcbiAgICAgICAgICAgIHJlcXVpcmVzOiAnd2lkZ2V0JyxcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBBRV9FTUJFRF9VUkxfVFBMID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKGVkaXRvci5jb25maWcuZW1iZWRVcmxUZW1wbGF0ZSB8fCBDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1VSTF9UUEwpO1xuICAgICAgICAgICAgICAgIHZhciBBRV9FTUJFRF9XSURHRVRfVFBMID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKGVkaXRvci5jb25maWcuZW1iZWRXaWRnZXRUcGwgfHwgQ0tFRElUT1IuREVGQVVMVF9BRV9FTUJFRF9XSURHRVRfVFBMKTtcbiAgICAgICAgICAgICAgICB2YXIgQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShlZGl0b3IuY29uZmlnLmVtYmVkTGlua0RlZmF1bHRUcGwgfHwgQ0tFRElUT1IuREVGQVVMVF9BRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMKTtcblxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgZnVuY3Rpb24gdG8gdXBjYXN0IERPTSBlbGVtZW50cyB0byBlbWJlZCB3aWRnZXRzLlxuICAgICAgICAgICAgICAgIC8vIEl0IG1hdGNoZXMgQ0tFRElUT1IuREVGQVVMVF9BRV9FTUJFRF9XSURHRVRfVFBMXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5uYW1lID09PSAnZGl2JyAmJiBlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtYWUtZW1iZWQtdXJsJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudXJsID0gZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWFlLWVtYmVkLXVybCddO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBlbWJlZFVybCBjb21tYW5kIHRoYXQgY2FuIGJlIGludm9rZWQgdG8gZWFzaWx5IGVtYmVkIG1lZGlhIFVSTHNcbiAgICAgICAgICAgICAgICBlZGl0b3IuYWRkQ29tbWFuZCgnZW1iZWRVcmwnLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydEh0bWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQUVfRU1CRURfV0lER0VUX1RQTC5vdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdpZGdldCB0byBwcm9wZXJseSBoYW5kbGUgZW1iZWQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgIGVkaXRvci53aWRnZXRzLmFkZCgnYWVfZW1iZWQnLCB7XG5cblxuICAgICAgICAgICAgICAgICAgICBtYXNrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRlbnQ6ICdkaXZbZGF0YS1hZS1lbWJlZC11cmxdJyxcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogTGlzdGVuZXIgdG8gYmUgZXhlY3V0ZWQgZXZlcnkgdGltZSB0aGUgd2lkZ2V0J3MgZGF0YSBjaGFuZ2VzLiBJdCB0YWtlcyBjYXJlIG9mXG4gICAgICAgICAgICAgICAgICAgICAqIHJlcXVlc3RpbmcgdGhlIGVtYmVkIG9iamVjdCB0byB0aGUgY29uZmlndXJlZCBvZW1iZWQgc2VydmljZSBhbmQgcmVuZGVyIGl0IGluXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQG1ldGhvZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IERhdGEgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBldmVudC5kYXRhLnVybDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENLRURJVE9SLnRvb2xzLmpzb25wKEFFX0VNQkVEX1VSTF9UUEwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBlbmNvZGVVUklDb21wb25lbnQodXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5odG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVHRVhfREVGQVVMVF9MSU5LLnRlc3QocmVzcG9uc2UuaHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuY3JlYXRlQVRhZyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZWxlbWVudC5zZXRIdG1sKHJlc3BvbnNlLmh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmNyZWF0ZUFUYWcodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuY3JlYXRlQVRhZyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUFUYWc6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZXhlY0NvbW1hbmQoJ3VuZG8nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFUYWdIdG1sID0gQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTC5vdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuaW5zZXJ0SHRtbChhVGFnSHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRnVuY3Rpb24gdXNlZCB0byB1cGNhc3QgYW4gZWxlbWVudCB0byBhZV9lbWJlZCB3aWRnZXRzLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIHVwY2FzdFxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgd2lkZ2V0XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB1cGNhc3Q6IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbWJlZFdpZGdldFVwY2FzdEZuID0gZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFVwY2FzdEZuIHx8IGRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1iZWRXaWRnZXRVcGNhc3RGbihlbGVtZW50LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgbGlzdGVuZXIgdG8gaGFuZGxlIHBhc3RlIGV2ZW50cyBhbmQgdHVybiBsaW5rcyBpbnRvIGVtYmVkIG9iamVjdHNcbiAgICAgICAgICAgICAgICBlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ3Bhc3RlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5rID0gZXZlbnQuZGF0YS5kYXRhVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRUdFWF9IVFRQLnRlc3QobGluaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ2VtYmVkVXJsJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGV2ZW50LmRhdGEuZGF0YVZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgbGlzdGVuZXIgdG8gaGFuZGxlIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnRzIGFuZCBwcm9wZXJseSBkZXRlY3QgZWRpdG9yXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJhY3Rpb25zIG9uIHRoZSB3aWRnZXRzIHdpdGhvdXQgbWVzc2luZyB3aXRoIHdpZGdldCBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uKCdzZWxlY3Rpb25DaGFuZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGdldEVsZW1lbnQgPSBlbGVtZW50LmZpbmRPbmUoJ1tkYXRhLXdpZGdldD1cImFlX2VtYmVkXCJdJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3cod2luZG93KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb24ubGVmdCAtPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLmRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB3aWRnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgZmlsdGVyIHRvIHNraXAgZmlsdGVyaW5nIHdpZGdldCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGVkaXRvci5maWx0ZXIuYWRkRWxlbWVudENhbGxiYWNrKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdkYXRhLWFlLWVtYmVkLXVybCcgaW4gZWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ0tFRElUT1IuRklMVEVSX1NLSVBfVFJFRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiaW1wb3J0IFNlbGVjdGlvblRlc3QgZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdC5qcyc7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2ltYWdlYWxpZ25tZW50JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudW0gZm9yIHN1cHBvcnRlZCBpbWFnZSBhbGlnbm1lbnRzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgSU1BR0VfQUxJR05NRU5UID0ge1xuICAgICAgICBDRU5URVI6ICdjZW50ZXInLFxuICAgICAgICBMRUZUOiAnbGVmdCcsXG4gICAgICAgIFJJR0hUOiAncmlnaHQnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVudW0gdmFsdWVzIGZvciBzdXBwb3J0ZWQgaW1hZ2UgYWxpZ25tZW50c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB2YXIgQUxJR05fVkFMVUVTID0gW1xuICAgICAgICBJTUFHRV9BTElHTk1FTlQuTEVGVCxcbiAgICAgICAgSU1BR0VfQUxJR05NRU5ULlJJR0hULFxuICAgICAgICBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIE5lY2Vzc2FyeSBzdHlsZXMgZm9yIHRoZSBjZW50ZXIgYWxpZ25tZW50XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHZhciBDRU5URVJFRF9JTUFHRV9TVFlMRSA9IFt7XG4gICAgICAgIG5hbWU6ICdkaXNwbGF5JyxcbiAgICAgICAgdmFsdWU6ICdibG9jaydcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdtYXJnaW4tbGVmdCcsXG4gICAgICAgIHZhbHVlOiAnYXV0bydcbiAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdtYXJnaW4tcmlnaHQnLFxuICAgICAgICB2YWx1ZTogJ2F1dG8nXG4gICAgfV07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgYWxpZ25tZW50IHZhbHVlXG4gICAgICovXG4gICAgdmFyIGdldEltYWdlQWxpZ25tZW50ID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgICAgdmFyIGltYWdlQWxpZ25tZW50ID0gaW1hZ2UuZ2V0U3R5bGUoJ2Zsb2F0Jyk7XG5cbiAgICAgICAgaWYgKCFpbWFnZUFsaWdubWVudCB8fCBpbWFnZUFsaWdubWVudCA9PT0gJ2luaGVyaXQnIHx8IGltYWdlQWxpZ25tZW50ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGltYWdlQWxpZ25tZW50ID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdhbGlnbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbWFnZUFsaWdubWVudCkge1xuICAgICAgICAgICAgdmFyIGNlbnRlcmVkSW1hZ2UgPSBDRU5URVJFRF9JTUFHRV9TVFlMRS5ldmVyeShmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZUNoZWNrID0gaW1hZ2UuZ2V0U3R5bGUoc3R5bGUubmFtZSkgPT09IHN0eWxlLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZUNoZWNrICYmIHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlQ2hlY2sgPSBzdHlsZS52ZW5kb3JQcmVmaXhlcy5zb21lKGZ1bmN0aW9uKHZlbmRvclByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlLmdldFN0eWxlKHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUpID09PSBzdHlsZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlQ2hlY2s7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW1hZ2VBbGlnbm1lbnQgPSBjZW50ZXJlZEltYWdlID8gSU1BR0VfQUxJR05NRU5ULkNFTlRFUiA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW1hZ2VBbGlnbm1lbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBpbWFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2UgVGhlIGltYWdlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VBbGlnbm1lbnQgVGhlIGltYWdlIGFsaWdubWVudCB2YWx1ZSB0byBiZSByZW1vdmVkXG4gICAgICovXG4gICAgdmFyIHJlbW92ZUltYWdlQWxpZ25tZW50ID0gZnVuY3Rpb24oaW1hZ2UsIGltYWdlQWxpZ25tZW50KSB7XG4gICAgICAgIGlmIChpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULkxFRlQgfHwgaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5SSUdIVCkge1xuICAgICAgICAgICAgaW1hZ2UucmVtb3ZlU3R5bGUoJ2Zsb2F0Jyk7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZUFsaWdubWVudCA9PT0gZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdhbGlnbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSKSB7XG4gICAgICAgICAgICBDRU5URVJFRF9JTUFHRV9TVFlMRS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UucmVtb3ZlU3R5bGUoc3R5bGUubmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudmVuZG9yUHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbih2ZW5kb3JQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZVN0eWxlKHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gaW1hZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGltYWdlQWxpZ25tZW50IFRoZSBpbWFnZSBhbGlnbm1lbnQgdmFsdWUgdG8gYmUgc2V0XG4gICAgICovXG4gICAgdmFyIHNldEltYWdlQWxpZ25tZW50ID0gZnVuY3Rpb24oaW1hZ2UsIGltYWdlQWxpZ25tZW50KSB7XG4gICAgICAgIHJlbW92ZUltYWdlQWxpZ25tZW50KGltYWdlLCBnZXRJbWFnZUFsaWdubWVudChpbWFnZSkpO1xuXG4gICAgICAgIGlmIChpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULkxFRlQgfHwgaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5SSUdIVCkge1xuICAgICAgICAgICAgaW1hZ2Uuc2V0U3R5bGUoJ2Zsb2F0JywgaW1hZ2VBbGlnbm1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSKSB7XG4gICAgICAgICAgICBDRU5URVJFRF9JTUFHRV9TVFlMRS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc2V0U3R5bGUoc3R5bGUubmFtZSwgc3R5bGUudmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24odmVuZG9yUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zZXRTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBtb2RpZmllcyB0aGUganVzdGlmeSBjb21tYW5kcyB0byBwcm9wZXJseSBhbGlnbiBpbWFnZXMuIFRoaXNcbiAgICAgKiBwbHVnaW4gaXMgYW4gZXhjZXJwdCBvZiBDS0VkaXRvcidzIG9yaWdpbmFsIGltYWdlIG9uZSB0aGF0IGNhbiBiZSBmb3VuZCBhdFxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvci1kZXYvYmxvYi9tYXN0ZXIvcGx1Z2lucy9pbWFnZS9wbHVnaW4uanNcbiAgICAgKlxuICAgICAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX2ltYWdlYWxpZ25tZW50XG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV9pbWFnZWFsaWdubWVudCcsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdwYXN0ZScgZXZlbnQgb24gdGhlIGVkaXRpbmcgYXJlYS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFmdGVySW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWZ0ZXJJbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBBTElHTl9WQUxVRVMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKCdqdXN0aWZ5JyArIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5vbignZXhlYycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkRhdGEgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkRhdGEgJiYgU2VsZWN0aW9uVGVzdC5pbWFnZSh7ZGF0YToge3NlbGVjdGlvbkRhdGE6IHNlbGVjdGlvbkRhdGF9fSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gc2VsZWN0aW9uRGF0YS5lbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUFsaWdubWVudCA9IGdldEltYWdlQWxpZ25tZW50KGltYWdlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVJbWFnZUFsaWdubWVudChpbWFnZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaENvbW1hbmRzKGVkaXRvciwgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50UGF0aChpbWFnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZXZlbnQuZGF0YS5wYXRoLmxhc3RFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTZWxlY3Rpb25UZXN0LmltYWdlKHtkYXRhOiB7c2VsZWN0aW9uRGF0YTogc2VsZWN0aW9uRGF0YX19KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VBbGlnbm1lbnQgPSBnZXRJbWFnZUFsaWdubWVudChzZWxlY3Rpb25EYXRhLmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoaW1hZ2VBbGlnbm1lbnQgPT09IHZhbHVlID8gQ0tFRElUT1IuVFJJU1RBVEVfT04gOiBDS0VESVRPUi5UUklTVEFURV9PRkYpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvcmNlcyBhIHJlZnJlc2ggb2YgdGhlIG1vZGlmaWVkIGp1c3RpZnkgY29tbWFuZHMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGFwcGxpZWQgY2hhbmdlc1xuICAgICAgICAgICAgICogZG8gbm90IG1vZGlmeSB0aGUgc2VsZWN0aW9uLCBzbyB0aGUgcmVmcmVzaCBpcyBuZXZlciB0cmlnZ2VyZWQgYW5kIHRoZSBVSSBkb2VzIG5vdCB1cGRhdGVcbiAgICAgICAgICAgICAqIHByb3Blcmx5IHVudGlsIHRoZSBuZXh0IHNlbGVjdGlvbkNoYW5nZSBldmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yIFRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnRQYXRofSBlbGVtZW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVmcmVzaENvbW1hbmRzOiBmdW5jdGlvbihlZGl0b3IsIGVsZW1lbnRQYXRoKSB7XG4gICAgICAgICAgICAgICAgQUxJR05fVkFMVUVTLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCgnanVzdGlmeScgKyB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQucmVmcmVzaChlZGl0b3IsIGVsZW1lbnRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiaW1wb3J0IGFkZGltYWdlcyBmcm9tICcuL2FkZGltYWdlcyc7XG5pbXBvcnQgYXV0b2xpbmsgZnJvbSAnLi9hdXRvbGluayc7XG5pbXBvcnQgYXV0b2xpc3QgZnJvbSAnLi9hdXRvbGlzdCc7XG5pbXBvcnQgZHJhZ3Jlc2l6ZSBmcm9tICcuL2RyYWdyZXNpemUnO1xuaW1wb3J0IGRyYWdyZXNpemVpZSBmcm9tICcuL2RyYWdyZXNpemVfaWUnO1xuaW1wb3J0IGVtYmVkIGZyb20gJy4vZW1iZWQnO1xuaW1wb3J0IGltYWdlYWxpZ25tZW50IGZyb20gJy4vaW1hZ2VhbGlnbm1lbnQnO1xuaW1wb3J0IHBhc3RlaW1hZ2VzIGZyb20gJy4vcGFzdGVpbWFnZXMnO1xuaW1wb3J0IHBsYWNlaG9sZGVyIGZyb20gJy4vcGxhY2Vob2xkZXInO1xuaW1wb3J0IHNlbGVjdGlvbmtleXN0cm9rZXMgZnJvbSAnLi9zZWxlY3Rpb25rZXlzdHJva2VzJztcbmltcG9ydCB0YWJsZXJlc2l6ZSBmcm9tICcuL3RhYmxlcmVzaXplJztcbmltcG9ydCB0YWJsZXRvb2xzIGZyb20gJy4vdGFibGV0b29scyc7XG5cbmV4cG9ydCB7XG4gICAgYWRkaW1hZ2VzLFxuICAgIGF1dG9saW5rLFxuICAgIGF1dG9saXN0LFxuICAgIGRyYWdyZXNpemUsXG4gICAgZHJhZ3Jlc2l6ZWllLFxuICAgIGVtYmVkLFxuICAgIGltYWdlYWxpZ25tZW50LFxuICAgIHBhc3RlaW1hZ2VzLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIHNlbGVjdGlvbmtleXN0cm9rZXMsXG4gICAgdGFibGVyZXNpemUsXG4gICAgdGFibGV0b29sc1xufTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9wYXN0ZWltYWdlcycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWxsb3dzIHBhc3RpbmcgaW1hZ2VzIGRpcmVjdGx5IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuIFRoZSBpbWFnZSB3aWxsIGJlIGVuY29kZWRcbiAgICAgKiBhcyBEYXRhIFVSSS4gQW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGxpc3Qgb2YgcGFzdGVkIGltYWdlcy4gSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiByZXR1cm5zIGBmYWxzZWAgb3IgY2FuY2VscyB0aGUgZXZlbnQsIHRoZSBpbWFnZXMgd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGNvbnRlbnQuIE90aGVyd2lzZSxcbiAgICAgKiBhbiBldmVudCBgaW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgaW5zZXJ0ZWQgZWxlbWVudCBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLlxuICAgICAqXG4gICAgICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfcGFzdGVpbWFnZXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGJlZm9yZSBhZGRpbmcgaW1hZ2VzIHRvIHRoZSBlZGl0b3IuXG4gICAgICogQGV2ZW50IGJlZm9yZUltYWdlQWRkXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VGaWxlcyBBcnJheSBvZiBpbWFnZSBmaWxlc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhbiBpbWFnZSBpcyBiZWluZyBhZGRlZCB0byB0aGUgZWRpdG9yIHN1Y2Nlc3NmdWxseS5cbiAgICAgKlxuICAgICAqIEBldmVudCBpbWFnZUFkZFxuICAgICAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSBjcmVhdGVkIGltYWdlIHdpdGggc3JjIGFzIERhdGEgVVJJXG4gICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIFRoZSBpbWFnZSBmaWxlXG4gICAgICovXG5cbiAgICBDS0VESVRPUi5wbHVnaW5zLmFkZChcbiAgICAgICAgJ2FlX3Bhc3RlaW1hZ2VzJywge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ3Bhc3RlJyBldmVudCBvbiB0aGUgZWRpdGluZyBhcmVhLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdwYXN0ZScsIHRoaXMuX29uUGFzdGUsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBjcmVhdGVzIGFuIGltZyBlbGVtZW50IHdpdGggc3JjIHRoZSBpbWFnZSBkYXRhIGFzIERhdGEgVVJJLlxuICAgICAgICAgICAgICogVGhlbiwgaXQgZmlyZXMgYW4gJ2ltYWdlQWRkJyBldmVudCB2aWEgQ0tFZGl0b3IncyBldmVudCBzeXN0ZW0uIFRoZSBwYXNzZWRcbiAgICAgICAgICAgICAqIHBhcmFtcyB3aWxsIGJlOlxuICAgICAgICAgICAgICogLSBgZWxgIC0gdGhlIGNyZWF0ZWQgaW1nIGVsZW1lbnRcbiAgICAgICAgICAgICAqIC0gYGZpbGVgIC0gdGhlIG9yaWdpbmFsIHBhc3RlZCBkYXRhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBfb25QYXN0ZVxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGV2ZW50IEEgYHBhc3RlYCBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfb25QYXN0ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhc3RlZERhdGEgPSBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3RlZERhdGEudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUZpbGUgPSBwYXN0ZWREYXRhLmdldEFzRmlsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZWRpdG9yLmZpcmUoJ2JlZm9yZUltYWdlQWRkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUZpbGVzOiBpbWFnZUZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbCgnPGltZyBzcmM9XCInICsgZXZlbnQudGFyZ2V0LnJlc3VsdCArICdcIj4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5zZXJ0RWxlbWVudChlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGltYWdlRmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZUZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn0oKSk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcGxhY2Vob2xkZXInKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ0tFRElUT1IgZW50ZXJNb2RlIGNvbmZpZyBzZXQgdGhlIGJlaGF2aW9yIG9mIHBhcmFncmFwaHNcbiAgICAgKiBXaGVuIHRoZSBjb250ZW50IGlzIGVtcHR5IENLRURJVE9SIGtlZXBzIHRoZSBlbnRlck1vZGUgc3RyaW5nXG4gICAgICogaW50byB0aGUgY29udGVudFxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdmFyIGJyRmlsbGVyID0gQ0tFRElUT1IuZW52Lm5lZWRzQnJGaWxsZXIgPyAnPGJyPicgOiAnJztcblxuICAgIHZhciBlbnRlck1vZGVFbXB0eVZhbHVlID0ge1xuICAgICAgICAxOiBbJzxwPicgKyBickZpbGxlciArICc8L3A+J10sXG4gICAgICAgIDI6IFsnJywgJyAnLCBickZpbGxlcl0sXG4gICAgICAgIDM6IFsnPGRpdj4nICsgYnJGaWxsZXIgKyAnPC9kaXY+J11cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFsbG93cyBhZGRpbmcgYSBwbGFjZWhvbGRlciB0byB0aGUgZWRpdG9yLiBJbiB0aGlzIGNhc2UsIGlmIHRoZXJlXG4gICAgICogaXMgbm8gY29udGVudCB0byB0aGUgZWRpdG9yLCB0aGVyZSB3aWxsIGJlIGhpbnQgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9wbGFjZWhvbGRlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBwbGFjZWhvbGRlciBjbGFzcyB3aGljaCBoYXZlIHRvIGJlIGFkZWQgdG8gZWRpdG9yIHdoZW4gZWRpdG9yIGlzIG5vdCBmb2N1c2VkLlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBwbGFjZWhvbGRlckNsYXNzXG4gICAgICogQGRlZmF1bHQgYWVfcGxhY2Vob2xkZXJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cblxuICAgIENLRURJVE9SLnBsdWdpbnMuYWRkKFxuICAgICAgICAnYWVfcGxhY2Vob2xkZXInLCB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdibHVyJyBhbmQgJ2NvbnRlbnREb20nIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbignYmx1cicsIHRoaXMuX2NoZWNrRW1wdHlEYXRhLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ2NoYW5nZScsIHRoaXMuX2NoZWNrRW1wdHlEYXRhLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBlZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5fcmVtb3ZlUGxhY2Vob2xkZXJDbGFzcywgdGhpcyk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCB0aGlzLl9jaGVja0VtcHR5RGF0YSwgdGhpcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYW55IGRhdGEgZnJvbSB0aGUgY29udGVudCBhbmQgYWRkcyBhIGNsYXNzLFxuICAgICAgICAgICAgICogc3BlY2lmaWVkIGJ5IHRoZSBcInBsYWNlaG9sZGVyQ2xhc3NcIiBjb25maWcgYXR0cmlidXRlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqIEBtZXRob2QgX2NoZWNrRW1wdHlEYXRhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZWRpdG9yIGV2ZW50LCBmaXJlZCBmcm9tIENLRWRpdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9jaGVja0VtcHR5RGF0YTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRhYmxlTm9kZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlubmVySHRtbCA9IGVkaXRhYmxlTm9kZS4kLmlubmVySFRNTC50cmltKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNFbXB0eSA9IGVudGVyTW9kZUVtcHR5VmFsdWVbZWRpdG9yLmNvbmZpZy5lbnRlck1vZGVdLnNvbWUoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJIdG1sID09PSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGVOb2RlLmFkZENsYXNzKGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGVOb2RlLnJlbW92ZUNsYXNzKGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgcGxhY2Vob2xkZXIgY2xhc3Mgd2hlbiBpbnB1dCBpcyBmb2N1c2VkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQG1ldGhvZCBfcmVtb3ZlUGxhY2Vob2xkZXJDbGFzc1xuICAgICAgICAgICAgICsgQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGVkaXRvciBldmVudCwgZmlyZWQgZnJvbSBDS0VkaXRvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVtb3ZlUGxhY2Vob2xkZXJDbGFzczogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gZXZlbnQuZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvck5vZGUgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZWRpdG9yLmVsZW1lbnQuJCk7XG5cbiAgICAgICAgICAgICAgICBlZGl0b3JOb2RlLnJlbW92ZUNsYXNzKGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSgpKTsiLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9zZWxlY3Rpb25rZXlzdHJva2VzJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IHNpbXVsYXRlcyBlZGl0b3IgaW50ZXJhY3Rpb24gZXZlbnRzIGJhc2VkIG9uIG1hbnVhbCBrZXlzdHJva2VzLiBUaGlzXG4gICAgICogY2FuIGJlIHVzZWQgdG8gdHJpZ2dlciBkaWZmZXJlbnQgcmVhY3Rpb25zIGluIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25rZXlzdHJva2VzXG4gICAgICovXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoXG4gICAgICAgICdhZV9zZWxlY3Rpb25rZXlzdHJva2VzJywge1xuICAgICAgICAgICAgcmVxdWlyZXM6ICdhZV9zZWxlY3Rpb25yZWdpb24nLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBhZGRzIGEgY29tbWFuZCB0byB0aGUgZWRpdG9yIGZvciBldmVyeSBkZWZpbmVkIHNlbGVjdGlvbktleXN0cm9rZVxuICAgICAgICAgICAgICogaW4gdGhlIGNvbmZpZ3VyYXRpb24gYW5kIG1hcHMgaXQgdG8gdGhlIHNwZWNpZmllZCBrZXlzdHJva2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBpbml0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLmNvbmZpZy5zZWxlY3Rpb25LZXlzdHJva2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5jb25maWcuc2VsZWN0aW9uS2V5c3Ryb2tlcy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvbktleXN0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBuZXcgQ0tFRElUT1IuY29tbWFuZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFudWFsU2VsZWN0aW9uOiBzZWxlY3Rpb25LZXlzdHJva2Uuc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRGF0YTogZWRpdG9yLmdldFNlbGVjdGlvbkRhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hbmROYW1lID0gJ3NlbGVjdGlvbktleXN0cm9rZScgKyBzZWxlY3Rpb25LZXlzdHJva2Uuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYWRkQ29tbWFuZChjb21tYW5kTmFtZSwgY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0S2V5c3Ryb2tlKHNlbGVjdGlvbktleXN0cm9rZS5rZXlzLCBjb21tYW5kTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KCkpOyIsIi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMTUsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwOi8vY2tlZGl0b3IuY29tL2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV90YWJsZXJlc2l6ZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHhVbml0ID0gQ0tFRElUT1IudG9vbHMuY3NzTGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gZ2V0V2lkdGgoZWwpIHtcbiAgICAgICAgcmV0dXJuIENLRURJVE9SLmVudi5pZSA/IGVsLiQuY2xpZW50V2lkdGggOiBwYXJzZUludChlbC5nZXRDb21wdXRlZFN0eWxlKCd3aWR0aCcpLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9yZGVyV2lkdGgoZWxlbWVudCwgc2lkZSkge1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBlbGVtZW50LmdldENvbXB1dGVkU3R5bGUoJ2JvcmRlci0nICsgc2lkZSArICctd2lkdGgnKSxcbiAgICAgICAgICAgIGJvcmRlck1hcCA9IHtcbiAgICAgICAgICAgICAgICB0aGluOiAnMHB4JyxcbiAgICAgICAgICAgICAgICBtZWRpdW06ICcxcHgnLFxuICAgICAgICAgICAgICAgIHRoaWNrOiAnMnB4J1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29tcHV0ZWQuaW5kZXhPZigncHgnKSA8IDApIHtcbiAgICAgICAgICAgIC8vIGxvb2sgdXAga2V5d29yZHNcbiAgICAgICAgICAgIGlmIChjb21wdXRlZCBpbiBib3JkZXJNYXAgJiYgZWxlbWVudC5nZXRDb21wdXRlZFN0eWxlKCdib3JkZXItc3R5bGUnKSAhPSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZCA9IGJvcmRlck1hcFtjb21wdXRlZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChjb21wdXRlZCwgMTApO1xuICAgIH1cblxuICAgIC8vIEdldHMgdGhlIHRhYmxlIHJvdyB0aGF0IGNvbnRhaW5zIHRoZSBtb3N0IGNvbHVtbnMuXG4gICAgZnVuY3Rpb24gZ2V0TWFzdGVyUGlsbGFyUm93KHRhYmxlKSB7XG4gICAgICAgIHZhciAkcm93cyA9IHRhYmxlLiQucm93cyxcbiAgICAgICAgICAgIG1heENlbGxzID0gMCxcbiAgICAgICAgICAgIGNlbGxzQ291bnQsICRlbGVjdGVkLCAkdHI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRyb3dzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAkdHIgPSAkcm93c1tpXTtcbiAgICAgICAgICAgIGNlbGxzQ291bnQgPSAkdHIuY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoY2VsbHNDb3VudCA+IG1heENlbGxzKSB7XG4gICAgICAgICAgICAgICAgbWF4Q2VsbHMgPSBjZWxsc0NvdW50O1xuICAgICAgICAgICAgICAgICRlbGVjdGVkID0gJHRyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRlbGVjdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkVGFibGVDb2x1bW5QaWxsYXJzKHRhYmxlKSB7XG4gICAgICAgIHZhciBwaWxsYXJzID0gW10sXG4gICAgICAgICAgICBwaWxsYXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgcnRsID0gKHRhYmxlLmdldENvbXB1dGVkU3R5bGUoJ2RpcmVjdGlvbicpID09PSAncnRsJyk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSByYXcgcm93IGVsZW1lbnQgdGhhdCBjb2ludGFpbnMgdGhlIG1vc3QgY29sdW1ucy5cbiAgICAgICAgdmFyICR0ciA9IGdldE1hc3RlclBpbGxhclJvdyh0YWJsZSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB0Ym9keSBlbGVtZW50IGFuZCBwb3NpdGlvbiwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNldCB0aGVcbiAgICAgICAgLy8gdG9wIGFuZCBib3R0b20gYm91bmRhcmllcy5cbiAgICAgICAgdmFyIHRib2R5ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQudEJvZGllc1swXSksXG4gICAgICAgICAgICB0Ym9keVBvc2l0aW9uID0gdGJvZHkuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIExvb3AgdGhvcnVnaCBhbGwgY2VsbHMsIGJ1aWxkaW5nIHBpbGxhcnMgYWZ0ZXIgZWFjaCBvbmUgb2YgdGhlbS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICR0ci5jZWxscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgLy8gQm90aCB0aGUgY3VycmVudCBjZWxsIGFuZCB0aGUgc3VjY2Vzc2l2ZSBvbmUgd2lsbCBiZSB1c2VkIGluIHRoZVxuICAgICAgICAgICAgLy8gcGlsbGFyIHNpemUgY2FsY3VsYXRpb24uXG4gICAgICAgICAgICB2YXIgdGQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJHRyLmNlbGxzW2ldKSxcbiAgICAgICAgICAgICAgICBuZXh0VGQgPSAkdHIuY2VsbHNbaSArIDFdICYmIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCgkdHIuY2VsbHNbaSArIDFdKTtcblxuICAgICAgICAgICAgcGlsbGFySW5kZXggKz0gdGQuJC5jb2xTcGFuIHx8IDE7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGlsbGFyIGJvdW5kYXJ5IHBvc2l0aW9ucy5cbiAgICAgICAgICAgIHZhciBwaWxsYXJMZWZ0LCBwaWxsYXJSaWdodCwgcGlsbGFyV2lkdGg7XG5cbiAgICAgICAgICAgIHZhciB4ID0gdGQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY2VsbC5cbiAgICAgICAgICAgIHJ0bCA/IHBpbGxhclJpZ2h0ID0geCArIGdldEJvcmRlcldpZHRoKHRkLCAnbGVmdCcpIDogcGlsbGFyTGVmdCA9IHggKyB0ZC4kLm9mZnNldFdpZHRoIC0gZ2V0Qm9yZGVyV2lkdGgodGQsICdyaWdodCcpO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb25zIGJhc2VkIG9uIHRoZSBuZXh0IGNlbGwsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGlmIChuZXh0VGQpIHtcbiAgICAgICAgICAgICAgICB4ID0gbmV4dFRkLmdldERvY3VtZW50UG9zaXRpb24oKS54O1xuXG4gICAgICAgICAgICAgICAgcnRsID8gcGlsbGFyTGVmdCA9IHggKyBuZXh0VGQuJC5vZmZzZXRXaWR0aCAtIGdldEJvcmRlcldpZHRoKG5leHRUZCwgJ3JpZ2h0JykgOiBwaWxsYXJSaWdodCA9IHggKyBnZXRCb3JkZXJXaWR0aChuZXh0VGQsICdsZWZ0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgdGFibGUgKGZvciBsYXN0IGNlbGwpLlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IHRhYmxlLmdldERvY3VtZW50UG9zaXRpb24oKS54O1xuXG4gICAgICAgICAgICAgICAgcnRsID8gcGlsbGFyTGVmdCA9IHggOiBwaWxsYXJSaWdodCA9IHggKyB0YWJsZS4kLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaWxsYXJXaWR0aCA9IE1hdGgubWF4KHBpbGxhclJpZ2h0IC0gcGlsbGFyTGVmdCwgNCk7XG5cbiAgICAgICAgICAgIC8vIFRoZSBwaWxsYXIgc2hvdWxkIHJlZmxlY3RzIGV4YWN0bHkgdGhlIHNoYXBlIG9mIHRoZSBob3ZlcmVkXG4gICAgICAgICAgICAvLyBjb2x1bW4gYm9yZGVyIGxpbmUuXG4gICAgICAgICAgICBwaWxsYXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgICBpbmRleDogcGlsbGFySW5kZXgsXG4gICAgICAgICAgICAgICAgeDogcGlsbGFyTGVmdCxcbiAgICAgICAgICAgICAgICB5OiB0Ym9keVBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBpbGxhcldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGJvZHkuJC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgcnRsOiBydGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBpbGxhcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGlsbGFyQXRQb3NpdGlvbihwaWxsYXJzLCBwb3NpdGlvblgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBpbGxhcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaWxsYXIgPSBwaWxsYXJzW2ldO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb25YID49IHBpbGxhci54ICYmIHBvc2l0aW9uWCA8PSAocGlsbGFyLnggKyBwaWxsYXIud2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpbGxhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbmNlbChldnQpIHtcbiAgICAgICAgKGV2dC5kYXRhIHx8IGV2dCkucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2x1bW5SZXNpemVyKGVkaXRvcikge1xuICAgICAgICB2YXIgcGlsbGFyLCBkb2N1bWVudCwgcmVzaXplciwgaXNSZXNpemluZywgc3RhcnRPZmZzZXQsIGN1cnJlbnRTaGlmdDtcblxuICAgICAgICB2YXIgbGVmdFNpZGVDZWxscywgcmlnaHRTaWRlQ2VsbHMsIGxlZnRTaGlmdEJvdW5kYXJ5LCByaWdodFNoaWZ0Qm91bmRhcnk7XG5cbiAgICAgICAgZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgICAgICAgcGlsbGFyID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRTaGlmdCA9IDA7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nID0gMDtcblxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlTGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgICAgICAgcmVzaXplci5yZW1vdmVMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgICAgICAgICAgcmVzaXplci5yZW1vdmVMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRCb2R5KCkuc2V0U3R5bGUoJ2N1cnNvcicsICdhdXRvJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNpemVTdGFydCgpIHtcbiAgICAgICAgICAgIC8vIEJlZm9yZSBzdGFydGluZyB0byByZXNpemUsIGZpZ3VyZSBvdXQgd2hpY2ggY2VsbHMgdG8gY2hhbmdlXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGJvdW5kYXJpZXMgb2YgdGhpcyByZXNpemluZyBzaGlmdC5cblxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gcGlsbGFyLmluZGV4LFxuICAgICAgICAgICAgICAgIG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAocGlsbGFyLnRhYmxlKSxcbiAgICAgICAgICAgICAgICBsZWZ0Q29sdW1uQ2VsbHMgPSBbXSxcbiAgICAgICAgICAgICAgICByaWdodENvbHVtbkNlbGxzID0gW10sXG4gICAgICAgICAgICAgICAgbGVmdE1pblNpemUgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgIHJpZ2h0TWluU2l6ZSA9IGxlZnRNaW5TaXplLFxuICAgICAgICAgICAgICAgIHJ0bCA9IHBpbGxhci5ydGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gbWFwW2ldLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2VsbCA9IHJvd1tjb2x1bW5JbmRleCArIChydGwgPyAxIDogMCldLFxuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwgPSByb3dbY29sdW1uSW5kZXggKyAocnRsID8gMCA6IDEpXTtcblxuICAgICAgICAgICAgICAgIGxlZnRDZWxsID0gbGVmdENlbGwgJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGxlZnRDZWxsKTtcbiAgICAgICAgICAgICAgICByaWdodENlbGwgPSByaWdodENlbGwgJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHJpZ2h0Q2VsbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxlZnRDZWxsIHx8ICFyaWdodENlbGwgfHwgIWxlZnRDZWxsLmVxdWFscyhyaWdodENlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDZWxsICYmIChsZWZ0TWluU2l6ZSA9IE1hdGgubWluKGxlZnRNaW5TaXplLCBnZXRXaWR0aChsZWZ0Q2VsbCkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDZWxsICYmIChyaWdodE1pblNpemUgPSBNYXRoLm1pbihyaWdodE1pblNpemUsIGdldFdpZHRoKHJpZ2h0Q2VsbCkpKTtcblxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29sdW1uQ2VsbHMucHVzaChsZWZ0Q2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q29sdW1uQ2VsbHMucHVzaChyaWdodENlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGxpc3Qgb2YgY2VsbHMgdG8gYmUgcmVzaXplZC5cbiAgICAgICAgICAgIGxlZnRTaWRlQ2VsbHMgPSBsZWZ0Q29sdW1uQ2VsbHM7XG4gICAgICAgICAgICByaWdodFNpZGVDZWxscyA9IHJpZ2h0Q29sdW1uQ2VsbHM7XG5cbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSByZXNpemUgbGltaXQgYm91bmRhcmllcy5cbiAgICAgICAgICAgIGxlZnRTaGlmdEJvdW5kYXJ5ID0gcGlsbGFyLnggLSBsZWZ0TWluU2l6ZTtcbiAgICAgICAgICAgIHJpZ2h0U2hpZnRCb3VuZGFyeSA9IHBpbGxhci54ICsgcmlnaHRNaW5TaXplO1xuXG4gICAgICAgICAgICByZXNpemVyLnNldE9wYWNpdHkoMC41KTtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gcGFyc2VJbnQocmVzaXplci5nZXRTdHlsZSgnbGVmdCcpLCAxMCk7XG4gICAgICAgICAgICBjdXJyZW50U2hpZnQgPSAwO1xuICAgICAgICAgICAgaXNSZXNpemluZyA9IDE7XG5cbiAgICAgICAgICAgIHJlc2l6ZXIub24oJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgbmF0aXZlIGRyYWcgYmVoYXZpb3Igb3RoZXJ3aXNlICdtb3VzZW1vdmUnIHdvbid0IGZpcmUuXG4gICAgICAgICAgICBkb2N1bWVudC5vbignZHJhZ3N0YXJ0JywgY2FuY2VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc2l6ZUVuZCgpIHtcbiAgICAgICAgICAgIGlzUmVzaXppbmcgPSAwO1xuXG4gICAgICAgICAgICByZXNpemVyLnNldE9wYWNpdHkoMCk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRTaGlmdCAmJiByZXNpemVDb2x1bW4oKTtcblxuICAgICAgICAgICAgdmFyIHRhYmxlID0gcGlsbGFyLnRhYmxlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0YWJsZS5yZW1vdmVDdXN0b21EYXRhKCdfY2tlX3RhYmxlX3BpbGxhcnMnKTtcbiAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVMaXN0ZW5lcignZHJhZ3N0YXJ0JywgY2FuY2VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc2l6ZUNvbHVtbigpIHtcbiAgICAgICAgICAgIHZhciBydGwgPSBwaWxsYXIucnRsLFxuICAgICAgICAgICAgICAgIGNlbGxzQ291bnQgPSBydGwgPyByaWdodFNpZGVDZWxscy5sZW5ndGggOiBsZWZ0U2lkZUNlbGxzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgYWN0dWFsIHJlc2l6ZSB0byB0YWJsZSBjZWxscywgb25seSBmb3IgdGhvc2UgYnkgc2lkZSBvZiB0aGUgcGlsbGFyLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxsc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENlbGwgPSBsZWZ0U2lkZUNlbGxzW2ldLFxuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwgPSByaWdodFNpZGVDZWxsc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgdGFibGUgPSBwaWxsYXIudGFibGU7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWZlciB0aGUgcmVzaXppbmcgdG8gYXZvaWQgYW55IGludGVyZmVyZW5jZSBhbW9uZyBjZWxscy5cbiAgICAgICAgICAgICAgICBDS0VESVRPUi50b29scy5zZXRUaW1lb3V0KGZ1bmN0aW9uKGxlZnRDZWxsLCBsZWZ0T2xkV2lkdGgsIHJpZ2h0Q2VsbCwgcmlnaHRPbGRXaWR0aCwgdGFibGVXaWR0aCwgc2l6ZVNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDFweCBpcyB0aGUgbWluaW11bSB2YWxpZCB3aWR0aCAoIzExNjI2KS5cbiAgICAgICAgICAgICAgICAgICAgbGVmdENlbGwgJiYgbGVmdENlbGwuc2V0U3R5bGUoJ3dpZHRoJywgcHhVbml0KE1hdGgubWF4KGxlZnRPbGRXaWR0aCArIHNpemVTaGlmdCwgMSkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDZWxsICYmIHJpZ2h0Q2VsbC5zZXRTdHlsZSgnd2lkdGgnLCBweFVuaXQoTWF0aC5tYXgocmlnaHRPbGRXaWR0aCAtIHNpemVTaGlmdCwgMSkpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgbGFzdCBjZWxsLCB3ZSBuZWVkIHRvIHJlc2l6ZSB0aGUgdGFibGUgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGFibGVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuc2V0U3R5bGUoJ3dpZHRoJywgcHhVbml0KHRhYmxlV2lkdGggKyBzaXplU2hpZnQgKiAocnRsID8gLTEgOiAxKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCwgdGhpcywgW1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2VsbCwgbGVmdENlbGwgJiYgZ2V0V2lkdGgobGVmdENlbGwpLFxuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwsIHJpZ2h0Q2VsbCAmJiBnZXRXaWR0aChyaWdodENlbGwpLCAoIWxlZnRDZWxsIHx8ICFyaWdodENlbGwpICYmIChnZXRXaWR0aCh0YWJsZSkgKyBnZXRCb3JkZXJXaWR0aCh0YWJsZSwgJ2xlZnQnKSArIGdldEJvcmRlcldpZHRoKHRhYmxlLCAncmlnaHQnKSksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaGlmdFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZXZ0KSB7XG4gICAgICAgICAgICBjYW5jZWwoZXZ0KTtcblxuICAgICAgICAgICAgcmVzaXplU3RhcnQoKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQub24oJ21vdXNldXAnLCBvbk1vdXNlVXAsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZVVwKGV2dCkge1xuICAgICAgICAgICAgZXZ0LnJlbW92ZUxpc3RlbmVyKCk7XG5cbiAgICAgICAgICAgIHJlc2l6ZUVuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgICAgICAgICBtb3ZlKGV2dC5kYXRhLmdldFBhZ2VPZmZzZXQoKS54KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50O1xuXG4gICAgICAgIHJlc2l6ZXIgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbCgnPGRpdiBkYXRhLWNrZS10ZW1wPTEgY29udGVudGVkaXRhYmxlPWZhbHNlIHVuc2VsZWN0YWJsZT1vbiAnICtcbiAgICAgICAgICAgICdzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO2N1cnNvcjpjb2wtcmVzaXplO2ZpbHRlcjphbHBoYShvcGFjaXR5PTApO29wYWNpdHk6MDsnICtcbiAgICAgICAgICAgICdwYWRkaW5nOjA7YmFja2dyb3VuZC1jb2xvcjojMDA0O2JhY2tncm91bmQtaW1hZ2U6bm9uZTtib3JkZXI6MHB4IG5vbmU7ei1pbmRleDoxMFwiPjwvZGl2PicsIGRvY3VtZW50KTtcblxuICAgICAgICAvLyBDbGVhbiBET00gd2hlbiBlZGl0b3IgaXMgZGVzdHJveWVkLlxuICAgICAgICBlZGl0b3Iub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc2l6ZXIucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFBsYWNlIHRoZSByZXNpemVyIGFmdGVyIGJvZHkgdG8gcHJldmVudCBpdFxuICAgICAgICAvLyBmcm9tIGJlaW5nIGVkaXRhYmxlLlxuICAgICAgICBkb2N1bWVudC5nZXREb2N1bWVudEVsZW1lbnQoKS5hcHBlbmQocmVzaXplcik7XG5cbiAgICAgICAgdGhpcy5hdHRhY2hUbyA9IGZ1bmN0aW9uKHRhcmdldFBpbGxhcikge1xuICAgICAgICAgICAgLy8gQWNjZXB0IG9ubHkgb25lIHBpbGxhciBhdCBhIHRpbWUuXG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGlsbGFyID0gdGFyZ2V0UGlsbGFyO1xuXG4gICAgICAgICAgICByZXNpemVyLnNldFN0eWxlcyh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHB4VW5pdCh0YXJnZXRQaWxsYXIud2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHhVbml0KHRhcmdldFBpbGxhci5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHB4VW5pdCh0YXJnZXRQaWxsYXIueCksXG4gICAgICAgICAgICAgICAgdG9wOiBweFVuaXQodGFyZ2V0UGlsbGFyLnkpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzaXplci5vbignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIHRoaXMpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRCb2R5KCkuc2V0U3R5bGUoJ2N1cnNvcicsICdjb2wtcmVzaXplJyk7XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgdGhlIHJlc2l6ZXIgdG8gcmVjZWl2ZSBldmVudHMgYnV0IGRvbid0IHNob3cgaXQsXG4gICAgICAgICAgICAvLyBvbmx5IGNoYW5nZSB0aGUgY3Vyc29yIHRvIHJlc2l6YWJsZSBzaGFwZS5cbiAgICAgICAgICAgIHJlc2l6ZXIuc2hvdygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3ZlID0gdGhpcy5tb3ZlID0gZnVuY3Rpb24ocG9zWCkge1xuICAgICAgICAgICAgaWYgKCFwaWxsYXIpe1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzUmVzaXppbmcgJiYgKHBvc1ggPCBwaWxsYXIueCB8fCBwb3NYID4gKHBpbGxhci54ICsgcGlsbGFyLndpZHRoKSkpIHtcbiAgICAgICAgICAgICAgICBkZXRhY2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc2l6ZXJOZXdQb3NpdGlvbiA9IHBvc1ggLSBNYXRoLnJvdW5kKHJlc2l6ZXIuJC5vZmZzZXRXaWR0aCAvIDIpO1xuXG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVyTmV3UG9zaXRpb24gPT09IGxlZnRTaGlmdEJvdW5kYXJ5IHx8IHJlc2l6ZXJOZXdQb3NpdGlvbiA9PT0gcmlnaHRTaGlmdEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc2l6ZXJOZXdQb3NpdGlvbiA9IE1hdGgubWF4KHJlc2l6ZXJOZXdQb3NpdGlvbiwgbGVmdFNoaWZ0Qm91bmRhcnkpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZXJOZXdQb3NpdGlvbiA9IE1hdGgubWluKHJlc2l6ZXJOZXdQb3NpdGlvbiwgcmlnaHRTaGlmdEJvdW5kYXJ5KTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRTaGlmdCA9IHJlc2l6ZXJOZXdQb3NpdGlvbiAtIHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNpemVyLnNldFN0eWxlKCdsZWZ0JywgcHhVbml0KHJlc2l6ZXJOZXdQb3NpdGlvbikpO1xuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhclBpbGxhcnNDYWNoZShldnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2dC5kYXRhLmdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmIChldnQubmFtZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgICAgLy8gQnlwYXNzIGludGVyYWwgbW91c2UgbW92ZS5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0LmlzKCd0YWJsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVzdCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChldnQuZGF0YS4kLnJlbGF0ZWRUYXJnZXQgfHwgZXZ0LmRhdGEuJC50b0VsZW1lbnQpO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3QgJiYgZGVzdC4kICYmICFkZXN0LmVxdWFscyh0YXJnZXQpICYmICFkZXN0LmlzKCdib2R5JykpIHtcbiAgICAgICAgICAgICAgICBkZXN0ID0gZGVzdC5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzdCB8fCBkZXN0LmVxdWFscyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LmdldEFzY2VuZGFudCgndGFibGUnLCAxKS5yZW1vdmVDdXN0b21EYXRhKCdfY2tlX3RhYmxlX3BpbGxhcnMnKTtcbiAgICAgICAgZXZ0LnJlbW92ZUxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgQ0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3RhYmxlcmVzaXplJywge1xuICAgICAgICByZXF1aXJlczogJ2FlX3RhYmxldG9vbHMnLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLm9uKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZXIsXG4gICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbiBDbGFzc2ljIGVkaXRvciBpdCBpcyBiZXR0ZXIgdG8gdXNlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBlZGl0YWJsZSBzbyBldmVudCB3aWxsIHdvcmsgYmVsb3cgYm9keS5cbiAgICAgICAgICAgICAgICBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZS5pc0lubGluZSgpID8gZWRpdGFibGUgOiBlZGl0b3IuZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0ID0gZXZ0LmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2dC5nZXRUYXJnZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGRiBtYXkgcmV0dXJuIGRvY3VtZW50IGFuZCBJRTggc29tZSBVRk8gKG9iamVjdCB3aXRoIG5vIG5vZGVUeXBlIHByb3BlcnR5Li4uKVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQgKCMxMTgyMykuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQudHlwZSAhPT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZVggPSBldnQuZ2V0UGFnZU9mZnNldCgpLng7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgYWxyZWFkeSBhdHRhY2hlZCB0byBhIHBpbGxhciwgc2ltcGx5IG1vdmUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2l6ZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVyICYmIHJlc2l6ZXIubW92ZShwYWdlWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbChldnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgdGFibGUsIHRyLCB0ZCwgdGJvZHkgYnV0IG5vdGhpbmcgZWxzZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlLCBwaWxsYXJzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmlzKCd0YWJsZScpICYmICF0YXJnZXQuZ2V0QXNjZW5kYW50KCd0Ym9keScsIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHRhcmdldC5nZXRBc2NlbmRhbnQoJ3RhYmxlJywgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0YWJsZSB3ZSBmb3VuZCBpcyBpbnNpZGUgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAvLyAoZWcuIHdlIHNob3VsZCBub3QgdXNlIHRhYmxlcyB0aGUgZWRpdG9yIGlzIGVtYmVkZGVkIHdpdGhpbilcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGl0b3IuZWRpdGFibGUoKS5jb250YWlucyh0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBpbGxhcnMgPSB0YWJsZS5nZXRDdXN0b21EYXRhKCdfY2tlX3RhYmxlX3BpbGxhcnMnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRhYmxlIHBpbGxhcnMgY2FsY3VsYXRpb24gcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuc2V0Q3VzdG9tRGF0YSgnX2NrZV90YWJsZV9waWxsYXJzJywgKHBpbGxhcnMgPSBidWlsZFRhYmxlQ29sdW1uUGlsbGFycyh0YWJsZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLm9uKCdtb3VzZW91dCcsIGNsZWFyUGlsbGFyc0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLm9uKCdtb3VzZWRvd24nLCBjbGVhclBpbGxhcnNDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGlsbGFyID0gZ2V0UGlsbGFyQXRQb3NpdGlvbihwaWxsYXJzLCBwYWdlWCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWxsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICFyZXNpemVyICYmIChyZXNpemVyID0gbmV3IGNvbHVtblJlc2l6ZXIoZWRpdG9yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVyLmF0dGFjaFRvKHBpbGxhcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbn0oKSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE1LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cDovL2NrZWRpdG9yLmNvbS9saWNlbnNlXG4gKi9cblxuKCBmdW5jdGlvbigpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV90YWJsZXRvb2xzJykpe1xuXHRcdHJldHVybjtcbiAgICB9XG5cblx0dmFyIGNlbGxOb2RlUmVnZXggPSAvXig/OnRkfHRoKSQvO1xuXG5cdGZ1bmN0aW9uIGdldFNlbGVjdGVkQ2VsbHMoIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXHRcdHZhciByZXR2YWwgPSBbXTtcblx0XHR2YXIgZGF0YWJhc2UgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIG1vdmVPdXRPZkNlbGxHdWFyZCggbm9kZSApIHtcblx0XHRcdC8vIEFwcGx5IHRvIHRoZSBmaXJzdCBjZWxsIG9ubHkuXG5cdFx0XHRpZiAoIHJldHZhbC5sZW5ndGggPiAwIClcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBJZiB3ZSBhcmUgZXhpdGluZyBmcm9tIHRoZSBmaXJzdCA8L3RkPiwgdGhlbiB0aGUgdGQgc2hvdWxkIGRlZmluaXRlbHkgYmVcblx0XHRcdC8vIGluY2x1ZGVkLlxuXHRcdFx0aWYgKCBub2RlLnR5cGUgPT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UICYmIGNlbGxOb2RlUmVnZXgudGVzdCggbm9kZS5nZXROYW1lKCkgKSAmJiAhbm9kZS5nZXRDdXN0b21EYXRhKCAnc2VsZWN0ZWRfY2VsbCcgKSApIHtcblx0XHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuc2V0TWFya2VyKCBkYXRhYmFzZSwgbm9kZSwgJ3NlbGVjdGVkX2NlbGwnLCB0cnVlICk7XG5cdFx0XHRcdHJldHZhbC5wdXNoKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0dmFyIHJhbmdlID0gcmFuZ2VzWyBpIF07XG5cblx0XHRcdGlmICggcmFuZ2UuY29sbGFwc2VkICkge1xuXHRcdFx0XHQvLyBXYWxrZXIgZG9lcyBub3QgaGFuZGxlIGNvbGxhcHNlZCByYW5nZXMgeWV0IC0gZmFsbCBiYWNrIHRvIG9sZCBBUEkuXG5cdFx0XHRcdHZhciBzdGFydE5vZGUgPSByYW5nZS5nZXRDb21tb25BbmNlc3RvcigpO1xuXHRcdFx0XHR2YXIgbmVhcmVzdENlbGwgPSBzdGFydE5vZGUuZ2V0QXNjZW5kYW50KCAndGQnLCB0cnVlICkgfHwgc3RhcnROb2RlLmdldEFzY2VuZGFudCggJ3RoJywgdHJ1ZSApO1xuXHRcdFx0XHRpZiAoIG5lYXJlc3RDZWxsIClcblx0XHRcdFx0XHRyZXR2YWwucHVzaCggbmVhcmVzdENlbGwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB3YWxrZXIgPSBuZXcgQ0tFRElUT1IuZG9tLndhbGtlciggcmFuZ2UgKTtcblx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdHdhbGtlci5ndWFyZCA9IG1vdmVPdXRPZkNlbGxHdWFyZDtcblxuXHRcdFx0XHR3aGlsZSAoICggbm9kZSA9IHdhbGtlci5uZXh0KCkgKSApIHtcblx0XHRcdFx0XHQvLyBJZiBtYXkgYmUgcG9zc2libGUgZm9yIHVzIHRvIGhhdmUgYSByYW5nZSBsaWtlIHRoaXM6XG5cdFx0XHRcdFx0Ly8gPHRkPl4xPC90ZD48dGQ+XjI8L3RkPlxuXHRcdFx0XHRcdC8vIFRoZSAybmQgdGQgc2hvdWxkbid0IGJlIGluY2x1ZGVkLlxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gU28gd2UgaGF2ZSB0byB0YWtlIGNhcmUgdG8gaW5jbHVkZSBhIHRkIHdlJ3ZlIGVudGVyZWQgb25seSB3aGVuIHdlJ3ZlXG5cdFx0XHRcdFx0Ly8gd2Fsa2VkIGludG8gaXRzIGNoaWxkcmVuLlxuXG5cdFx0XHRcdFx0aWYgKCBub2RlLnR5cGUgIT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UIHx8ICFub2RlLmlzKCBDS0VESVRPUi5kdGQudGFibGUgKSApIHtcblx0XHRcdFx0XHRcdHZhciBwYXJlbnQgPSBub2RlLmdldEFzY2VuZGFudCggJ3RkJywgdHJ1ZSApIHx8IG5vZGUuZ2V0QXNjZW5kYW50KCAndGgnLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmVudCAmJiAhcGFyZW50LmdldEN1c3RvbURhdGEoICdzZWxlY3RlZF9jZWxsJyApICkge1xuXHRcdFx0XHRcdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoIGRhdGFiYXNlLCBwYXJlbnQsICdzZWxlY3RlZF9jZWxsJywgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0XHRyZXR2YWwucHVzaCggcGFyZW50ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuY2xlYXJBbGxNYXJrZXJzKCBkYXRhYmFzZSApO1xuXG5cdFx0cmV0dXJuIHJldHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMoIGNlbGxzVG9EZWxldGUgKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGFzdCA9IGNlbGxzVG9EZWxldGUubGVuZ3RoIC0gMSxcblx0XHRcdGRhdGFiYXNlID0ge30sXG5cdFx0XHRjZWxsLCBmb2N1c2VkQ2VsbCwgdHI7XG5cblx0XHR3aGlsZSAoICggY2VsbCA9IGNlbGxzVG9EZWxldGVbIGkrKyBdICkgKVxuXHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuc2V0TWFya2VyKCBkYXRhYmFzZSwgY2VsbCwgJ2RlbGV0ZV9jZWxsJywgdHJ1ZSApO1xuXG5cdFx0Ly8gMS5maXJzdCB3ZSBjaGVjayBsZWZ0IG9yIHJpZ2h0IHNpZGUgZm9jdXNhYmxlIGNlbGwgcm93IGJ5IHJvdztcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY2VsbCA9IGNlbGxzVG9EZWxldGVbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoICggZm9jdXNlZENlbGwgPSBjZWxsLmdldFByZXZpb3VzKCkgKSAmJiAhZm9jdXNlZENlbGwuZ2V0Q3VzdG9tRGF0YSggJ2RlbGV0ZV9jZWxsJyApIHx8ICggZm9jdXNlZENlbGwgPSBjZWxsLmdldE5leHQoKSApICYmICFmb2N1c2VkQ2VsbC5nZXRDdXN0b21EYXRhKCAnZGVsZXRlX2NlbGwnICkgKSB7XG5cdFx0XHRcdENLRURJVE9SLmRvbS5lbGVtZW50LmNsZWFyQWxsTWFya2VycyggZGF0YWJhc2UgKTtcblx0XHRcdFx0cmV0dXJuIGZvY3VzZWRDZWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdENLRURJVE9SLmRvbS5lbGVtZW50LmNsZWFyQWxsTWFya2VycyggZGF0YWJhc2UgKTtcblxuXHRcdC8vIDIuIHRoZW4gd2UgY2hlY2sgdGhlIHRvcHBlc3Qgcm93IChvdXRzaWRlIHRoZSBzZWxlY3Rpb24gYXJlYSBzcXVhcmUpIGZvY3VzYWJsZSBjZWxsXG5cdFx0dHIgPSBjZWxsc1RvRGVsZXRlWyAwIF0uZ2V0UGFyZW50KCk7XG5cdFx0aWYgKCAoIHRyID0gdHIuZ2V0UHJldmlvdXMoKSApIClcblx0XHRcdHJldHVybiB0ci5nZXRMYXN0KCk7XG5cblx0XHQvLyAzLiBsYXN0IHdlIGNoZWNrIHRoZSBsb3dlcmVzdCAgcm93IGZvY3VzYWJsZSBjZWxsXG5cdFx0dHIgPSBjZWxsc1RvRGVsZXRlWyBsYXN0IF0uZ2V0UGFyZW50KCk7XG5cdFx0aWYgKCAoIHRyID0gdHIuZ2V0TmV4dCgpICkgKVxuXHRcdFx0cmV0dXJuIHRyLmdldENoaWxkKCAwICk7XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc2VydFJvdyggc2VsZWN0aW9uLCBpbnNlcnRCZWZvcmUgKSB7XG5cdFx0dmFyIGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyggc2VsZWN0aW9uICksXG5cdFx0XHRmaXJzdENlbGwgPSBjZWxsc1sgMCBdLFxuXHRcdFx0dGFibGUgPSBmaXJzdENlbGwuZ2V0QXNjZW5kYW50KCAndGFibGUnICksXG5cdFx0XHRkb2MgPSBmaXJzdENlbGwuZ2V0RG9jdW1lbnQoKSxcblx0XHRcdHN0YXJ0Um93ID0gY2VsbHNbIDAgXS5nZXRQYXJlbnQoKSxcblx0XHRcdHN0YXJ0Um93SW5kZXggPSBzdGFydFJvdy4kLnJvd0luZGV4LFxuXHRcdFx0bGFzdENlbGwgPSBjZWxsc1sgY2VsbHMubGVuZ3RoIC0gMSBdLFxuXHRcdFx0ZW5kUm93SW5kZXggPSBsYXN0Q2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4ICsgbGFzdENlbGwuJC5yb3dTcGFuIC0gMSxcblx0XHRcdGVuZFJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggdGFibGUuJC5yb3dzWyBlbmRSb3dJbmRleCBdICksXG5cdFx0XHRyb3dJbmRleCA9IGluc2VydEJlZm9yZSA/IHN0YXJ0Um93SW5kZXggOiBlbmRSb3dJbmRleCxcblx0XHRcdHJvdyA9IGluc2VydEJlZm9yZSA/IHN0YXJ0Um93IDogZW5kUm93O1xuXG5cdFx0dmFyIG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAoIHRhYmxlICksXG5cdFx0XHRjbG9uZVJvdyA9IG1hcFsgcm93SW5kZXggXSxcblx0XHRcdG5leHRSb3cgPSBpbnNlcnRCZWZvcmUgPyBtYXBbIHJvd0luZGV4IC0gMSBdIDogbWFwWyByb3dJbmRleCArIDEgXSxcblx0XHRcdHdpZHRoID0gbWFwWyAwIF0ubGVuZ3RoO1xuXG5cdFx0dmFyIG5ld1JvdyA9IGRvYy5jcmVhdGVFbGVtZW50KCAndHInICk7XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBjbG9uZVJvd1sgaSBdICYmIGkgPCB3aWR0aDsgaSsrICkge1xuXHRcdFx0dmFyIGNlbGw7XG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIHRoZXJlJ3MgYSBzcGFubmluZyByb3cgaGVyZSwgZG8gbm90IGJyZWFrIGl0LlxuXHRcdFx0aWYgKCBjbG9uZVJvd1sgaSBdLnJvd1NwYW4gPiAxICYmIG5leHRSb3cgJiYgY2xvbmVSb3dbIGkgXSA9PSBuZXh0Um93WyBpIF0gKSB7XG5cdFx0XHRcdGNlbGwgPSBjbG9uZVJvd1sgaSBdO1xuXHRcdFx0XHRjZWxsLnJvd1NwYW4gKz0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIGNsb25lUm93WyBpIF0gKS5jbG9uZSgpO1xuXHRcdFx0XHRjZWxsLnJlbW92ZUF0dHJpYnV0ZSggJ3Jvd1NwYW4nICk7XG5cdFx0XHRcdGNlbGwuYXBwZW5kQm9ndXMoKTtcblx0XHRcdFx0bmV3Um93LmFwcGVuZCggY2VsbCApO1xuXHRcdFx0XHRjZWxsID0gY2VsbC4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGNlbGwuY29sU3BhbiAtIDE7XG5cdFx0fVxuXG5cdFx0aW5zZXJ0QmVmb3JlID8gbmV3Um93Lmluc2VydEJlZm9yZSggcm93ICkgOiBuZXdSb3cuaW5zZXJ0QWZ0ZXIoIHJvdyApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlUm93cyggc2VsZWN0aW9uT3JSb3cgKSB7XG5cdFx0aWYgKCBzZWxlY3Rpb25PclJvdyBpbnN0YW5jZW9mIENLRURJVE9SLmRvbS5zZWxlY3Rpb24gKSB7XG5cdFx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb25PclJvdyApLFxuXHRcdFx0XHRmaXJzdENlbGwgPSBjZWxsc1sgMCBdLFxuXHRcdFx0XHR0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdFx0bWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdFx0c3RhcnRSb3cgPSBjZWxsc1sgMCBdLmdldFBhcmVudCgpLFxuXHRcdFx0XHRzdGFydFJvd0luZGV4ID0gc3RhcnRSb3cuJC5yb3dJbmRleCxcblx0XHRcdFx0bGFzdENlbGwgPSBjZWxsc1sgY2VsbHMubGVuZ3RoIC0gMSBdLFxuXHRcdFx0XHRlbmRSb3dJbmRleCA9IGxhc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXggKyBsYXN0Q2VsbC4kLnJvd1NwYW4gLSAxLFxuXHRcdFx0XHRyb3dzVG9EZWxldGUgPSBbXTtcblxuXHRcdFx0Ly8gRGVsZXRlIGNlbGwgb3IgcmVkdWNlIGNlbGwgc3BhbnMgYnkgY2hlY2tpbmcgdGhyb3VnaCB0aGUgdGFibGUgbWFwLlxuXHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydFJvd0luZGV4OyBpIDw9IGVuZFJvd0luZGV4OyBpKysgKSB7XG5cdFx0XHRcdHZhciBtYXBSb3cgPSBtYXBbIGkgXSxcblx0XHRcdFx0XHRyb3cgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHRhYmxlLiQucm93c1sgaSBdICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbWFwUm93Lmxlbmd0aDsgaisrICkge1xuXHRcdFx0XHRcdHZhciBjZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBtYXBSb3dbIGogXSApLFxuXHRcdFx0XHRcdFx0Y2VsbFJvd0luZGV4ID0gY2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4O1xuXG5cdFx0XHRcdFx0aWYgKCBjZWxsLiQucm93U3BhbiA9PSAxIClcblx0XHRcdFx0XHRcdGNlbGwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0Ly8gUm93IHNwYW5uZWQgY2VsbC5cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFNwYW4gcm93IG9mIHRoZSBjZWxsLCByZWR1Y2Ugc3Bhbm5pbmcuXG5cdFx0XHRcdFx0XHRjZWxsLiQucm93U3BhbiAtPSAxO1xuXHRcdFx0XHRcdFx0Ly8gUm9vdCByb3cgb2YgdGhlIGNlbGwsIHJvb3QgY2VsbCB0byBuZXh0IHJvdy5cblx0XHRcdFx0XHRcdGlmICggY2VsbFJvd0luZGV4ID09IGkgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBuZXh0TWFwUm93ID0gbWFwWyBpICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRuZXh0TWFwUm93WyBqIC0gMSBdID8gY2VsbC5pbnNlcnRBZnRlciggbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBuZXh0TWFwUm93WyBqIC0gMSBdICkgKSA6IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggdGFibGUuJC5yb3dzWyBpICsgMSBdICkuYXBwZW5kKCBjZWxsLCAxICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aiArPSBjZWxsLiQuY29sU3BhbiAtIDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyb3dzVG9EZWxldGUucHVzaCggcm93ICk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciByb3dzID0gdGFibGUuJC5yb3dzO1xuXG5cdFx0XHQvLyBXaGVyZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciByb3dzIGJlZW4gZGVsZXRlZD9cblx0XHRcdC8vIDEuIEludG8gbmV4dCBzaWJsaW5nIHJvdyBpZiBhbnk7XG5cdFx0XHQvLyAyLiBJbnRvIHByZXZpb3VzIHNpYmxpbmcgcm93IGlmIGFueTtcblx0XHRcdC8vIDMuIEludG8gdGFibGUncyBwYXJlbnQgZWxlbWVudCBpZiBpdCdzIHRoZSB2ZXJ5IGxhc3Qgcm93LlxuXHRcdFx0dmFyIGN1cnNvclBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCByb3dzWyBlbmRSb3dJbmRleCArIDEgXSB8fCAoIHN0YXJ0Um93SW5kZXggPiAwID8gcm93c1sgc3RhcnRSb3dJbmRleCAtIDEgXSA6IG51bGwgKSB8fCB0YWJsZS4kLnBhcmVudE5vZGUgKTtcblxuXHRcdFx0Zm9yICggaSA9IHJvd3NUb0RlbGV0ZS5sZW5ndGg7IGkgPj0gMDsgaS0tIClcblx0XHRcdFx0ZGVsZXRlUm93cyggcm93c1RvRGVsZXRlWyBpIF0gKTtcblxuXHRcdFx0cmV0dXJuIGN1cnNvclBvc2l0aW9uO1xuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdGlvbk9yUm93IGluc3RhbmNlb2YgQ0tFRElUT1IuZG9tLmVsZW1lbnQgKSB7XG5cdFx0XHR0YWJsZSA9IHNlbGVjdGlvbk9yUm93LmdldEFzY2VuZGFudCggJ3RhYmxlJyApO1xuXG5cdFx0XHRpZiAoIHRhYmxlLiQucm93cy5sZW5ndGggPT0gMSApXG5cdFx0XHRcdHRhYmxlLnJlbW92ZSgpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzZWxlY3Rpb25PclJvdy5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENlbGxDb2xJbmRleCggY2VsbCwgaXNTdGFydCApIHtcblx0XHR2YXIgcm93ID0gY2VsbC5nZXRQYXJlbnQoKSxcblx0XHRcdHJvd0NlbGxzID0gcm93LiQuY2VsbHM7XG5cblx0XHR2YXIgY29sSW5kZXggPSAwO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHJvd0NlbGxzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0dmFyIG1hcENlbGwgPSByb3dDZWxsc1sgaSBdO1xuXHRcdFx0Y29sSW5kZXggKz0gaXNTdGFydCA/IDEgOiBtYXBDZWxsLmNvbFNwYW47XG5cdFx0XHRpZiAoIG1hcENlbGwgPT0gY2VsbC4kIClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbEluZGV4IC0gMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbHVtbnNJbmRpY2VzKCBjZWxscywgaXNTdGFydCApIHtcblx0XHR2YXIgcmV0dmFsID0gaXNTdGFydCA/IEluZmluaXR5IDogMDtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdHZhciBjb2xJbmRleCA9IGdldENlbGxDb2xJbmRleCggY2VsbHNbIGkgXSwgaXNTdGFydCApO1xuXHRcdFx0aWYgKCBpc1N0YXJ0ID8gY29sSW5kZXggPCByZXR2YWwgOiBjb2xJbmRleCA+IHJldHZhbCApXG5cdFx0XHRcdHJldHZhbCA9IGNvbEluZGV4O1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Q29sdW1uKCBzZWxlY3Rpb24sIGluc2VydEJlZm9yZSApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKSxcblx0XHRcdGZpcnN0Q2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHR0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdHN0YXJ0Q29sID0gZ2V0Q29sdW1uc0luZGljZXMoIGNlbGxzLCAxICksXG5cdFx0XHRsYXN0Q29sID0gZ2V0Q29sdW1uc0luZGljZXMoIGNlbGxzICksXG5cdFx0XHRjb2xJbmRleCA9IGluc2VydEJlZm9yZSA/IHN0YXJ0Q29sIDogbGFzdENvbDtcblxuXHRcdHZhciBtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKCB0YWJsZSApLFxuXHRcdFx0Y2xvbmVDb2wgPSBbXSxcblx0XHRcdG5leHRDb2wgPSBbXSxcblx0XHRcdGhlaWdodCA9IG1hcC5sZW5ndGg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKyApIHtcblx0XHRcdGNsb25lQ29sLnB1c2goIG1hcFsgaSBdWyBjb2xJbmRleCBdICk7XG5cdFx0XHR2YXIgbmV4dENlbGwgPSBpbnNlcnRCZWZvcmUgPyBtYXBbIGkgXVsgY29sSW5kZXggLSAxIF0gOiBtYXBbIGkgXVsgY29sSW5kZXggKyAxIF07XG5cdFx0XHRuZXh0Q29sLnB1c2goIG5leHRDZWxsICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKyApIHtcblx0XHRcdHZhciBjZWxsO1xuXG5cdFx0XHRpZiAoICFjbG9uZUNvbFsgaSBdIClcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgdGhlcmUncyBhIHNwYW5uaW5nIGNvbHVtbiBoZXJlLCBkbyBub3QgYnJlYWsgaXQuXG5cdFx0XHRpZiAoIGNsb25lQ29sWyBpIF0uY29sU3BhbiA+IDEgJiYgbmV4dENvbFsgaSBdID09IGNsb25lQ29sWyBpIF0gKSB7XG5cdFx0XHRcdGNlbGwgPSBjbG9uZUNvbFsgaSBdO1xuXHRcdFx0XHRjZWxsLmNvbFNwYW4gKz0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIGNsb25lQ29sWyBpIF0gKS5jbG9uZSgpO1xuXHRcdFx0XHRjZWxsLnJlbW92ZUF0dHJpYnV0ZSggJ2NvbFNwYW4nICk7XG5cdFx0XHRcdGNlbGwuYXBwZW5kQm9ndXMoKTtcblx0XHRcdFx0Y2VsbFsgaW5zZXJ0QmVmb3JlID8gJ2luc2VydEJlZm9yZScgOiAnaW5zZXJ0QWZ0ZXInIF0uY2FsbCggY2VsbCwgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCBjbG9uZUNvbFsgaSBdICkgKTtcblx0XHRcdFx0Y2VsbCA9IGNlbGwuJDtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBjZWxsLnJvd1NwYW4gLSAxO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUNvbHVtbnMoIHNlbGVjdGlvbk9yQ2VsbCApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb25PckNlbGwgKSxcblx0XHRcdGZpcnN0Q2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHRsYXN0Q2VsbCA9IGNlbGxzWyBjZWxscy5sZW5ndGggLSAxIF0sXG5cdFx0XHR0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAoIHRhYmxlICksXG5cdFx0XHRzdGFydENvbEluZGV4LCBlbmRDb2xJbmRleCxcblx0XHRcdHJvd3NUb0RlbGV0ZSA9IFtdO1xuXG5cdFx0Ly8gRmlndXJlIG91dCBzZWxlY3RlZCBjZWxscycgY29sdW1uIGluZGljZXMuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCByb3dzID0gbWFwLmxlbmd0aDsgaSA8IHJvd3M7IGkrKyApIHtcblx0XHRcdGZvciAoIHZhciBqID0gMCwgY29scyA9IG1hcFsgaSBdLmxlbmd0aDsgaiA8IGNvbHM7IGorKyApIHtcblx0XHRcdFx0aWYgKCBtYXBbIGkgXVsgaiBdID09IGZpcnN0Q2VsbC4kIClcblx0XHRcdFx0XHRzdGFydENvbEluZGV4ID0gajtcblx0XHRcdFx0aWYgKCBtYXBbIGkgXVsgaiBdID09IGxhc3RDZWxsLiQgKVxuXHRcdFx0XHRcdGVuZENvbEluZGV4ID0gajtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWxldGUgY2VsbCBvciByZWR1Y2UgY2VsbCBzcGFucyBieSBjaGVja2luZyB0aHJvdWdoIHRoZSB0YWJsZSBtYXAuXG5cdFx0Zm9yICggaSA9IHN0YXJ0Q29sSW5kZXg7IGkgPD0gZW5kQ29sSW5kZXg7IGkrKyApIHtcblx0XHRcdGZvciAoIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrICkge1xuXHRcdFx0XHR2YXIgbWFwUm93ID0gbWFwWyBqIF0sXG5cdFx0XHRcdFx0cm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCB0YWJsZS4kLnJvd3NbIGogXSApLFxuXHRcdFx0XHRcdGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIG1hcFJvd1sgaSBdICk7XG5cblx0XHRcdFx0aWYgKCBjZWxsLiQgKSB7XG5cdFx0XHRcdFx0aWYgKCBjZWxsLiQuY29sU3BhbiA9PSAxIClcblx0XHRcdFx0XHRcdGNlbGwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0Ly8gUmVkdWNlIHRoZSBjb2wgc3BhbnMuXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0Y2VsbC4kLmNvbFNwYW4gLT0gMTtcblxuXHRcdFx0XHRcdGogKz0gY2VsbC4kLnJvd1NwYW4gLSAxO1xuXG5cdFx0XHRcdFx0aWYgKCAhcm93LiQuY2VsbHMubGVuZ3RoIClcblx0XHRcdFx0XHRcdHJvd3NUb0RlbGV0ZS5wdXNoKCByb3cgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBmaXJzdFJvd0NlbGxzID0gdGFibGUuJC5yb3dzWyAwIF0gJiYgdGFibGUuJC5yb3dzWyAwIF0uY2VsbHM7XG5cblx0XHQvLyBXaGVyZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciBjb2x1bW5zIGJlZW4gZGVsZXRlZD9cblx0XHQvLyAxLiBJbnRvIG5leHQgY2VsbCBvZiB0aGUgZmlyc3Qgcm93IGlmIGFueTtcblx0XHQvLyAyLiBJbnRvIHByZXZpb3VzIGNlbGwgb2YgdGhlIGZpcnN0IHJvdyBpZiBhbnk7XG5cdFx0Ly8gMy4gSW50byB0YWJsZSdzIHBhcmVudCBlbGVtZW50O1xuXHRcdHZhciBjdXJzb3JQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggZmlyc3RSb3dDZWxsc1sgc3RhcnRDb2xJbmRleCBdIHx8ICggc3RhcnRDb2xJbmRleCA/IGZpcnN0Um93Q2VsbHNbIHN0YXJ0Q29sSW5kZXggLSAxIF0gOiB0YWJsZS4kLnBhcmVudE5vZGUgKSApO1xuXG5cdFx0Ly8gRGVsZXRlIHRhYmxlIHJvd3Mgb25seSBpZiBhbGwgY29sdW1ucyBhcmUgZ29uZSAoZG8gbm90IHJlbW92ZSBlbXB0eSByb3cpLlxuXHRcdGlmICggcm93c1RvRGVsZXRlLmxlbmd0aCA9PSByb3dzIClcblx0XHRcdHRhYmxlLnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIGN1cnNvclBvc2l0aW9uO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Q2VsbCggc2VsZWN0aW9uLCBpbnNlcnRCZWZvcmUgKSB7XG5cdFx0dmFyIHN0YXJ0RWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKTtcblx0XHR2YXIgY2VsbCA9IHN0YXJ0RWxlbWVudC5nZXRBc2NlbmRhbnQoICd0ZCcsIDEgKSB8fCBzdGFydEVsZW1lbnQuZ2V0QXNjZW5kYW50KCAndGgnLCAxICk7XG5cblx0XHRpZiAoICFjZWxsIClcblx0XHRcdHJldHVybjtcblxuXHRcdC8vIENyZWF0ZSB0aGUgbmV3IGNlbGwgZWxlbWVudCB0byBiZSBhZGRlZC5cblx0XHR2YXIgbmV3Q2VsbCA9IGNlbGwuY2xvbmUoKTtcblx0XHRuZXdDZWxsLmFwcGVuZEJvZ3VzKCk7XG5cblx0XHRpZiAoIGluc2VydEJlZm9yZSApXG5cdFx0XHRuZXdDZWxsLmluc2VydEJlZm9yZSggY2VsbCApO1xuXHRcdGVsc2Vcblx0XHRcdG5ld0NlbGwuaW5zZXJ0QWZ0ZXIoIGNlbGwgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUNlbGxzKCBzZWxlY3Rpb25PckNlbGwgKSB7XG5cdFx0aWYgKCBzZWxlY3Rpb25PckNlbGwgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uc2VsZWN0aW9uICkge1xuXHRcdFx0dmFyIGNlbGxzVG9EZWxldGUgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb25PckNlbGwgKTtcblx0XHRcdHZhciB0YWJsZSA9IGNlbGxzVG9EZWxldGVbIDAgXSAmJiBjZWxsc1RvRGVsZXRlWyAwIF0uZ2V0QXNjZW5kYW50KCAndGFibGUnICk7XG5cdFx0XHR2YXIgY2VsbFRvRm9jdXMgPSBnZXRGb2N1c0VsZW1lbnRBZnRlckRlbENlbGxzKCBjZWxsc1RvRGVsZXRlICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gY2VsbHNUb0RlbGV0ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSApXG5cdFx0XHRcdGRlbGV0ZUNlbGxzKCBjZWxsc1RvRGVsZXRlWyBpIF0gKTtcblxuXHRcdFx0aWYgKCBjZWxsVG9Gb2N1cyApXG5cdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKCBjZWxsVG9Gb2N1cywgdHJ1ZSApO1xuXHRcdFx0ZWxzZSBpZiAoIHRhYmxlIClcblx0XHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0fSBlbHNlIGlmICggc2VsZWN0aW9uT3JDZWxsIGluc3RhbmNlb2YgQ0tFRElUT1IuZG9tLmVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgdHIgPSBzZWxlY3Rpb25PckNlbGwuZ2V0UGFyZW50KCk7XG5cdFx0XHRpZiAoIHRyLmdldENoaWxkQ291bnQoKSA9PSAxIClcblx0XHRcdFx0dHIucmVtb3ZlKCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHNlbGVjdGlvbk9yQ2VsbC5yZW1vdmUoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgZmlsbGVyIGF0IGVuZCBhbmQgZW1wdHkgc3BhY2VzIGFyb3VuZCB0aGUgY2VsbCBjb250ZW50LlxuXHRmdW5jdGlvbiB0cmltQ2VsbCggY2VsbCApIHtcblx0XHR2YXIgYm9ndXMgPSBjZWxsLmdldEJvZ3VzKCk7XG5cdFx0Ym9ndXMgJiYgYm9ndXMucmVtb3ZlKCk7XG5cdFx0Y2VsbC50cmltKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBwbGFjZUN1cnNvckluQ2VsbCggY2VsbCwgcGxhY2VBdEVuZCApIHtcblx0XHR2YXIgZG9jSW5uZXIgPSBjZWxsLmdldERvY3VtZW50KCksXG5cdFx0XHRkb2NPdXRlciA9IENLRURJVE9SLmRvY3VtZW50O1xuXG5cdFx0Ly8gRml4aW5nIFwiVW5zcGVjaWZpZWQgZXJyb3JcIiB0aHJvd24gaW4gSUUxMCBieSByZXNldHRpbmdcblx0XHQvLyBzZWxlY3Rpb24gdGhlIGRpcnR5IGFuZCBzaGFtZWZ1bCB3YXkgKCMxMDMwOCkuXG5cdFx0Ly8gV2UgY2FuIG5vdCBhcHBseSB0aGlzIGhhY2sgdG8gSUU4IGJlY2F1c2Vcblx0XHQvLyBpdCBjYXVzZXMgZXJyb3IgKCMxMTA1OCkuXG5cdFx0aWYgKCBDS0VESVRPUi5lbnYuaWUgJiYgQ0tFRElUT1IuZW52LnZlcnNpb24gPT0gMTAgKSB7XG5cdFx0XHRkb2NPdXRlci5mb2N1cygpO1xuXHRcdFx0ZG9jSW5uZXIuZm9jdXMoKTtcblx0XHR9XG5cblx0XHR2YXIgcmFuZ2UgPSBuZXcgQ0tFRElUT1IuZG9tLnJhbmdlKCBkb2NJbm5lciApO1xuXHRcdGlmICggIXJhbmdlWyAnbW92ZVRvRWxlbWVudEVkaXQnICsgKCBwbGFjZUF0RW5kID8gJ0VuZCcgOiAnU3RhcnQnICkgXSggY2VsbCApICkge1xuXHRcdFx0cmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKCBjZWxsICk7XG5cdFx0XHRyYW5nZS5jb2xsYXBzZSggcGxhY2VBdEVuZCA/IGZhbHNlIDogdHJ1ZSApO1xuXHRcdH1cblx0XHRyYW5nZS5zZWxlY3QoIHRydWUgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNlbGxJblJvdyggdGFibGVNYXAsIHJvd0luZGV4LCBjZWxsICkge1xuXHRcdHZhciBvUm93ID0gdGFibGVNYXBbIHJvd0luZGV4IF07XG5cdFx0aWYgKCB0eXBlb2YgY2VsbCA9PSAndW5kZWZpbmVkJyApXG5cdFx0XHRyZXR1cm4gb1JvdztcblxuXHRcdGZvciAoIHZhciBjID0gMDsgb1JvdyAmJiBjIDwgb1Jvdy5sZW5ndGg7IGMrKyApIHtcblx0XHRcdGlmICggY2VsbC5pcyAmJiBvUm93WyBjIF0gPT0gY2VsbC4kIClcblx0XHRcdFx0cmV0dXJuIGM7XG5cdFx0XHRlbHNlIGlmICggYyA9PSBjZWxsIClcblx0XHRcdFx0cmV0dXJuIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggb1Jvd1sgYyBdICk7XG5cdFx0fVxuXHRcdHJldHVybiBjZWxsLmlzID8gLTEgOiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2VsbEluQ29sKCB0YWJsZU1hcCwgY29sSW5kZXggKSB7XG5cdFx0dmFyIG9Db2wgPSBbXTtcblx0XHRmb3IgKCB2YXIgciA9IDA7IHIgPCB0YWJsZU1hcC5sZW5ndGg7IHIrKyApIHtcblx0XHRcdHZhciByb3cgPSB0YWJsZU1hcFsgciBdO1xuXHRcdFx0b0NvbC5wdXNoKCByb3dbIGNvbEluZGV4IF0gKTtcblxuXHRcdFx0Ly8gQXZvaWQgYWRkaW5nIGR1cGxpY2F0ZSBjZWxscy5cblx0XHRcdGlmICggcm93WyBjb2xJbmRleCBdLnJvd1NwYW4gPiAxIClcblx0XHRcdFx0ciArPSByb3dbIGNvbEluZGV4IF0ucm93U3BhbiAtIDE7XG5cdFx0fVxuXHRcdHJldHVybiBvQ29sO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWVyZ2VDZWxscyggc2VsZWN0aW9uLCBtZXJnZURpcmVjdGlvbiwgaXNEZXRlY3QgKSB7XG5cdFx0dmFyIGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyggc2VsZWN0aW9uICk7XG5cblx0XHQvLyBJbnZhbGlkIG1lcmdlIHJlcXVlc3QgaWY6XG5cdFx0Ly8gMS4gSW4gYmF0Y2ggbW9kZSBkZXNwaXRlIHRoYXQgbGVzcyB0aGFuIHR3byBzZWxlY3RlZC5cblx0XHQvLyAyLiBJbiBzb2xvIG1vZGUgd2hpbGUgbm90IGV4YWN0bHkgb25seSBvbmUgc2VsZWN0ZWQuXG5cdFx0Ly8gMy4gQ2VsbHMgZGlzdHJpYnV0ZWQgaW4gZGlmZmVyZW50IHRhYmxlIGdyb3VwcyAoZS5nLiBmcm9tIGJvdGggdGhlYWQgYW5kIHRib2R5KS5cblx0XHR2YXIgY29tbW9uQW5jZXN0b3I7XG5cdFx0aWYgKCAoIG1lcmdlRGlyZWN0aW9uID8gY2VsbHMubGVuZ3RoICE9IDEgOiBjZWxscy5sZW5ndGggPCAyICkgfHwgKCBjb21tb25BbmNlc3RvciA9IHNlbGVjdGlvbi5nZXRDb21tb25BbmNlc3RvcigpICkgJiYgY29tbW9uQW5jZXN0b3IudHlwZSA9PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiYgY29tbW9uQW5jZXN0b3IuaXMoICd0YWJsZScgKSApXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR2YXIgY2VsbCxcblx0XHRcdGZpcnN0Q2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHR0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoICd0YWJsZScgKSxcblx0XHRcdG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAoIHRhYmxlICksXG5cdFx0XHRtYXBIZWlnaHQgPSBtYXAubGVuZ3RoLFxuXHRcdFx0bWFwV2lkdGggPSBtYXBbIDAgXS5sZW5ndGgsXG5cdFx0XHRzdGFydFJvdyA9IGZpcnN0Q2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4LFxuXHRcdFx0c3RhcnRDb2x1bW4gPSBjZWxsSW5Sb3coIG1hcCwgc3RhcnRSb3csIGZpcnN0Q2VsbCApO1xuXG5cdFx0aWYgKCBtZXJnZURpcmVjdGlvbiApIHtcblx0XHRcdHZhciB0YXJnZXRDZWxsO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHJvd3NwYW4gPSBwYXJzZUludCggZmlyc3RDZWxsLmdldEF0dHJpYnV0ZSggJ3Jvd3NwYW4nICksIDEwICkgfHwgMTtcblx0XHRcdFx0dmFyIGNvbHNwYW4gPSBwYXJzZUludCggZmlyc3RDZWxsLmdldEF0dHJpYnV0ZSggJ2NvbHNwYW4nICksIDEwICkgfHwgMTtcblxuXHRcdFx0XHR0YXJnZXRDZWxsID0gbWFwWyBtZXJnZURpcmVjdGlvbiA9PSAndXAnID8gKCBzdGFydFJvdyAtIHJvd3NwYW4gKSA6IG1lcmdlRGlyZWN0aW9uID09ICdkb3duJyA/ICggc3RhcnRSb3cgKyByb3dzcGFuICkgOiBzdGFydFJvdyBdW1xuXHRcdFx0XHRcdG1lcmdlRGlyZWN0aW9uID09ICdsZWZ0JyA/XG5cdFx0XHRcdFx0XHQoIHN0YXJ0Q29sdW1uIC0gY29sc3BhbiApIDpcblx0XHRcdFx0XHRtZXJnZURpcmVjdGlvbiA9PSAncmlnaHQnID8gKCBzdGFydENvbHVtbiArIGNvbHNwYW4gKSA6IHN0YXJ0Q29sdW1uIF07XG5cblx0XHRcdH0gY2F0Y2ggKCBlciApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAxLiBObyBjZWxsIGNvdWxkIGJlIG1lcmdlZC5cblx0XHRcdC8vIDIuIFNhbWUgY2VsbCBhY3R1YWxseS5cblx0XHRcdGlmICggIXRhcmdldENlbGwgfHwgZmlyc3RDZWxsLiQgPT0gdGFyZ2V0Q2VsbCApXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0Ly8gU29ydCBpbiBtYXAgb3JkZXIgcmVnYXJkbGVzcyBvZiB0aGUgRE9NIHNlcXVlbmNlLlxuXHRcdFx0Y2VsbHNbICggbWVyZ2VEaXJlY3Rpb24gPT0gJ3VwJyB8fCBtZXJnZURpcmVjdGlvbiA9PSAnbGVmdCcgKSA/ICd1bnNoaWZ0JyA6ICdwdXNoJyBdKCBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoIHRhcmdldENlbGwgKSApO1xuXHRcdH1cblxuXHRcdC8vIFN0YXJ0IGZyb20gaGVyZSBhcmUgbWVyZ2luZyB3YXkgaWdub3JhbmNlIChtZXJnZSB1cC9yaWdodCwgYmF0Y2ggbWVyZ2UpLlxuXHRcdHZhciBkb2MgPSBmaXJzdENlbGwuZ2V0RG9jdW1lbnQoKSxcblx0XHRcdGxhc3RSb3dJbmRleCA9IHN0YXJ0Um93LFxuXHRcdFx0dG90YWxSb3dTcGFuID0gMCxcblx0XHRcdHRvdGFsQ29sU3BhbiA9IDAsXG5cdFx0XHQvLyBVc2UgYSBkb2N1bWVudEZyYWdtZW50IGFzIGJ1ZmZlciB3aGVuIGFwcGVuZGluZyBjZWxsIGNvbnRlbnRzLlxuXHRcdFx0ZnJhZyA9ICFpc0RldGVjdCAmJiBuZXcgQ0tFRElUT1IuZG9tLmRvY3VtZW50RnJhZ21lbnQoIGRvYyApLFxuXHRcdFx0ZGltZW5zaW9uID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2VsbCA9IGNlbGxzWyBpIF07XG5cblx0XHRcdHZhciB0ciA9IGNlbGwuZ2V0UGFyZW50KCksXG5cdFx0XHRcdGNlbGxGaXJzdENoaWxkID0gY2VsbC5nZXRGaXJzdCgpLFxuXHRcdFx0XHRjb2xTcGFuID0gY2VsbC4kLmNvbFNwYW4sXG5cdFx0XHRcdHJvd1NwYW4gPSBjZWxsLiQucm93U3Bhbixcblx0XHRcdFx0cm93SW5kZXggPSB0ci4kLnJvd0luZGV4LFxuXHRcdFx0XHRjb2xJbmRleCA9IGNlbGxJblJvdyggbWFwLCByb3dJbmRleCwgY2VsbCApO1xuXG5cdFx0XHQvLyBBY2N1bXVsYXRlZCB0aGUgYWN0dWFsIHBsYWNlcyB0YWtlbiBieSBhbGwgc2VsZWN0ZWQgY2VsbHMuXG5cdFx0XHRkaW1lbnNpb24gKz0gY29sU3BhbiAqIHJvd1NwYW47XG5cdFx0XHQvLyBBY2N1bXVsYXRlZCB0aGUgbWF4aW11bSB2aXJ0dWFsIHNwYW5zIGZyb20gY29sdW1uIGFuZCByb3cuXG5cdFx0XHR0b3RhbENvbFNwYW4gPSBNYXRoLm1heCggdG90YWxDb2xTcGFuLCBjb2xJbmRleCAtIHN0YXJ0Q29sdW1uICsgY29sU3BhbiApO1xuXHRcdFx0dG90YWxSb3dTcGFuID0gTWF0aC5tYXgoIHRvdGFsUm93U3Bhbiwgcm93SW5kZXggLSBzdGFydFJvdyArIHJvd1NwYW4gKTtcblxuXHRcdFx0aWYgKCAhaXNEZXRlY3QgKSB7XG5cdFx0XHRcdC8vIFRyaW0gYWxsIGNlbGwgZmlsbGVycyBhbmQgY2hlY2sgdG8gcmVtb3ZlIGVtcHR5IGNlbGxzLlxuXHRcdFx0XHRpZiAoIHRyaW1DZWxsKCBjZWxsICksIGNlbGwuZ2V0Q2hpbGRyZW4oKS5jb3VudCgpICkge1xuXHRcdFx0XHRcdC8vIE1lcmdlIHZlcnRpY2FsbHkgY2VsbHMgYXMgdHdvIHNlcGFyYXRlZCBwYXJhZ3JhcGhzLlxuXHRcdFx0XHRcdGlmICggcm93SW5kZXggIT0gbGFzdFJvd0luZGV4ICYmIGNlbGxGaXJzdENoaWxkICYmICEoIGNlbGxGaXJzdENoaWxkLmlzQmxvY2tCb3VuZGFyeSAmJiBjZWxsRmlyc3RDaGlsZC5pc0Jsb2NrQm91bmRhcnkoIHsgYnI6IDEgfSApICkgKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGFzdCA9IGZyYWcuZ2V0TGFzdCggQ0tFRElUT1IuZG9tLndhbGtlci53aGl0ZXNwYWNlcyggdHJ1ZSApICk7XG5cdFx0XHRcdFx0XHRpZiAoIGxhc3QgJiYgISggbGFzdC5pcyAmJiBsYXN0LmlzKCAnYnInICkgKSApXG5cdFx0XHRcdFx0XHRcdGZyYWcuYXBwZW5kKCAnYnInICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2VsbC5tb3ZlQ2hpbGRyZW4oIGZyYWcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID8gY2VsbC5yZW1vdmUoKSA6IGNlbGwuc2V0SHRtbCggJycgKTtcblx0XHRcdH1cblx0XHRcdGxhc3RSb3dJbmRleCA9IHJvd0luZGV4O1xuXHRcdH1cblxuXHRcdGlmICggIWlzRGV0ZWN0ICkge1xuXHRcdFx0ZnJhZy5tb3ZlQ2hpbGRyZW4oIGZpcnN0Q2VsbCApO1xuXG5cdFx0XHRmaXJzdENlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdFx0aWYgKCB0b3RhbENvbFNwYW4gPj0gbWFwV2lkdGggKVxuXHRcdFx0XHRmaXJzdENlbGwucmVtb3ZlQXR0cmlidXRlKCAncm93U3BhbicgKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0Zmlyc3RDZWxsLiQucm93U3BhbiA9IHRvdGFsUm93U3BhbjtcblxuXHRcdFx0aWYgKCB0b3RhbFJvd1NwYW4gPj0gbWFwSGVpZ2h0IClcblx0XHRcdFx0Zmlyc3RDZWxsLnJlbW92ZUF0dHJpYnV0ZSggJ2NvbFNwYW4nICk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGZpcnN0Q2VsbC4kLmNvbFNwYW4gPSB0b3RhbENvbFNwYW47XG5cblx0XHRcdC8vIFN3aXAgZW1wdHkgPHRyPiBsZWZ0IGF0IHRoZSBlbmQgb2YgdGFibGUgZHVlIHRvIHRoZSBtZXJnaW5nLlxuXHRcdFx0dmFyIHRycyA9IG5ldyBDS0VESVRPUi5kb20ubm9kZUxpc3QoIHRhYmxlLiQucm93cyApLFxuXHRcdFx0XHRjb3VudCA9IHRycy5jb3VudCgpO1xuXG5cdFx0XHRmb3IgKCBpID0gY291bnQgLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdFx0dmFyIHRhaWxUciA9IHRycy5nZXRJdGVtKCBpICk7XG5cdFx0XHRcdGlmICggIXRhaWxUci4kLmNlbGxzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0YWlsVHIucmVtb3ZlKCk7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmlyc3RDZWxsO1xuXHRcdH1cblx0XHQvLyBCZSBhYmxlIHRvIG1lcmdlIGNlbGxzIG9ubHkgaWYgYWN0dWFsIGRpbWVuc2lvbiBvZiBzZWxlY3RlZFxuXHRcdC8vIGNlbGxzIGVxdWFscyB0byB0aGUgY2FjdWxhdGVkIHJlY3RhbmdsZS5cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiAoIHRvdGFsUm93U3BhbiAqIHRvdGFsQ29sU3BhbiApID09IGRpbWVuc2lvbjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB2ZXJ0aWNhbFNwbGl0Q2VsbCggc2VsZWN0aW9uLCBpc0RldGVjdCApIHtcblx0XHR2YXIgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKCBzZWxlY3Rpb24gKTtcblx0XHRpZiAoIGNlbGxzLmxlbmd0aCA+IDEgKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGVsc2UgaWYgKCBpc0RldGVjdCApXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdHZhciBjZWxsID0gY2VsbHNbIDAgXSxcblx0XHRcdHRyID0gY2VsbC5nZXRQYXJlbnQoKSxcblx0XHRcdHRhYmxlID0gdHIuZ2V0QXNjZW5kYW50KCAndGFibGUnICksXG5cdFx0XHRtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKCB0YWJsZSApLFxuXHRcdFx0cm93SW5kZXggPSB0ci4kLnJvd0luZGV4LFxuXHRcdFx0Y29sSW5kZXggPSBjZWxsSW5Sb3coIG1hcCwgcm93SW5kZXgsIGNlbGwgKSxcblx0XHRcdHJvd1NwYW4gPSBjZWxsLiQucm93U3Bhbixcblx0XHRcdG5ld0NlbGwsIG5ld1Jvd1NwYW4sIG5ld0NlbGxSb3dTcGFuLCBuZXdSb3dJbmRleDtcblxuXHRcdGlmICggcm93U3BhbiA+IDEgKSB7XG5cdFx0XHRuZXdSb3dTcGFuID0gTWF0aC5jZWlsKCByb3dTcGFuIC8gMiApO1xuXHRcdFx0bmV3Q2VsbFJvd1NwYW4gPSBNYXRoLmZsb29yKCByb3dTcGFuIC8gMiApO1xuXHRcdFx0bmV3Um93SW5kZXggPSByb3dJbmRleCArIG5ld1Jvd1NwYW47XG5cdFx0XHR2YXIgbmV3Q2VsbFRyID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCB0YWJsZS4kLnJvd3NbIG5ld1Jvd0luZGV4IF0gKSxcblx0XHRcdFx0bmV3Q2VsbFJvdyA9IGNlbGxJblJvdyggbWFwLCBuZXdSb3dJbmRleCApLFxuXHRcdFx0XHRjYW5kaWRhdGVDZWxsO1xuXG5cdFx0XHRuZXdDZWxsID0gY2VsbC5jbG9uZSgpO1xuXG5cdFx0XHQvLyBGaWd1cmUgb3V0IHdoZXJlIHRvIGluc2VydCB0aGUgbmV3IGNlbGwgYnkgY2hlY2tpbmcgdGhlIHZpdHVhbCByb3cuXG5cdFx0XHRmb3IgKCB2YXIgYyA9IDA7IGMgPCBuZXdDZWxsUm93Lmxlbmd0aDsgYysrICkge1xuXHRcdFx0XHRjYW5kaWRhdGVDZWxsID0gbmV3Q2VsbFJvd1sgYyBdO1xuXHRcdFx0XHQvLyBDYXRjaCBmaXJzdCBjZWxsIGFjdHVhbGx5IGZvbGxvd2luZyB0aGUgY29sdW1uLlxuXHRcdFx0XHRpZiAoIGNhbmRpZGF0ZUNlbGwucGFyZW50Tm9kZSA9PSBuZXdDZWxsVHIuJCAmJiBjID4gY29sSW5kZXggKSB7XG5cdFx0XHRcdFx0bmV3Q2VsbC5pbnNlcnRCZWZvcmUoIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCggY2FuZGlkYXRlQ2VsbCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FuZGlkYXRlQ2VsbCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGRlc3RpbmF0aW9uIHJvdyBpcyBlbXB0eSwgYXBwZW5kIGF0IHdpbGwuXG5cdFx0XHRpZiAoICFjYW5kaWRhdGVDZWxsIClcblx0XHRcdFx0bmV3Q2VsbFRyLmFwcGVuZCggbmV3Q2VsbCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdDZWxsUm93U3BhbiA9IG5ld1Jvd1NwYW4gPSAxO1xuXG5cdFx0XHRuZXdDZWxsVHIgPSB0ci5jbG9uZSgpO1xuXHRcdFx0bmV3Q2VsbFRyLmluc2VydEFmdGVyKCB0ciApO1xuXHRcdFx0bmV3Q2VsbFRyLmFwcGVuZCggbmV3Q2VsbCA9IGNlbGwuY2xvbmUoKSApO1xuXG5cdFx0XHR2YXIgY2VsbHNJblNhbWVSb3cgPSBjZWxsSW5Sb3coIG1hcCwgcm93SW5kZXggKTtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNlbGxzSW5TYW1lUm93Lmxlbmd0aDsgaSsrIClcblx0XHRcdFx0Y2VsbHNJblNhbWVSb3dbIGkgXS5yb3dTcGFuKys7XG5cdFx0fVxuXG5cdFx0bmV3Q2VsbC5hcHBlbmRCb2d1cygpO1xuXG5cdFx0Y2VsbC4kLnJvd1NwYW4gPSBuZXdSb3dTcGFuO1xuXHRcdG5ld0NlbGwuJC5yb3dTcGFuID0gbmV3Q2VsbFJvd1NwYW47XG5cdFx0aWYgKCBuZXdSb3dTcGFuID09IDEgKVxuXHRcdFx0Y2VsbC5yZW1vdmVBdHRyaWJ1dGUoICdyb3dTcGFuJyApO1xuXHRcdGlmICggbmV3Q2VsbFJvd1NwYW4gPT0gMSApXG5cdFx0XHRuZXdDZWxsLnJlbW92ZUF0dHJpYnV0ZSggJ3Jvd1NwYW4nICk7XG5cblx0XHRyZXR1cm4gbmV3Q2VsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGhvcml6b250YWxTcGxpdENlbGwoIHNlbGVjdGlvbiwgaXNEZXRlY3QgKSB7XG5cdFx0dmFyIGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyggc2VsZWN0aW9uICk7XG5cdFx0aWYgKCBjZWxscy5sZW5ndGggPiAxIClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRlbHNlIGlmICggaXNEZXRlY3QgKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR2YXIgY2VsbCA9IGNlbGxzWyAwIF0sXG5cdFx0XHR0ciA9IGNlbGwuZ2V0UGFyZW50KCksXG5cdFx0XHR0YWJsZSA9IHRyLmdldEFzY2VuZGFudCggJ3RhYmxlJyApLFxuXHRcdFx0bWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCggdGFibGUgKSxcblx0XHRcdHJvd0luZGV4ID0gdHIuJC5yb3dJbmRleCxcblx0XHRcdGNvbEluZGV4ID0gY2VsbEluUm93KCBtYXAsIHJvd0luZGV4LCBjZWxsICksXG5cdFx0XHRjb2xTcGFuID0gY2VsbC4kLmNvbFNwYW4sXG5cdFx0XHRuZXdDZWxsLCBuZXdDb2xTcGFuLCBuZXdDZWxsQ29sU3BhbjtcblxuXHRcdGlmICggY29sU3BhbiA+IDEgKSB7XG5cdFx0XHRuZXdDb2xTcGFuID0gTWF0aC5jZWlsKCBjb2xTcGFuIC8gMiApO1xuXHRcdFx0bmV3Q2VsbENvbFNwYW4gPSBNYXRoLmZsb29yKCBjb2xTcGFuIC8gMiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdDZWxsQ29sU3BhbiA9IG5ld0NvbFNwYW4gPSAxO1xuXHRcdFx0dmFyIGNlbGxzSW5TYW1lQ29sID0gY2VsbEluQ29sKCBtYXAsIGNvbEluZGV4ICk7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjZWxsc0luU2FtZUNvbC5sZW5ndGg7IGkrKyApXG5cdFx0XHRcdGNlbGxzSW5TYW1lQ29sWyBpIF0uY29sU3BhbisrO1xuXHRcdH1cblx0XHRuZXdDZWxsID0gY2VsbC5jbG9uZSgpO1xuXHRcdG5ld0NlbGwuaW5zZXJ0QWZ0ZXIoIGNlbGwgKTtcblx0XHRuZXdDZWxsLmFwcGVuZEJvZ3VzKCk7XG5cblx0XHRjZWxsLiQuY29sU3BhbiA9IG5ld0NvbFNwYW47XG5cdFx0bmV3Q2VsbC4kLmNvbFNwYW4gPSBuZXdDZWxsQ29sU3Bhbjtcblx0XHRpZiAoIG5ld0NvbFNwYW4gPT0gMSApXG5cdFx0XHRjZWxsLnJlbW92ZUF0dHJpYnV0ZSggJ2NvbFNwYW4nICk7XG5cdFx0aWYgKCBuZXdDZWxsQ29sU3BhbiA9PSAxIClcblx0XHRcdG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCAnY29sU3BhbicgKTtcblxuXHRcdHJldHVybiBuZXdDZWxsO1xuXHR9XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3RhYmxldG9vbHMnLCB7XG5cdFx0aW5pdDogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdHZhciBsYW5nID0gZWRpdG9yLmxhbmcudGFibGU7XG5cblx0XHRcdGZ1bmN0aW9uIGNyZWF0ZURlZiggZGVmICkge1xuXHRcdFx0XHRyZXR1cm4gQ0tFRElUT1IudG9vbHMuZXh0ZW5kKCBkZWYgfHwge30sIHtcblx0XHRcdFx0XHRjb250ZXh0U2Vuc2l0aXZlOiAxLFxuXHRcdFx0XHRcdHJlZnJlc2g6IGZ1bmN0aW9uKCBlZGl0b3IsIHBhdGggKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFN0YXRlKCBwYXRoLmNvbnRhaW5zKCB7IHRkOiAxLCB0aDogMSB9LCAxICkgPyBDS0VESVRPUi5UUklTVEFURV9PRkYgOiBDS0VESVRPUi5UUklTVEFURV9ESVNBQkxFRCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gYWRkQ21kKCBuYW1lLCBkZWYgKSB7XG5cdFx0XHRcdHZhciBjbWQgPSBlZGl0b3IuZ2V0Q29tbWFuZChuYW1lKTtcblxuXHRcdFx0XHRpZiAoY21kKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y21kID0gZWRpdG9yLmFkZENvbW1hbmQobmFtZSwgZGVmKTtcblx0XHRcdFx0ZWRpdG9yLmFkZEZlYXR1cmUoY21kKTtcblx0XHRcdH1cblxuXHRcdFx0YWRkQ21kKCAncm93RGVsZXRlJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKCBkZWxldGVSb3dzKCBzZWxlY3Rpb24gKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAncm93SW5zZXJ0QmVmb3JlJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGluc2VydFJvdyggc2VsZWN0aW9uLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdyb3dJbnNlcnRBZnRlcicsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRpbnNlcnRSb3coIHNlbGVjdGlvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY29sdW1uRGVsZXRlJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdHZhciBlbGVtZW50ID0gZGVsZXRlQ29sdW1ucyggc2VsZWN0aW9uICk7XG5cdFx0XHRcdFx0ZWxlbWVudCAmJiBwbGFjZUN1cnNvckluQ2VsbCggZWxlbWVudCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY29sdW1uSW5zZXJ0QmVmb3JlJywgY3JlYXRlRGVmKCB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdGluc2VydENvbHVtbiggc2VsZWN0aW9uLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjb2x1bW5JbnNlcnRBZnRlcicsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRpbnNlcnRDb2x1bW4oIHNlbGVjdGlvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY2VsbERlbGV0ZScsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRkZWxldGVDZWxscyggc2VsZWN0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsTWVyZ2UnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuLHJvd3NwYW5dJyxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbY29sc3Bhbixyb3dzcGFuXScsXG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKCBlZGl0b3IgKSB7XG5cdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoIG1lcmdlQ2VsbHMoIGVkaXRvci5nZXRTZWxlY3Rpb24oKSApLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsTWVyZ2VSaWdodCcsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKCBtZXJnZUNlbGxzKCBlZGl0b3IuZ2V0U2VsZWN0aW9uKCksICdyaWdodCcgKSwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0YWRkQ21kKCAnY2VsbE1lcmdlRG93bicsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW3Jvd3NwYW5dJyxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKCBtZXJnZUNlbGxzKCBlZGl0b3IuZ2V0U2VsZWN0aW9uKCksICdkb3duJyApLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsVmVydGljYWxTcGxpdCcsIGNyZWF0ZURlZigge1xuXHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW3Jvd3NwYW5dJyxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKCB2ZXJ0aWNhbFNwbGl0Q2VsbCggZWRpdG9yLmdldFNlbGVjdGlvbigpICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxIb3Jpem9udGFsU3BsaXQnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuXScsXG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0ZXhlYzogZnVuY3Rpb24oIGVkaXRvciApIHtcblx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbCggaG9yaXpvbnRhbFNwbGl0Q2VsbCggZWRpdG9yLmdldFNlbGVjdGlvbigpICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdGFkZENtZCggJ2NlbGxJbnNlcnRCZWZvcmUnLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0aW5zZXJ0Q2VsbCggc2VsZWN0aW9uLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXG5cdFx0XHRhZGRDbWQoICdjZWxsSW5zZXJ0QWZ0ZXInLCBjcmVhdGVEZWYoIHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRleGVjOiBmdW5jdGlvbiggZWRpdG9yICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0aW5zZXJ0Q2VsbCggc2VsZWN0aW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH0sXG5cblx0XHRnZXRTZWxlY3RlZENlbGxzOiBnZXRTZWxlY3RlZENlbGxzXG5cblx0fSk7XG59ICkoKTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0d28tZGltZW5zaW9uIGFycmF5IHRoYXQgcmVmbGVjdHMgdGhlIGFjdHVhbCBsYXlvdXQgb2YgdGFibGUgY2VsbHMsXG4gKiB3aXRoIGNlbGwgc3BhbnMsIHdpdGggbWFwcGluZ3MgdG8gdGhlIG9yaWdpbmFsIHRkIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IHRhYmxlXG4gKiBAbWVtYmVyIENLRURJVE9SLnRvb2xzXG4gKi9cbkNLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAgPSBmdW5jdGlvbiggdGFibGUgKSB7XG5cdHZhciBhUm93cyA9IHRhYmxlLiQucm93cztcblxuXHQvLyBSb3cgYW5kIENvbHVtbiBjb3VudGVycy5cblx0dmFyIHIgPSAtMTtcblxuXHR2YXIgYU1hcCA9IFtdO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IGFSb3dzLmxlbmd0aDsgaSsrICkge1xuXHRcdHIrKztcblx0XHQhYU1hcFsgciBdICYmICggYU1hcFsgciBdID0gW10gKTtcblxuXHRcdHZhciBjID0gLTE7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBhUm93c1sgaSBdLmNlbGxzLmxlbmd0aDsgaisrICkge1xuXHRcdFx0dmFyIG9DZWxsID0gYVJvd3NbIGkgXS5jZWxsc1sgaiBdO1xuXG5cdFx0XHRjKys7XG5cdFx0XHR3aGlsZSAoIGFNYXBbIHIgXVsgYyBdIClcblx0XHRcdFx0YysrO1xuXG5cdFx0XHR2YXIgaUNvbFNwYW4gPSBpc05hTiggb0NlbGwuY29sU3BhbiApID8gMSA6IG9DZWxsLmNvbFNwYW47XG5cdFx0XHR2YXIgaVJvd1NwYW4gPSBpc05hTiggb0NlbGwucm93U3BhbiApID8gMSA6IG9DZWxsLnJvd1NwYW47XG5cblx0XHRcdGZvciAoIHZhciBycyA9IDA7IHJzIDwgaVJvd1NwYW47IHJzKysgKSB7XG5cdFx0XHRcdGlmICggIWFNYXBbIHIgKyBycyBdIClcblx0XHRcdFx0XHRhTWFwWyByICsgcnMgXSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBjcyA9IDA7IGNzIDwgaUNvbFNwYW47IGNzKysgKSB7XG5cdFx0XHRcdFx0YU1hcFsgciArIHJzIF1bIGMgKyBjcyBdID0gYVJvd3NbIGkgXS5jZWxsc1sgaiBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMgKz0gaUNvbFNwYW4gLSAxO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYU1hcDtcbn07XG4iLCJ2YXIgdGFibGVTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ2FlLWFycm93LWJveCBhZS1hcnJvdy1ib3gtYm90dG9tJztcbn07XG5cbmNvbnN0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyA9IHtcbiAgICB0YWJsZTogdGFibGVTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlczsiLCJpbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuLy8gRGVmYXVsdCBndXR0ZXIgdmFsdWUgZm9yIHRvb2xiYXIgcG9zaXRpb25pbmdcbnZhciBERUZBVUxUX0dVVFRFUiA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxufTtcblxuLyoqXG4gKiBDZW50ZXJzIGEgVG9vbGJhciBhY2NvcmRpbmcgdG8gZ2l2ZW4gcmVjdGFuZ2xlXG4gKlxuICogQG1ldGhvZCBjZW50ZXJUb29sYmFyXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbGJhciBUaGUgdG9vbGJhciB0byBiZSBjZW50ZXJlZFxuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgVGhlIHJlY3RhbmdsZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIFRvb2xiYXIgd2lsbCBiZSBjZW50ZXJlZFxuICovXG52YXIgY2VudGVyVG9vbGJhciA9IGZ1bmN0aW9uKHRvb2xiYXIsIHJlY3QpIHtcbiAgICB2YXIgdG9vbGJhck5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0b29sYmFyKTtcblxuICAgIHZhciBoYWxmTm9kZVdpZHRoID0gdG9vbGJhck5vZGUub2Zmc2V0V2lkdGggLyAyO1xuICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuICAgIHZhciBndXR0ZXIgPSB0b29sYmFyLnByb3BzLmd1dHRlciB8fCBERUZBVUxUX0dVVFRFUjtcblxuICAgIHZhciB3aWRnZXRYWSA9IHRvb2xiYXIuZ2V0V2lkZ2V0WFlQb2ludChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiAtIHNjcm9sbFBvc2l0aW9uLngsIHJlY3QudG9wICsgc2Nyb2xsUG9zaXRpb24ueSwgQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1ApO1xuXG4gICAgdG9vbGJhci5tb3ZlVG9Qb2ludChbXG4gICAgICAgIHdpZGdldFhZWzBdLFxuICAgICAgICB3aWRnZXRYWVsxXVxuICAgIF0sIFtcbiAgICAgICAgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIgLSBoYWxmTm9kZVdpZHRoIC0gc2Nyb2xsUG9zaXRpb24ueCxcbiAgICAgICAgcmVjdC50b3AgLSB0b29sYmFyTm9kZS5vZmZzZXRIZWlnaHQgKyBzY3JvbGxQb3NpdGlvbi55IC0gZ3V0dGVyLnRvcFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIHRvb2xiYXIgYWNjb3JkaW5nIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2VcbiAqXG4gKiBAbWV0aG9kIGltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFBheWxvYWQsIHNob3VsZCBjb250YWluIHRoZSBzZWxlY3Rpb24gZGF0YSBmb3IgcmV0cmlldmluZyB0aGVcbiAqIGNsaWVudCByZWN0YW5nbGUgb2YgdGhlIHNlbGVjdGVkIGltYWdlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlLCBpbiBhbGwgY2FzZXNcbiAqL1xudmFyIGltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb24gPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgY2VudGVyVG9vbGJhcih0aGlzLCBwYXlsb2FkLnNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXRDbGllbnRSZWN0KCkpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgdG9vbGJhciBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICpcbiAqIEBtZXRob2QgdGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgT2JqZWN0LCB3aGljaCBjb250YWlucyB0aGUgc2VsZWN0aW9uIGRhdGEgZm9yIHJldHJpZXZpbmcgdGhlXG4gKiBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBzZWxlY3RlZCB0YWJsZVxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSwgaW4gYWxsIGNhc2VzXG4gKi9cbnZhciB0YWJsZVNlbGVjdGlvblNldFBvc2l0aW9uID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHZhciBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG4gICAgdmFyIHRhYmxlID0gbmV3IENLRURJVE9SLlRhYmxlKG5hdGl2ZUVkaXRvcikuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG4gICAgY2VudGVyVG9vbGJhcih0aGlzLCB0YWJsZS5nZXRDbGllbnRSZWN0KCkpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25TZXRQb3NpdGlvbiA9IHtcbiAgICBpbWFnZTogaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvbixcbiAgICB0YWJsZTogdGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvblxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uU2V0UG9zaXRpb247IiwidmFyIF9pc1JhbmdlQXRFbGVtZW50RW5kID0gZnVuY3Rpb24ocmFuZ2UsIGVsZW1lbnQpIHtcbiAgICAvLyBGaW5kaW5nIGlmIGEgcmFuZ2UgaXMgYXQgdGhlIGVuZCBvZiBhbiBlbGVtZW50IGlzIHNvbWV3aGF0IHRyaWNreSBkdWUgdG8gaG93IENLRWRpdG9yIGhhbmRsZXNcbiAgICAvLyByYW5nZXMuIEl0IG1pZ2h0IGRlcGVuZCBvbiB3ZXRoZXIgYSBzb3VyY2Ugbm9kZSBpbnNpZGUgdGhlIGVsZW1lbnQgaXMgc2VsZWN0ZWQgb3Igbm90LiBGb3Igbm93LFxuICAgIC8vIHdlIG5lZWQgdG8gY292ZXIgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAvL1xuICAgIC8vIC0gVGhlIHRleHQgbGVuZ3RoIG9mIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIGFzIHRoZSBlbmRPZmZzZXQgb2YgdGhlIHJhbmdlXG4gICAgLy8gLSBCb3RoIHN0YXJ0IGFuZCBlbmQgY29udGFpbmVycyBtYXRjaCB0aGUgZWxlbWVudCBhbmQgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBhcmUgMVxuXG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0VGV4dCgpLmxlbmd0aCA9PT0gcmFuZ2UuZW5kT2Zmc2V0IHx8XG4gICAgICAgIChcbiAgICAgICAgICAgIGVsZW1lbnQuZXF1YWxzKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSAmJlxuICAgICAgICAgICAgZWxlbWVudC5lcXVhbHMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJlxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLmVuZE9mZnNldCAmJlxuICAgICAgICAgICAgcmFuZ2UuZW5kT2Zmc2V0ID09PSAxXG4gICAgICAgICk7XG59O1xuXG52YXIgZW1iZWRTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHZhciBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cbiAgICByZXR1cm4gISEoXG4gICAgICAgIHNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuICAgICAgICBzZWxlY3Rpb25EYXRhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXdpZGdldCcpID09PSAnYWVfZW1iZWQnXG4gICAgKTtcbn07XG5cbnZhciBsaW5rU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICB2YXIgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcbiAgICB2YXIgcmFuZ2UgPSBuYXRpdmVFZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cbiAgICB2YXIgZWxlbWVudDtcblxuICAgIHJldHVybiAhIShcbiAgICAgICAgbmF0aXZlRWRpdG9yLmlzU2VsZWN0aW9uRW1wdHkoKSAmJlxuICAgICAgICAoZWxlbWVudCA9IChuZXcgQ0tFRElUT1IuTGluayhuYXRpdmVFZGl0b3IpKS5nZXRGcm9tU2VsZWN0aW9uKCkpICYmXG4gICAgICAgIGVsZW1lbnQuZ2V0VGV4dCgpLmxlbmd0aCAhPT0gcmFuZ2UuZW5kT2Zmc2V0ICYmXG4gICAgICAgICFlbGVtZW50LmlzUmVhZE9ubHkoKSAmJlxuICAgICAgICAhX2lzUmFuZ2VBdEVsZW1lbnRFbmQocmFuZ2UsIGVsZW1lbnQpXG4gICAgKTtcbn07XG5cbnZhciBpbWFnZVNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgdmFyIHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuICAgIHJldHVybiAhIShcbiAgICAgICAgc2VsZWN0aW9uRGF0YS5lbGVtZW50ICYmXG4gICAgICAgIHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXROYW1lKCkgPT09ICdpbWcnICYmXG4gICAgICAgICFzZWxlY3Rpb25EYXRhLmVsZW1lbnQuaXNSZWFkT25seSgpXG4gICAgKTtcbn07XG5cbnZhciB0ZXh0U2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICB2YXIgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuICAgIHZhciBzZWxlY3Rpb25FbXB0eSA9IG5hdGl2ZUVkaXRvci5pc1NlbGVjdGlvbkVtcHR5KCk7XG5cbiAgICB2YXIgc2VsZWN0aW9uRGF0YSA9IHBheWxvYWQuZGF0YS5zZWxlY3Rpb25EYXRhO1xuXG4gICAgcmV0dXJuICEhKFxuICAgICAgICAhc2VsZWN0aW9uRGF0YS5lbGVtZW50ICYmXG4gICAgICAgIHNlbGVjdGlvbkRhdGEucmVnaW9uICYmXG4gICAgICAgICFzZWxlY3Rpb25FbXB0eSAmJlxuICAgICAgICAhbmF0aXZlRWRpdG9yLmdldFNlbGVjdGlvbigpLmdldENvbW1vbkFuY2VzdG9yKCkuaXNSZWFkT25seSgpXG4gICAgKTtcbn07XG5cbnZhciB0YWJsZVNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgdmFyIG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cbiAgICB2YXIgdGFibGUgPSBuZXcgQ0tFRElUT1IuVGFibGUobmF0aXZlRWRpdG9yKTtcbiAgICB2YXIgZWxlbWVudCA9IHRhYmxlLmdldEZyb21TZWxlY3Rpb24oKTtcblxuICAgIHJldHVybiAhIShlbGVtZW50ICYmIHRhYmxlLmlzRWRpdGFibGUoZWxlbWVudCkpO1xufTtcblxuY29uc3QgU2VsZWN0aW9uVGVzdCA9IHtcbiAgICBlbWJlZDogZW1iZWRTZWxlY3Rpb25UZXN0LFxuICAgIGltYWdlOiBpbWFnZVNlbGVjdGlvblRlc3QsXG4gICAgbGluazogbGlua1NlbGVjdGlvblRlc3QsXG4gICAgdGFibGU6IHRhYmxlU2VsZWN0aW9uVGVzdCxcbiAgICB0ZXh0OiB0ZXh0U2VsZWN0aW9uVGVzdFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uVGVzdDsiLCJpbXBvcnQgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzIGZyb20gJy4vc2VsZWN0aW9uLWFycm93Ym94LmpzJztcbmltcG9ydCBTZWxlY3Rpb25TZXRQb3NpdGlvbiBmcm9tICcuL3NlbGVjdGlvbi1wb3NpdGlvbi5qcyc7XG5pbXBvcnQgU2VsZWN0aW9uVGVzdCBmcm9tICcuL3NlbGVjdGlvbi10ZXN0LmpzJztcblxuY29uc3QgU2VsZWN0aW9ucyA9IFt7XG4gICAgbmFtZTogJ2VtYmVkJyxcbiAgICBidXR0b25zOiBbJ2VtYmVkUmVtb3ZlJywgJ2VtYmVkRWRpdCddLFxuICAgIHRlc3Q6IFNlbGVjdGlvblRlc3QuZW1iZWRcbn0sIHtcbiAgICBuYW1lOiAnbGluaycsXG4gICAgYnV0dG9uczogWydsaW5rRWRpdCddLFxuICAgIHRlc3Q6IFNlbGVjdGlvblRlc3QubGlua1xufSwge1xuICAgIG5hbWU6ICdpbWFnZScsXG4gICAgYnV0dG9uczogWydpbWFnZUxlZnQnLCAnaW1hZ2VDZW50ZXInLCAnaW1hZ2VSaWdodCddLFxuICAgIHNldFBvc2l0aW9uOiBTZWxlY3Rpb25TZXRQb3NpdGlvbi5pbWFnZSxcbiAgICB0ZXN0OiBTZWxlY3Rpb25UZXN0LmltYWdlXG59LCB7XG4gICAgbmFtZTogJ3RleHQnLFxuICAgIGJ1dHRvbnM6IFsnc3R5bGVzJywgJ2JvbGQnLCAnaXRhbGljJywgJ3VuZGVybGluZScsICdsaW5rJywgJ3R3aXR0ZXInXSxcbiAgICB0ZXN0OiBTZWxlY3Rpb25UZXN0LnRleHRcbn0sIHtcbiAgICBuYW1lOiAndGFibGUnLFxuICAgIGJ1dHRvbnM6IFsndGFibGVIZWFkaW5nJywgJ3RhYmxlUm93JywgJ3RhYmxlQ29sdW1uJywgJ3RhYmxlQ2VsbCcsICd0YWJsZVJlbW92ZSddLFxuICAgIGdldEFycm93Qm94Q2xhc3NlczogU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzLnRhYmxlLFxuICAgIHNldFBvc2l0aW9uOiBTZWxlY3Rpb25TZXRQb3NpdGlvbi50YWJsZSxcbiAgICB0ZXN0OiBTZWxlY3Rpb25UZXN0LnRhYmxlXG59XTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uczsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W3VuZGVmaW5lZF07IH0oKSk7IiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1t1bmRlZmluZWRdOyB9KCkpOyJdLCJzb3VyY2VSb290IjoiIn0=